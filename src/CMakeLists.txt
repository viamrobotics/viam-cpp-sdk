# Copyright 2023 Viam Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set(PROTO_GEN_DIR ${CMAKE_CURRENT_SOURCE_DIR})

if (VIAMCPPSDK_USE_DYNAMIC_PROTOS)

  # Look for the `buf` command in the usual places, and use it if
  # found. If we can't find it, try to download it and use that.
  #
  # TODO: File an upstream issue with `buf.build` to add
  # `find_package` support for it, then use it.
  #
  find_program(BUF_COMMAND buf)
  if (NOT BUF_COMMAND)
    file(
      DOWNLOAD
      https://github.com/bufbuild/buf/releases/latest/download/buf-${CMAKE_HOST_SYSTEM_NAME}-${CMAKE_HOST_SYSTEM_PROCESSOR}
      ${CMAKE_CURRENT_BINARY_DIR}/buf_latest
      STATUS buf_status
    )
    list(GET buf_status 0 buf_status_code)
    list(GET buf_status 1 buf_status_string)

    if(NOT buf_status_code EQUAL 0)
      message(FATAL_ERROR "No local `buf` program found (try setting PATH?) and failed to download: ${buf_status_string}")
    endif()

    set(BUF_COMMAND ${CMAKE_CURRENT_BINARY_DIR}/buf_latest)
    file(CHMOD ${BUF_COMMAND} PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE)
  endif()

  set(PROTO_GEN_DIR ${CMAKE_CURRENT_BINARY_DIR})

  # Buf only goes back to 1.41.1 for generation against their "custom
  # remote" registry (see https://buf.build/grpc/plugins/cpp), and we
  # need a differently shaped file to do local generation if we must
  # handle versions older than that. For versions newer than 1.51,
  # "remote plugins" seem to be the thing to use for now.
  #
  # TODO: Should we have an option to always do local generation so
  # offline development always works?
  #
  if ((NOT VIAMCPPSDK_OFFLINE_PROTO_GENERATION) AND (VIAMCPPSDK_GRPCXX_VERSION VERSION_GREATER 1.51.1))
    configure_file(
      gen/etc/buf.gen.remote.plugin.yaml.in
      buf.gen.yaml
    )
  elseif ((NOT VIAMCPPSDK_OFFLINE_PROTO_GENERATION) AND (VIAMCPPSDK_GRPCXX_VERSION VERSION_GREATER_EQUAL 1.41.1))
    configure_file(
      gen/etc/buf.gen.custom.remote.yaml.in
      buf.gen.yaml
    )
  else()
    configure_file(
      gen/etc/buf.gen.local.yaml.in
      buf.gen.yaml
    )
  endif()

  add_custom_command(
    OUTPUT
    # Unfortunately, there isn't a good way to know in advance what
    # files will be generated by invoking `buf generate`.  Instead, we
    # just list the files here that we know we need in the
    # `add_library` call below. But we will find in practice that more
    # files are generated.
    #
    # TODO: We reiterate this list below in `add_library`. Can we DRY
    # it sanely? We would need to filter out (or add in) the headers.

    # This list is needed for the core library.
    ${PROTO_GEN_DIR}/gen/app/v1/app.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/app/v1/app.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/app/v1/app.pb.cc
    ${PROTO_GEN_DIR}/gen/app/v1/app.pb.h
    ${PROTO_GEN_DIR}/gen/app/v1/robot.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/app/v1/robot.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/app/v1/robot.pb.cc
    ${PROTO_GEN_DIR}/gen/app/v1/robot.pb.h
    ${PROTO_GEN_DIR}/gen/common/v1/common.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/common/v1/common.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/common/v1/common.pb.cc
    ${PROTO_GEN_DIR}/gen/common/v1/common.pb.h
    ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.pb.cc
    ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.pb.h
    ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.pb.cc
    ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.pb.h
    ${PROTO_GEN_DIR}/gen/google/api/annotations.pb.cc
    ${PROTO_GEN_DIR}/gen/google/api/annotations.pb.h
    ${PROTO_GEN_DIR}/gen/google/api/httpbody.pb.cc
    ${PROTO_GEN_DIR}/gen/google/api/httpbody.pb.h
    ${PROTO_GEN_DIR}/gen/google/api/http.pb.cc
    ${PROTO_GEN_DIR}/gen/google/api/http.pb.h
    ${PROTO_GEN_DIR}/gen/module/v1/module.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/module/v1/module.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/module/v1/module.pb.cc
    ${PROTO_GEN_DIR}/gen/module/v1/module.pb.h
    ${PROTO_GEN_DIR}/gen/robot/v1/robot.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/robot/v1/robot.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/robot/v1/robot.pb.cc
    ${PROTO_GEN_DIR}/gen/robot/v1/robot.pb.h
    ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.pb.cc
    ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.pb.h

    # These are needed for `echo` example, which is awkward. These can
    # probably be removed if that example is pulled.
    ${PROTO_GEN_DIR}/gen/proto/rpc/examples/echo/v1/echo.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/proto/rpc/examples/echo/v1/echo.grpc.pb.h
    ${PROTO_GEN_DIR}/gen/proto/rpc/examples/echo/v1/echo.pb.cc
    ${PROTO_GEN_DIR}/gen/proto/rpc/examples/echo/v1/echo.pb.h

    COMMAND ${BUF_COMMAND} generate buf.build/viamrobotics/goutils --template buf.gen.yaml
    COMMAND ${BUF_COMMAND} generate buf.build/googleapis/googleapis --template buf.gen.yaml --path google/rpc --path google/api
    COMMAND ${BUF_COMMAND} generate buf.build/viamrobotics/api --template buf.gen.yaml --path common,component,robot,service,module,tagger,app/v1
    MAIN_DEPENDENCY buf.gen.yaml
  )

  add_custom_target(
    generate-dynamic-protos
    # This must be one of the files listed in `add_custom_command` above,
    # but it doesn't matter which one, we just need to have a dependency edge
    # into the files produced by that command.
    #
    # TODO: If we DRY as suggested above, this could just be the first list item.
    #
    DEPENDS ${PROTO_GEN_DIR}/gen/common/v1/common.grpc.pb.cc
  )

  add_custom_target(
    update-static-protos
    DEPENDS generate-dynamic-protos
  )

  add_custom_command(
    TARGET update-static-protos
    COMMAND ${CMAKE_COMMAND} -E copy_directory ${PROTO_GEN_DIR}/gen ${CMAKE_SOURCE_DIR}/src/gen
  )
endif(VIAMCPPSDK_USE_DYNAMIC_PROTOS)

# I dislike exporting values via `CACHE` but for now we need this
# state over in the `examples` directory. Hopefully when we do some
# physical refactoring that can be eliminated.
set(PROTO_GEN_DIR ${PROTO_GEN_DIR} CACHE INTERNAL "")


# Declare the viamcpp library, and attach sources,
# headers for installation
add_library(viamcpp)

# TODO: This is analogized from
# https://gitlab.kitware.com/cmake/cmake/-/tree/master/Help/guide/importing-exporting/MathFunctionsComponents
# but it doesn't really seem to do anything. Everything works fine if
# it is removed, and naming the alias something other than `viamcpp`
# doesn't make it available under that alias anyway, as one might
# hope. What is it supposed to do?
add_library(viam-cpp-sdk::viamcpp ALIAS viamcpp)

target_sources(viamcpp
  PRIVATE
    ${PROTO_GEN_DIR}/gen/app/v1/app.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/app/v1/app.pb.cc
    ${PROTO_GEN_DIR}/gen/app/v1/robot.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/app/v1/robot.pb.cc
    ${PROTO_GEN_DIR}/gen/common/v1/common.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/common/v1/common.pb.cc
    ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.pb.cc
    ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.pb.cc
    ${PROTO_GEN_DIR}/gen/google/api/annotations.pb.cc
    ${PROTO_GEN_DIR}/gen/google/api/http.pb.cc
    ${PROTO_GEN_DIR}/gen/google/api/httpbody.pb.cc
    ${PROTO_GEN_DIR}/gen/module/v1/module.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/module/v1/module.pb.cc
    ${PROTO_GEN_DIR}/gen/robot/v1/robot.pb.cc
    ${PROTO_GEN_DIR}/gen/robot/v1/robot.grpc.pb.cc
    ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.pb.cc
    ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.grpc.pb.cc
    # TODO(RSDK-1742): we have to put `registry` up top here because we need the
    # registry types to be defined first, before anything tries to init them.
    # this obviously isn't great. it breaks up stylistic ordering and is brittle
    # when we need to add updates. we should refactor to make this unnecessary.
    # consider making all necessary runtime values a single `context` that has to
    # be initialized within main before anything else happens?
    registry/registry.cpp
    common/proto_type.cpp
    common/utils.cpp
    components/camera/camera.cpp
    components/camera/client.cpp
    components/camera/server.cpp
    components/component_base.cpp
    components/component_type.cpp
    components/generic/client.cpp
    components/generic/generic.cpp
    components/generic/server.cpp
    config/resource.cpp
    module/handler_map.cpp
    module/module.cpp
    module/service.cpp
    referenceframe/frame.cpp
    resource/resource.cpp
    resource/resource_base.cpp
    resource/resource_server_base.cpp
    resource/resource_manager.cpp
    resource/resource_type.cpp
    robot/client.cpp
    rpc/dial.cpp
    rpc/server.cpp
    services/service_base.cpp
    services/service_type.cpp
    spatialmath/geometry.cpp
    spatialmath/orientation_types.cpp
    spatialmath/orientation.cpp
    subtype/subtype.cpp
    tests/test_utils.cpp
    tests/mocks/camera_mocks.cpp
    tests/mocks/generic_mocks.cpp
  PUBLIC FILE_SET viamcpp_public_includes TYPE HEADERS
    FILES
      common/proto_type.hpp
      common/utils.hpp
      components/camera/camera.hpp
      components/camera/client.hpp
      components/camera/server.hpp
      components/component_base.hpp
      components/component_type.hpp
      components/generic/client.hpp
      components/generic/generic.hpp
      components/generic/server.hpp
      components/service_base.hpp
      config/resource.hpp
      module/handler_map.hpp
      module/module.hpp
      module/service.hpp
      referenceframe/frame.hpp
      registry/registry.hpp
      resource/resource.hpp
      resource/resource_base.hpp
      resource/resource_server_base.hpp
      resource/resource_manager.hpp
      resource/resource_type.hpp
      robot/client.hpp
      robot/service.hpp
      rpc/dial.hpp
      rpc/server.hpp
      services/service_base.hpp
      services/service_type.hpp
      spatialmath/geometry.hpp
      spatialmath/orientation_types.hpp
      spatialmath/orientation.hpp
      subtype/subtype.hpp
      tests/test_utils.hpp
      tests/mocks/camera_mocks.hpp
      tests/mocks/generic_mocks.hpp
  PUBLIC FILE_SET viamcpp_public_pb_includes TYPE HEADERS
    BASE_DIRS
      ${PROTO_GEN_DIR}/gen
    FILES
      ${PROTO_GEN_DIR}/gen/app/v1/app.grpc.pb.h
      ${PROTO_GEN_DIR}/gen/app/v1/app.pb.h
      ${PROTO_GEN_DIR}/gen/app/v1/robot.grpc.pb.h
      ${PROTO_GEN_DIR}/gen/app/v1/robot.pb.h
      ${PROTO_GEN_DIR}/gen/google/api/annotations.pb.h
      ${PROTO_GEN_DIR}/gen/google/api/http.pb.h
      ${PROTO_GEN_DIR}/gen/google/api/httpbody.pb.h
      ${PROTO_GEN_DIR}/gen/common/v1/common.pb.h
      ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.grpc.pb.h
      ${PROTO_GEN_DIR}/gen/component/camera/v1/camera.pb.h
      ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.grpc.pb.h
      ${PROTO_GEN_DIR}/gen/component/generic/v1/generic.pb.h
      ${PROTO_GEN_DIR}/gen/module/v1/module.grpc.pb.h
      ${PROTO_GEN_DIR}/gen/module/v1/module.pb.h
      ${PROTO_GEN_DIR}/gen/robot/v1/robot.grpc.pb.h
      ${PROTO_GEN_DIR}/gen/robot/v1/robot.pb.h
      ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.grpc.pb.h
      ${PROTO_GEN_DIR}/gen/tagger/v1/tagger.pb.h
)

set_target_properties(
  viamcpp PROPERTIES
  SOVERSION noabi
  VERSION ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}
)

target_include_directories(viamcpp
  PUBLIC
    "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>"
    "$<BUILD_INTERFACE:${PROTO_GEN_DIR}/gen>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"

    # These expand to nothing unless we picked up grpc/proto via
    # pkgconfig rather than find_package
    "$<BUILD_INTERFACE:${VIAMCPPSDK_GRPCXX_INCLUDE_DIRS}>"
    "$<INSTALL_INTERFACE:${VIAMCPPSDK_GRPCXX_INCLUDE_DIRS}>"
    "$<BUILD_INTERFACE:${VIAMCPPSDK_GRPC_INCLUDE_DIRS}>"
    "$<INSTALL_INTERFACE:${VIAMCPPSDK_GRPC_INCLUDE_DIRS}>"
    "$<BUILD_INTERFACE:${VIAMCPPSDK_PROTOBUF_INCLUDE_DIRS}>"
    "$<INSTALL_INTERFACE:${VIAMCPPSDK_PROTOBUF_INCLUDE_DIRS}>"
)

target_link_directories(viamcpp
  PUBLIC
    # This shouldn't be necessary, but we need it so that the
    # installation path of the C++ SDK is added to the link line of
    # consumers to that `-lviam_rust_utils` can be meaningfully
    # resolved.
    #
    # TODO: Remove this when we can import `viam_rust_utils` as a real
    # imported target with its own properties.
    "$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_LIBDIR}>"

    # These expand to nothing unless we picked up grpc/proto via
    # pkg-config rather than find_package
    "$<BUILD_INTERFACE:${VIAMCPPSDK_GRPCXX_LIBRARY_DIRS}>"
    "$<INSTALL_INTERFACE:${VIAMCPPSDK_GRPCXX_LIBRARY_DIRS}>"
    "$<BUILD_INTERFACE:${VIAMCPPSDK_GRPC_LIBRARY_DIRS}>"
    "$<INSTALL_INTERFACE:${VIAMCPPSDK_GRPC_LIBRARY_DIRS}>"
    "$<BUILD_INTERFACE:${VIAMCPPSDK_PROTOBUF_LIBRARY_DIRS}>"
    "$<INSTALL_INTERFACE:${VIAMCPPSDK_PROTOBUF_LIBRARY_DIRS}>"
)

target_link_libraries(viamcpp
  PUBLIC ${VIAMCPPSDK_GRPCXX_LIBRARIES}
  PUBLIC ${VIAMCPPSDK_GRPC_LIBRARIES}
  PUBLIC ${VIAMCPPSDK_PROTOBUF_LIBRARIES}
  PUBLIC Boost::headers
  PRIVATE Boost::log
  PRIVATE gRPC::grpc++_reflection
  PRIVATE viam_rust_utils
  PRIVATE Threads::Threads
)

add_subdirectory(tests)

install(
  TARGETS viamcpp
  EXPORT LibTargets
  RUNTIME COMPONENT viam-cpp-sdk_runtime
  LIBRARY COMPONENT viam-cpp-sdk_runtime
      NAMELINK_COMPONENT viam-cpp-sdk_dev
  ARCHIVE COMPONENT viam-cpp-sdk_dev
  FILE_SET viamcpp_public_includes COMPONENT viam-cpp-sdk_dev
  FILE_SET viamcpp_public_pb_includes COMPONENT viam-cpp-sdk_dev
)

install(
  EXPORT LibTargets
  FILE viam-cpp-sdkLibTargets.cmake
  NAMESPACE viam-cpp-sdk::
  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/viam-cpp-sdk
  COMPONENT viam-cpp-sdk_dev
)


# Generate a `pkg-config` file for the library component of the
# project. This is realy best effort as we can't necessarily capture
# the full set of requirements and dependencies.
#
# TODO: We should be pulling the paths and libaries out as properties
# and interpolating them in, but I can't yet figure out the right
# incantation to get CMake to expand the various generator expressions
# in the "INSTALL" context.

configure_file(
  config/viam-cpp-sdk-libviamcpp.pc.in
  config/viam-cpp-sdk-libviamcpp.pc
  @ONLY
)

install(FILES
  ${CMAKE_CURRENT_BINARY_DIR}/config/viam-cpp-sdk-libviamcpp.pc
  DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig
  COMPONENT viam-cpp-sdk_dev
)
