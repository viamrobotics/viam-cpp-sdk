// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: robot/v1/robot.proto
#ifndef GRPC_robot_2fv1_2frobot_2eproto__INCLUDED
#define GRPC_robot_2fv1_2frobot_2eproto__INCLUDED

#include "robot/v1/robot.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace viam {
namespace robot {
namespace v1 {

// A RobotService encompasses all functionality of some robot comprised of parts, local and remote.
class RobotService final {
 public:
  static constexpr char const* service_full_name() {
    return "viam.robot.v1.RobotService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::viam::robot::v1::GetOperationsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>> AsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>>(AsyncGetOperationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>> PrepareAsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>>(PrepareAsyncGetOperationsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::viam::robot::v1::GetSessionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>> AsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>>(AsyncGetSessionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>> PrepareAsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>>(PrepareAsyncGetSessionsRaw(context, request, cq));
    }
    // ResourceNames returns the list of all resources.
    virtual ::grpc::Status ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::viam::robot::v1::ResourceNamesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>> AsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>>(AsyncResourceNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>> PrepareAsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>>(PrepareAsyncResourceNamesRaw(context, request, cq));
    }
    // ResourceRPCSubtypes returns the list of all resource types.
    virtual ::grpc::Status ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>> AsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(AsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>> PrepareAsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(PrepareAsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    virtual ::grpc::Status CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::viam::robot::v1::CancelOperationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>> AsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>>(AsyncCancelOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>> PrepareAsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>>(PrepareAsyncCancelOperationRaw(context, request, cq));
    }
    virtual ::grpc::Status BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::viam::robot::v1::BlockForOperationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>> AsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>>(AsyncBlockForOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>> PrepareAsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>>(PrepareAsyncBlockForOperationRaw(context, request, cq));
    }
    // GetModelsFromModules returns the list of models supported in modules on the machine.
    virtual ::grpc::Status GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::viam::robot::v1::GetModelsFromModulesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetModelsFromModulesResponse>> AsyncGetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetModelsFromModulesResponse>>(AsyncGetModelsFromModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetModelsFromModulesResponse>> PrepareAsyncGetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetModelsFromModulesResponse>>(PrepareAsyncGetModelsFromModulesRaw(context, request, cq));
    }
    // DiscoverComponents returns the list of discovered component configurations.
    // This API is deprecated
    virtual ::grpc::Status DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::viam::robot::v1::DiscoverComponentsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>> AsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>>(AsyncDiscoverComponentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>> PrepareAsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>>(PrepareAsyncDiscoverComponentsRaw(context, request, cq));
    }
    virtual ::grpc::Status FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::viam::robot::v1::FrameSystemConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>> AsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>>(AsyncFrameSystemConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>> PrepareAsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>>(PrepareAsyncFrameSystemConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::viam::robot::v1::TransformPoseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>> AsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>>(AsyncTransformPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>> PrepareAsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>>(PrepareAsyncTransformPoseRaw(context, request, cq));
    }
    virtual ::grpc::Status TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::viam::robot::v1::TransformPCDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPCDResponse>> AsyncTransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPCDResponse>>(AsyncTransformPCDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPCDResponse>> PrepareAsyncTransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPCDResponse>>(PrepareAsyncTransformPCDRaw(context, request, cq));
    }
    // GetStatus returns the list of all statuses requested. An empty request signifies all resources.
    virtual ::grpc::Status GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::viam::robot::v1::GetStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>> AsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>>(AsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>> PrepareAsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>>(PrepareAsyncGetStatusRaw(context, request, cq));
    }
    // StreamStatus periodically sends the status of all statuses requested. An empty request signifies all resources.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::viam::robot::v1::StreamStatusResponse>> StreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::viam::robot::v1::StreamStatusResponse>>(StreamStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>> AsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>>(AsyncStreamStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>> PrepareAsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>>(PrepareAsyncStreamStatusRaw(context, request, cq));
    }
    // StopAll will stop all current and outstanding operations for the robot and stops all actuators and movement
    virtual ::grpc::Status StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::viam::robot::v1::StopAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>> AsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>>(AsyncStopAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>> PrepareAsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>>(PrepareAsyncStopAllRaw(context, request, cq));
    }
    // StartSession creates a new session that expects at least one heartbeat within the returned window.
    // If the window lapses, any resources that have safety heart monitored methods, where this session was
    // the last caller on the resource, will be stopped.
    virtual ::grpc::Status StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::viam::robot::v1::StartSessionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>> AsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>>(AsyncStartSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>> PrepareAsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>>(PrepareAsyncStartSessionRaw(context, request, cq));
    }
    // SendSessionHeartbeat sends a heartbeat to the given session. If the session has expired, a
    // SESSION_EXPIRED error will be returned.
    virtual ::grpc::Status SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::viam::robot::v1::SendSessionHeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>> AsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>>(AsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>> PrepareAsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>>(PrepareAsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    // Log sends logs to be logged by this robot. Currently used for module logging.
    virtual ::grpc::Status Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::viam::robot::v1::LogResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::LogResponse>> AsyncLog(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::LogResponse>>(AsyncLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::LogResponse>> PrepareAsyncLog(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::LogResponse>>(PrepareAsyncLogRaw(context, request, cq));
    }
    // GetCloudMetadata returns app-related information about the robot.
    virtual ::grpc::Status GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::viam::robot::v1::GetCloudMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetCloudMetadataResponse>> AsyncGetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetCloudMetadataResponse>>(AsyncGetCloudMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetCloudMetadataResponse>> PrepareAsyncGetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetCloudMetadataResponse>>(PrepareAsyncGetCloudMetadataRaw(context, request, cq));
    }
    virtual ::grpc::Status RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::viam::robot::v1::RestartModuleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::RestartModuleResponse>> AsyncRestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::RestartModuleResponse>>(AsyncRestartModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::RestartModuleResponse>> PrepareAsyncRestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::RestartModuleResponse>>(PrepareAsyncRestartModuleRaw(context, request, cq));
    }
    // Shutdown shuts down the robot.
    virtual ::grpc::Status Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::viam::robot::v1::ShutdownResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ShutdownResponse>> AsyncShutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ShutdownResponse>>(AsyncShutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ShutdownResponse>> PrepareAsyncShutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ShutdownResponse>>(PrepareAsyncShutdownRaw(context, request, cq));
    }
    // GetMachineStatus returns the current status of the robot.
    virtual ::grpc::Status GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::viam::robot::v1::GetMachineStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetMachineStatusResponse>> AsyncGetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetMachineStatusResponse>>(AsyncGetMachineStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetMachineStatusResponse>> PrepareAsyncGetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetMachineStatusResponse>>(PrepareAsyncGetMachineStatusRaw(context, request, cq));
    }
    // GetVersion returns version information about the robot.
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::viam::robot::v1::GetVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    // Tunnel tunnels traffic to the destination port of the robot server.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>> Tunnel(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>>(TunnelRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>> AsyncTunnel(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>>(AsyncTunnelRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>> PrepareAsyncTunnel(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>>(PrepareAsyncTunnelRaw(context, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOperations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetOperationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetOperations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetOperations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSessions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetSessionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSessions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSessions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // ResourceNames returns the list of all resources.
      virtual void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResourceNames(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceNamesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResourceNames(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResourceNames(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // ResourceRPCSubtypes returns the list of all resource types.
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::CancelOperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CancelOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CancelOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::BlockForOperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetModelsFromModules returns the list of models supported in modules on the machine.
      virtual void GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModelsFromModules(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetModelsFromModules(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetModelsFromModules(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // DiscoverComponents returns the list of discovered component configurations.
      // This API is deprecated
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::DiscoverComponentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::FrameSystemConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TransformPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPoseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TransformPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TransformPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TransformPCD(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPCDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TransformPCD(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TransformPCD(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetStatus returns the list of all statuses requested. An empty request signifies all resources.
      virtual void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // StreamStatus periodically sends the status of all statuses requested. An empty request signifies all resources.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StreamStatus(::grpc::ClientContext* context, ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ClientReadReactor< ::viam::robot::v1::StreamStatusResponse>* reactor) = 0;
      #else
      virtual void StreamStatus(::grpc::ClientContext* context, ::viam::robot::v1::StreamStatusRequest* request, ::grpc::experimental::ClientReadReactor< ::viam::robot::v1::StreamStatusResponse>* reactor) = 0;
      #endif
      // StopAll will stop all current and outstanding operations for the robot and stops all actuators and movement
      virtual void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StopAllResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StopAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StopAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // StartSession creates a new session that expects at least one heartbeat within the returned window.
      // If the window lapses, any resources that have safety heart monitored methods, where this session was
      // the last caller on the resource, will be stopped.
      virtual void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartSession(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StartSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartSession(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StartSession(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // SendSessionHeartbeat sends a heartbeat to the given session. If the session has expired, a
      // SESSION_EXPIRED error will be returned.
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Log sends logs to be logged by this robot. Currently used for module logging.
      virtual void Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Log(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::LogResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Log(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::LogResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Log(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::LogResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetCloudMetadata returns app-related information about the robot.
      virtual void GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCloudMetadata(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetCloudMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCloudMetadata(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCloudMetadata(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RestartModule(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::RestartModuleResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RestartModule(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RestartModule(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Shutdown shuts down the robot.
      virtual void Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Shutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ShutdownResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Shutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Shutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetMachineStatus returns the current status of the robot.
      virtual void GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMachineStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetMachineStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetMachineStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetMachineStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetVersion returns version information about the robot.
      virtual void GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Tunnel tunnels traffic to the destination port of the robot server.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Tunnel(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::viam::robot::v1::TunnelRequest,::viam::robot::v1::TunnelResponse>* reactor) = 0;
      #else
      virtual void Tunnel(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::viam::robot::v1::TunnelRequest,::viam::robot::v1::TunnelResponse>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>* AsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>* PrepareAsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>* AsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>* PrepareAsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>* AsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>* PrepareAsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>* AsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>* PrepareAsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>* AsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>* PrepareAsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>* AsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>* PrepareAsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetModelsFromModulesResponse>* AsyncGetModelsFromModulesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetModelsFromModulesResponse>* PrepareAsyncGetModelsFromModulesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>* AsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>* PrepareAsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>* AsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>* PrepareAsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>* AsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>* PrepareAsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPCDResponse>* AsyncTransformPCDRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPCDResponse>* PrepareAsyncTransformPCDRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>* AsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>* PrepareAsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::viam::robot::v1::StreamStatusResponse>* StreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>* AsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>* PrepareAsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>* AsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>* PrepareAsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>* AsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>* PrepareAsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>* AsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>* PrepareAsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::LogResponse>* AsyncLogRaw(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::LogResponse>* PrepareAsyncLogRaw(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetCloudMetadataResponse>* AsyncGetCloudMetadataRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetCloudMetadataResponse>* PrepareAsyncGetCloudMetadataRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::RestartModuleResponse>* AsyncRestartModuleRaw(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::RestartModuleResponse>* PrepareAsyncRestartModuleRaw(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ShutdownResponse>* AsyncShutdownRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ShutdownResponse>* PrepareAsyncShutdownRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetMachineStatusResponse>* AsyncGetMachineStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetMachineStatusResponse>* PrepareAsyncGetMachineStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* TunnelRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* AsyncTunnelRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* PrepareAsyncTunnelRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::viam::robot::v1::GetOperationsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>> AsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>>(AsyncGetOperationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>> PrepareAsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>>(PrepareAsyncGetOperationsRaw(context, request, cq));
    }
    ::grpc::Status GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::viam::robot::v1::GetSessionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>> AsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>>(AsyncGetSessionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>> PrepareAsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>>(PrepareAsyncGetSessionsRaw(context, request, cq));
    }
    ::grpc::Status ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::viam::robot::v1::ResourceNamesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>> AsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>>(AsyncResourceNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>> PrepareAsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>>(PrepareAsyncResourceNamesRaw(context, request, cq));
    }
    ::grpc::Status ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>> AsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(AsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>> PrepareAsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(PrepareAsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    ::grpc::Status CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::viam::robot::v1::CancelOperationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>> AsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>>(AsyncCancelOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>> PrepareAsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>>(PrepareAsyncCancelOperationRaw(context, request, cq));
    }
    ::grpc::Status BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::viam::robot::v1::BlockForOperationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>> AsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>>(AsyncBlockForOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>> PrepareAsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>>(PrepareAsyncBlockForOperationRaw(context, request, cq));
    }
    ::grpc::Status GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::viam::robot::v1::GetModelsFromModulesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetModelsFromModulesResponse>> AsyncGetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetModelsFromModulesResponse>>(AsyncGetModelsFromModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetModelsFromModulesResponse>> PrepareAsyncGetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetModelsFromModulesResponse>>(PrepareAsyncGetModelsFromModulesRaw(context, request, cq));
    }
    ::grpc::Status DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::viam::robot::v1::DiscoverComponentsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>> AsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>>(AsyncDiscoverComponentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>> PrepareAsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>>(PrepareAsyncDiscoverComponentsRaw(context, request, cq));
    }
    ::grpc::Status FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::viam::robot::v1::FrameSystemConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>> AsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>>(AsyncFrameSystemConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>> PrepareAsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>>(PrepareAsyncFrameSystemConfigRaw(context, request, cq));
    }
    ::grpc::Status TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::viam::robot::v1::TransformPoseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>> AsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>>(AsyncTransformPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>> PrepareAsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>>(PrepareAsyncTransformPoseRaw(context, request, cq));
    }
    ::grpc::Status TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::viam::robot::v1::TransformPCDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPCDResponse>> AsyncTransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPCDResponse>>(AsyncTransformPCDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPCDResponse>> PrepareAsyncTransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPCDResponse>>(PrepareAsyncTransformPCDRaw(context, request, cq));
    }
    ::grpc::Status GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::viam::robot::v1::GetStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>> AsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>>(AsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>> PrepareAsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>>(PrepareAsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::viam::robot::v1::StreamStatusResponse>> StreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::viam::robot::v1::StreamStatusResponse>>(StreamStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>> AsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>>(AsyncStreamStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>> PrepareAsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>>(PrepareAsyncStreamStatusRaw(context, request, cq));
    }
    ::grpc::Status StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::viam::robot::v1::StopAllResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>> AsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>>(AsyncStopAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>> PrepareAsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>>(PrepareAsyncStopAllRaw(context, request, cq));
    }
    ::grpc::Status StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::viam::robot::v1::StartSessionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>> AsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>>(AsyncStartSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>> PrepareAsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>>(PrepareAsyncStartSessionRaw(context, request, cq));
    }
    ::grpc::Status SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::viam::robot::v1::SendSessionHeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>> AsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>>(AsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>> PrepareAsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>>(PrepareAsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    ::grpc::Status Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::viam::robot::v1::LogResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::LogResponse>> AsyncLog(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::LogResponse>>(AsyncLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::LogResponse>> PrepareAsyncLog(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::LogResponse>>(PrepareAsyncLogRaw(context, request, cq));
    }
    ::grpc::Status GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::viam::robot::v1::GetCloudMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetCloudMetadataResponse>> AsyncGetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetCloudMetadataResponse>>(AsyncGetCloudMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetCloudMetadataResponse>> PrepareAsyncGetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetCloudMetadataResponse>>(PrepareAsyncGetCloudMetadataRaw(context, request, cq));
    }
    ::grpc::Status RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::viam::robot::v1::RestartModuleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::RestartModuleResponse>> AsyncRestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::RestartModuleResponse>>(AsyncRestartModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::RestartModuleResponse>> PrepareAsyncRestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::RestartModuleResponse>>(PrepareAsyncRestartModuleRaw(context, request, cq));
    }
    ::grpc::Status Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::viam::robot::v1::ShutdownResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ShutdownResponse>> AsyncShutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ShutdownResponse>>(AsyncShutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ShutdownResponse>> PrepareAsyncShutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ShutdownResponse>>(PrepareAsyncShutdownRaw(context, request, cq));
    }
    ::grpc::Status GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::viam::robot::v1::GetMachineStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetMachineStatusResponse>> AsyncGetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetMachineStatusResponse>>(AsyncGetMachineStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetMachineStatusResponse>> PrepareAsyncGetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetMachineStatusResponse>>(PrepareAsyncGetMachineStatusRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::viam::robot::v1::GetVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>> Tunnel(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>>(TunnelRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>> AsyncTunnel(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>>(AsyncTunnelRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>> PrepareAsyncTunnel(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>>(PrepareAsyncTunnelRaw(context, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOperations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetOperationsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetOperations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetOperations(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSessions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetSessionsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSessions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSessions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, std::function<void(::grpc::Status)>) override;
      void ResourceNames(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceNamesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResourceNames(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResourceNames(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, std::function<void(::grpc::Status)>) override;
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::CancelOperationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CancelOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CancelOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, std::function<void(::grpc::Status)>) override;
      void BlockForOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::BlockForOperationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BlockForOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BlockForOperation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModelsFromModules(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelsFromModules(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetModelsFromModules(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetModelsFromModules(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetModelsFromModulesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, std::function<void(::grpc::Status)>) override;
      void DiscoverComponents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::DiscoverComponentsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DiscoverComponents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DiscoverComponents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void FrameSystemConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::FrameSystemConfigResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrameSystemConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrameSystemConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, std::function<void(::grpc::Status)>) override;
      void TransformPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPoseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TransformPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TransformPose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response, std::function<void(::grpc::Status)>) override;
      void TransformPCD(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPCDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TransformPCD(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TransformPCD(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TransformPCD(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::TransformPCDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StreamStatus(::grpc::ClientContext* context, ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ClientReadReactor< ::viam::robot::v1::StreamStatusResponse>* reactor) override;
      #else
      void StreamStatus(::grpc::ClientContext* context, ::viam::robot::v1::StreamStatusRequest* request, ::grpc::experimental::ClientReadReactor< ::viam::robot::v1::StreamStatusResponse>* reactor) override;
      #endif
      void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, std::function<void(::grpc::Status)>) override;
      void StopAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StopAllResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StopAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StopAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, std::function<void(::grpc::Status)>) override;
      void StartSession(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StartSessionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartSession(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StartSession(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response, std::function<void(::grpc::Status)>) override;
      void Log(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::LogResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Log(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Log(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::LogResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Log(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::LogResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCloudMetadata(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetCloudMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCloudMetadata(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCloudMetadata(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCloudMetadata(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetCloudMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response, std::function<void(::grpc::Status)>) override;
      void RestartModule(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::RestartModuleResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RestartModule(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RestartModule(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RestartModule(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::RestartModuleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response, std::function<void(::grpc::Status)>) override;
      void Shutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ShutdownResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Shutdown(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Shutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Shutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::ShutdownResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetMachineStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetMachineStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetMachineStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetMachineStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetMachineStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetMachineStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVersion(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::viam::robot::v1::GetVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Tunnel(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::viam::robot::v1::TunnelRequest,::viam::robot::v1::TunnelResponse>* reactor) override;
      #else
      void Tunnel(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::viam::robot::v1::TunnelRequest,::viam::robot::v1::TunnelResponse>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>* AsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>* PrepareAsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>* AsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>* PrepareAsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>* AsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>* PrepareAsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>* AsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>* PrepareAsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>* AsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>* PrepareAsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>* AsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>* PrepareAsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetModelsFromModulesResponse>* AsyncGetModelsFromModulesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetModelsFromModulesResponse>* PrepareAsyncGetModelsFromModulesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>* AsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>* PrepareAsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>* AsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>* PrepareAsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>* AsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>* PrepareAsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPCDResponse>* AsyncTransformPCDRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPCDResponse>* PrepareAsyncTransformPCDRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPCDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>* AsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>* PrepareAsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::viam::robot::v1::StreamStatusResponse>* StreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) override;
    ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>* AsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>* PrepareAsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>* AsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>* PrepareAsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>* AsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>* PrepareAsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>* AsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>* PrepareAsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::LogResponse>* AsyncLogRaw(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::LogResponse>* PrepareAsyncLogRaw(::grpc::ClientContext* context, const ::viam::robot::v1::LogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetCloudMetadataResponse>* AsyncGetCloudMetadataRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetCloudMetadataResponse>* PrepareAsyncGetCloudMetadataRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetCloudMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::RestartModuleResponse>* AsyncRestartModuleRaw(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::RestartModuleResponse>* PrepareAsyncRestartModuleRaw(::grpc::ClientContext* context, const ::viam::robot::v1::RestartModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ShutdownResponse>* AsyncShutdownRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ShutdownResponse>* PrepareAsyncShutdownRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ShutdownRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetMachineStatusResponse>* AsyncGetMachineStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetMachineStatusResponse>* PrepareAsyncGetMachineStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetMachineStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* TunnelRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* AsyncTunnelRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* PrepareAsyncTunnelRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetOperations_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSessions_;
    const ::grpc::internal::RpcMethod rpcmethod_ResourceNames_;
    const ::grpc::internal::RpcMethod rpcmethod_ResourceRPCSubtypes_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelOperation_;
    const ::grpc::internal::RpcMethod rpcmethod_BlockForOperation_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModelsFromModules_;
    const ::grpc::internal::RpcMethod rpcmethod_DiscoverComponents_;
    const ::grpc::internal::RpcMethod rpcmethod_FrameSystemConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_TransformPose_;
    const ::grpc::internal::RpcMethod rpcmethod_TransformPCD_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_StopAll_;
    const ::grpc::internal::RpcMethod rpcmethod_StartSession_;
    const ::grpc::internal::RpcMethod rpcmethod_SendSessionHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_Log_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCloudMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_RestartModule_;
    const ::grpc::internal::RpcMethod rpcmethod_Shutdown_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMachineStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_Tunnel_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetOperations(::grpc::ServerContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response);
    virtual ::grpc::Status GetSessions(::grpc::ServerContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response);
    // ResourceNames returns the list of all resources.
    virtual ::grpc::Status ResourceNames(::grpc::ServerContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response);
    // ResourceRPCSubtypes returns the list of all resource types.
    virtual ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response);
    virtual ::grpc::Status CancelOperation(::grpc::ServerContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response);
    virtual ::grpc::Status BlockForOperation(::grpc::ServerContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response);
    // GetModelsFromModules returns the list of models supported in modules on the machine.
    virtual ::grpc::Status GetModelsFromModules(::grpc::ServerContext* context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response);
    // DiscoverComponents returns the list of discovered component configurations.
    // This API is deprecated
    virtual ::grpc::Status DiscoverComponents(::grpc::ServerContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response);
    virtual ::grpc::Status FrameSystemConfig(::grpc::ServerContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response);
    virtual ::grpc::Status TransformPose(::grpc::ServerContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response);
    virtual ::grpc::Status TransformPCD(::grpc::ServerContext* context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response);
    // GetStatus returns the list of all statuses requested. An empty request signifies all resources.
    virtual ::grpc::Status GetStatus(::grpc::ServerContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response);
    // StreamStatus periodically sends the status of all statuses requested. An empty request signifies all resources.
    virtual ::grpc::Status StreamStatus(::grpc::ServerContext* context, const ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* writer);
    // StopAll will stop all current and outstanding operations for the robot and stops all actuators and movement
    virtual ::grpc::Status StopAll(::grpc::ServerContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response);
    // StartSession creates a new session that expects at least one heartbeat within the returned window.
    // If the window lapses, any resources that have safety heart monitored methods, where this session was
    // the last caller on the resource, will be stopped.
    virtual ::grpc::Status StartSession(::grpc::ServerContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response);
    // SendSessionHeartbeat sends a heartbeat to the given session. If the session has expired, a
    // SESSION_EXPIRED error will be returned.
    virtual ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response);
    // Log sends logs to be logged by this robot. Currently used for module logging.
    virtual ::grpc::Status Log(::grpc::ServerContext* context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response);
    // GetCloudMetadata returns app-related information about the robot.
    virtual ::grpc::Status GetCloudMetadata(::grpc::ServerContext* context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response);
    virtual ::grpc::Status RestartModule(::grpc::ServerContext* context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response);
    // Shutdown shuts down the robot.
    virtual ::grpc::Status Shutdown(::grpc::ServerContext* context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response);
    // GetMachineStatus returns the current status of the robot.
    virtual ::grpc::Status GetMachineStatus(::grpc::ServerContext* context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response);
    // GetVersion returns version information about the robot.
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response);
    // Tunnel tunnels traffic to the destination port of the robot server.
    virtual ::grpc::Status Tunnel(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::viam::robot::v1::TunnelResponse, ::viam::robot::v1::TunnelRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOperations() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOperations(::grpc::ServerContext* context, ::viam::robot::v1::GetOperationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetOperationsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSessions() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessions(::grpc::ServerContext* context, ::viam::robot::v1::GetSessionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetSessionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResourceNames() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceNames(::grpc::ServerContext* context, ::viam::robot::v1::ResourceNamesRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::ResourceNamesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceRPCSubtypes(::grpc::ServerContext* context, ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::ResourceRPCSubtypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelOperation() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelOperation(::grpc::ServerContext* context, ::viam::robot::v1::CancelOperationRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::CancelOperationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlockForOperation(::grpc::ServerContext* context, ::viam::robot::v1::BlockForOperationRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::BlockForOperationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModelsFromModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModelsFromModules() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetModelsFromModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelsFromModules(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelsFromModules(::grpc::ServerContext* context, ::viam::robot::v1::GetModelsFromModulesRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetModelsFromModulesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDiscoverComponents(::grpc::ServerContext* context, ::viam::robot::v1::DiscoverComponentsRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::DiscoverComponentsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrameSystemConfig(::grpc::ServerContext* context, ::viam::robot::v1::FrameSystemConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::FrameSystemConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TransformPose() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransformPose(::grpc::ServerContext* context, ::viam::robot::v1::TransformPoseRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::TransformPoseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransformPCD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TransformPCD() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_TransformPCD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPCD(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransformPCD(::grpc::ServerContext* context, ::viam::robot::v1::TransformPCDRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::TransformPCDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStatus() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatus(::grpc::ServerContext* context, ::viam::robot::v1::GetStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamStatus() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamStatus(::grpc::ServerContext* context, ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ServerAsyncWriter< ::viam::robot::v1::StreamStatusResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(12, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopAll() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAll(::grpc::ServerContext* context, ::viam::robot::v1::StopAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::StopAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartSession() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartSession(::grpc::ServerContext* context, ::viam::robot::v1::StartSessionRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::StartSessionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendSessionHeartbeat(::grpc::ServerContext* context, ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::SendSessionHeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Log() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLog(::grpc::ServerContext* context, ::viam::robot::v1::LogRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::LogResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCloudMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCloudMetadata() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetCloudMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCloudMetadata(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCloudMetadata(::grpc::ServerContext* context, ::viam::robot::v1::GetCloudMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetCloudMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RestartModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RestartModule() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_RestartModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestartModule(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRestartModule(::grpc::ServerContext* context, ::viam::robot::v1::RestartModuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::RestartModuleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Shutdown() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_Shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Shutdown(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShutdown(::grpc::ServerContext* context, ::viam::robot::v1::ShutdownRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::ShutdownResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMachineStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMachineStatus() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetMachineStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMachineStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMachineStatus(::grpc::ServerContext* context, ::viam::robot::v1::GetMachineStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetMachineStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::viam::robot::v1::GetVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Tunnel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Tunnel() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_Tunnel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tunnel(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::viam::robot::v1::TunnelResponse, ::viam::robot::v1::TunnelRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTunnel(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::viam::robot::v1::TunnelResponse, ::viam::robot::v1::TunnelRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(22, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetOperations<WithAsyncMethod_GetSessions<WithAsyncMethod_ResourceNames<WithAsyncMethod_ResourceRPCSubtypes<WithAsyncMethod_CancelOperation<WithAsyncMethod_BlockForOperation<WithAsyncMethod_GetModelsFromModules<WithAsyncMethod_DiscoverComponents<WithAsyncMethod_FrameSystemConfig<WithAsyncMethod_TransformPose<WithAsyncMethod_TransformPCD<WithAsyncMethod_GetStatus<WithAsyncMethod_StreamStatus<WithAsyncMethod_StopAll<WithAsyncMethod_StartSession<WithAsyncMethod_SendSessionHeartbeat<WithAsyncMethod_Log<WithAsyncMethod_GetCloudMetadata<WithAsyncMethod_RestartModule<WithAsyncMethod_Shutdown<WithAsyncMethod_GetMachineStatus<WithAsyncMethod_GetVersion<WithAsyncMethod_Tunnel<Service > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetOperations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response) { return this->GetOperations(context, request, response); }));}
    void SetMessageAllocatorFor_GetOperations(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetOperations(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetOperations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSessions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response) { return this->GetSessions(context, request, response); }));}
    void SetMessageAllocatorFor_GetSessions(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessions(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResourceNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response) { return this->ResourceNames(context, request, response); }));}
    void SetMessageAllocatorFor_ResourceNames(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResourceNames(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResourceNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResourceRPCSubtypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response) { return this->ResourceRPCSubtypes(context, request, response); }));}
    void SetMessageAllocatorFor_ResourceRPCSubtypes(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResourceRPCSubtypes(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResourceRPCSubtypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CancelOperation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response) { return this->CancelOperation(context, request, response); }));}
    void SetMessageAllocatorFor_CancelOperation(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelOperation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BlockForOperation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response) { return this->BlockForOperation(context, request, response); }));}
    void SetMessageAllocatorFor_BlockForOperation(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BlockForOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BlockForOperation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetModelsFromModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetModelsFromModules() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetModelsFromModulesRequest, ::viam::robot::v1::GetModelsFromModulesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::GetModelsFromModulesRequest* request, ::viam::robot::v1::GetModelsFromModulesResponse* response) { return this->GetModelsFromModules(context, request, response); }));}
    void SetMessageAllocatorFor_GetModelsFromModules(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::GetModelsFromModulesRequest, ::viam::robot::v1::GetModelsFromModulesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetModelsFromModulesRequest, ::viam::robot::v1::GetModelsFromModulesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetModelsFromModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelsFromModules(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelsFromModules(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelsFromModules(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DiscoverComponents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response) { return this->DiscoverComponents(context, request, response); }));}
    void SetMessageAllocatorFor_DiscoverComponents(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DiscoverComponents(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DiscoverComponents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrameSystemConfig() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response) { return this->FrameSystemConfig(context, request, response); }));}
    void SetMessageAllocatorFor_FrameSystemConfig(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrameSystemConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrameSystemConfig(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TransformPose() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response) { return this->TransformPose(context, request, response); }));}
    void SetMessageAllocatorFor_TransformPose(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TransformPose(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TransformPose(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TransformPCD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TransformPCD() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::TransformPCDRequest, ::viam::robot::v1::TransformPCDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::TransformPCDRequest* request, ::viam::robot::v1::TransformPCDResponse* response) { return this->TransformPCD(context, request, response); }));}
    void SetMessageAllocatorFor_TransformPCD(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::TransformPCDRequest, ::viam::robot::v1::TransformPCDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::TransformPCDRequest, ::viam::robot::v1::TransformPCDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TransformPCD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPCD(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TransformPCD(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TransformPCD(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response) { return this->GetStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetStatus(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StreamStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::viam::robot::v1::StreamStatusRequest, ::viam::robot::v1::StreamStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::StreamStatusRequest* request) { return this->StreamStatus(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::viam::robot::v1::StreamStatusResponse>* StreamStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::viam::robot::v1::StreamStatusResponse>* StreamStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StopAll() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response) { return this->StopAll(context, request, response); }));}
    void SetMessageAllocatorFor_StopAll(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopAll(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopAll(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response) { return this->StartSession(context, request, response); }));}
    void SetMessageAllocatorFor_StartSession(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartSession(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendSessionHeartbeat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response) { return this->SendSessionHeartbeat(context, request, response); }));}
    void SetMessageAllocatorFor_SendSessionHeartbeat(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendSessionHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendSessionHeartbeat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Log() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::LogRequest, ::viam::robot::v1::LogResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::LogRequest* request, ::viam::robot::v1::LogResponse* response) { return this->Log(context, request, response); }));}
    void SetMessageAllocatorFor_Log(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::LogRequest, ::viam::robot::v1::LogResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::LogRequest, ::viam::robot::v1::LogResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Log(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Log(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCloudMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCloudMetadata() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetCloudMetadataRequest, ::viam::robot::v1::GetCloudMetadataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::GetCloudMetadataRequest* request, ::viam::robot::v1::GetCloudMetadataResponse* response) { return this->GetCloudMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_GetCloudMetadata(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::GetCloudMetadataRequest, ::viam::robot::v1::GetCloudMetadataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetCloudMetadataRequest, ::viam::robot::v1::GetCloudMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCloudMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCloudMetadata(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCloudMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCloudMetadata(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RestartModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RestartModule() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::RestartModuleRequest, ::viam::robot::v1::RestartModuleResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::RestartModuleRequest* request, ::viam::robot::v1::RestartModuleResponse* response) { return this->RestartModule(context, request, response); }));}
    void SetMessageAllocatorFor_RestartModule(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::RestartModuleRequest, ::viam::robot::v1::RestartModuleResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::RestartModuleRequest, ::viam::robot::v1::RestartModuleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RestartModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestartModule(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RestartModule(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RestartModule(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Shutdown() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::ShutdownRequest, ::viam::robot::v1::ShutdownResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::ShutdownRequest* request, ::viam::robot::v1::ShutdownResponse* response) { return this->Shutdown(context, request, response); }));}
    void SetMessageAllocatorFor_Shutdown(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::ShutdownRequest, ::viam::robot::v1::ShutdownResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::ShutdownRequest, ::viam::robot::v1::ShutdownResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Shutdown(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Shutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Shutdown(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMachineStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMachineStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetMachineStatusRequest, ::viam::robot::v1::GetMachineStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::GetMachineStatusRequest* request, ::viam::robot::v1::GetMachineStatusResponse* response) { return this->GetMachineStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetMachineStatus(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::GetMachineStatusRequest, ::viam::robot::v1::GetMachineStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetMachineStatusRequest, ::viam::robot::v1::GetMachineStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMachineStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMachineStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetMachineStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetMachineStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetVersionRequest, ::viam::robot::v1::GetVersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::viam::robot::v1::GetVersionRequest* request, ::viam::robot::v1::GetVersionResponse* response) { return this->GetVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetVersion(
        ::grpc::experimental::MessageAllocator< ::viam::robot::v1::GetVersionRequest, ::viam::robot::v1::GetVersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::viam::robot::v1::GetVersionRequest, ::viam::robot::v1::GetVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Tunnel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Tunnel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc_impl::internal::CallbackBidiHandler< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->Tunnel(context); }));
    }
    ~ExperimentalWithCallbackMethod_Tunnel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tunnel(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::viam::robot::v1::TunnelResponse, ::viam::robot::v1::TunnelRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* Tunnel(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::viam::robot::v1::TunnelRequest, ::viam::robot::v1::TunnelResponse>* Tunnel(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetOperations<ExperimentalWithCallbackMethod_GetSessions<ExperimentalWithCallbackMethod_ResourceNames<ExperimentalWithCallbackMethod_ResourceRPCSubtypes<ExperimentalWithCallbackMethod_CancelOperation<ExperimentalWithCallbackMethod_BlockForOperation<ExperimentalWithCallbackMethod_GetModelsFromModules<ExperimentalWithCallbackMethod_DiscoverComponents<ExperimentalWithCallbackMethod_FrameSystemConfig<ExperimentalWithCallbackMethod_TransformPose<ExperimentalWithCallbackMethod_TransformPCD<ExperimentalWithCallbackMethod_GetStatus<ExperimentalWithCallbackMethod_StreamStatus<ExperimentalWithCallbackMethod_StopAll<ExperimentalWithCallbackMethod_StartSession<ExperimentalWithCallbackMethod_SendSessionHeartbeat<ExperimentalWithCallbackMethod_Log<ExperimentalWithCallbackMethod_GetCloudMetadata<ExperimentalWithCallbackMethod_RestartModule<ExperimentalWithCallbackMethod_Shutdown<ExperimentalWithCallbackMethod_GetMachineStatus<ExperimentalWithCallbackMethod_GetVersion<ExperimentalWithCallbackMethod_Tunnel<Service > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetOperations<ExperimentalWithCallbackMethod_GetSessions<ExperimentalWithCallbackMethod_ResourceNames<ExperimentalWithCallbackMethod_ResourceRPCSubtypes<ExperimentalWithCallbackMethod_CancelOperation<ExperimentalWithCallbackMethod_BlockForOperation<ExperimentalWithCallbackMethod_GetModelsFromModules<ExperimentalWithCallbackMethod_DiscoverComponents<ExperimentalWithCallbackMethod_FrameSystemConfig<ExperimentalWithCallbackMethod_TransformPose<ExperimentalWithCallbackMethod_TransformPCD<ExperimentalWithCallbackMethod_GetStatus<ExperimentalWithCallbackMethod_StreamStatus<ExperimentalWithCallbackMethod_StopAll<ExperimentalWithCallbackMethod_StartSession<ExperimentalWithCallbackMethod_SendSessionHeartbeat<ExperimentalWithCallbackMethod_Log<ExperimentalWithCallbackMethod_GetCloudMetadata<ExperimentalWithCallbackMethod_RestartModule<ExperimentalWithCallbackMethod_Shutdown<ExperimentalWithCallbackMethod_GetMachineStatus<ExperimentalWithCallbackMethod_GetVersion<ExperimentalWithCallbackMethod_Tunnel<Service > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOperations() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSessions() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResourceNames() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelOperation() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModelsFromModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModelsFromModules() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetModelsFromModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelsFromModules(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TransformPose() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransformPCD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TransformPCD() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_TransformPCD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPCD(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStatus() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamStatus() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopAll() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartSession() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Log() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCloudMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCloudMetadata() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetCloudMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCloudMetadata(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RestartModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RestartModule() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_RestartModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestartModule(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Shutdown() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_Shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Shutdown(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMachineStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMachineStatus() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetMachineStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMachineStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Tunnel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Tunnel() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_Tunnel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tunnel(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::viam::robot::v1::TunnelResponse, ::viam::robot::v1::TunnelRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOperations() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOperations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSessions() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResourceNames() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceNames(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceRPCSubtypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelOperation() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelOperation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlockForOperation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModelsFromModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModelsFromModules() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetModelsFromModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelsFromModules(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModelsFromModules(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDiscoverComponents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrameSystemConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TransformPose() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransformPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransformPCD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TransformPCD() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_TransformPCD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPCD(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransformPCD(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStatus() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamStatus() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(12, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopAll() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartSession() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartSession(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendSessionHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Log() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCloudMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCloudMetadata() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetCloudMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCloudMetadata(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCloudMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RestartModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RestartModule() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_RestartModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestartModule(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRestartModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Shutdown() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_Shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Shutdown(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShutdown(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMachineStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMachineStatus() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetMachineStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMachineStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMachineStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Tunnel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Tunnel() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_Tunnel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tunnel(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::viam::robot::v1::TunnelResponse, ::viam::robot::v1::TunnelRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTunnel(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(22, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetOperations() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOperations(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetOperations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetOperations(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSessions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSessions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResourceNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResourceNames(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResourceNames(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResourceNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResourceRPCSubtypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResourceRPCSubtypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResourceRPCSubtypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResourceRPCSubtypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CancelOperation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelOperation(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelOperation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BlockForOperation() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BlockForOperation(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BlockForOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BlockForOperation(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetModelsFromModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetModelsFromModules() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModelsFromModules(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetModelsFromModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModelsFromModules(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetModelsFromModules(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetModelsFromModules(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DiscoverComponents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DiscoverComponents(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DiscoverComponents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DiscoverComponents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrameSystemConfig() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrameSystemConfig(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrameSystemConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrameSystemConfig(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TransformPose() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TransformPose(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TransformPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TransformPose(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TransformPCD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TransformPCD() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TransformPCD(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TransformPCD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPCD(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TransformPCD(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TransformPCD(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StreamStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->StreamStatus(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* StreamStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StopAll() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopAll(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopAll(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartSession(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartSession(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendSessionHeartbeat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendSessionHeartbeat(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendSessionHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendSessionHeartbeat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Log() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Log(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Log(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Log(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCloudMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCloudMetadata() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCloudMetadata(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCloudMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCloudMetadata(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCloudMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCloudMetadata(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RestartModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RestartModule() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RestartModule(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RestartModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RestartModule(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RestartModule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RestartModule(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Shutdown() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Shutdown(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Shutdown(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Shutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Shutdown(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMachineStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMachineStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMachineStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMachineStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMachineStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetMachineStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetMachineStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVersion(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Tunnel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Tunnel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->Tunnel(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_Tunnel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tunnel(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::viam::robot::v1::TunnelResponse, ::viam::robot::v1::TunnelRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Tunnel(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Tunnel(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOperations() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>* streamer) {
                       return this->StreamedGetOperations(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOperations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetOperationsRequest,::viam::robot::v1::GetOperationsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSessions() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>* streamer) {
                       return this->StreamedGetSessions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSessions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetSessionsRequest,::viam::robot::v1::GetSessionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResourceNames() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>* streamer) {
                       return this->StreamedResourceNames(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResourceNames(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::ResourceNamesRequest,::viam::robot::v1::ResourceNamesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>* streamer) {
                       return this->StreamedResourceRPCSubtypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResourceRPCSubtypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::ResourceRPCSubtypesRequest,::viam::robot::v1::ResourceRPCSubtypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelOperation() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>* streamer) {
                       return this->StreamedCancelOperation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelOperation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::CancelOperationRequest,::viam::robot::v1::CancelOperationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>* streamer) {
                       return this->StreamedBlockForOperation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBlockForOperation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::BlockForOperationRequest,::viam::robot::v1::BlockForOperationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModelsFromModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModelsFromModules() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetModelsFromModulesRequest, ::viam::robot::v1::GetModelsFromModulesResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::GetModelsFromModulesRequest, ::viam::robot::v1::GetModelsFromModulesResponse>* streamer) {
                       return this->StreamedGetModelsFromModules(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetModelsFromModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModelsFromModules(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetModelsFromModulesRequest* /*request*/, ::viam::robot::v1::GetModelsFromModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModelsFromModules(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetModelsFromModulesRequest,::viam::robot::v1::GetModelsFromModulesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>* streamer) {
                       return this->StreamedDiscoverComponents(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDiscoverComponents(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::DiscoverComponentsRequest,::viam::robot::v1::DiscoverComponentsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>* streamer) {
                       return this->StreamedFrameSystemConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrameSystemConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::FrameSystemConfigRequest,::viam::robot::v1::FrameSystemConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TransformPose() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>* streamer) {
                       return this->StreamedTransformPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransformPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::TransformPoseRequest,::viam::robot::v1::TransformPoseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransformPCD : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TransformPCD() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::TransformPCDRequest, ::viam::robot::v1::TransformPCDResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::TransformPCDRequest, ::viam::robot::v1::TransformPCDResponse>* streamer) {
                       return this->StreamedTransformPCD(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TransformPCD() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransformPCD(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPCDRequest* /*request*/, ::viam::robot::v1::TransformPCDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransformPCD(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::TransformPCDRequest,::viam::robot::v1::TransformPCDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStatus() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>* streamer) {
                       return this->StreamedGetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetStatusRequest,::viam::robot::v1::GetStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopAll() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>* streamer) {
                       return this->StreamedStopAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::StopAllRequest,::viam::robot::v1::StopAllResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartSession() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>* streamer) {
                       return this->StreamedStartSession(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartSession(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::StartSessionRequest,::viam::robot::v1::StartSessionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>* streamer) {
                       return this->StreamedSendSessionHeartbeat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendSessionHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::SendSessionHeartbeatRequest,::viam::robot::v1::SendSessionHeartbeatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Log() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::LogRequest, ::viam::robot::v1::LogResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::LogRequest, ::viam::robot::v1::LogResponse>* streamer) {
                       return this->StreamedLog(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Log(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::LogRequest* /*request*/, ::viam::robot::v1::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::LogRequest,::viam::robot::v1::LogResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCloudMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCloudMetadata() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetCloudMetadataRequest, ::viam::robot::v1::GetCloudMetadataResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::GetCloudMetadataRequest, ::viam::robot::v1::GetCloudMetadataResponse>* streamer) {
                       return this->StreamedGetCloudMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCloudMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCloudMetadata(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetCloudMetadataRequest* /*request*/, ::viam::robot::v1::GetCloudMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCloudMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetCloudMetadataRequest,::viam::robot::v1::GetCloudMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RestartModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RestartModule() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::RestartModuleRequest, ::viam::robot::v1::RestartModuleResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::RestartModuleRequest, ::viam::robot::v1::RestartModuleResponse>* streamer) {
                       return this->StreamedRestartModule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RestartModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RestartModule(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::RestartModuleRequest* /*request*/, ::viam::robot::v1::RestartModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRestartModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::RestartModuleRequest,::viam::robot::v1::RestartModuleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Shutdown() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::ShutdownRequest, ::viam::robot::v1::ShutdownResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::ShutdownRequest, ::viam::robot::v1::ShutdownResponse>* streamer) {
                       return this->StreamedShutdown(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Shutdown(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ShutdownRequest* /*request*/, ::viam::robot::v1::ShutdownResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedShutdown(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::ShutdownRequest,::viam::robot::v1::ShutdownResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMachineStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMachineStatus() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetMachineStatusRequest, ::viam::robot::v1::GetMachineStatusResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::GetMachineStatusRequest, ::viam::robot::v1::GetMachineStatusResponse>* streamer) {
                       return this->StreamedGetMachineStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMachineStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMachineStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetMachineStatusRequest* /*request*/, ::viam::robot::v1::GetMachineStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMachineStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetMachineStatusRequest,::viam::robot::v1::GetMachineStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetVersionRequest, ::viam::robot::v1::GetVersionResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::viam::robot::v1::GetVersionRequest, ::viam::robot::v1::GetVersionResponse>* streamer) {
                       return this->StreamedGetVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetVersionRequest* /*request*/, ::viam::robot::v1::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetVersionRequest,::viam::robot::v1::GetVersionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetOperations<WithStreamedUnaryMethod_GetSessions<WithStreamedUnaryMethod_ResourceNames<WithStreamedUnaryMethod_ResourceRPCSubtypes<WithStreamedUnaryMethod_CancelOperation<WithStreamedUnaryMethod_BlockForOperation<WithStreamedUnaryMethod_GetModelsFromModules<WithStreamedUnaryMethod_DiscoverComponents<WithStreamedUnaryMethod_FrameSystemConfig<WithStreamedUnaryMethod_TransformPose<WithStreamedUnaryMethod_TransformPCD<WithStreamedUnaryMethod_GetStatus<WithStreamedUnaryMethod_StopAll<WithStreamedUnaryMethod_StartSession<WithStreamedUnaryMethod_SendSessionHeartbeat<WithStreamedUnaryMethod_Log<WithStreamedUnaryMethod_GetCloudMetadata<WithStreamedUnaryMethod_RestartModule<WithStreamedUnaryMethod_Shutdown<WithStreamedUnaryMethod_GetMachineStatus<WithStreamedUnaryMethod_GetVersion<Service > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamStatus() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::viam::robot::v1::StreamStatusRequest, ::viam::robot::v1::StreamStatusResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::viam::robot::v1::StreamStatusRequest, ::viam::robot::v1::StreamStatusResponse>* streamer) {
                       return this->StreamedStreamStatus(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamStatus(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::viam::robot::v1::StreamStatusRequest,::viam::robot::v1::StreamStatusResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StreamStatus<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetOperations<WithStreamedUnaryMethod_GetSessions<WithStreamedUnaryMethod_ResourceNames<WithStreamedUnaryMethod_ResourceRPCSubtypes<WithStreamedUnaryMethod_CancelOperation<WithStreamedUnaryMethod_BlockForOperation<WithStreamedUnaryMethod_GetModelsFromModules<WithStreamedUnaryMethod_DiscoverComponents<WithStreamedUnaryMethod_FrameSystemConfig<WithStreamedUnaryMethod_TransformPose<WithStreamedUnaryMethod_TransformPCD<WithStreamedUnaryMethod_GetStatus<WithSplitStreamingMethod_StreamStatus<WithStreamedUnaryMethod_StopAll<WithStreamedUnaryMethod_StartSession<WithStreamedUnaryMethod_SendSessionHeartbeat<WithStreamedUnaryMethod_Log<WithStreamedUnaryMethod_GetCloudMetadata<WithStreamedUnaryMethod_RestartModule<WithStreamedUnaryMethod_Shutdown<WithStreamedUnaryMethod_GetMachineStatus<WithStreamedUnaryMethod_GetVersion<Service > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace robot
}  // namespace viam


#endif  // GRPC_robot_2fv1_2frobot_2eproto__INCLUDED
