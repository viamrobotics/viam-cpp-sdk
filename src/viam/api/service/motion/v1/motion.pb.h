// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service/motion/v1/motion.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2fmotion_2fv1_2fmotion_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_service_2fmotion_2fv1_2fmotion_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common/v1/common.pb.h"
#include "google/api/annotations.pb.h"
#include "google/protobuf/struct.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_service_2fmotion_2fv1_2fmotion_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2fmotion_2fv1_2fmotion_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_service_2fmotion_2fv1_2fmotion_2eproto;
namespace viam {
namespace service {
namespace motion {
namespace v1 {
class CollisionSpecification;
struct CollisionSpecificationDefaultTypeInternal;
extern CollisionSpecificationDefaultTypeInternal _CollisionSpecification_default_instance_;
class CollisionSpecification_AllowedFrameCollisions;
struct CollisionSpecification_AllowedFrameCollisionsDefaultTypeInternal;
extern CollisionSpecification_AllowedFrameCollisionsDefaultTypeInternal _CollisionSpecification_AllowedFrameCollisions_default_instance_;
class ComponentState;
struct ComponentStateDefaultTypeInternal;
extern ComponentStateDefaultTypeInternal _ComponentState_default_instance_;
class Constraints;
struct ConstraintsDefaultTypeInternal;
extern ConstraintsDefaultTypeInternal _Constraints_default_instance_;
class GetPlanRequest;
struct GetPlanRequestDefaultTypeInternal;
extern GetPlanRequestDefaultTypeInternal _GetPlanRequest_default_instance_;
class GetPlanResponse;
struct GetPlanResponseDefaultTypeInternal;
extern GetPlanResponseDefaultTypeInternal _GetPlanResponse_default_instance_;
class GetPoseRequest;
struct GetPoseRequestDefaultTypeInternal;
extern GetPoseRequestDefaultTypeInternal _GetPoseRequest_default_instance_;
class GetPoseResponse;
struct GetPoseResponseDefaultTypeInternal;
extern GetPoseResponseDefaultTypeInternal _GetPoseResponse_default_instance_;
class LinearConstraint;
struct LinearConstraintDefaultTypeInternal;
extern LinearConstraintDefaultTypeInternal _LinearConstraint_default_instance_;
class ListPlanStatusesRequest;
struct ListPlanStatusesRequestDefaultTypeInternal;
extern ListPlanStatusesRequestDefaultTypeInternal _ListPlanStatusesRequest_default_instance_;
class ListPlanStatusesResponse;
struct ListPlanStatusesResponseDefaultTypeInternal;
extern ListPlanStatusesResponseDefaultTypeInternal _ListPlanStatusesResponse_default_instance_;
class MotionConfiguration;
struct MotionConfigurationDefaultTypeInternal;
extern MotionConfigurationDefaultTypeInternal _MotionConfiguration_default_instance_;
class MoveOnGlobeRequest;
struct MoveOnGlobeRequestDefaultTypeInternal;
extern MoveOnGlobeRequestDefaultTypeInternal _MoveOnGlobeRequest_default_instance_;
class MoveOnGlobeResponse;
struct MoveOnGlobeResponseDefaultTypeInternal;
extern MoveOnGlobeResponseDefaultTypeInternal _MoveOnGlobeResponse_default_instance_;
class MoveOnMapRequest;
struct MoveOnMapRequestDefaultTypeInternal;
extern MoveOnMapRequestDefaultTypeInternal _MoveOnMapRequest_default_instance_;
class MoveOnMapResponse;
struct MoveOnMapResponseDefaultTypeInternal;
extern MoveOnMapResponseDefaultTypeInternal _MoveOnMapResponse_default_instance_;
class MoveRequest;
struct MoveRequestDefaultTypeInternal;
extern MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
class MoveResponse;
struct MoveResponseDefaultTypeInternal;
extern MoveResponseDefaultTypeInternal _MoveResponse_default_instance_;
class ObstacleDetector;
struct ObstacleDetectorDefaultTypeInternal;
extern ObstacleDetectorDefaultTypeInternal _ObstacleDetector_default_instance_;
class OrientationConstraint;
struct OrientationConstraintDefaultTypeInternal;
extern OrientationConstraintDefaultTypeInternal _OrientationConstraint_default_instance_;
class Plan;
struct PlanDefaultTypeInternal;
extern PlanDefaultTypeInternal _Plan_default_instance_;
class PlanStatus;
struct PlanStatusDefaultTypeInternal;
extern PlanStatusDefaultTypeInternal _PlanStatus_default_instance_;
class PlanStatusWithID;
struct PlanStatusWithIDDefaultTypeInternal;
extern PlanStatusWithIDDefaultTypeInternal _PlanStatusWithID_default_instance_;
class PlanStep;
struct PlanStepDefaultTypeInternal;
extern PlanStepDefaultTypeInternal _PlanStep_default_instance_;
class PlanStep_StepEntry_DoNotUse;
struct PlanStep_StepEntry_DoNotUseDefaultTypeInternal;
extern PlanStep_StepEntry_DoNotUseDefaultTypeInternal _PlanStep_StepEntry_DoNotUse_default_instance_;
class PlanWithStatus;
struct PlanWithStatusDefaultTypeInternal;
extern PlanWithStatusDefaultTypeInternal _PlanWithStatus_default_instance_;
class StopPlanRequest;
struct StopPlanRequestDefaultTypeInternal;
extern StopPlanRequestDefaultTypeInternal _StopPlanRequest_default_instance_;
class StopPlanResponse;
struct StopPlanResponseDefaultTypeInternal;
extern StopPlanResponseDefaultTypeInternal _StopPlanResponse_default_instance_;
}  // namespace v1
}  // namespace motion
}  // namespace service
}  // namespace viam
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace viam {
namespace service {
namespace motion {
namespace v1 {
enum PlanState : int {
  PLAN_STATE_UNSPECIFIED = 0,
  PLAN_STATE_IN_PROGRESS = 1,
  PLAN_STATE_STOPPED = 2,
  PLAN_STATE_SUCCEEDED = 3,
  PLAN_STATE_FAILED = 4,
  PlanState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PlanState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PlanState_IsValid(int value);
extern const uint32_t PlanState_internal_data_[];
constexpr PlanState PlanState_MIN = static_cast<PlanState>(0);
constexpr PlanState PlanState_MAX = static_cast<PlanState>(4);
constexpr int PlanState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
PlanState_descriptor();
template <typename T>
const std::string& PlanState_Name(T value) {
  static_assert(std::is_same<T, PlanState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PlanState_Name().");
  return PlanState_Name(static_cast<PlanState>(value));
}
template <>
inline const std::string& PlanState_Name(PlanState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PlanState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool PlanState_Parse(absl::string_view name, PlanState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlanState>(
      PlanState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class StopPlanResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.StopPlanResponse) */ {
 public:
  inline StopPlanResponse() : StopPlanResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopPlanResponse(::google::protobuf::internal::ConstantInitialized);

  inline StopPlanResponse(const StopPlanResponse& from)
      : StopPlanResponse(nullptr, from) {}
  StopPlanResponse(StopPlanResponse&& from) noexcept
    : StopPlanResponse() {
    *this = ::std::move(from);
  }

  inline StopPlanResponse& operator=(const StopPlanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPlanResponse& operator=(StopPlanResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPlanResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPlanResponse* internal_default_instance() {
    return reinterpret_cast<const StopPlanResponse*>(
               &_StopPlanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StopPlanResponse& a, StopPlanResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPlanResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPlanResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPlanResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPlanResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopPlanResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopPlanResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.StopPlanResponse";
  }
  protected:
  explicit StopPlanResponse(::google::protobuf::Arena* arena);
  StopPlanResponse(::google::protobuf::Arena* arena, const StopPlanResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.StopPlanResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class OrientationConstraint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.OrientationConstraint) */ {
 public:
  inline OrientationConstraint() : OrientationConstraint(nullptr) {}
  ~OrientationConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrientationConstraint(::google::protobuf::internal::ConstantInitialized);

  inline OrientationConstraint(const OrientationConstraint& from)
      : OrientationConstraint(nullptr, from) {}
  OrientationConstraint(OrientationConstraint&& from) noexcept
    : OrientationConstraint() {
    *this = ::std::move(from);
  }

  inline OrientationConstraint& operator=(const OrientationConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrientationConstraint& operator=(OrientationConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrientationConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrientationConstraint* internal_default_instance() {
    return reinterpret_cast<const OrientationConstraint*>(
               &_OrientationConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OrientationConstraint& a, OrientationConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(OrientationConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrientationConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrientationConstraint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrientationConstraint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrientationConstraint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OrientationConstraint& from) {
    OrientationConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OrientationConstraint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.OrientationConstraint";
  }
  protected:
  explicit OrientationConstraint(::google::protobuf::Arena* arena);
  OrientationConstraint(::google::protobuf::Arena* arena, const OrientationConstraint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrientationToleranceDegsFieldNumber = 1,
  };
  // optional float orientation_tolerance_degs = 1 [json_name = "orientationToleranceDegs"];
  bool has_orientation_tolerance_degs() const;
  void clear_orientation_tolerance_degs() ;
  float orientation_tolerance_degs() const;
  void set_orientation_tolerance_degs(float value);

  private:
  float _internal_orientation_tolerance_degs() const;
  void _internal_set_orientation_tolerance_degs(float value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.OrientationConstraint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float orientation_tolerance_degs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class MoveResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveResponse) */ {
 public:
  inline MoveResponse() : MoveResponse(nullptr) {}
  ~MoveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveResponse(::google::protobuf::internal::ConstantInitialized);

  inline MoveResponse(const MoveResponse& from)
      : MoveResponse(nullptr, from) {}
  MoveResponse(MoveResponse&& from) noexcept
    : MoveResponse() {
    *this = ::std::move(from);
  }

  inline MoveResponse& operator=(const MoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveResponse& operator=(MoveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveResponse* internal_default_instance() {
    return reinterpret_cast<const MoveResponse*>(
               &_MoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MoveResponse& a, MoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveResponse& from) {
    MoveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.MoveResponse";
  }
  protected:
  explicit MoveResponse(::google::protobuf::Arena* arena);
  MoveResponse(::google::protobuf::Arena* arena, const MoveResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class MoveOnMapResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnMapResponse) */ {
 public:
  inline MoveOnMapResponse() : MoveOnMapResponse(nullptr) {}
  ~MoveOnMapResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveOnMapResponse(::google::protobuf::internal::ConstantInitialized);

  inline MoveOnMapResponse(const MoveOnMapResponse& from)
      : MoveOnMapResponse(nullptr, from) {}
  MoveOnMapResponse(MoveOnMapResponse&& from) noexcept
    : MoveOnMapResponse() {
    *this = ::std::move(from);
  }

  inline MoveOnMapResponse& operator=(const MoveOnMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnMapResponse& operator=(MoveOnMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnMapResponse* internal_default_instance() {
    return reinterpret_cast<const MoveOnMapResponse*>(
               &_MoveOnMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MoveOnMapResponse& a, MoveOnMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnMapResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnMapResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnMapResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveOnMapResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveOnMapResponse& from) {
    MoveOnMapResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveOnMapResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.MoveOnMapResponse";
  }
  protected:
  explicit MoveOnMapResponse(::google::protobuf::Arena* arena);
  MoveOnMapResponse(::google::protobuf::Arena* arena, const MoveOnMapResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionIdFieldNumber = 1,
  };
  // string execution_id = 1 [json_name = "executionId"];
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnMapResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class MoveOnGlobeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnGlobeResponse) */ {
 public:
  inline MoveOnGlobeResponse() : MoveOnGlobeResponse(nullptr) {}
  ~MoveOnGlobeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveOnGlobeResponse(::google::protobuf::internal::ConstantInitialized);

  inline MoveOnGlobeResponse(const MoveOnGlobeResponse& from)
      : MoveOnGlobeResponse(nullptr, from) {}
  MoveOnGlobeResponse(MoveOnGlobeResponse&& from) noexcept
    : MoveOnGlobeResponse() {
    *this = ::std::move(from);
  }

  inline MoveOnGlobeResponse& operator=(const MoveOnGlobeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnGlobeResponse& operator=(MoveOnGlobeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnGlobeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnGlobeResponse* internal_default_instance() {
    return reinterpret_cast<const MoveOnGlobeResponse*>(
               &_MoveOnGlobeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MoveOnGlobeResponse& a, MoveOnGlobeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnGlobeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnGlobeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnGlobeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnGlobeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveOnGlobeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveOnGlobeResponse& from) {
    MoveOnGlobeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveOnGlobeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.MoveOnGlobeResponse";
  }
  protected:
  explicit MoveOnGlobeResponse(::google::protobuf::Arena* arena);
  MoveOnGlobeResponse(::google::protobuf::Arena* arena, const MoveOnGlobeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionIdFieldNumber = 1,
  };
  // string execution_id = 1 [json_name = "executionId"];
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnGlobeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class LinearConstraint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.LinearConstraint) */ {
 public:
  inline LinearConstraint() : LinearConstraint(nullptr) {}
  ~LinearConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LinearConstraint(::google::protobuf::internal::ConstantInitialized);

  inline LinearConstraint(const LinearConstraint& from)
      : LinearConstraint(nullptr, from) {}
  LinearConstraint(LinearConstraint&& from) noexcept
    : LinearConstraint() {
    *this = ::std::move(from);
  }

  inline LinearConstraint& operator=(const LinearConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearConstraint& operator=(LinearConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearConstraint* internal_default_instance() {
    return reinterpret_cast<const LinearConstraint*>(
               &_LinearConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LinearConstraint& a, LinearConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearConstraint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearConstraint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearConstraint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LinearConstraint& from) {
    LinearConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LinearConstraint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.LinearConstraint";
  }
  protected:
  explicit LinearConstraint(::google::protobuf::Arena* arena);
  LinearConstraint(::google::protobuf::Arena* arena, const LinearConstraint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineToleranceMmFieldNumber = 1,
    kOrientationToleranceDegsFieldNumber = 2,
  };
  // optional float line_tolerance_mm = 1 [json_name = "lineToleranceMm"];
  bool has_line_tolerance_mm() const;
  void clear_line_tolerance_mm() ;
  float line_tolerance_mm() const;
  void set_line_tolerance_mm(float value);

  private:
  float _internal_line_tolerance_mm() const;
  void _internal_set_line_tolerance_mm(float value);

  public:
  // optional float orientation_tolerance_degs = 2 [json_name = "orientationToleranceDegs"];
  bool has_orientation_tolerance_degs() const;
  void clear_orientation_tolerance_degs() ;
  float orientation_tolerance_degs() const;
  void set_orientation_tolerance_degs(float value);

  private:
  float _internal_orientation_tolerance_degs() const;
  void _internal_set_orientation_tolerance_degs(float value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.LinearConstraint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float line_tolerance_mm_;
    float orientation_tolerance_degs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class CollisionSpecification_AllowedFrameCollisions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions) */ {
 public:
  inline CollisionSpecification_AllowedFrameCollisions() : CollisionSpecification_AllowedFrameCollisions(nullptr) {}
  ~CollisionSpecification_AllowedFrameCollisions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollisionSpecification_AllowedFrameCollisions(::google::protobuf::internal::ConstantInitialized);

  inline CollisionSpecification_AllowedFrameCollisions(const CollisionSpecification_AllowedFrameCollisions& from)
      : CollisionSpecification_AllowedFrameCollisions(nullptr, from) {}
  CollisionSpecification_AllowedFrameCollisions(CollisionSpecification_AllowedFrameCollisions&& from) noexcept
    : CollisionSpecification_AllowedFrameCollisions() {
    *this = ::std::move(from);
  }

  inline CollisionSpecification_AllowedFrameCollisions& operator=(const CollisionSpecification_AllowedFrameCollisions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollisionSpecification_AllowedFrameCollisions& operator=(CollisionSpecification_AllowedFrameCollisions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollisionSpecification_AllowedFrameCollisions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollisionSpecification_AllowedFrameCollisions* internal_default_instance() {
    return reinterpret_cast<const CollisionSpecification_AllowedFrameCollisions*>(
               &_CollisionSpecification_AllowedFrameCollisions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CollisionSpecification_AllowedFrameCollisions& a, CollisionSpecification_AllowedFrameCollisions& b) {
    a.Swap(&b);
  }
  inline void Swap(CollisionSpecification_AllowedFrameCollisions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollisionSpecification_AllowedFrameCollisions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollisionSpecification_AllowedFrameCollisions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollisionSpecification_AllowedFrameCollisions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollisionSpecification_AllowedFrameCollisions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollisionSpecification_AllowedFrameCollisions& from) {
    CollisionSpecification_AllowedFrameCollisions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollisionSpecification_AllowedFrameCollisions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions";
  }
  protected:
  explicit CollisionSpecification_AllowedFrameCollisions(::google::protobuf::Arena* arena);
  CollisionSpecification_AllowedFrameCollisions(::google::protobuf::Arena* arena, const CollisionSpecification_AllowedFrameCollisions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrame1FieldNumber = 1,
    kFrame2FieldNumber = 2,
  };
  // string frame1 = 1 [json_name = "frame1"];
  void clear_frame1() ;
  const std::string& frame1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame1(Arg_&& arg, Args_... args);
  std::string* mutable_frame1();
  PROTOBUF_NODISCARD std::string* release_frame1();
  void set_allocated_frame1(std::string* value);

  private:
  const std::string& _internal_frame1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame1(
      const std::string& value);
  std::string* _internal_mutable_frame1();

  public:
  // string frame2 = 2 [json_name = "frame2"];
  void clear_frame2() ;
  const std::string& frame2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame2(Arg_&& arg, Args_... args);
  std::string* mutable_frame2();
  PROTOBUF_NODISCARD std::string* release_frame2();
  void set_allocated_frame2(std::string* value);

  private:
  const std::string& _internal_frame2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame2(
      const std::string& value);
  std::string* _internal_mutable_frame2();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      89, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr frame1_;
    ::google::protobuf::internal::ArenaStringPtr frame2_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class StopPlanRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.StopPlanRequest) */ {
 public:
  inline StopPlanRequest() : StopPlanRequest(nullptr) {}
  ~StopPlanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopPlanRequest(::google::protobuf::internal::ConstantInitialized);

  inline StopPlanRequest(const StopPlanRequest& from)
      : StopPlanRequest(nullptr, from) {}
  StopPlanRequest(StopPlanRequest&& from) noexcept
    : StopPlanRequest() {
    *this = ::std::move(from);
  }

  inline StopPlanRequest& operator=(const StopPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPlanRequest& operator=(StopPlanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPlanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPlanRequest* internal_default_instance() {
    return reinterpret_cast<const StopPlanRequest*>(
               &_StopPlanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StopPlanRequest& a, StopPlanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPlanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPlanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPlanRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPlanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StopPlanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StopPlanRequest& from) {
    StopPlanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StopPlanRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.StopPlanRequest";
  }
  protected:
  explicit StopPlanRequest(::google::protobuf::Arena* arena);
  StopPlanRequest(::google::protobuf::Arena* arena, const StopPlanRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kComponentNameFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  void clear_extra() ;
  const ::google::protobuf::Struct& extra() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_extra();
  ::google::protobuf::Struct* mutable_extra();
  void set_allocated_extra(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_extra();

  private:
  const ::google::protobuf::Struct& _internal_extra() const;
  ::google::protobuf::Struct* _internal_mutable_extra();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.StopPlanRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      51, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::viam::common::v1::ResourceName* component_name_;
    ::google::protobuf::Struct* extra_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class PlanStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanStatus) */ {
 public:
  inline PlanStatus() : PlanStatus(nullptr) {}
  ~PlanStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlanStatus(::google::protobuf::internal::ConstantInitialized);

  inline PlanStatus(const PlanStatus& from)
      : PlanStatus(nullptr, from) {}
  PlanStatus(PlanStatus&& from) noexcept
    : PlanStatus() {
    *this = ::std::move(from);
  }

  inline PlanStatus& operator=(const PlanStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanStatus& operator=(PlanStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanStatus* internal_default_instance() {
    return reinterpret_cast<const PlanStatus*>(
               &_PlanStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlanStatus& a, PlanStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlanStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlanStatus& from) {
    PlanStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlanStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.PlanStatus";
  }
  protected:
  explicit PlanStatus(::google::protobuf::Arena* arena);
  PlanStatus(::google::protobuf::Arena* arena, const PlanStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // optional string reason = 3 [json_name = "reason"];
  bool has_reason() const;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .viam.service.motion.v1.PlanState state = 1 [json_name = "state"];
  void clear_state() ;
  ::viam::service::motion::v1::PlanState state() const;
  void set_state(::viam::service::motion::v1::PlanState value);

  private:
  ::viam::service::motion::v1::PlanState _internal_state() const;
  void _internal_set_state(::viam::service::motion::v1::PlanState value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::Timestamp* timestamp_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class ObstacleDetector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ObstacleDetector) */ {
 public:
  inline ObstacleDetector() : ObstacleDetector(nullptr) {}
  ~ObstacleDetector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ObstacleDetector(::google::protobuf::internal::ConstantInitialized);

  inline ObstacleDetector(const ObstacleDetector& from)
      : ObstacleDetector(nullptr, from) {}
  ObstacleDetector(ObstacleDetector&& from) noexcept
    : ObstacleDetector() {
    *this = ::std::move(from);
  }

  inline ObstacleDetector& operator=(const ObstacleDetector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleDetector& operator=(ObstacleDetector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleDetector& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleDetector* internal_default_instance() {
    return reinterpret_cast<const ObstacleDetector*>(
               &_ObstacleDetector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ObstacleDetector& a, ObstacleDetector& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleDetector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleDetector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleDetector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleDetector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObstacleDetector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ObstacleDetector& from) {
    ObstacleDetector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObstacleDetector* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.ObstacleDetector";
  }
  protected:
  explicit ObstacleDetector(::google::protobuf::Arena* arena);
  ObstacleDetector(::google::protobuf::Arena* arena, const ObstacleDetector& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisionServiceFieldNumber = 1,
    kCameraFieldNumber = 2,
  };
  // .viam.common.v1.ResourceName vision_service = 1 [json_name = "visionService"];
  bool has_vision_service() const;
  void clear_vision_service() ;
  const ::viam::common::v1::ResourceName& vision_service() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_vision_service();
  ::viam::common::v1::ResourceName* mutable_vision_service();
  void set_allocated_vision_service(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_vision_service(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_vision_service();

  private:
  const ::viam::common::v1::ResourceName& _internal_vision_service() const;
  ::viam::common::v1::ResourceName* _internal_mutable_vision_service();

  public:
  // .viam.common.v1.ResourceName camera = 2 [json_name = "camera"];
  bool has_camera() const;
  void clear_camera() ;
  const ::viam::common::v1::ResourceName& camera() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_camera();
  ::viam::common::v1::ResourceName* mutable_camera();
  void set_allocated_camera(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_camera(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_camera();

  private:
  const ::viam::common::v1::ResourceName& _internal_camera() const;
  ::viam::common::v1::ResourceName* _internal_mutable_camera();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ObstacleDetector)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::viam::common::v1::ResourceName* vision_service_;
    ::viam::common::v1::ResourceName* camera_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class ListPlanStatusesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ListPlanStatusesRequest) */ {
 public:
  inline ListPlanStatusesRequest() : ListPlanStatusesRequest(nullptr) {}
  ~ListPlanStatusesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListPlanStatusesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListPlanStatusesRequest(const ListPlanStatusesRequest& from)
      : ListPlanStatusesRequest(nullptr, from) {}
  ListPlanStatusesRequest(ListPlanStatusesRequest&& from) noexcept
    : ListPlanStatusesRequest() {
    *this = ::std::move(from);
  }

  inline ListPlanStatusesRequest& operator=(const ListPlanStatusesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPlanStatusesRequest& operator=(ListPlanStatusesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPlanStatusesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPlanStatusesRequest* internal_default_instance() {
    return reinterpret_cast<const ListPlanStatusesRequest*>(
               &_ListPlanStatusesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListPlanStatusesRequest& a, ListPlanStatusesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPlanStatusesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPlanStatusesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPlanStatusesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPlanStatusesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListPlanStatusesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListPlanStatusesRequest& from) {
    ListPlanStatusesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListPlanStatusesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.ListPlanStatusesRequest";
  }
  protected:
  explicit ListPlanStatusesRequest(::google::protobuf::Arena* arena);
  ListPlanStatusesRequest(::google::protobuf::Arena* arena, const ListPlanStatusesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExtraFieldNumber = 99,
    kOnlyActivePlansFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  void clear_extra() ;
  const ::google::protobuf::Struct& extra() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_extra();
  ::google::protobuf::Struct* mutable_extra();
  void set_allocated_extra(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_extra();

  private:
  const ::google::protobuf::Struct& _internal_extra() const;
  ::google::protobuf::Struct* _internal_mutable_extra();

  public:
  // bool only_active_plans = 2 [json_name = "onlyActivePlans"];
  void clear_only_active_plans() ;
  bool only_active_plans() const;
  void set_only_active_plans(bool value);

  private:
  bool _internal_only_active_plans() const;
  void _internal_set_only_active_plans(bool value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ListPlanStatusesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      59, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::Struct* extra_;
    bool only_active_plans_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class GetPlanRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPlanRequest) */ {
 public:
  inline GetPlanRequest() : GetPlanRequest(nullptr) {}
  ~GetPlanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlanRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetPlanRequest(const GetPlanRequest& from)
      : GetPlanRequest(nullptr, from) {}
  GetPlanRequest(GetPlanRequest&& from) noexcept
    : GetPlanRequest() {
    *this = ::std::move(from);
  }

  inline GetPlanRequest& operator=(const GetPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlanRequest& operator=(GetPlanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlanRequest* internal_default_instance() {
    return reinterpret_cast<const GetPlanRequest*>(
               &_GetPlanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetPlanRequest& a, GetPlanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlanRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlanRequest& from) {
    GetPlanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlanRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.GetPlanRequest";
  }
  protected:
  explicit GetPlanRequest(::google::protobuf::Arena* arena);
  GetPlanRequest(::google::protobuf::Arena* arena, const GetPlanRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExecutionIdFieldNumber = 4,
    kComponentNameFieldNumber = 2,
    kExtraFieldNumber = 99,
    kLastPlanOnlyFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string execution_id = 4 [json_name = "executionId"];
  bool has_execution_id() const;
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  void clear_extra() ;
  const ::google::protobuf::Struct& extra() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_extra();
  ::google::protobuf::Struct* mutable_extra();
  void set_allocated_extra(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_extra();

  private:
  const ::google::protobuf::Struct& _internal_extra() const;
  ::google::protobuf::Struct* _internal_mutable_extra();

  public:
  // bool last_plan_only = 3 [json_name = "lastPlanOnly"];
  void clear_last_plan_only() ;
  bool last_plan_only() const;
  void set_last_plan_only(bool value);

  private:
  bool _internal_last_plan_only() const;
  void _internal_set_last_plan_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPlanRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 2,
      62, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::viam::common::v1::ResourceName* component_name_;
    ::google::protobuf::Struct* extra_;
    bool last_plan_only_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class ComponentState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ComponentState) */ {
 public:
  inline ComponentState() : ComponentState(nullptr) {}
  ~ComponentState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ComponentState(::google::protobuf::internal::ConstantInitialized);

  inline ComponentState(const ComponentState& from)
      : ComponentState(nullptr, from) {}
  ComponentState(ComponentState&& from) noexcept
    : ComponentState() {
    *this = ::std::move(from);
  }

  inline ComponentState& operator=(const ComponentState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComponentState& operator=(ComponentState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComponentState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComponentState* internal_default_instance() {
    return reinterpret_cast<const ComponentState*>(
               &_ComponentState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ComponentState& a, ComponentState& b) {
    a.Swap(&b);
  }
  inline void Swap(ComponentState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComponentState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComponentState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComponentState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComponentState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ComponentState& from) {
    ComponentState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ComponentState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.ComponentState";
  }
  protected:
  explicit ComponentState(::google::protobuf::Arena* arena);
  ComponentState(::google::protobuf::Arena* arena, const ComponentState& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .viam.common.v1.Pose pose = 1 [json_name = "pose"];
  bool has_pose() const;
  void clear_pose() ;
  const ::viam::common::v1::Pose& pose() const;
  PROTOBUF_NODISCARD ::viam::common::v1::Pose* release_pose();
  ::viam::common::v1::Pose* mutable_pose();
  void set_allocated_pose(::viam::common::v1::Pose* value);
  void unsafe_arena_set_allocated_pose(::viam::common::v1::Pose* value);
  ::viam::common::v1::Pose* unsafe_arena_release_pose();

  private:
  const ::viam::common::v1::Pose& _internal_pose() const;
  ::viam::common::v1::Pose* _internal_mutable_pose();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ComponentState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::viam::common::v1::Pose* pose_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class CollisionSpecification final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.CollisionSpecification) */ {
 public:
  inline CollisionSpecification() : CollisionSpecification(nullptr) {}
  ~CollisionSpecification() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollisionSpecification(::google::protobuf::internal::ConstantInitialized);

  inline CollisionSpecification(const CollisionSpecification& from)
      : CollisionSpecification(nullptr, from) {}
  CollisionSpecification(CollisionSpecification&& from) noexcept
    : CollisionSpecification() {
    *this = ::std::move(from);
  }

  inline CollisionSpecification& operator=(const CollisionSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollisionSpecification& operator=(CollisionSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollisionSpecification& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollisionSpecification* internal_default_instance() {
    return reinterpret_cast<const CollisionSpecification*>(
               &_CollisionSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CollisionSpecification& a, CollisionSpecification& b) {
    a.Swap(&b);
  }
  inline void Swap(CollisionSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollisionSpecification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollisionSpecification* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollisionSpecification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollisionSpecification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollisionSpecification& from) {
    CollisionSpecification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollisionSpecification* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.CollisionSpecification";
  }
  protected:
  explicit CollisionSpecification(::google::protobuf::Arena* arena);
  CollisionSpecification(::google::protobuf::Arena* arena, const CollisionSpecification& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AllowedFrameCollisions = CollisionSpecification_AllowedFrameCollisions;

  // accessors -------------------------------------------------------

  enum : int {
    kAllowsFieldNumber = 1,
  };
  // repeated .viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions allows = 1 [json_name = "allows"];
  int allows_size() const;
  private:
  int _internal_allows_size() const;

  public:
  void clear_allows() ;
  ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* mutable_allows(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions >*
      mutable_allows();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions>& _internal_allows() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions>* _internal_mutable_allows();
  public:
  const ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions& allows(int index) const;
  ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* add_allows();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions >&
      allows() const;
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.CollisionSpecification)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions > allows_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class PlanStep_StepEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          PlanStep_StepEntry_DoNotUse, std::string, ::viam::service::motion::v1::ComponentState,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      PlanStep_StepEntry_DoNotUse, std::string, ::viam::service::motion::v1::ComponentState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  PlanStep_StepEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlanStep_StepEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PlanStep_StepEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PlanStep_StepEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PlanStep_StepEntry_DoNotUse*>(
        &_PlanStep_StepEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "viam.service.motion.v1.PlanStep.StepEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class PlanStatusWithID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanStatusWithID) */ {
 public:
  inline PlanStatusWithID() : PlanStatusWithID(nullptr) {}
  ~PlanStatusWithID() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlanStatusWithID(::google::protobuf::internal::ConstantInitialized);

  inline PlanStatusWithID(const PlanStatusWithID& from)
      : PlanStatusWithID(nullptr, from) {}
  PlanStatusWithID(PlanStatusWithID&& from) noexcept
    : PlanStatusWithID() {
    *this = ::std::move(from);
  }

  inline PlanStatusWithID& operator=(const PlanStatusWithID& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanStatusWithID& operator=(PlanStatusWithID&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanStatusWithID& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanStatusWithID* internal_default_instance() {
    return reinterpret_cast<const PlanStatusWithID*>(
               &_PlanStatusWithID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlanStatusWithID& a, PlanStatusWithID& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanStatusWithID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanStatusWithID* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanStatusWithID* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanStatusWithID>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlanStatusWithID& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlanStatusWithID& from) {
    PlanStatusWithID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlanStatusWithID* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.PlanStatusWithID";
  }
  protected:
  explicit PlanStatusWithID(::google::protobuf::Arena* arena);
  PlanStatusWithID(::google::protobuf::Arena* arena, const PlanStatusWithID& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanIdFieldNumber = 1,
    kExecutionIdFieldNumber = 3,
    kComponentNameFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // string plan_id = 1 [json_name = "planId"];
  void clear_plan_id() ;
  const std::string& plan_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_plan_id(Arg_&& arg, Args_... args);
  std::string* mutable_plan_id();
  PROTOBUF_NODISCARD std::string* release_plan_id();
  void set_allocated_plan_id(std::string* value);

  private:
  const std::string& _internal_plan_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan_id(
      const std::string& value);
  std::string* _internal_mutable_plan_id();

  public:
  // string execution_id = 3 [json_name = "executionId"];
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // .viam.service.motion.v1.PlanStatus status = 4 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::viam::service::motion::v1::PlanStatus& status() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::PlanStatus* release_status();
  ::viam::service::motion::v1::PlanStatus* mutable_status();
  void set_allocated_status(::viam::service::motion::v1::PlanStatus* value);
  void unsafe_arena_set_allocated_status(::viam::service::motion::v1::PlanStatus* value);
  ::viam::service::motion::v1::PlanStatus* unsafe_arena_release_status();

  private:
  const ::viam::service::motion::v1::PlanStatus& _internal_status() const;
  ::viam::service::motion::v1::PlanStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanStatusWithID)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      67, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr plan_id_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::viam::common::v1::ResourceName* component_name_;
    ::viam::service::motion::v1::PlanStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class MotionConfiguration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MotionConfiguration) */ {
 public:
  inline MotionConfiguration() : MotionConfiguration(nullptr) {}
  ~MotionConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotionConfiguration(::google::protobuf::internal::ConstantInitialized);

  inline MotionConfiguration(const MotionConfiguration& from)
      : MotionConfiguration(nullptr, from) {}
  MotionConfiguration(MotionConfiguration&& from) noexcept
    : MotionConfiguration() {
    *this = ::std::move(from);
  }

  inline MotionConfiguration& operator=(const MotionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionConfiguration& operator=(MotionConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionConfiguration* internal_default_instance() {
    return reinterpret_cast<const MotionConfiguration*>(
               &_MotionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MotionConfiguration& a, MotionConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotionConfiguration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotionConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MotionConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MotionConfiguration& from) {
    MotionConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MotionConfiguration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.MotionConfiguration";
  }
  protected:
  explicit MotionConfiguration(::google::protobuf::Arena* arena);
  MotionConfiguration(::google::protobuf::Arena* arena, const MotionConfiguration& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleDetectorsFieldNumber = 1,
    kPositionPollingFrequencyHzFieldNumber = 2,
    kObstaclePollingFrequencyHzFieldNumber = 3,
    kPlanDeviationMFieldNumber = 4,
    kLinearMPerSecFieldNumber = 5,
    kAngularDegsPerSecFieldNumber = 6,
  };
  // repeated .viam.service.motion.v1.ObstacleDetector obstacle_detectors = 1 [json_name = "obstacleDetectors"];
  int obstacle_detectors_size() const;
  private:
  int _internal_obstacle_detectors_size() const;

  public:
  void clear_obstacle_detectors() ;
  ::viam::service::motion::v1::ObstacleDetector* mutable_obstacle_detectors(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector >*
      mutable_obstacle_detectors();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::ObstacleDetector>& _internal_obstacle_detectors() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::ObstacleDetector>* _internal_mutable_obstacle_detectors();
  public:
  const ::viam::service::motion::v1::ObstacleDetector& obstacle_detectors(int index) const;
  ::viam::service::motion::v1::ObstacleDetector* add_obstacle_detectors();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector >&
      obstacle_detectors() const;
  // optional double position_polling_frequency_hz = 2 [json_name = "positionPollingFrequencyHz"];
  bool has_position_polling_frequency_hz() const;
  void clear_position_polling_frequency_hz() ;
  double position_polling_frequency_hz() const;
  void set_position_polling_frequency_hz(double value);

  private:
  double _internal_position_polling_frequency_hz() const;
  void _internal_set_position_polling_frequency_hz(double value);

  public:
  // optional double obstacle_polling_frequency_hz = 3 [json_name = "obstaclePollingFrequencyHz"];
  bool has_obstacle_polling_frequency_hz() const;
  void clear_obstacle_polling_frequency_hz() ;
  double obstacle_polling_frequency_hz() const;
  void set_obstacle_polling_frequency_hz(double value);

  private:
  double _internal_obstacle_polling_frequency_hz() const;
  void _internal_set_obstacle_polling_frequency_hz(double value);

  public:
  // optional double plan_deviation_m = 4 [json_name = "planDeviationM"];
  bool has_plan_deviation_m() const;
  void clear_plan_deviation_m() ;
  double plan_deviation_m() const;
  void set_plan_deviation_m(double value);

  private:
  double _internal_plan_deviation_m() const;
  void _internal_set_plan_deviation_m(double value);

  public:
  // optional double linear_m_per_sec = 5 [json_name = "linearMPerSec"];
  bool has_linear_m_per_sec() const;
  void clear_linear_m_per_sec() ;
  double linear_m_per_sec() const;
  void set_linear_m_per_sec(double value);

  private:
  double _internal_linear_m_per_sec() const;
  void _internal_set_linear_m_per_sec(double value);

  public:
  // optional double angular_degs_per_sec = 6 [json_name = "angularDegsPerSec"];
  bool has_angular_degs_per_sec() const;
  void clear_angular_degs_per_sec() ;
  double angular_degs_per_sec() const;
  void set_angular_degs_per_sec(double value);

  private:
  double _internal_angular_degs_per_sec() const;
  void _internal_set_angular_degs_per_sec(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MotionConfiguration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector > obstacle_detectors_;
    double position_polling_frequency_hz_;
    double obstacle_polling_frequency_hz_;
    double plan_deviation_m_;
    double linear_m_per_sec_;
    double angular_degs_per_sec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class GetPoseResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPoseResponse) */ {
 public:
  inline GetPoseResponse() : GetPoseResponse(nullptr) {}
  ~GetPoseResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPoseResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetPoseResponse(const GetPoseResponse& from)
      : GetPoseResponse(nullptr, from) {}
  GetPoseResponse(GetPoseResponse&& from) noexcept
    : GetPoseResponse() {
    *this = ::std::move(from);
  }

  inline GetPoseResponse& operator=(const GetPoseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoseResponse& operator=(GetPoseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPoseResponse* internal_default_instance() {
    return reinterpret_cast<const GetPoseResponse*>(
               &_GetPoseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetPoseResponse& a, GetPoseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPoseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoseResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoseResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPoseResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPoseResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPoseResponse& from) {
    GetPoseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPoseResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.GetPoseResponse";
  }
  protected:
  explicit GetPoseResponse(::google::protobuf::Arena* arena);
  GetPoseResponse(::google::protobuf::Arena* arena, const GetPoseResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .viam.common.v1.PoseInFrame pose = 1 [json_name = "pose"];
  bool has_pose() const;
  void clear_pose() ;
  const ::viam::common::v1::PoseInFrame& pose() const;
  PROTOBUF_NODISCARD ::viam::common::v1::PoseInFrame* release_pose();
  ::viam::common::v1::PoseInFrame* mutable_pose();
  void set_allocated_pose(::viam::common::v1::PoseInFrame* value);
  void unsafe_arena_set_allocated_pose(::viam::common::v1::PoseInFrame* value);
  ::viam::common::v1::PoseInFrame* unsafe_arena_release_pose();

  private:
  const ::viam::common::v1::PoseInFrame& _internal_pose() const;
  ::viam::common::v1::PoseInFrame* _internal_mutable_pose();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPoseResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::viam::common::v1::PoseInFrame* pose_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class Constraints final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.Constraints) */ {
 public:
  inline Constraints() : Constraints(nullptr) {}
  ~Constraints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Constraints(::google::protobuf::internal::ConstantInitialized);

  inline Constraints(const Constraints& from)
      : Constraints(nullptr, from) {}
  Constraints(Constraints&& from) noexcept
    : Constraints() {
    *this = ::std::move(from);
  }

  inline Constraints& operator=(const Constraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraints& operator=(Constraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Constraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Constraints* internal_default_instance() {
    return reinterpret_cast<const Constraints*>(
               &_Constraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Constraints& a, Constraints& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Constraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Constraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Constraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Constraints& from) {
    Constraints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Constraints* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.Constraints";
  }
  protected:
  explicit Constraints(::google::protobuf::Arena* arena);
  Constraints(::google::protobuf::Arena* arena, const Constraints& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearConstraintFieldNumber = 1,
    kOrientationConstraintFieldNumber = 2,
    kCollisionSpecificationFieldNumber = 3,
  };
  // repeated .viam.service.motion.v1.LinearConstraint linear_constraint = 1 [json_name = "linearConstraint"];
  int linear_constraint_size() const;
  private:
  int _internal_linear_constraint_size() const;

  public:
  void clear_linear_constraint() ;
  ::viam::service::motion::v1::LinearConstraint* mutable_linear_constraint(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint >*
      mutable_linear_constraint();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::LinearConstraint>& _internal_linear_constraint() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::LinearConstraint>* _internal_mutable_linear_constraint();
  public:
  const ::viam::service::motion::v1::LinearConstraint& linear_constraint(int index) const;
  ::viam::service::motion::v1::LinearConstraint* add_linear_constraint();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint >&
      linear_constraint() const;
  // repeated .viam.service.motion.v1.OrientationConstraint orientation_constraint = 2 [json_name = "orientationConstraint"];
  int orientation_constraint_size() const;
  private:
  int _internal_orientation_constraint_size() const;

  public:
  void clear_orientation_constraint() ;
  ::viam::service::motion::v1::OrientationConstraint* mutable_orientation_constraint(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint >*
      mutable_orientation_constraint();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::OrientationConstraint>& _internal_orientation_constraint() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::OrientationConstraint>* _internal_mutable_orientation_constraint();
  public:
  const ::viam::service::motion::v1::OrientationConstraint& orientation_constraint(int index) const;
  ::viam::service::motion::v1::OrientationConstraint* add_orientation_constraint();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint >&
      orientation_constraint() const;
  // repeated .viam.service.motion.v1.CollisionSpecification collision_specification = 3 [json_name = "collisionSpecification"];
  int collision_specification_size() const;
  private:
  int _internal_collision_specification_size() const;

  public:
  void clear_collision_specification() ;
  ::viam::service::motion::v1::CollisionSpecification* mutable_collision_specification(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification >*
      mutable_collision_specification();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification>& _internal_collision_specification() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification>* _internal_mutable_collision_specification();
  public:
  const ::viam::service::motion::v1::CollisionSpecification& collision_specification(int index) const;
  ::viam::service::motion::v1::CollisionSpecification* add_collision_specification();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification >&
      collision_specification() const;
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.Constraints)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint > linear_constraint_;
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint > orientation_constraint_;
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification > collision_specification_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class PlanStep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanStep) */ {
 public:
  inline PlanStep() : PlanStep(nullptr) {}
  ~PlanStep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlanStep(::google::protobuf::internal::ConstantInitialized);

  inline PlanStep(const PlanStep& from)
      : PlanStep(nullptr, from) {}
  PlanStep(PlanStep&& from) noexcept
    : PlanStep() {
    *this = ::std::move(from);
  }

  inline PlanStep& operator=(const PlanStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanStep& operator=(PlanStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanStep* internal_default_instance() {
    return reinterpret_cast<const PlanStep*>(
               &_PlanStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PlanStep& a, PlanStep& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanStep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanStep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanStep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlanStep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlanStep& from) {
    PlanStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlanStep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.PlanStep";
  }
  protected:
  explicit PlanStep(::google::protobuf::Arena* arena);
  PlanStep(::google::protobuf::Arena* arena, const PlanStep& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
  };
  // map<string, .viam.service.motion.v1.ComponentState> step = 1 [json_name = "step"];
  int step_size() const;
  private:
  int _internal_step_size() const;

  public:
  void clear_step() ;
  const ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>& step() const;
  ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>* mutable_step();

  private:
  const ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>& _internal_step() const;
  ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>* _internal_mutable_step();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanStep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<PlanStep_StepEntry_DoNotUse, std::string, ::viam::service::motion::v1::ComponentState,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        step_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class MoveOnMapRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnMapRequest) */ {
 public:
  inline MoveOnMapRequest() : MoveOnMapRequest(nullptr) {}
  ~MoveOnMapRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveOnMapRequest(::google::protobuf::internal::ConstantInitialized);

  inline MoveOnMapRequest(const MoveOnMapRequest& from)
      : MoveOnMapRequest(nullptr, from) {}
  MoveOnMapRequest(MoveOnMapRequest&& from) noexcept
    : MoveOnMapRequest() {
    *this = ::std::move(from);
  }

  inline MoveOnMapRequest& operator=(const MoveOnMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnMapRequest& operator=(MoveOnMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnMapRequest* internal_default_instance() {
    return reinterpret_cast<const MoveOnMapRequest*>(
               &_MoveOnMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MoveOnMapRequest& a, MoveOnMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnMapRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnMapRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnMapRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveOnMapRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveOnMapRequest& from) {
    MoveOnMapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveOnMapRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.MoveOnMapRequest";
  }
  protected:
  explicit MoveOnMapRequest(::google::protobuf::Arena* arena);
  MoveOnMapRequest(::google::protobuf::Arena* arena, const MoveOnMapRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstaclesFieldNumber = 6,
    kNameFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kComponentNameFieldNumber = 3,
    kSlamServiceNameFieldNumber = 4,
    kMotionConfigurationFieldNumber = 5,
    kExtraFieldNumber = 99,
  };
  // repeated .viam.common.v1.Geometry obstacles = 6 [json_name = "obstacles"];
  int obstacles_size() const;
  private:
  int _internal_obstacles_size() const;

  public:
  void clear_obstacles() ;
  ::viam::common::v1::Geometry* mutable_obstacles(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::common::v1::Geometry >*
      mutable_obstacles();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::common::v1::Geometry>& _internal_obstacles() const;
  ::google::protobuf::RepeatedPtrField<::viam::common::v1::Geometry>* _internal_mutable_obstacles();
  public:
  const ::viam::common::v1::Geometry& obstacles(int index) const;
  ::viam::common::v1::Geometry* add_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::viam::common::v1::Geometry >&
      obstacles() const;
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .viam.common.v1.Pose destination = 2 [json_name = "destination"];
  bool has_destination() const;
  void clear_destination() ;
  const ::viam::common::v1::Pose& destination() const;
  PROTOBUF_NODISCARD ::viam::common::v1::Pose* release_destination();
  ::viam::common::v1::Pose* mutable_destination();
  void set_allocated_destination(::viam::common::v1::Pose* value);
  void unsafe_arena_set_allocated_destination(::viam::common::v1::Pose* value);
  ::viam::common::v1::Pose* unsafe_arena_release_destination();

  private:
  const ::viam::common::v1::Pose& _internal_destination() const;
  ::viam::common::v1::Pose* _internal_mutable_destination();

  public:
  // .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // .viam.common.v1.ResourceName slam_service_name = 4 [json_name = "slamServiceName"];
  bool has_slam_service_name() const;
  void clear_slam_service_name() ;
  const ::viam::common::v1::ResourceName& slam_service_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_slam_service_name();
  ::viam::common::v1::ResourceName* mutable_slam_service_name();
  void set_allocated_slam_service_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_slam_service_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_slam_service_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_slam_service_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_slam_service_name();

  public:
  // optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 5 [json_name = "motionConfiguration"];
  bool has_motion_configuration() const;
  void clear_motion_configuration() ;
  const ::viam::service::motion::v1::MotionConfiguration& motion_configuration() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::MotionConfiguration* release_motion_configuration();
  ::viam::service::motion::v1::MotionConfiguration* mutable_motion_configuration();
  void set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value);
  void unsafe_arena_set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value);
  ::viam::service::motion::v1::MotionConfiguration* unsafe_arena_release_motion_configuration();

  private:
  const ::viam::service::motion::v1::MotionConfiguration& _internal_motion_configuration() const;
  ::viam::service::motion::v1::MotionConfiguration* _internal_mutable_motion_configuration();

  public:
  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  void clear_extra() ;
  const ::google::protobuf::Struct& extra() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_extra();
  ::google::protobuf::Struct* mutable_extra();
  void set_allocated_extra(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_extra();

  private:
  const ::google::protobuf::Struct& _internal_extra() const;
  ::google::protobuf::Struct* _internal_mutable_extra();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnMapRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      52, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::common::v1::Geometry > obstacles_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::viam::common::v1::Pose* destination_;
    ::viam::common::v1::ResourceName* component_name_;
    ::viam::common::v1::ResourceName* slam_service_name_;
    ::viam::service::motion::v1::MotionConfiguration* motion_configuration_;
    ::google::protobuf::Struct* extra_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class ListPlanStatusesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ListPlanStatusesResponse) */ {
 public:
  inline ListPlanStatusesResponse() : ListPlanStatusesResponse(nullptr) {}
  ~ListPlanStatusesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListPlanStatusesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListPlanStatusesResponse(const ListPlanStatusesResponse& from)
      : ListPlanStatusesResponse(nullptr, from) {}
  ListPlanStatusesResponse(ListPlanStatusesResponse&& from) noexcept
    : ListPlanStatusesResponse() {
    *this = ::std::move(from);
  }

  inline ListPlanStatusesResponse& operator=(const ListPlanStatusesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPlanStatusesResponse& operator=(ListPlanStatusesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPlanStatusesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPlanStatusesResponse* internal_default_instance() {
    return reinterpret_cast<const ListPlanStatusesResponse*>(
               &_ListPlanStatusesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListPlanStatusesResponse& a, ListPlanStatusesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPlanStatusesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPlanStatusesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPlanStatusesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPlanStatusesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListPlanStatusesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListPlanStatusesResponse& from) {
    ListPlanStatusesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListPlanStatusesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.ListPlanStatusesResponse";
  }
  protected:
  explicit ListPlanStatusesResponse(::google::protobuf::Arena* arena);
  ListPlanStatusesResponse(::google::protobuf::Arena* arena, const ListPlanStatusesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanStatusesWithIdsFieldNumber = 1,
  };
  // repeated .viam.service.motion.v1.PlanStatusWithID plan_statuses_with_ids = 1 [json_name = "planStatusesWithIds"];
  int plan_statuses_with_ids_size() const;
  private:
  int _internal_plan_statuses_with_ids_size() const;

  public:
  void clear_plan_statuses_with_ids() ;
  ::viam::service::motion::v1::PlanStatusWithID* mutable_plan_statuses_with_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID >*
      mutable_plan_statuses_with_ids();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatusWithID>& _internal_plan_statuses_with_ids() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatusWithID>* _internal_mutable_plan_statuses_with_ids();
  public:
  const ::viam::service::motion::v1::PlanStatusWithID& plan_statuses_with_ids(int index) const;
  ::viam::service::motion::v1::PlanStatusWithID* add_plan_statuses_with_ids();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID >&
      plan_statuses_with_ids() const;
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ListPlanStatusesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID > plan_statuses_with_ids_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class Plan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.Plan) */ {
 public:
  inline Plan() : Plan(nullptr) {}
  ~Plan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Plan(::google::protobuf::internal::ConstantInitialized);

  inline Plan(const Plan& from)
      : Plan(nullptr, from) {}
  Plan(Plan&& from) noexcept
    : Plan() {
    *this = ::std::move(from);
  }

  inline Plan& operator=(const Plan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plan& operator=(Plan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plan* internal_default_instance() {
    return reinterpret_cast<const Plan*>(
               &_Plan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Plan& a, Plan& b) {
    a.Swap(&b);
  }
  inline void Swap(Plan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Plan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Plan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Plan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Plan& from) {
    Plan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Plan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.Plan";
  }
  protected:
  explicit Plan(::google::protobuf::Arena* arena);
  Plan(::google::protobuf::Arena* arena, const Plan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepsFieldNumber = 4,
    kIdFieldNumber = 1,
    kExecutionIdFieldNumber = 3,
    kComponentNameFieldNumber = 2,
  };
  // repeated .viam.service.motion.v1.PlanStep steps = 4 [json_name = "steps"];
  int steps_size() const;
  private:
  int _internal_steps_size() const;

  public:
  void clear_steps() ;
  ::viam::service::motion::v1::PlanStep* mutable_steps(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStep >*
      mutable_steps();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStep>& _internal_steps() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStep>* _internal_mutable_steps();
  public:
  const ::viam::service::motion::v1::PlanStep& steps(int index) const;
  ::viam::service::motion::v1::PlanStep* add_steps();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStep >&
      steps() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string execution_id = 3 [json_name = "executionId"];
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.Plan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStep > steps_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::viam::common::v1::ResourceName* component_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class MoveOnGlobeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnGlobeRequest) */ {
 public:
  inline MoveOnGlobeRequest() : MoveOnGlobeRequest(nullptr) {}
  ~MoveOnGlobeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveOnGlobeRequest(::google::protobuf::internal::ConstantInitialized);

  inline MoveOnGlobeRequest(const MoveOnGlobeRequest& from)
      : MoveOnGlobeRequest(nullptr, from) {}
  MoveOnGlobeRequest(MoveOnGlobeRequest&& from) noexcept
    : MoveOnGlobeRequest() {
    *this = ::std::move(from);
  }

  inline MoveOnGlobeRequest& operator=(const MoveOnGlobeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnGlobeRequest& operator=(MoveOnGlobeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnGlobeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnGlobeRequest* internal_default_instance() {
    return reinterpret_cast<const MoveOnGlobeRequest*>(
               &_MoveOnGlobeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MoveOnGlobeRequest& a, MoveOnGlobeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnGlobeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnGlobeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnGlobeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnGlobeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveOnGlobeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveOnGlobeRequest& from) {
    MoveOnGlobeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveOnGlobeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.MoveOnGlobeRequest";
  }
  protected:
  explicit MoveOnGlobeRequest(::google::protobuf::Arena* arena);
  MoveOnGlobeRequest(::google::protobuf::Arena* arena, const MoveOnGlobeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstaclesFieldNumber = 6,
    kBoundingRegionsFieldNumber = 8,
    kNameFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kComponentNameFieldNumber = 4,
    kMovementSensorNameFieldNumber = 5,
    kMotionConfigurationFieldNumber = 7,
    kExtraFieldNumber = 99,
    kHeadingFieldNumber = 3,
  };
  // repeated .viam.common.v1.GeoGeometry obstacles = 6 [json_name = "obstacles"];
  int obstacles_size() const;
  private:
  int _internal_obstacles_size() const;

  public:
  void clear_obstacles() ;
  ::viam::common::v1::GeoGeometry* mutable_obstacles(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::common::v1::GeoGeometry >*
      mutable_obstacles();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>& _internal_obstacles() const;
  ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>* _internal_mutable_obstacles();
  public:
  const ::viam::common::v1::GeoGeometry& obstacles(int index) const;
  ::viam::common::v1::GeoGeometry* add_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::viam::common::v1::GeoGeometry >&
      obstacles() const;
  // repeated .viam.common.v1.GeoGeometry bounding_regions = 8 [json_name = "boundingRegions"];
  int bounding_regions_size() const;
  private:
  int _internal_bounding_regions_size() const;

  public:
  void clear_bounding_regions() ;
  ::viam::common::v1::GeoGeometry* mutable_bounding_regions(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::common::v1::GeoGeometry >*
      mutable_bounding_regions();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>& _internal_bounding_regions() const;
  ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>* _internal_mutable_bounding_regions();
  public:
  const ::viam::common::v1::GeoGeometry& bounding_regions(int index) const;
  ::viam::common::v1::GeoGeometry* add_bounding_regions();
  const ::google::protobuf::RepeatedPtrField< ::viam::common::v1::GeoGeometry >&
      bounding_regions() const;
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .viam.common.v1.GeoPoint destination = 2 [json_name = "destination"];
  bool has_destination() const;
  void clear_destination() ;
  const ::viam::common::v1::GeoPoint& destination() const;
  PROTOBUF_NODISCARD ::viam::common::v1::GeoPoint* release_destination();
  ::viam::common::v1::GeoPoint* mutable_destination();
  void set_allocated_destination(::viam::common::v1::GeoPoint* value);
  void unsafe_arena_set_allocated_destination(::viam::common::v1::GeoPoint* value);
  ::viam::common::v1::GeoPoint* unsafe_arena_release_destination();

  private:
  const ::viam::common::v1::GeoPoint& _internal_destination() const;
  ::viam::common::v1::GeoPoint* _internal_mutable_destination();

  public:
  // .viam.common.v1.ResourceName component_name = 4 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // .viam.common.v1.ResourceName movement_sensor_name = 5 [json_name = "movementSensorName"];
  bool has_movement_sensor_name() const;
  void clear_movement_sensor_name() ;
  const ::viam::common::v1::ResourceName& movement_sensor_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_movement_sensor_name();
  ::viam::common::v1::ResourceName* mutable_movement_sensor_name();
  void set_allocated_movement_sensor_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_movement_sensor_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_movement_sensor_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_movement_sensor_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_movement_sensor_name();

  public:
  // optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 7 [json_name = "motionConfiguration"];
  bool has_motion_configuration() const;
  void clear_motion_configuration() ;
  const ::viam::service::motion::v1::MotionConfiguration& motion_configuration() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::MotionConfiguration* release_motion_configuration();
  ::viam::service::motion::v1::MotionConfiguration* mutable_motion_configuration();
  void set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value);
  void unsafe_arena_set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value);
  ::viam::service::motion::v1::MotionConfiguration* unsafe_arena_release_motion_configuration();

  private:
  const ::viam::service::motion::v1::MotionConfiguration& _internal_motion_configuration() const;
  ::viam::service::motion::v1::MotionConfiguration* _internal_mutable_motion_configuration();

  public:
  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  void clear_extra() ;
  const ::google::protobuf::Struct& extra() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_extra();
  ::google::protobuf::Struct* mutable_extra();
  void set_allocated_extra(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_extra();

  private:
  const ::google::protobuf::Struct& _internal_extra() const;
  ::google::protobuf::Struct* _internal_mutable_extra();

  public:
  // optional double heading = 3 [json_name = "heading"];
  bool has_heading() const;
  void clear_heading() ;
  double heading() const;
  void set_heading(double value);

  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnGlobeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 7,
      62, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::common::v1::GeoGeometry > obstacles_;
    ::google::protobuf::RepeatedPtrField< ::viam::common::v1::GeoGeometry > bounding_regions_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::viam::common::v1::GeoPoint* destination_;
    ::viam::common::v1::ResourceName* component_name_;
    ::viam::common::v1::ResourceName* movement_sensor_name_;
    ::viam::service::motion::v1::MotionConfiguration* motion_configuration_;
    ::google::protobuf::Struct* extra_;
    double heading_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class GetPoseRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPoseRequest) */ {
 public:
  inline GetPoseRequest() : GetPoseRequest(nullptr) {}
  ~GetPoseRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPoseRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetPoseRequest(const GetPoseRequest& from)
      : GetPoseRequest(nullptr, from) {}
  GetPoseRequest(GetPoseRequest&& from) noexcept
    : GetPoseRequest() {
    *this = ::std::move(from);
  }

  inline GetPoseRequest& operator=(const GetPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoseRequest& operator=(GetPoseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPoseRequest* internal_default_instance() {
    return reinterpret_cast<const GetPoseRequest*>(
               &_GetPoseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetPoseRequest& a, GetPoseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPoseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoseRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPoseRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPoseRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPoseRequest& from) {
    GetPoseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPoseRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.GetPoseRequest";
  }
  protected:
  explicit GetPoseRequest(::google::protobuf::Arena* arena);
  GetPoseRequest(::google::protobuf::Arena* arena, const GetPoseRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupplementalTransformsFieldNumber = 4,
    kNameFieldNumber = 1,
    kDestinationFrameFieldNumber = 3,
    kComponentNameFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // repeated .viam.common.v1.Transform supplemental_transforms = 4 [json_name = "supplementalTransforms"];
  int supplemental_transforms_size() const;
  private:
  int _internal_supplemental_transforms_size() const;

  public:
  void clear_supplemental_transforms() ;
  ::viam::common::v1::Transform* mutable_supplemental_transforms(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::common::v1::Transform >*
      mutable_supplemental_transforms();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::common::v1::Transform>& _internal_supplemental_transforms() const;
  ::google::protobuf::RepeatedPtrField<::viam::common::v1::Transform>* _internal_mutable_supplemental_transforms();
  public:
  const ::viam::common::v1::Transform& supplemental_transforms(int index) const;
  ::viam::common::v1::Transform* add_supplemental_transforms();
  const ::google::protobuf::RepeatedPtrField< ::viam::common::v1::Transform >&
      supplemental_transforms() const;
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string destination_frame = 3 [json_name = "destinationFrame"];
  void clear_destination_frame() ;
  const std::string& destination_frame() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination_frame(Arg_&& arg, Args_... args);
  std::string* mutable_destination_frame();
  PROTOBUF_NODISCARD std::string* release_destination_frame();
  void set_allocated_destination_frame(std::string* value);

  private:
  const std::string& _internal_destination_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_frame(
      const std::string& value);
  std::string* _internal_mutable_destination_frame();

  public:
  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  void clear_extra() ;
  const ::google::protobuf::Struct& extra() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_extra();
  ::google::protobuf::Struct* mutable_extra();
  void set_allocated_extra(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_extra();

  private:
  const ::google::protobuf::Struct& _internal_extra() const;
  ::google::protobuf::Struct* _internal_mutable_extra();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPoseRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      67, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::common::v1::Transform > supplemental_transforms_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr destination_frame_;
    ::viam::common::v1::ResourceName* component_name_;
    ::google::protobuf::Struct* extra_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class PlanWithStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanWithStatus) */ {
 public:
  inline PlanWithStatus() : PlanWithStatus(nullptr) {}
  ~PlanWithStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlanWithStatus(::google::protobuf::internal::ConstantInitialized);

  inline PlanWithStatus(const PlanWithStatus& from)
      : PlanWithStatus(nullptr, from) {}
  PlanWithStatus(PlanWithStatus&& from) noexcept
    : PlanWithStatus() {
    *this = ::std::move(from);
  }

  inline PlanWithStatus& operator=(const PlanWithStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanWithStatus& operator=(PlanWithStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanWithStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanWithStatus* internal_default_instance() {
    return reinterpret_cast<const PlanWithStatus*>(
               &_PlanWithStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PlanWithStatus& a, PlanWithStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanWithStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanWithStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanWithStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanWithStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlanWithStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlanWithStatus& from) {
    PlanWithStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlanWithStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.PlanWithStatus";
  }
  protected:
  explicit PlanWithStatus(::google::protobuf::Arena* arena);
  PlanWithStatus(::google::protobuf::Arena* arena, const PlanWithStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusHistoryFieldNumber = 3,
    kPlanFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .viam.service.motion.v1.PlanStatus status_history = 3 [json_name = "statusHistory"];
  int status_history_size() const;
  private:
  int _internal_status_history_size() const;

  public:
  void clear_status_history() ;
  ::viam::service::motion::v1::PlanStatus* mutable_status_history(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus >*
      mutable_status_history();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatus>& _internal_status_history() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatus>* _internal_mutable_status_history();
  public:
  const ::viam::service::motion::v1::PlanStatus& status_history(int index) const;
  ::viam::service::motion::v1::PlanStatus* add_status_history();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus >&
      status_history() const;
  // .viam.service.motion.v1.Plan plan = 1 [json_name = "plan"];
  bool has_plan() const;
  void clear_plan() ;
  const ::viam::service::motion::v1::Plan& plan() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::Plan* release_plan();
  ::viam::service::motion::v1::Plan* mutable_plan();
  void set_allocated_plan(::viam::service::motion::v1::Plan* value);
  void unsafe_arena_set_allocated_plan(::viam::service::motion::v1::Plan* value);
  ::viam::service::motion::v1::Plan* unsafe_arena_release_plan();

  private:
  const ::viam::service::motion::v1::Plan& _internal_plan() const;
  ::viam::service::motion::v1::Plan* _internal_mutable_plan();

  public:
  // .viam.service.motion.v1.PlanStatus status = 2 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::viam::service::motion::v1::PlanStatus& status() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::PlanStatus* release_status();
  ::viam::service::motion::v1::PlanStatus* mutable_status();
  void set_allocated_status(::viam::service::motion::v1::PlanStatus* value);
  void unsafe_arena_set_allocated_status(::viam::service::motion::v1::PlanStatus* value);
  ::viam::service::motion::v1::PlanStatus* unsafe_arena_release_status();

  private:
  const ::viam::service::motion::v1::PlanStatus& _internal_status() const;
  ::viam::service::motion::v1::PlanStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanWithStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus > status_history_;
    ::viam::service::motion::v1::Plan* plan_;
    ::viam::service::motion::v1::PlanStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class MoveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveRequest) */ {
 public:
  inline MoveRequest() : MoveRequest(nullptr) {}
  ~MoveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveRequest(::google::protobuf::internal::ConstantInitialized);

  inline MoveRequest(const MoveRequest& from)
      : MoveRequest(nullptr, from) {}
  MoveRequest(MoveRequest&& from) noexcept
    : MoveRequest() {
    *this = ::std::move(from);
  }

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveRequest& operator=(MoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveRequest* internal_default_instance() {
    return reinterpret_cast<const MoveRequest*>(
               &_MoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MoveRequest& a, MoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveRequest& from) {
    MoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.MoveRequest";
  }
  protected:
  explicit MoveRequest(::google::protobuf::Arena* arena);
  MoveRequest(::google::protobuf::Arena* arena, const MoveRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kComponentNameFieldNumber = 3,
    kWorldStateFieldNumber = 4,
    kConstraintsFieldNumber = 5,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .viam.common.v1.PoseInFrame destination = 2 [json_name = "destination"];
  bool has_destination() const;
  void clear_destination() ;
  const ::viam::common::v1::PoseInFrame& destination() const;
  PROTOBUF_NODISCARD ::viam::common::v1::PoseInFrame* release_destination();
  ::viam::common::v1::PoseInFrame* mutable_destination();
  void set_allocated_destination(::viam::common::v1::PoseInFrame* value);
  void unsafe_arena_set_allocated_destination(::viam::common::v1::PoseInFrame* value);
  ::viam::common::v1::PoseInFrame* unsafe_arena_release_destination();

  private:
  const ::viam::common::v1::PoseInFrame& _internal_destination() const;
  ::viam::common::v1::PoseInFrame* _internal_mutable_destination();

  public:
  // .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
  bool has_component_name() const;
  void clear_component_name() ;
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* value);
  void unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();

  public:
  // optional .viam.common.v1.WorldState world_state = 4 [json_name = "worldState"];
  bool has_world_state() const;
  void clear_world_state() ;
  const ::viam::common::v1::WorldState& world_state() const;
  PROTOBUF_NODISCARD ::viam::common::v1::WorldState* release_world_state();
  ::viam::common::v1::WorldState* mutable_world_state();
  void set_allocated_world_state(::viam::common::v1::WorldState* value);
  void unsafe_arena_set_allocated_world_state(::viam::common::v1::WorldState* value);
  ::viam::common::v1::WorldState* unsafe_arena_release_world_state();

  private:
  const ::viam::common::v1::WorldState& _internal_world_state() const;
  ::viam::common::v1::WorldState* _internal_mutable_world_state();

  public:
  // optional .viam.service.motion.v1.Constraints constraints = 5 [json_name = "constraints"];
  bool has_constraints() const;
  void clear_constraints() ;
  const ::viam::service::motion::v1::Constraints& constraints() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::Constraints* release_constraints();
  ::viam::service::motion::v1::Constraints* mutable_constraints();
  void set_allocated_constraints(::viam::service::motion::v1::Constraints* value);
  void unsafe_arena_set_allocated_constraints(::viam::service::motion::v1::Constraints* value);
  ::viam::service::motion::v1::Constraints* unsafe_arena_release_constraints();

  private:
  const ::viam::service::motion::v1::Constraints& _internal_constraints() const;
  ::viam::service::motion::v1::Constraints* _internal_mutable_constraints();

  public:
  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  void clear_extra() ;
  const ::google::protobuf::Struct& extra() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_extra();
  ::google::protobuf::Struct* mutable_extra();
  void set_allocated_extra(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_extra();

  private:
  const ::google::protobuf::Struct& _internal_extra() const;
  ::google::protobuf::Struct* _internal_mutable_extra();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      47, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::viam::common::v1::PoseInFrame* destination_;
    ::viam::common::v1::ResourceName* component_name_;
    ::viam::common::v1::WorldState* world_state_;
    ::viam::service::motion::v1::Constraints* constraints_;
    ::google::protobuf::Struct* extra_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};// -------------------------------------------------------------------

class GetPlanResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPlanResponse) */ {
 public:
  inline GetPlanResponse() : GetPlanResponse(nullptr) {}
  ~GetPlanResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPlanResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetPlanResponse(const GetPlanResponse& from)
      : GetPlanResponse(nullptr, from) {}
  GetPlanResponse(GetPlanResponse&& from) noexcept
    : GetPlanResponse() {
    *this = ::std::move(from);
  }

  inline GetPlanResponse& operator=(const GetPlanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlanResponse& operator=(GetPlanResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlanResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlanResponse* internal_default_instance() {
    return reinterpret_cast<const GetPlanResponse*>(
               &_GetPlanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetPlanResponse& a, GetPlanResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlanResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlanResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlanResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlanResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPlanResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPlanResponse& from) {
    GetPlanResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPlanResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.service.motion.v1.GetPlanResponse";
  }
  protected:
  explicit GetPlanResponse(::google::protobuf::Arena* arena);
  GetPlanResponse(::google::protobuf::Arena* arena, const GetPlanResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplanHistoryFieldNumber = 2,
    kCurrentPlanWithStatusFieldNumber = 1,
  };
  // repeated .viam.service.motion.v1.PlanWithStatus replan_history = 2 [json_name = "replanHistory"];
  int replan_history_size() const;
  private:
  int _internal_replan_history_size() const;

  public:
  void clear_replan_history() ;
  ::viam::service::motion::v1::PlanWithStatus* mutable_replan_history(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus >*
      mutable_replan_history();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanWithStatus>& _internal_replan_history() const;
  ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanWithStatus>* _internal_mutable_replan_history();
  public:
  const ::viam::service::motion::v1::PlanWithStatus& replan_history(int index) const;
  ::viam::service::motion::v1::PlanWithStatus* add_replan_history();
  const ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus >&
      replan_history() const;
  // .viam.service.motion.v1.PlanWithStatus current_plan_with_status = 1 [json_name = "currentPlanWithStatus"];
  bool has_current_plan_with_status() const;
  void clear_current_plan_with_status() ;
  const ::viam::service::motion::v1::PlanWithStatus& current_plan_with_status() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::PlanWithStatus* release_current_plan_with_status();
  ::viam::service::motion::v1::PlanWithStatus* mutable_current_plan_with_status();
  void set_allocated_current_plan_with_status(::viam::service::motion::v1::PlanWithStatus* value);
  void unsafe_arena_set_allocated_current_plan_with_status(::viam::service::motion::v1::PlanWithStatus* value);
  ::viam::service::motion::v1::PlanWithStatus* unsafe_arena_release_current_plan_with_status();

  private:
  const ::viam::service::motion::v1::PlanWithStatus& _internal_current_plan_with_status() const;
  ::viam::service::motion::v1::PlanWithStatus* _internal_mutable_current_plan_with_status();

  public:
  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPlanResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus > replan_history_;
    ::viam::service::motion::v1::PlanWithStatus* current_plan_with_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MoveRequest

// string name = 1 [json_name = "name"];
inline void MoveRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MoveRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MoveRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveRequest.name)
}
inline std::string* MoveRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.name)
  return _s;
}
inline const std::string& MoveRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MoveRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MoveRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MoveRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.name)
  return _impl_.name_.Release();
}
inline void MoveRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.name)
}

// .viam.common.v1.PoseInFrame destination = 2 [json_name = "destination"];
inline bool MoveRequest::has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline const ::viam::common::v1::PoseInFrame& MoveRequest::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::PoseInFrame* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::PoseInFrame&>(::viam::common::v1::_PoseInFrame_default_instance_);
}
inline const ::viam::common::v1::PoseInFrame& MoveRequest::destination() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.destination)
  return _internal_destination();
}
inline void MoveRequest::unsafe_arena_set_allocated_destination(::viam::common::v1::PoseInFrame* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = reinterpret_cast<::viam::common::v1::PoseInFrame*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.destination)
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::PoseInFrame* released = _impl_.destination_;
  _impl_.destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::unsafe_arena_release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.destination)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::PoseInFrame* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::PoseInFrame>(GetArena());
    _impl_.destination_ = reinterpret_cast<::viam::common::v1::PoseInFrame*>(p);
  }
  return _impl_.destination_;
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::mutable_destination() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::PoseInFrame* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.destination)
  return _msg;
}
inline void MoveRequest::set_allocated_destination(::viam::common::v1::PoseInFrame* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.destination_ = reinterpret_cast<::viam::common::v1::PoseInFrame*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.destination)
}

// .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
inline bool MoveRequest::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& MoveRequest::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveRequest::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.component_name)
  return _internal_component_name();
}
inline void MoveRequest::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.component_name)
}
inline ::viam::common::v1::ResourceName* MoveRequest::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* MoveRequest::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.component_name)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveRequest::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* MoveRequest::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.component_name)
  return _msg;
}
inline void MoveRequest::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.component_name)
}

// optional .viam.common.v1.WorldState world_state = 4 [json_name = "worldState"];
inline bool MoveRequest::has_world_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.world_state_ != nullptr);
  return value;
}
inline const ::viam::common::v1::WorldState& MoveRequest::_internal_world_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::WorldState* p = _impl_.world_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::WorldState&>(::viam::common::v1::_WorldState_default_instance_);
}
inline const ::viam::common::v1::WorldState& MoveRequest::world_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.world_state)
  return _internal_world_state();
}
inline void MoveRequest::unsafe_arena_set_allocated_world_state(::viam::common::v1::WorldState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.world_state_);
  }
  _impl_.world_state_ = reinterpret_cast<::viam::common::v1::WorldState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.world_state)
}
inline ::viam::common::v1::WorldState* MoveRequest::release_world_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::WorldState* released = _impl_.world_state_;
  _impl_.world_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::WorldState* MoveRequest::unsafe_arena_release_world_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.world_state)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::WorldState* temp = _impl_.world_state_;
  _impl_.world_state_ = nullptr;
  return temp;
}
inline ::viam::common::v1::WorldState* MoveRequest::_internal_mutable_world_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.world_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::WorldState>(GetArena());
    _impl_.world_state_ = reinterpret_cast<::viam::common::v1::WorldState*>(p);
  }
  return _impl_.world_state_;
}
inline ::viam::common::v1::WorldState* MoveRequest::mutable_world_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::WorldState* _msg = _internal_mutable_world_state();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.world_state)
  return _msg;
}
inline void MoveRequest::set_allocated_world_state(::viam::common::v1::WorldState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.world_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.world_state_ = reinterpret_cast<::viam::common::v1::WorldState*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.world_state)
}

// optional .viam.service.motion.v1.Constraints constraints = 5 [json_name = "constraints"];
inline bool MoveRequest::has_constraints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.constraints_ != nullptr);
  return value;
}
inline void MoveRequest::clear_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.constraints_ != nullptr) _impl_.constraints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::viam::service::motion::v1::Constraints& MoveRequest::_internal_constraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::service::motion::v1::Constraints* p = _impl_.constraints_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::Constraints&>(::viam::service::motion::v1::_Constraints_default_instance_);
}
inline const ::viam::service::motion::v1::Constraints& MoveRequest::constraints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.constraints)
  return _internal_constraints();
}
inline void MoveRequest::unsafe_arena_set_allocated_constraints(::viam::service::motion::v1::Constraints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.constraints_);
  }
  _impl_.constraints_ = reinterpret_cast<::viam::service::motion::v1::Constraints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.constraints)
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::release_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::viam::service::motion::v1::Constraints* released = _impl_.constraints_;
  _impl_.constraints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::unsafe_arena_release_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.constraints)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::viam::service::motion::v1::Constraints* temp = _impl_.constraints_;
  _impl_.constraints_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::_internal_mutable_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::Constraints>(GetArena());
    _impl_.constraints_ = reinterpret_cast<::viam::service::motion::v1::Constraints*>(p);
  }
  return _impl_.constraints_;
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::mutable_constraints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::service::motion::v1::Constraints* _msg = _internal_mutable_constraints();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.constraints)
  return _msg;
}
inline void MoveRequest::set_allocated_constraints(::viam::service::motion::v1::Constraints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::service::motion::v1::Constraints*>(_impl_.constraints_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::service::motion::v1::Constraints*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.constraints_ = reinterpret_cast<::viam::service::motion::v1::Constraints*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.constraints)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool MoveRequest::has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& MoveRequest::_internal_extra() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& MoveRequest::extra() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.extra)
  return _internal_extra();
}
inline void MoveRequest::unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.extra)
}
inline ::google::protobuf::Struct* MoveRequest::release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Struct* released = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* MoveRequest::unsafe_arena_release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.extra)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* MoveRequest::_internal_mutable_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.extra_;
}
inline ::google::protobuf::Struct* MoveRequest::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.extra)
  return _msg;
}
inline void MoveRequest::set_allocated_extra(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.extra)
}

// -------------------------------------------------------------------

// MoveResponse

// bool success = 1 [json_name = "success"];
inline void MoveResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool MoveResponse::success() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveResponse.success)
  return _internal_success();
}
inline void MoveResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveResponse.success)
}
inline bool MoveResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void MoveResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// MoveOnMapRequest

// string name = 1 [json_name = "name"];
inline void MoveOnMapRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MoveOnMapRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MoveOnMapRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnMapRequest.name)
}
inline std::string* MoveOnMapRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.name)
  return _s;
}
inline const std::string& MoveOnMapRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MoveOnMapRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MoveOnMapRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MoveOnMapRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.name)
  return _impl_.name_.Release();
}
inline void MoveOnMapRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.name)
}

// .viam.common.v1.Pose destination = 2 [json_name = "destination"];
inline bool MoveOnMapRequest::has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline const ::viam::common::v1::Pose& MoveOnMapRequest::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::Pose* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::Pose&>(::viam::common::v1::_Pose_default_instance_);
}
inline const ::viam::common::v1::Pose& MoveOnMapRequest::destination() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.destination)
  return _internal_destination();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_destination(::viam::common::v1::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = reinterpret_cast<::viam::common::v1::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.destination)
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::Pose* released = _impl_.destination_;
  _impl_.destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::unsafe_arena_release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.destination)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::Pose* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::Pose>(GetArena());
    _impl_.destination_ = reinterpret_cast<::viam::common::v1::Pose*>(p);
  }
  return _impl_.destination_;
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::mutable_destination() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::Pose* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.destination)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_destination(::viam::common::v1::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.destination_ = reinterpret_cast<::viam::common::v1::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.destination)
}

// .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
inline bool MoveOnMapRequest::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.component_name)
  return _internal_component_name();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.component_name)
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.component_name)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.component_name)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.component_name)
}

// .viam.common.v1.ResourceName slam_service_name = 4 [json_name = "slamServiceName"];
inline bool MoveOnMapRequest::has_slam_service_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.slam_service_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::_internal_slam_service_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.slam_service_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::slam_service_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
  return _internal_slam_service_name();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_slam_service_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.slam_service_name_);
  }
  _impl_.slam_service_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::release_slam_service_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::ResourceName* released = _impl_.slam_service_name_;
  _impl_.slam_service_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::unsafe_arena_release_slam_service_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::ResourceName* temp = _impl_.slam_service_name_;
  _impl_.slam_service_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::_internal_mutable_slam_service_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.slam_service_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.slam_service_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.slam_service_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::mutable_slam_service_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_slam_service_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_slam_service_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.slam_service_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.slam_service_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
}

// optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 5 [json_name = "motionConfiguration"];
inline bool MoveOnMapRequest::has_motion_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.motion_configuration_ != nullptr);
  return value;
}
inline void MoveOnMapRequest::clear_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.motion_configuration_ != nullptr) _impl_.motion_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnMapRequest::_internal_motion_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::service::motion::v1::MotionConfiguration* p = _impl_.motion_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::MotionConfiguration&>(::viam::service::motion::v1::_MotionConfiguration_default_instance_);
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnMapRequest::motion_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
  return _internal_motion_configuration();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.motion_configuration_);
  }
  _impl_.motion_configuration_ = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::release_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::viam::service::motion::v1::MotionConfiguration* released = _impl_.motion_configuration_;
  _impl_.motion_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::unsafe_arena_release_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::viam::service::motion::v1::MotionConfiguration* temp = _impl_.motion_configuration_;
  _impl_.motion_configuration_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::_internal_mutable_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.motion_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::MotionConfiguration>(GetArena());
    _impl_.motion_configuration_ = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(p);
  }
  return _impl_.motion_configuration_;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::mutable_motion_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::service::motion::v1::MotionConfiguration* _msg = _internal_mutable_motion_configuration();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(_impl_.motion_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.motion_configuration_ = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
}

// repeated .viam.common.v1.Geometry obstacles = 6 [json_name = "obstacles"];
inline int MoveOnMapRequest::_internal_obstacles_size() const {
  return _internal_obstacles().size();
}
inline int MoveOnMapRequest::obstacles_size() const {
  return _internal_obstacles_size();
}
inline ::viam::common::v1::Geometry* MoveOnMapRequest::mutable_obstacles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return _internal_mutable_obstacles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::Geometry>* MoveOnMapRequest::mutable_obstacles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_obstacles();
}
inline const ::viam::common::v1::Geometry& MoveOnMapRequest::obstacles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return _internal_obstacles().Get(index);
}
inline ::viam::common::v1::Geometry* MoveOnMapRequest::add_obstacles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::common::v1::Geometry* _add = _internal_mutable_obstacles()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::Geometry>& MoveOnMapRequest::obstacles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return _internal_obstacles();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::Geometry>&
MoveOnMapRequest::_internal_obstacles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.obstacles_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::Geometry>*
MoveOnMapRequest::_internal_mutable_obstacles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.obstacles_;
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool MoveOnMapRequest::has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& MoveOnMapRequest::_internal_extra() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& MoveOnMapRequest::extra() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.extra)
  return _internal_extra();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.extra)
}
inline ::google::protobuf::Struct* MoveOnMapRequest::release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Struct* released = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* MoveOnMapRequest::unsafe_arena_release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.extra)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* MoveOnMapRequest::_internal_mutable_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.extra_;
}
inline ::google::protobuf::Struct* MoveOnMapRequest::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.extra)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_extra(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.extra)
}

// -------------------------------------------------------------------

// MoveOnMapResponse

// string execution_id = 1 [json_name = "executionId"];
inline void MoveOnMapResponse::clear_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& MoveOnMapResponse::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapResponse.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MoveOnMapResponse::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnMapResponse.execution_id)
}
inline std::string* MoveOnMapResponse::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapResponse.execution_id)
  return _s;
}
inline const std::string& MoveOnMapResponse::_internal_execution_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.execution_id_.Get();
}
inline void MoveOnMapResponse::_internal_set_execution_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* MoveOnMapResponse::_internal_mutable_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* MoveOnMapResponse::release_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapResponse.execution_id)
  return _impl_.execution_id_.Release();
}
inline void MoveOnMapResponse::set_allocated_execution_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_id_.IsDefault()) {
          _impl_.execution_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapResponse.execution_id)
}

// -------------------------------------------------------------------

// ObstacleDetector

// .viam.common.v1.ResourceName vision_service = 1 [json_name = "visionService"];
inline bool ObstacleDetector::has_vision_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vision_service_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::_internal_vision_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.vision_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::vision_service() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ObstacleDetector.vision_service)
  return _internal_vision_service();
}
inline void ObstacleDetector::unsafe_arena_set_allocated_vision_service(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vision_service_);
  }
  _impl_.vision_service_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ObstacleDetector.vision_service)
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::release_vision_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* released = _impl_.vision_service_;
  _impl_.vision_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::unsafe_arena_release_vision_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ObstacleDetector.vision_service)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* temp = _impl_.vision_service_;
  _impl_.vision_service_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::_internal_mutable_vision_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vision_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.vision_service_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.vision_service_;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::mutable_vision_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_vision_service();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ObstacleDetector.vision_service)
  return _msg;
}
inline void ObstacleDetector::set_allocated_vision_service(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vision_service_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.vision_service_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ObstacleDetector.vision_service)
}

// .viam.common.v1.ResourceName camera = 2 [json_name = "camera"];
inline bool ObstacleDetector::has_camera() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::_internal_camera() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::camera() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ObstacleDetector.camera)
  return _internal_camera();
}
inline void ObstacleDetector::unsafe_arena_set_allocated_camera(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_);
  }
  _impl_.camera_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ObstacleDetector.camera)
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::release_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* released = _impl_.camera_;
  _impl_.camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::unsafe_arena_release_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ObstacleDetector.camera)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::_internal_mutable_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.camera_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.camera_;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::mutable_camera() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ObstacleDetector.camera)
  return _msg;
}
inline void ObstacleDetector::set_allocated_camera(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.camera_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ObstacleDetector.camera)
}

// -------------------------------------------------------------------

// MotionConfiguration

// repeated .viam.service.motion.v1.ObstacleDetector obstacle_detectors = 1 [json_name = "obstacleDetectors"];
inline int MotionConfiguration::_internal_obstacle_detectors_size() const {
  return _internal_obstacle_detectors().size();
}
inline int MotionConfiguration::obstacle_detectors_size() const {
  return _internal_obstacle_detectors_size();
}
inline void MotionConfiguration::clear_obstacle_detectors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obstacle_detectors_.Clear();
}
inline ::viam::service::motion::v1::ObstacleDetector* MotionConfiguration::mutable_obstacle_detectors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return _internal_mutable_obstacle_detectors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::ObstacleDetector>* MotionConfiguration::mutable_obstacle_detectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_obstacle_detectors();
}
inline const ::viam::service::motion::v1::ObstacleDetector& MotionConfiguration::obstacle_detectors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return _internal_obstacle_detectors().Get(index);
}
inline ::viam::service::motion::v1::ObstacleDetector* MotionConfiguration::add_obstacle_detectors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::ObstacleDetector* _add = _internal_mutable_obstacle_detectors()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::ObstacleDetector>& MotionConfiguration::obstacle_detectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return _internal_obstacle_detectors();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::ObstacleDetector>&
MotionConfiguration::_internal_obstacle_detectors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.obstacle_detectors_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::ObstacleDetector>*
MotionConfiguration::_internal_mutable_obstacle_detectors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.obstacle_detectors_;
}

// optional double position_polling_frequency_hz = 2 [json_name = "positionPollingFrequencyHz"];
inline bool MotionConfiguration::has_position_polling_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MotionConfiguration::clear_position_polling_frequency_hz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.position_polling_frequency_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double MotionConfiguration::position_polling_frequency_hz() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.position_polling_frequency_hz)
  return _internal_position_polling_frequency_hz();
}
inline void MotionConfiguration::set_position_polling_frequency_hz(double value) {
  _internal_set_position_polling_frequency_hz(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.position_polling_frequency_hz)
}
inline double MotionConfiguration::_internal_position_polling_frequency_hz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.position_polling_frequency_hz_;
}
inline void MotionConfiguration::_internal_set_position_polling_frequency_hz(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.position_polling_frequency_hz_ = value;
}

// optional double obstacle_polling_frequency_hz = 3 [json_name = "obstaclePollingFrequencyHz"];
inline bool MotionConfiguration::has_obstacle_polling_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MotionConfiguration::clear_obstacle_polling_frequency_hz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obstacle_polling_frequency_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double MotionConfiguration::obstacle_polling_frequency_hz() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.obstacle_polling_frequency_hz)
  return _internal_obstacle_polling_frequency_hz();
}
inline void MotionConfiguration::set_obstacle_polling_frequency_hz(double value) {
  _internal_set_obstacle_polling_frequency_hz(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.obstacle_polling_frequency_hz)
}
inline double MotionConfiguration::_internal_obstacle_polling_frequency_hz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.obstacle_polling_frequency_hz_;
}
inline void MotionConfiguration::_internal_set_obstacle_polling_frequency_hz(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obstacle_polling_frequency_hz_ = value;
}

// optional double plan_deviation_m = 4 [json_name = "planDeviationM"];
inline bool MotionConfiguration::has_plan_deviation_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MotionConfiguration::clear_plan_deviation_m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.plan_deviation_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double MotionConfiguration::plan_deviation_m() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.plan_deviation_m)
  return _internal_plan_deviation_m();
}
inline void MotionConfiguration::set_plan_deviation_m(double value) {
  _internal_set_plan_deviation_m(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.plan_deviation_m)
}
inline double MotionConfiguration::_internal_plan_deviation_m() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.plan_deviation_m_;
}
inline void MotionConfiguration::_internal_set_plan_deviation_m(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.plan_deviation_m_ = value;
}

// optional double linear_m_per_sec = 5 [json_name = "linearMPerSec"];
inline bool MotionConfiguration::has_linear_m_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MotionConfiguration::clear_linear_m_per_sec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linear_m_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double MotionConfiguration::linear_m_per_sec() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.linear_m_per_sec)
  return _internal_linear_m_per_sec();
}
inline void MotionConfiguration::set_linear_m_per_sec(double value) {
  _internal_set_linear_m_per_sec(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.linear_m_per_sec)
}
inline double MotionConfiguration::_internal_linear_m_per_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linear_m_per_sec_;
}
inline void MotionConfiguration::_internal_set_linear_m_per_sec(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.linear_m_per_sec_ = value;
}

// optional double angular_degs_per_sec = 6 [json_name = "angularDegsPerSec"];
inline bool MotionConfiguration::has_angular_degs_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MotionConfiguration::clear_angular_degs_per_sec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angular_degs_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double MotionConfiguration::angular_degs_per_sec() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.angular_degs_per_sec)
  return _internal_angular_degs_per_sec();
}
inline void MotionConfiguration::set_angular_degs_per_sec(double value) {
  _internal_set_angular_degs_per_sec(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.angular_degs_per_sec)
}
inline double MotionConfiguration::_internal_angular_degs_per_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angular_degs_per_sec_;
}
inline void MotionConfiguration::_internal_set_angular_degs_per_sec(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.angular_degs_per_sec_ = value;
}

// -------------------------------------------------------------------

// MoveOnGlobeRequest

// string name = 1 [json_name = "name"];
inline void MoveOnGlobeRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MoveOnGlobeRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MoveOnGlobeRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnGlobeRequest.name)
}
inline std::string* MoveOnGlobeRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.name)
  return _s;
}
inline const std::string& MoveOnGlobeRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MoveOnGlobeRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MoveOnGlobeRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MoveOnGlobeRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.name)
  return _impl_.name_.Release();
}
inline void MoveOnGlobeRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.name)
}

// .viam.common.v1.GeoPoint destination = 2 [json_name = "destination"];
inline bool MoveOnGlobeRequest::has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline const ::viam::common::v1::GeoPoint& MoveOnGlobeRequest::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::GeoPoint* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::GeoPoint&>(::viam::common::v1::_GeoPoint_default_instance_);
}
inline const ::viam::common::v1::GeoPoint& MoveOnGlobeRequest::destination() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.destination)
  return _internal_destination();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_destination(::viam::common::v1::GeoPoint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = reinterpret_cast<::viam::common::v1::GeoPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.destination)
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::GeoPoint* released = _impl_.destination_;
  _impl_.destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::unsafe_arena_release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.destination)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::GeoPoint* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::GeoPoint>(GetArena());
    _impl_.destination_ = reinterpret_cast<::viam::common::v1::GeoPoint*>(p);
  }
  return _impl_.destination_;
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::mutable_destination() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::GeoPoint* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.destination)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_destination(::viam::common::v1::GeoPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.destination_ = reinterpret_cast<::viam::common::v1::GeoPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.destination)
}

// optional double heading = 3 [json_name = "heading"];
inline bool MoveOnGlobeRequest::has_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MoveOnGlobeRequest::clear_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double MoveOnGlobeRequest::heading() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.heading)
  return _internal_heading();
}
inline void MoveOnGlobeRequest::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnGlobeRequest.heading)
}
inline double MoveOnGlobeRequest::_internal_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heading_;
}
inline void MoveOnGlobeRequest::_internal_set_heading(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.heading_ = value;
}

// .viam.common.v1.ResourceName component_name = 4 [json_name = "componentName"];
inline bool MoveOnGlobeRequest::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
  return _internal_component_name();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.component_name)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
}

// .viam.common.v1.ResourceName movement_sensor_name = 5 [json_name = "movementSensorName"];
inline bool MoveOnGlobeRequest::has_movement_sensor_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.movement_sensor_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::_internal_movement_sensor_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.movement_sensor_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::movement_sensor_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
  return _internal_movement_sensor_name();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_movement_sensor_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.movement_sensor_name_);
  }
  _impl_.movement_sensor_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::release_movement_sensor_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::ResourceName* released = _impl_.movement_sensor_name_;
  _impl_.movement_sensor_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::unsafe_arena_release_movement_sensor_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::ResourceName* temp = _impl_.movement_sensor_name_;
  _impl_.movement_sensor_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::_internal_mutable_movement_sensor_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.movement_sensor_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.movement_sensor_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.movement_sensor_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::mutable_movement_sensor_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_movement_sensor_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_movement_sensor_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.movement_sensor_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.movement_sensor_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
}

// repeated .viam.common.v1.GeoGeometry obstacles = 6 [json_name = "obstacles"];
inline int MoveOnGlobeRequest::_internal_obstacles_size() const {
  return _internal_obstacles().size();
}
inline int MoveOnGlobeRequest::obstacles_size() const {
  return _internal_obstacles_size();
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::mutable_obstacles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return _internal_mutable_obstacles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>* MoveOnGlobeRequest::mutable_obstacles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_obstacles();
}
inline const ::viam::common::v1::GeoGeometry& MoveOnGlobeRequest::obstacles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return _internal_obstacles().Get(index);
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::add_obstacles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::common::v1::GeoGeometry* _add = _internal_mutable_obstacles()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>& MoveOnGlobeRequest::obstacles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return _internal_obstacles();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>&
MoveOnGlobeRequest::_internal_obstacles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.obstacles_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>*
MoveOnGlobeRequest::_internal_mutable_obstacles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.obstacles_;
}

// optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 7 [json_name = "motionConfiguration"];
inline bool MoveOnGlobeRequest::has_motion_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.motion_configuration_ != nullptr);
  return value;
}
inline void MoveOnGlobeRequest::clear_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.motion_configuration_ != nullptr) _impl_.motion_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnGlobeRequest::_internal_motion_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::service::motion::v1::MotionConfiguration* p = _impl_.motion_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::MotionConfiguration&>(::viam::service::motion::v1::_MotionConfiguration_default_instance_);
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnGlobeRequest::motion_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
  return _internal_motion_configuration();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.motion_configuration_);
  }
  _impl_.motion_configuration_ = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::release_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::viam::service::motion::v1::MotionConfiguration* released = _impl_.motion_configuration_;
  _impl_.motion_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::unsafe_arena_release_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::viam::service::motion::v1::MotionConfiguration* temp = _impl_.motion_configuration_;
  _impl_.motion_configuration_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::_internal_mutable_motion_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.motion_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::MotionConfiguration>(GetArena());
    _impl_.motion_configuration_ = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(p);
  }
  return _impl_.motion_configuration_;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::mutable_motion_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::service::motion::v1::MotionConfiguration* _msg = _internal_mutable_motion_configuration();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(_impl_.motion_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.motion_configuration_ = reinterpret_cast<::viam::service::motion::v1::MotionConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
}

// repeated .viam.common.v1.GeoGeometry bounding_regions = 8 [json_name = "boundingRegions"];
inline int MoveOnGlobeRequest::_internal_bounding_regions_size() const {
  return _internal_bounding_regions().size();
}
inline int MoveOnGlobeRequest::bounding_regions_size() const {
  return _internal_bounding_regions_size();
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::mutable_bounding_regions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return _internal_mutable_bounding_regions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>* MoveOnGlobeRequest::mutable_bounding_regions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_bounding_regions();
}
inline const ::viam::common::v1::GeoGeometry& MoveOnGlobeRequest::bounding_regions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return _internal_bounding_regions().Get(index);
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::add_bounding_regions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::common::v1::GeoGeometry* _add = _internal_mutable_bounding_regions()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>& MoveOnGlobeRequest::bounding_regions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return _internal_bounding_regions();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>&
MoveOnGlobeRequest::_internal_bounding_regions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bounding_regions_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::GeoGeometry>*
MoveOnGlobeRequest::_internal_mutable_bounding_regions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.bounding_regions_;
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool MoveOnGlobeRequest::has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& MoveOnGlobeRequest::_internal_extra() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& MoveOnGlobeRequest::extra() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.extra)
  return _internal_extra();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.extra)
}
inline ::google::protobuf::Struct* MoveOnGlobeRequest::release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Struct* released = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* MoveOnGlobeRequest::unsafe_arena_release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.extra)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* MoveOnGlobeRequest::_internal_mutable_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.extra_;
}
inline ::google::protobuf::Struct* MoveOnGlobeRequest::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.extra)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_extra(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.extra)
}

// -------------------------------------------------------------------

// MoveOnGlobeResponse

// string execution_id = 1 [json_name = "executionId"];
inline void MoveOnGlobeResponse::clear_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& MoveOnGlobeResponse::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MoveOnGlobeResponse::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
}
inline std::string* MoveOnGlobeResponse::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
  return _s;
}
inline const std::string& MoveOnGlobeResponse::_internal_execution_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.execution_id_.Get();
}
inline void MoveOnGlobeResponse::_internal_set_execution_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* MoveOnGlobeResponse::_internal_mutable_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* MoveOnGlobeResponse::release_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
  return _impl_.execution_id_.Release();
}
inline void MoveOnGlobeResponse::set_allocated_execution_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_id_.IsDefault()) {
          _impl_.execution_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
}

// -------------------------------------------------------------------

// GetPoseRequest

// string name = 1 [json_name = "name"];
inline void GetPoseRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetPoseRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPoseRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPoseRequest.name)
}
inline std::string* GetPoseRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.name)
  return _s;
}
inline const std::string& GetPoseRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetPoseRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetPoseRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetPoseRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.name)
  return _impl_.name_.Release();
}
inline void GetPoseRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.name)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool GetPoseRequest::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& GetPoseRequest::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& GetPoseRequest::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.component_name)
  return _internal_component_name();
}
inline void GetPoseRequest::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPoseRequest.component_name)
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.component_name)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.component_name)
  return _msg;
}
inline void GetPoseRequest::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.component_name)
}

// string destination_frame = 3 [json_name = "destinationFrame"];
inline void GetPoseRequest::clear_destination_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_frame_.ClearToEmpty();
}
inline const std::string& GetPoseRequest::destination_frame() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.destination_frame)
  return _internal_destination_frame();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPoseRequest::set_destination_frame(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.destination_frame_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPoseRequest.destination_frame)
}
inline std::string* GetPoseRequest::mutable_destination_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_destination_frame();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.destination_frame)
  return _s;
}
inline const std::string& GetPoseRequest::_internal_destination_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destination_frame_.Get();
}
inline void GetPoseRequest::_internal_set_destination_frame(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.destination_frame_.Set(value, GetArena());
}
inline std::string* GetPoseRequest::_internal_mutable_destination_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.destination_frame_.Mutable( GetArena());
}
inline std::string* GetPoseRequest::release_destination_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.destination_frame)
  return _impl_.destination_frame_.Release();
}
inline void GetPoseRequest::set_allocated_destination_frame(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_frame_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_frame_.IsDefault()) {
          _impl_.destination_frame_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.destination_frame)
}

// repeated .viam.common.v1.Transform supplemental_transforms = 4 [json_name = "supplementalTransforms"];
inline int GetPoseRequest::_internal_supplemental_transforms_size() const {
  return _internal_supplemental_transforms().size();
}
inline int GetPoseRequest::supplemental_transforms_size() const {
  return _internal_supplemental_transforms_size();
}
inline ::viam::common::v1::Transform* GetPoseRequest::mutable_supplemental_transforms(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return _internal_mutable_supplemental_transforms()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::Transform>* GetPoseRequest::mutable_supplemental_transforms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_supplemental_transforms();
}
inline const ::viam::common::v1::Transform& GetPoseRequest::supplemental_transforms(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return _internal_supplemental_transforms().Get(index);
}
inline ::viam::common::v1::Transform* GetPoseRequest::add_supplemental_transforms() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::common::v1::Transform* _add = _internal_mutable_supplemental_transforms()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::Transform>& GetPoseRequest::supplemental_transforms() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return _internal_supplemental_transforms();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::Transform>&
GetPoseRequest::_internal_supplemental_transforms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supplemental_transforms_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::Transform>*
GetPoseRequest::_internal_mutable_supplemental_transforms() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.supplemental_transforms_;
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetPoseRequest::has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& GetPoseRequest::_internal_extra() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& GetPoseRequest::extra() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.extra)
  return _internal_extra();
}
inline void GetPoseRequest::unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPoseRequest.extra)
}
inline ::google::protobuf::Struct* GetPoseRequest::release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Struct* released = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* GetPoseRequest::unsafe_arena_release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.extra)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* GetPoseRequest::_internal_mutable_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.extra_;
}
inline ::google::protobuf::Struct* GetPoseRequest::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.extra)
  return _msg;
}
inline void GetPoseRequest::set_allocated_extra(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.extra)
}

// -------------------------------------------------------------------

// GetPoseResponse

// .viam.common.v1.PoseInFrame pose = 1 [json_name = "pose"];
inline bool GetPoseResponse::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline const ::viam::common::v1::PoseInFrame& GetPoseResponse::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::PoseInFrame* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::PoseInFrame&>(::viam::common::v1::_PoseInFrame_default_instance_);
}
inline const ::viam::common::v1::PoseInFrame& GetPoseResponse::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseResponse.pose)
  return _internal_pose();
}
inline void GetPoseResponse::unsafe_arena_set_allocated_pose(::viam::common::v1::PoseInFrame* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::viam::common::v1::PoseInFrame*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPoseResponse.pose)
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::PoseInFrame* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseResponse.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::PoseInFrame* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::PoseInFrame>(GetArena());
    _impl_.pose_ = reinterpret_cast<::viam::common::v1::PoseInFrame*>(p);
  }
  return _impl_.pose_;
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::PoseInFrame* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseResponse.pose)
  return _msg;
}
inline void GetPoseResponse::set_allocated_pose(::viam::common::v1::PoseInFrame* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::viam::common::v1::PoseInFrame*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseResponse.pose)
}

// -------------------------------------------------------------------

// StopPlanRequest

// string name = 1 [json_name = "name"];
inline void StopPlanRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StopPlanRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.StopPlanRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StopPlanRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.StopPlanRequest.name)
}
inline std::string* StopPlanRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.StopPlanRequest.name)
  return _s;
}
inline const std::string& StopPlanRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void StopPlanRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* StopPlanRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* StopPlanRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.StopPlanRequest.name)
  return _impl_.name_.Release();
}
inline void StopPlanRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.StopPlanRequest.name)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool StopPlanRequest::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& StopPlanRequest::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& StopPlanRequest::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.StopPlanRequest.component_name)
  return _internal_component_name();
}
inline void StopPlanRequest::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.StopPlanRequest.component_name)
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.StopPlanRequest.component_name)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.StopPlanRequest.component_name)
  return _msg;
}
inline void StopPlanRequest::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.StopPlanRequest.component_name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool StopPlanRequest::has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& StopPlanRequest::_internal_extra() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& StopPlanRequest::extra() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.StopPlanRequest.extra)
  return _internal_extra();
}
inline void StopPlanRequest::unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.StopPlanRequest.extra)
}
inline ::google::protobuf::Struct* StopPlanRequest::release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Struct* released = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* StopPlanRequest::unsafe_arena_release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.StopPlanRequest.extra)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* StopPlanRequest::_internal_mutable_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.extra_;
}
inline ::google::protobuf::Struct* StopPlanRequest::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.StopPlanRequest.extra)
  return _msg;
}
inline void StopPlanRequest::set_allocated_extra(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.StopPlanRequest.extra)
}

// -------------------------------------------------------------------

// StopPlanResponse

// -------------------------------------------------------------------

// ListPlanStatusesRequest

// string name = 1 [json_name = "name"];
inline void ListPlanStatusesRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListPlanStatusesRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListPlanStatusesRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.ListPlanStatusesRequest.name)
}
inline std::string* ListPlanStatusesRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ListPlanStatusesRequest.name)
  return _s;
}
inline const std::string& ListPlanStatusesRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ListPlanStatusesRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ListPlanStatusesRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ListPlanStatusesRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ListPlanStatusesRequest.name)
  return _impl_.name_.Release();
}
inline void ListPlanStatusesRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ListPlanStatusesRequest.name)
}

// bool only_active_plans = 2 [json_name = "onlyActivePlans"];
inline void ListPlanStatusesRequest::clear_only_active_plans() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.only_active_plans_ = false;
}
inline bool ListPlanStatusesRequest::only_active_plans() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesRequest.only_active_plans)
  return _internal_only_active_plans();
}
inline void ListPlanStatusesRequest::set_only_active_plans(bool value) {
  _internal_set_only_active_plans(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.ListPlanStatusesRequest.only_active_plans)
}
inline bool ListPlanStatusesRequest::_internal_only_active_plans() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.only_active_plans_;
}
inline void ListPlanStatusesRequest::_internal_set_only_active_plans(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.only_active_plans_ = value;
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool ListPlanStatusesRequest::has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& ListPlanStatusesRequest::_internal_extra() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& ListPlanStatusesRequest::extra() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesRequest.extra)
  return _internal_extra();
}
inline void ListPlanStatusesRequest::unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ListPlanStatusesRequest.extra)
}
inline ::google::protobuf::Struct* ListPlanStatusesRequest::release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* released = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* ListPlanStatusesRequest::unsafe_arena_release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ListPlanStatusesRequest.extra)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* ListPlanStatusesRequest::_internal_mutable_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.extra_;
}
inline ::google::protobuf::Struct* ListPlanStatusesRequest::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ListPlanStatusesRequest.extra)
  return _msg;
}
inline void ListPlanStatusesRequest::set_allocated_extra(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ListPlanStatusesRequest.extra)
}

// -------------------------------------------------------------------

// ListPlanStatusesResponse

// repeated .viam.service.motion.v1.PlanStatusWithID plan_statuses_with_ids = 1 [json_name = "planStatusesWithIds"];
inline int ListPlanStatusesResponse::_internal_plan_statuses_with_ids_size() const {
  return _internal_plan_statuses_with_ids().size();
}
inline int ListPlanStatusesResponse::plan_statuses_with_ids_size() const {
  return _internal_plan_statuses_with_ids_size();
}
inline void ListPlanStatusesResponse::clear_plan_statuses_with_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.plan_statuses_with_ids_.Clear();
}
inline ::viam::service::motion::v1::PlanStatusWithID* ListPlanStatusesResponse::mutable_plan_statuses_with_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return _internal_mutable_plan_statuses_with_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatusWithID>* ListPlanStatusesResponse::mutable_plan_statuses_with_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_plan_statuses_with_ids();
}
inline const ::viam::service::motion::v1::PlanStatusWithID& ListPlanStatusesResponse::plan_statuses_with_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return _internal_plan_statuses_with_ids().Get(index);
}
inline ::viam::service::motion::v1::PlanStatusWithID* ListPlanStatusesResponse::add_plan_statuses_with_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::PlanStatusWithID* _add = _internal_mutable_plan_statuses_with_ids()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatusWithID>& ListPlanStatusesResponse::plan_statuses_with_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return _internal_plan_statuses_with_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatusWithID>&
ListPlanStatusesResponse::_internal_plan_statuses_with_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.plan_statuses_with_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatusWithID>*
ListPlanStatusesResponse::_internal_mutable_plan_statuses_with_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.plan_statuses_with_ids_;
}

// -------------------------------------------------------------------

// GetPlanRequest

// string name = 1 [json_name = "name"];
inline void GetPlanRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetPlanRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlanRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPlanRequest.name)
}
inline std::string* GetPlanRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.name)
  return _s;
}
inline const std::string& GetPlanRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetPlanRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetPlanRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetPlanRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.name)
  return _impl_.name_.Release();
}
inline void GetPlanRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.name)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool GetPlanRequest::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& GetPlanRequest::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& GetPlanRequest::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.component_name)
  return _internal_component_name();
}
inline void GetPlanRequest::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPlanRequest.component_name)
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.component_name)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.component_name)
  return _msg;
}
inline void GetPlanRequest::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.component_name)
}

// bool last_plan_only = 3 [json_name = "lastPlanOnly"];
inline void GetPlanRequest::clear_last_plan_only() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_plan_only_ = false;
}
inline bool GetPlanRequest::last_plan_only() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.last_plan_only)
  return _internal_last_plan_only();
}
inline void GetPlanRequest::set_last_plan_only(bool value) {
  _internal_set_last_plan_only(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPlanRequest.last_plan_only)
}
inline bool GetPlanRequest::_internal_last_plan_only() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_plan_only_;
}
inline void GetPlanRequest::_internal_set_last_plan_only(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_plan_only_ = value;
}

// optional string execution_id = 4 [json_name = "executionId"];
inline bool GetPlanRequest::has_execution_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetPlanRequest::clear_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetPlanRequest::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPlanRequest::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPlanRequest.execution_id)
}
inline std::string* GetPlanRequest::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.execution_id)
  return _s;
}
inline const std::string& GetPlanRequest::_internal_execution_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.execution_id_.Get();
}
inline void GetPlanRequest::_internal_set_execution_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* GetPlanRequest::_internal_mutable_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* GetPlanRequest::release_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.execution_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.execution_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetPlanRequest::set_allocated_execution_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.execution_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_id_.IsDefault()) {
          _impl_.execution_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.execution_id)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetPlanRequest::has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& GetPlanRequest::_internal_extra() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& GetPlanRequest::extra() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.extra)
  return _internal_extra();
}
inline void GetPlanRequest::unsafe_arena_set_allocated_extra(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPlanRequest.extra)
}
inline ::google::protobuf::Struct* GetPlanRequest::release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Struct* released = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* GetPlanRequest::unsafe_arena_release_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.extra)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* GetPlanRequest::_internal_mutable_extra() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.extra_;
}
inline ::google::protobuf::Struct* GetPlanRequest::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.extra)
  return _msg;
}
inline void GetPlanRequest::set_allocated_extra(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.extra_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.extra)
}

// -------------------------------------------------------------------

// GetPlanResponse

// .viam.service.motion.v1.PlanWithStatus current_plan_with_status = 1 [json_name = "currentPlanWithStatus"];
inline bool GetPlanResponse::has_current_plan_with_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.current_plan_with_status_ != nullptr);
  return value;
}
inline void GetPlanResponse::clear_current_plan_with_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.current_plan_with_status_ != nullptr) _impl_.current_plan_with_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::service::motion::v1::PlanWithStatus& GetPlanResponse::_internal_current_plan_with_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::service::motion::v1::PlanWithStatus* p = _impl_.current_plan_with_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::PlanWithStatus&>(::viam::service::motion::v1::_PlanWithStatus_default_instance_);
}
inline const ::viam::service::motion::v1::PlanWithStatus& GetPlanResponse::current_plan_with_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
  return _internal_current_plan_with_status();
}
inline void GetPlanResponse::unsafe_arena_set_allocated_current_plan_with_status(::viam::service::motion::v1::PlanWithStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_plan_with_status_);
  }
  _impl_.current_plan_with_status_ = reinterpret_cast<::viam::service::motion::v1::PlanWithStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::release_current_plan_with_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::PlanWithStatus* released = _impl_.current_plan_with_status_;
  _impl_.current_plan_with_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::unsafe_arena_release_current_plan_with_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::PlanWithStatus* temp = _impl_.current_plan_with_status_;
  _impl_.current_plan_with_status_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::_internal_mutable_current_plan_with_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.current_plan_with_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::PlanWithStatus>(GetArena());
    _impl_.current_plan_with_status_ = reinterpret_cast<::viam::service::motion::v1::PlanWithStatus*>(p);
  }
  return _impl_.current_plan_with_status_;
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::mutable_current_plan_with_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::service::motion::v1::PlanWithStatus* _msg = _internal_mutable_current_plan_with_status();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
  return _msg;
}
inline void GetPlanResponse::set_allocated_current_plan_with_status(::viam::service::motion::v1::PlanWithStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::service::motion::v1::PlanWithStatus*>(_impl_.current_plan_with_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::service::motion::v1::PlanWithStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.current_plan_with_status_ = reinterpret_cast<::viam::service::motion::v1::PlanWithStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
}

// repeated .viam.service.motion.v1.PlanWithStatus replan_history = 2 [json_name = "replanHistory"];
inline int GetPlanResponse::_internal_replan_history_size() const {
  return _internal_replan_history().size();
}
inline int GetPlanResponse::replan_history_size() const {
  return _internal_replan_history_size();
}
inline void GetPlanResponse::clear_replan_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replan_history_.Clear();
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::mutable_replan_history(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanResponse.replan_history)
  return _internal_mutable_replan_history()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanWithStatus>* GetPlanResponse::mutable_replan_history()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.GetPlanResponse.replan_history)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_replan_history();
}
inline const ::viam::service::motion::v1::PlanWithStatus& GetPlanResponse::replan_history(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanResponse.replan_history)
  return _internal_replan_history().Get(index);
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::add_replan_history() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::PlanWithStatus* _add = _internal_mutable_replan_history()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.GetPlanResponse.replan_history)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanWithStatus>& GetPlanResponse::replan_history() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.GetPlanResponse.replan_history)
  return _internal_replan_history();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanWithStatus>&
GetPlanResponse::_internal_replan_history() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replan_history_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanWithStatus>*
GetPlanResponse::_internal_mutable_replan_history() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.replan_history_;
}

// -------------------------------------------------------------------

// Constraints

// repeated .viam.service.motion.v1.LinearConstraint linear_constraint = 1 [json_name = "linearConstraint"];
inline int Constraints::_internal_linear_constraint_size() const {
  return _internal_linear_constraint().size();
}
inline int Constraints::linear_constraint_size() const {
  return _internal_linear_constraint_size();
}
inline void Constraints::clear_linear_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linear_constraint_.Clear();
}
inline ::viam::service::motion::v1::LinearConstraint* Constraints::mutable_linear_constraint(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Constraints.linear_constraint)
  return _internal_mutable_linear_constraint()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::LinearConstraint>* Constraints::mutable_linear_constraint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Constraints.linear_constraint)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_linear_constraint();
}
inline const ::viam::service::motion::v1::LinearConstraint& Constraints::linear_constraint(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Constraints.linear_constraint)
  return _internal_linear_constraint().Get(index);
}
inline ::viam::service::motion::v1::LinearConstraint* Constraints::add_linear_constraint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::LinearConstraint* _add = _internal_mutable_linear_constraint()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Constraints.linear_constraint)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::LinearConstraint>& Constraints::linear_constraint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Constraints.linear_constraint)
  return _internal_linear_constraint();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::LinearConstraint>&
Constraints::_internal_linear_constraint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linear_constraint_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::LinearConstraint>*
Constraints::_internal_mutable_linear_constraint() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.linear_constraint_;
}

// repeated .viam.service.motion.v1.OrientationConstraint orientation_constraint = 2 [json_name = "orientationConstraint"];
inline int Constraints::_internal_orientation_constraint_size() const {
  return _internal_orientation_constraint().size();
}
inline int Constraints::orientation_constraint_size() const {
  return _internal_orientation_constraint_size();
}
inline void Constraints::clear_orientation_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orientation_constraint_.Clear();
}
inline ::viam::service::motion::v1::OrientationConstraint* Constraints::mutable_orientation_constraint(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Constraints.orientation_constraint)
  return _internal_mutable_orientation_constraint()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::OrientationConstraint>* Constraints::mutable_orientation_constraint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Constraints.orientation_constraint)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_orientation_constraint();
}
inline const ::viam::service::motion::v1::OrientationConstraint& Constraints::orientation_constraint(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Constraints.orientation_constraint)
  return _internal_orientation_constraint().Get(index);
}
inline ::viam::service::motion::v1::OrientationConstraint* Constraints::add_orientation_constraint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::OrientationConstraint* _add = _internal_mutable_orientation_constraint()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Constraints.orientation_constraint)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::OrientationConstraint>& Constraints::orientation_constraint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Constraints.orientation_constraint)
  return _internal_orientation_constraint();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::OrientationConstraint>&
Constraints::_internal_orientation_constraint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.orientation_constraint_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::OrientationConstraint>*
Constraints::_internal_mutable_orientation_constraint() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.orientation_constraint_;
}

// repeated .viam.service.motion.v1.CollisionSpecification collision_specification = 3 [json_name = "collisionSpecification"];
inline int Constraints::_internal_collision_specification_size() const {
  return _internal_collision_specification().size();
}
inline int Constraints::collision_specification_size() const {
  return _internal_collision_specification_size();
}
inline void Constraints::clear_collision_specification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.collision_specification_.Clear();
}
inline ::viam::service::motion::v1::CollisionSpecification* Constraints::mutable_collision_specification(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Constraints.collision_specification)
  return _internal_mutable_collision_specification()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification>* Constraints::mutable_collision_specification()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Constraints.collision_specification)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_collision_specification();
}
inline const ::viam::service::motion::v1::CollisionSpecification& Constraints::collision_specification(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Constraints.collision_specification)
  return _internal_collision_specification().Get(index);
}
inline ::viam::service::motion::v1::CollisionSpecification* Constraints::add_collision_specification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::CollisionSpecification* _add = _internal_mutable_collision_specification()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Constraints.collision_specification)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification>& Constraints::collision_specification() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Constraints.collision_specification)
  return _internal_collision_specification();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification>&
Constraints::_internal_collision_specification() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collision_specification_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification>*
Constraints::_internal_mutable_collision_specification() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.collision_specification_;
}

// -------------------------------------------------------------------

// LinearConstraint

// optional float line_tolerance_mm = 1 [json_name = "lineToleranceMm"];
inline bool LinearConstraint::has_line_tolerance_mm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LinearConstraint::clear_line_tolerance_mm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.line_tolerance_mm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float LinearConstraint::line_tolerance_mm() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.LinearConstraint.line_tolerance_mm)
  return _internal_line_tolerance_mm();
}
inline void LinearConstraint::set_line_tolerance_mm(float value) {
  _internal_set_line_tolerance_mm(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.LinearConstraint.line_tolerance_mm)
}
inline float LinearConstraint::_internal_line_tolerance_mm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.line_tolerance_mm_;
}
inline void LinearConstraint::_internal_set_line_tolerance_mm(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.line_tolerance_mm_ = value;
}

// optional float orientation_tolerance_degs = 2 [json_name = "orientationToleranceDegs"];
inline bool LinearConstraint::has_orientation_tolerance_degs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LinearConstraint::clear_orientation_tolerance_degs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orientation_tolerance_degs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float LinearConstraint::orientation_tolerance_degs() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.LinearConstraint.orientation_tolerance_degs)
  return _internal_orientation_tolerance_degs();
}
inline void LinearConstraint::set_orientation_tolerance_degs(float value) {
  _internal_set_orientation_tolerance_degs(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.LinearConstraint.orientation_tolerance_degs)
}
inline float LinearConstraint::_internal_orientation_tolerance_degs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.orientation_tolerance_degs_;
}
inline void LinearConstraint::_internal_set_orientation_tolerance_degs(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.orientation_tolerance_degs_ = value;
}

// -------------------------------------------------------------------

// OrientationConstraint

// optional float orientation_tolerance_degs = 1 [json_name = "orientationToleranceDegs"];
inline bool OrientationConstraint::has_orientation_tolerance_degs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OrientationConstraint::clear_orientation_tolerance_degs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orientation_tolerance_degs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float OrientationConstraint::orientation_tolerance_degs() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.OrientationConstraint.orientation_tolerance_degs)
  return _internal_orientation_tolerance_degs();
}
inline void OrientationConstraint::set_orientation_tolerance_degs(float value) {
  _internal_set_orientation_tolerance_degs(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.OrientationConstraint.orientation_tolerance_degs)
}
inline float OrientationConstraint::_internal_orientation_tolerance_degs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.orientation_tolerance_degs_;
}
inline void OrientationConstraint::_internal_set_orientation_tolerance_degs(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.orientation_tolerance_degs_ = value;
}

// -------------------------------------------------------------------

// CollisionSpecification_AllowedFrameCollisions

// string frame1 = 1 [json_name = "frame1"];
inline void CollisionSpecification_AllowedFrameCollisions::clear_frame1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame1_.ClearToEmpty();
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::frame1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
  return _internal_frame1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollisionSpecification_AllowedFrameCollisions::set_frame1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame1_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::mutable_frame1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame1();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
  return _s;
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::_internal_frame1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame1_.Get();
}
inline void CollisionSpecification_AllowedFrameCollisions::_internal_set_frame1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame1_.Set(value, GetArena());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::_internal_mutable_frame1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.frame1_.Mutable( GetArena());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::release_frame1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
  return _impl_.frame1_.Release();
}
inline void CollisionSpecification_AllowedFrameCollisions::set_allocated_frame1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.frame1_.IsDefault()) {
          _impl_.frame1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
}

// string frame2 = 2 [json_name = "frame2"];
inline void CollisionSpecification_AllowedFrameCollisions::clear_frame2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame2_.ClearToEmpty();
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::frame2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
  return _internal_frame2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollisionSpecification_AllowedFrameCollisions::set_frame2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame2_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::mutable_frame2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame2();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
  return _s;
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::_internal_frame2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame2_.Get();
}
inline void CollisionSpecification_AllowedFrameCollisions::_internal_set_frame2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame2_.Set(value, GetArena());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::_internal_mutable_frame2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.frame2_.Mutable( GetArena());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::release_frame2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
  return _impl_.frame2_.Release();
}
inline void CollisionSpecification_AllowedFrameCollisions::set_allocated_frame2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame2_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.frame2_.IsDefault()) {
          _impl_.frame2_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
}

// -------------------------------------------------------------------

// CollisionSpecification

// repeated .viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions allows = 1 [json_name = "allows"];
inline int CollisionSpecification::_internal_allows_size() const {
  return _internal_allows().size();
}
inline int CollisionSpecification::allows_size() const {
  return _internal_allows_size();
}
inline void CollisionSpecification::clear_allows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allows_.Clear();
}
inline ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* CollisionSpecification::mutable_allows(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.CollisionSpecification.allows)
  return _internal_mutable_allows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions>* CollisionSpecification::mutable_allows()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.CollisionSpecification.allows)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_allows();
}
inline const ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions& CollisionSpecification::allows(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.CollisionSpecification.allows)
  return _internal_allows().Get(index);
}
inline ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* CollisionSpecification::add_allows() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* _add = _internal_mutable_allows()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.CollisionSpecification.allows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions>& CollisionSpecification::allows() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.CollisionSpecification.allows)
  return _internal_allows();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions>&
CollisionSpecification::_internal_allows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allows_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions>*
CollisionSpecification::_internal_mutable_allows() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.allows_;
}

// -------------------------------------------------------------------

// PlanWithStatus

// .viam.service.motion.v1.Plan plan = 1 [json_name = "plan"];
inline bool PlanWithStatus::has_plan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plan_ != nullptr);
  return value;
}
inline void PlanWithStatus::clear_plan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.plan_ != nullptr) _impl_.plan_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::service::motion::v1::Plan& PlanWithStatus::_internal_plan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::service::motion::v1::Plan* p = _impl_.plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::Plan&>(::viam::service::motion::v1::_Plan_default_instance_);
}
inline const ::viam::service::motion::v1::Plan& PlanWithStatus::plan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanWithStatus.plan)
  return _internal_plan();
}
inline void PlanWithStatus::unsafe_arena_set_allocated_plan(::viam::service::motion::v1::Plan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.plan_);
  }
  _impl_.plan_ = reinterpret_cast<::viam::service::motion::v1::Plan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanWithStatus.plan)
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::release_plan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::Plan* released = _impl_.plan_;
  _impl_.plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::unsafe_arena_release_plan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanWithStatus.plan)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::Plan* temp = _impl_.plan_;
  _impl_.plan_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::_internal_mutable_plan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::Plan>(GetArena());
    _impl_.plan_ = reinterpret_cast<::viam::service::motion::v1::Plan*>(p);
  }
  return _impl_.plan_;
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::mutable_plan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::service::motion::v1::Plan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanWithStatus.plan)
  return _msg;
}
inline void PlanWithStatus::set_allocated_plan(::viam::service::motion::v1::Plan* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::service::motion::v1::Plan*>(_impl_.plan_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::service::motion::v1::Plan*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.plan_ = reinterpret_cast<::viam::service::motion::v1::Plan*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanWithStatus.plan)
}

// .viam.service.motion.v1.PlanStatus status = 2 [json_name = "status"];
inline bool PlanWithStatus::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void PlanWithStatus::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::service::motion::v1::PlanStatus& PlanWithStatus::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::service::motion::v1::PlanStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::PlanStatus&>(::viam::service::motion::v1::_PlanStatus_default_instance_);
}
inline const ::viam::service::motion::v1::PlanStatus& PlanWithStatus::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanWithStatus.status)
  return _internal_status();
}
inline void PlanWithStatus::unsafe_arena_set_allocated_status(::viam::service::motion::v1::PlanStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanWithStatus.status)
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::service::motion::v1::PlanStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanWithStatus.status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::service::motion::v1::PlanStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::PlanStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(p);
  }
  return _impl_.status_;
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::service::motion::v1::PlanStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanWithStatus.status)
  return _msg;
}
inline void PlanWithStatus::set_allocated_status(::viam::service::motion::v1::PlanStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.status_ = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanWithStatus.status)
}

// repeated .viam.service.motion.v1.PlanStatus status_history = 3 [json_name = "statusHistory"];
inline int PlanWithStatus::_internal_status_history_size() const {
  return _internal_status_history().size();
}
inline int PlanWithStatus::status_history_size() const {
  return _internal_status_history_size();
}
inline void PlanWithStatus::clear_status_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_history_.Clear();
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::mutable_status_history(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanWithStatus.status_history)
  return _internal_mutable_status_history()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatus>* PlanWithStatus::mutable_status_history()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.PlanWithStatus.status_history)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_status_history();
}
inline const ::viam::service::motion::v1::PlanStatus& PlanWithStatus::status_history(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanWithStatus.status_history)
  return _internal_status_history().Get(index);
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::add_status_history() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::PlanStatus* _add = _internal_mutable_status_history()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.PlanWithStatus.status_history)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatus>& PlanWithStatus::status_history() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.PlanWithStatus.status_history)
  return _internal_status_history();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatus>&
PlanWithStatus::_internal_status_history() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_history_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStatus>*
PlanWithStatus::_internal_mutable_status_history() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.status_history_;
}

// -------------------------------------------------------------------

// PlanStatusWithID

// string plan_id = 1 [json_name = "planId"];
inline void PlanStatusWithID::clear_plan_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.plan_id_.ClearToEmpty();
}
inline const std::string& PlanStatusWithID::plan_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.plan_id)
  return _internal_plan_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlanStatusWithID::set_plan_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.plan_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatusWithID.plan_id)
}
inline std::string* PlanStatusWithID::mutable_plan_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_plan_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.plan_id)
  return _s;
}
inline const std::string& PlanStatusWithID::_internal_plan_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.plan_id_.Get();
}
inline void PlanStatusWithID::_internal_set_plan_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.plan_id_.Set(value, GetArena());
}
inline std::string* PlanStatusWithID::_internal_mutable_plan_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.plan_id_.Mutable( GetArena());
}
inline std::string* PlanStatusWithID::release_plan_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.plan_id)
  return _impl_.plan_id_.Release();
}
inline void PlanStatusWithID::set_allocated_plan_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.plan_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.plan_id_.IsDefault()) {
          _impl_.plan_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.plan_id)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool PlanStatusWithID::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& PlanStatusWithID::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& PlanStatusWithID::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.component_name)
  return _internal_component_name();
}
inline void PlanStatusWithID::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanStatusWithID.component_name)
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.component_name)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.component_name)
  return _msg;
}
inline void PlanStatusWithID::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.component_name)
}

// string execution_id = 3 [json_name = "executionId"];
inline void PlanStatusWithID::clear_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& PlanStatusWithID::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlanStatusWithID::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatusWithID.execution_id)
}
inline std::string* PlanStatusWithID::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.execution_id)
  return _s;
}
inline const std::string& PlanStatusWithID::_internal_execution_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.execution_id_.Get();
}
inline void PlanStatusWithID::_internal_set_execution_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* PlanStatusWithID::_internal_mutable_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* PlanStatusWithID::release_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.execution_id)
  return _impl_.execution_id_.Release();
}
inline void PlanStatusWithID::set_allocated_execution_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_id_.IsDefault()) {
          _impl_.execution_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.execution_id)
}

// .viam.service.motion.v1.PlanStatus status = 4 [json_name = "status"];
inline bool PlanStatusWithID::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void PlanStatusWithID::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::service::motion::v1::PlanStatus& PlanStatusWithID::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::service::motion::v1::PlanStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::PlanStatus&>(::viam::service::motion::v1::_PlanStatus_default_instance_);
}
inline const ::viam::service::motion::v1::PlanStatus& PlanStatusWithID::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.status)
  return _internal_status();
}
inline void PlanStatusWithID::unsafe_arena_set_allocated_status(::viam::service::motion::v1::PlanStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanStatusWithID.status)
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::service::motion::v1::PlanStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::service::motion::v1::PlanStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::PlanStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(p);
  }
  return _impl_.status_;
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::service::motion::v1::PlanStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.status)
  return _msg;
}
inline void PlanStatusWithID::set_allocated_status(::viam::service::motion::v1::PlanStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.status_ = reinterpret_cast<::viam::service::motion::v1::PlanStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.status)
}

// -------------------------------------------------------------------

// PlanStatus

// .viam.service.motion.v1.PlanState state = 1 [json_name = "state"];
inline void PlanStatus::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::viam::service::motion::v1::PlanState PlanStatus::state() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatus.state)
  return _internal_state();
}
inline void PlanStatus::set_state(::viam::service::motion::v1::PlanState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatus.state)
}
inline ::viam::service::motion::v1::PlanState PlanStatus::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::viam::service::motion::v1::PlanState>(_impl_.state_);
}
inline void PlanStatus::_internal_set_state(::viam::service::motion::v1::PlanState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
inline bool PlanStatus::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& PlanStatus::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& PlanStatus::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatus.timestamp)
  return _internal_timestamp();
}
inline void PlanStatus::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanStatus.timestamp)
}
inline ::google::protobuf::Timestamp* PlanStatus::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* PlanStatus::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatus.timestamp)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PlanStatus::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* PlanStatus::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatus.timestamp)
  return _msg;
}
inline void PlanStatus::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatus.timestamp)
}

// optional string reason = 3 [json_name = "reason"];
inline bool PlanStatus::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PlanStatus::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlanStatus::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatus.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlanStatus::set_reason(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatus.reason)
}
inline std::string* PlanStatus::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatus.reason)
  return _s;
}
inline const std::string& PlanStatus::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reason_.Get();
}
inline void PlanStatus::_internal_set_reason(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* PlanStatus::_internal_mutable_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* PlanStatus::release_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatus.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PlanStatus::set_allocated_reason(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatus.reason)
}

// -------------------------------------------------------------------

// Plan

// string id = 1 [json_name = "id"];
inline void Plan::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Plan::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Plan::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.Plan.id)
}
inline std::string* Plan::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.id)
  return _s;
}
inline const std::string& Plan::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Plan::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Plan::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Plan::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.Plan.id)
  return _impl_.id_.Release();
}
inline void Plan::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.Plan.id)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool Plan::has_component_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_name_ != nullptr);
  return value;
}
inline const ::viam::common::v1::ResourceName& Plan::_internal_component_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::ResourceName* p = _impl_.component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& Plan::component_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.component_name)
  return _internal_component_name();
}
inline void Plan::unsafe_arena_set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }
  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.Plan.component_name)
}
inline ::viam::common::v1::ResourceName* Plan::release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* released = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::ResourceName* Plan::unsafe_arena_release_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.Plan.component_name)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::ResourceName* temp = _impl_.component_name_;
  _impl_.component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* Plan::_internal_mutable_component_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArena());
    _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(p);
  }
  return _impl_.component_name_;
}
inline ::viam::common::v1::ResourceName* Plan::mutable_component_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.component_name)
  return _msg;
}
inline void Plan::set_allocated_component_name(::viam::common::v1::ResourceName* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.component_name_ = reinterpret_cast<::viam::common::v1::ResourceName*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.Plan.component_name)
}

// string execution_id = 3 [json_name = "executionId"];
inline void Plan::clear_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& Plan::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Plan::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.Plan.execution_id)
}
inline std::string* Plan::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.execution_id)
  return _s;
}
inline const std::string& Plan::_internal_execution_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.execution_id_.Get();
}
inline void Plan::_internal_set_execution_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* Plan::_internal_mutable_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* Plan::release_execution_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.Plan.execution_id)
  return _impl_.execution_id_.Release();
}
inline void Plan::set_allocated_execution_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_id_.IsDefault()) {
          _impl_.execution_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.Plan.execution_id)
}

// repeated .viam.service.motion.v1.PlanStep steps = 4 [json_name = "steps"];
inline int Plan::_internal_steps_size() const {
  return _internal_steps().size();
}
inline int Plan::steps_size() const {
  return _internal_steps_size();
}
inline void Plan::clear_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.steps_.Clear();
}
inline ::viam::service::motion::v1::PlanStep* Plan::mutable_steps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.steps)
  return _internal_mutable_steps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStep>* Plan::mutable_steps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Plan.steps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_steps();
}
inline const ::viam::service::motion::v1::PlanStep& Plan::steps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.steps)
  return _internal_steps().Get(index);
}
inline ::viam::service::motion::v1::PlanStep* Plan::add_steps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::service::motion::v1::PlanStep* _add = _internal_mutable_steps()->Add();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Plan.steps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStep>& Plan::steps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Plan.steps)
  return _internal_steps();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStep>&
Plan::_internal_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steps_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::service::motion::v1::PlanStep>*
Plan::_internal_mutable_steps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.steps_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PlanStep

// map<string, .viam.service.motion.v1.ComponentState> step = 1 [json_name = "step"];
inline int PlanStep::_internal_step_size() const {
  return _internal_step().size();
}
inline int PlanStep::step_size() const {
  return _internal_step_size();
}
inline void PlanStep::clear_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.step_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>& PlanStep::_internal_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.step_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>& PlanStep::step() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:viam.service.motion.v1.PlanStep.step)
  return _internal_step();
}
inline ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>* PlanStep::_internal_mutable_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.step_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::viam::service::motion::v1::ComponentState>* PlanStep::mutable_step() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:viam.service.motion.v1.PlanStep.step)
  return _internal_mutable_step();
}

// -------------------------------------------------------------------

// ComponentState

// .viam.common.v1.Pose pose = 1 [json_name = "pose"];
inline bool ComponentState::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline const ::viam::common::v1::Pose& ComponentState::_internal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::Pose&>(::viam::common::v1::_Pose_default_instance_);
}
inline const ::viam::common::v1::Pose& ComponentState::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ComponentState.pose)
  return _internal_pose();
}
inline void ComponentState::unsafe_arena_set_allocated_pose(::viam::common::v1::Pose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::viam::common::v1::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ComponentState.pose)
}
inline ::viam::common::v1::Pose* ComponentState::release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::Pose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::Pose* ComponentState::unsafe_arena_release_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ComponentState.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::viam::common::v1::Pose* ComponentState::_internal_mutable_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::Pose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::viam::common::v1::Pose*>(p);
  }
  return _impl_.pose_;
}
inline ::viam::common::v1::Pose* ComponentState::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ComponentState.pose)
  return _msg;
}
inline void ComponentState::set_allocated_pose(::viam::common::v1::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::viam::common::v1::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ComponentState.pose)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace motion
}  // namespace service
}  // namespace viam


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::viam::service::motion::v1::PlanState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::viam::service::motion::v1::PlanState>() {
  return ::viam::service::motion::v1::PlanState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_service_2fmotion_2fv1_2fmotion_2eproto_2epb_2eh
