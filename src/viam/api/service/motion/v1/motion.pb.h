// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service/motion/v1/motion.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2fmotion_2fv1_2fmotion_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_2fmotion_2fv1_2fmotion_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/common.pb.h"
#include "google/api/annotations.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_2fmotion_2fv1_2fmotion_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2fmotion_2fv1_2fmotion_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_service_2fmotion_2fv1_2fmotion_2eproto;
namespace viam {
namespace service {
namespace motion {
namespace v1 {
class CollisionSpecification;
struct CollisionSpecificationDefaultTypeInternal;
extern CollisionSpecificationDefaultTypeInternal _CollisionSpecification_default_instance_;
class CollisionSpecification_AllowedFrameCollisions;
struct CollisionSpecification_AllowedFrameCollisionsDefaultTypeInternal;
extern CollisionSpecification_AllowedFrameCollisionsDefaultTypeInternal _CollisionSpecification_AllowedFrameCollisions_default_instance_;
class ComponentState;
struct ComponentStateDefaultTypeInternal;
extern ComponentStateDefaultTypeInternal _ComponentState_default_instance_;
class Constraints;
struct ConstraintsDefaultTypeInternal;
extern ConstraintsDefaultTypeInternal _Constraints_default_instance_;
class GetPlanRequest;
struct GetPlanRequestDefaultTypeInternal;
extern GetPlanRequestDefaultTypeInternal _GetPlanRequest_default_instance_;
class GetPlanResponse;
struct GetPlanResponseDefaultTypeInternal;
extern GetPlanResponseDefaultTypeInternal _GetPlanResponse_default_instance_;
class GetPoseRequest;
struct GetPoseRequestDefaultTypeInternal;
extern GetPoseRequestDefaultTypeInternal _GetPoseRequest_default_instance_;
class GetPoseResponse;
struct GetPoseResponseDefaultTypeInternal;
extern GetPoseResponseDefaultTypeInternal _GetPoseResponse_default_instance_;
class LinearConstraint;
struct LinearConstraintDefaultTypeInternal;
extern LinearConstraintDefaultTypeInternal _LinearConstraint_default_instance_;
class ListPlanStatusesRequest;
struct ListPlanStatusesRequestDefaultTypeInternal;
extern ListPlanStatusesRequestDefaultTypeInternal _ListPlanStatusesRequest_default_instance_;
class ListPlanStatusesResponse;
struct ListPlanStatusesResponseDefaultTypeInternal;
extern ListPlanStatusesResponseDefaultTypeInternal _ListPlanStatusesResponse_default_instance_;
class MotionConfiguration;
struct MotionConfigurationDefaultTypeInternal;
extern MotionConfigurationDefaultTypeInternal _MotionConfiguration_default_instance_;
class MoveOnGlobeRequest;
struct MoveOnGlobeRequestDefaultTypeInternal;
extern MoveOnGlobeRequestDefaultTypeInternal _MoveOnGlobeRequest_default_instance_;
class MoveOnGlobeResponse;
struct MoveOnGlobeResponseDefaultTypeInternal;
extern MoveOnGlobeResponseDefaultTypeInternal _MoveOnGlobeResponse_default_instance_;
class MoveOnMapRequest;
struct MoveOnMapRequestDefaultTypeInternal;
extern MoveOnMapRequestDefaultTypeInternal _MoveOnMapRequest_default_instance_;
class MoveOnMapResponse;
struct MoveOnMapResponseDefaultTypeInternal;
extern MoveOnMapResponseDefaultTypeInternal _MoveOnMapResponse_default_instance_;
class MoveRequest;
struct MoveRequestDefaultTypeInternal;
extern MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
class MoveResponse;
struct MoveResponseDefaultTypeInternal;
extern MoveResponseDefaultTypeInternal _MoveResponse_default_instance_;
class ObstacleDetector;
struct ObstacleDetectorDefaultTypeInternal;
extern ObstacleDetectorDefaultTypeInternal _ObstacleDetector_default_instance_;
class OrientationConstraint;
struct OrientationConstraintDefaultTypeInternal;
extern OrientationConstraintDefaultTypeInternal _OrientationConstraint_default_instance_;
class Plan;
struct PlanDefaultTypeInternal;
extern PlanDefaultTypeInternal _Plan_default_instance_;
class PlanStatus;
struct PlanStatusDefaultTypeInternal;
extern PlanStatusDefaultTypeInternal _PlanStatus_default_instance_;
class PlanStatusWithID;
struct PlanStatusWithIDDefaultTypeInternal;
extern PlanStatusWithIDDefaultTypeInternal _PlanStatusWithID_default_instance_;
class PlanStep;
struct PlanStepDefaultTypeInternal;
extern PlanStepDefaultTypeInternal _PlanStep_default_instance_;
class PlanStep_StepEntry_DoNotUse;
struct PlanStep_StepEntry_DoNotUseDefaultTypeInternal;
extern PlanStep_StepEntry_DoNotUseDefaultTypeInternal _PlanStep_StepEntry_DoNotUse_default_instance_;
class PlanWithStatus;
struct PlanWithStatusDefaultTypeInternal;
extern PlanWithStatusDefaultTypeInternal _PlanWithStatus_default_instance_;
class StopPlanRequest;
struct StopPlanRequestDefaultTypeInternal;
extern StopPlanRequestDefaultTypeInternal _StopPlanRequest_default_instance_;
class StopPlanResponse;
struct StopPlanResponseDefaultTypeInternal;
extern StopPlanResponseDefaultTypeInternal _StopPlanResponse_default_instance_;
}  // namespace v1
}  // namespace motion
}  // namespace service
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::service::motion::v1::CollisionSpecification* Arena::CreateMaybeMessage<::viam::service::motion::v1::CollisionSpecification>(Arena*);
template<> ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* Arena::CreateMaybeMessage<::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions>(Arena*);
template<> ::viam::service::motion::v1::ComponentState* Arena::CreateMaybeMessage<::viam::service::motion::v1::ComponentState>(Arena*);
template<> ::viam::service::motion::v1::Constraints* Arena::CreateMaybeMessage<::viam::service::motion::v1::Constraints>(Arena*);
template<> ::viam::service::motion::v1::GetPlanRequest* Arena::CreateMaybeMessage<::viam::service::motion::v1::GetPlanRequest>(Arena*);
template<> ::viam::service::motion::v1::GetPlanResponse* Arena::CreateMaybeMessage<::viam::service::motion::v1::GetPlanResponse>(Arena*);
template<> ::viam::service::motion::v1::GetPoseRequest* Arena::CreateMaybeMessage<::viam::service::motion::v1::GetPoseRequest>(Arena*);
template<> ::viam::service::motion::v1::GetPoseResponse* Arena::CreateMaybeMessage<::viam::service::motion::v1::GetPoseResponse>(Arena*);
template<> ::viam::service::motion::v1::LinearConstraint* Arena::CreateMaybeMessage<::viam::service::motion::v1::LinearConstraint>(Arena*);
template<> ::viam::service::motion::v1::ListPlanStatusesRequest* Arena::CreateMaybeMessage<::viam::service::motion::v1::ListPlanStatusesRequest>(Arena*);
template<> ::viam::service::motion::v1::ListPlanStatusesResponse* Arena::CreateMaybeMessage<::viam::service::motion::v1::ListPlanStatusesResponse>(Arena*);
template<> ::viam::service::motion::v1::MotionConfiguration* Arena::CreateMaybeMessage<::viam::service::motion::v1::MotionConfiguration>(Arena*);
template<> ::viam::service::motion::v1::MoveOnGlobeRequest* Arena::CreateMaybeMessage<::viam::service::motion::v1::MoveOnGlobeRequest>(Arena*);
template<> ::viam::service::motion::v1::MoveOnGlobeResponse* Arena::CreateMaybeMessage<::viam::service::motion::v1::MoveOnGlobeResponse>(Arena*);
template<> ::viam::service::motion::v1::MoveOnMapRequest* Arena::CreateMaybeMessage<::viam::service::motion::v1::MoveOnMapRequest>(Arena*);
template<> ::viam::service::motion::v1::MoveOnMapResponse* Arena::CreateMaybeMessage<::viam::service::motion::v1::MoveOnMapResponse>(Arena*);
template<> ::viam::service::motion::v1::MoveRequest* Arena::CreateMaybeMessage<::viam::service::motion::v1::MoveRequest>(Arena*);
template<> ::viam::service::motion::v1::MoveResponse* Arena::CreateMaybeMessage<::viam::service::motion::v1::MoveResponse>(Arena*);
template<> ::viam::service::motion::v1::ObstacleDetector* Arena::CreateMaybeMessage<::viam::service::motion::v1::ObstacleDetector>(Arena*);
template<> ::viam::service::motion::v1::OrientationConstraint* Arena::CreateMaybeMessage<::viam::service::motion::v1::OrientationConstraint>(Arena*);
template<> ::viam::service::motion::v1::Plan* Arena::CreateMaybeMessage<::viam::service::motion::v1::Plan>(Arena*);
template<> ::viam::service::motion::v1::PlanStatus* Arena::CreateMaybeMessage<::viam::service::motion::v1::PlanStatus>(Arena*);
template<> ::viam::service::motion::v1::PlanStatusWithID* Arena::CreateMaybeMessage<::viam::service::motion::v1::PlanStatusWithID>(Arena*);
template<> ::viam::service::motion::v1::PlanStep* Arena::CreateMaybeMessage<::viam::service::motion::v1::PlanStep>(Arena*);
template<> ::viam::service::motion::v1::PlanStep_StepEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::service::motion::v1::PlanStep_StepEntry_DoNotUse>(Arena*);
template<> ::viam::service::motion::v1::PlanWithStatus* Arena::CreateMaybeMessage<::viam::service::motion::v1::PlanWithStatus>(Arena*);
template<> ::viam::service::motion::v1::StopPlanRequest* Arena::CreateMaybeMessage<::viam::service::motion::v1::StopPlanRequest>(Arena*);
template<> ::viam::service::motion::v1::StopPlanResponse* Arena::CreateMaybeMessage<::viam::service::motion::v1::StopPlanResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace service {
namespace motion {
namespace v1 {

enum PlanState : int {
  PLAN_STATE_UNSPECIFIED = 0,
  PLAN_STATE_IN_PROGRESS = 1,
  PLAN_STATE_STOPPED = 2,
  PLAN_STATE_SUCCEEDED = 3,
  PLAN_STATE_FAILED = 4,
  PlanState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlanState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlanState_IsValid(int value);
constexpr PlanState PlanState_MIN = PLAN_STATE_UNSPECIFIED;
constexpr PlanState PlanState_MAX = PLAN_STATE_FAILED;
constexpr int PlanState_ARRAYSIZE = PlanState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlanState_descriptor();
template<typename T>
inline const std::string& PlanState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlanState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlanState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlanState_descriptor(), enum_t_value);
}
inline bool PlanState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlanState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlanState>(
    PlanState_descriptor(), name, value);
}
// ===================================================================

class MoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveRequest) */ {
 public:
  inline MoveRequest() : MoveRequest(nullptr) {}
  ~MoveRequest() override;
  explicit PROTOBUF_CONSTEXPR MoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveRequest(const MoveRequest& from);
  MoveRequest(MoveRequest&& from) noexcept
    : MoveRequest() {
    *this = ::std::move(from);
  }

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveRequest& operator=(MoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveRequest* internal_default_instance() {
    return reinterpret_cast<const MoveRequest*>(
               &_MoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MoveRequest& a, MoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.MoveRequest";
  }
  protected:
  explicit MoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kComponentNameFieldNumber = 3,
    kWorldStateFieldNumber = 4,
    kConstraintsFieldNumber = 5,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .viam.common.v1.PoseInFrame destination = 2 [json_name = "destination"];
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::viam::common::v1::PoseInFrame& destination() const;
  PROTOBUF_NODISCARD ::viam::common::v1::PoseInFrame* release_destination();
  ::viam::common::v1::PoseInFrame* mutable_destination();
  void set_allocated_destination(::viam::common::v1::PoseInFrame* destination);
  private:
  const ::viam::common::v1::PoseInFrame& _internal_destination() const;
  ::viam::common::v1::PoseInFrame* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::viam::common::v1::PoseInFrame* destination);
  ::viam::common::v1::PoseInFrame* unsafe_arena_release_destination();

  // .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // optional .viam.common.v1.WorldState world_state = 4 [json_name = "worldState"];
  bool has_world_state() const;
  private:
  bool _internal_has_world_state() const;
  public:
  void clear_world_state();
  const ::viam::common::v1::WorldState& world_state() const;
  PROTOBUF_NODISCARD ::viam::common::v1::WorldState* release_world_state();
  ::viam::common::v1::WorldState* mutable_world_state();
  void set_allocated_world_state(::viam::common::v1::WorldState* world_state);
  private:
  const ::viam::common::v1::WorldState& _internal_world_state() const;
  ::viam::common::v1::WorldState* _internal_mutable_world_state();
  public:
  void unsafe_arena_set_allocated_world_state(
      ::viam::common::v1::WorldState* world_state);
  ::viam::common::v1::WorldState* unsafe_arena_release_world_state();

  // optional .viam.service.motion.v1.Constraints constraints = 5 [json_name = "constraints"];
  bool has_constraints() const;
  private:
  bool _internal_has_constraints() const;
  public:
  void clear_constraints();
  const ::viam::service::motion::v1::Constraints& constraints() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::Constraints* release_constraints();
  ::viam::service::motion::v1::Constraints* mutable_constraints();
  void set_allocated_constraints(::viam::service::motion::v1::Constraints* constraints);
  private:
  const ::viam::service::motion::v1::Constraints& _internal_constraints() const;
  ::viam::service::motion::v1::Constraints* _internal_mutable_constraints();
  public:
  void unsafe_arena_set_allocated_constraints(
      ::viam::service::motion::v1::Constraints* constraints);
  ::viam::service::motion::v1::Constraints* unsafe_arena_release_constraints();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::viam::common::v1::PoseInFrame* destination_;
  ::viam::common::v1::ResourceName* component_name_;
  ::viam::common::v1::WorldState* world_state_;
  ::viam::service::motion::v1::Constraints* constraints_;
  ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class MoveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveResponse) */ {
 public:
  inline MoveResponse() : MoveResponse(nullptr) {}
  ~MoveResponse() override;
  explicit PROTOBUF_CONSTEXPR MoveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveResponse(const MoveResponse& from);
  MoveResponse(MoveResponse&& from) noexcept
    : MoveResponse() {
    *this = ::std::move(from);
  }

  inline MoveResponse& operator=(const MoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveResponse& operator=(MoveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveResponse* internal_default_instance() {
    return reinterpret_cast<const MoveResponse*>(
               &_MoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MoveResponse& a, MoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.MoveResponse";
  }
  protected:
  explicit MoveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class MoveOnMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnMapRequest) */ {
 public:
  inline MoveOnMapRequest() : MoveOnMapRequest(nullptr) {}
  ~MoveOnMapRequest() override;
  explicit PROTOBUF_CONSTEXPR MoveOnMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveOnMapRequest(const MoveOnMapRequest& from);
  MoveOnMapRequest(MoveOnMapRequest&& from) noexcept
    : MoveOnMapRequest() {
    *this = ::std::move(from);
  }

  inline MoveOnMapRequest& operator=(const MoveOnMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnMapRequest& operator=(MoveOnMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnMapRequest* internal_default_instance() {
    return reinterpret_cast<const MoveOnMapRequest*>(
               &_MoveOnMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MoveOnMapRequest& a, MoveOnMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveOnMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveOnMapRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveOnMapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.MoveOnMapRequest";
  }
  protected:
  explicit MoveOnMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstaclesFieldNumber = 6,
    kNameFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kComponentNameFieldNumber = 3,
    kSlamServiceNameFieldNumber = 4,
    kMotionConfigurationFieldNumber = 5,
    kExtraFieldNumber = 99,
  };
  // repeated .viam.common.v1.Geometry obstacles = 6 [json_name = "obstacles"];
  int obstacles_size() const;
  private:
  int _internal_obstacles_size() const;
  public:
  void clear_obstacles();
  ::viam::common::v1::Geometry* mutable_obstacles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Geometry >*
      mutable_obstacles();
  private:
  const ::viam::common::v1::Geometry& _internal_obstacles(int index) const;
  ::viam::common::v1::Geometry* _internal_add_obstacles();
  public:
  const ::viam::common::v1::Geometry& obstacles(int index) const;
  ::viam::common::v1::Geometry* add_obstacles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Geometry >&
      obstacles() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .viam.common.v1.Pose destination = 2 [json_name = "destination"];
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::viam::common::v1::Pose& destination() const;
  PROTOBUF_NODISCARD ::viam::common::v1::Pose* release_destination();
  ::viam::common::v1::Pose* mutable_destination();
  void set_allocated_destination(::viam::common::v1::Pose* destination);
  private:
  const ::viam::common::v1::Pose& _internal_destination() const;
  ::viam::common::v1::Pose* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::viam::common::v1::Pose* destination);
  ::viam::common::v1::Pose* unsafe_arena_release_destination();

  // .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // .viam.common.v1.ResourceName slam_service_name = 4 [json_name = "slamServiceName"];
  bool has_slam_service_name() const;
  private:
  bool _internal_has_slam_service_name() const;
  public:
  void clear_slam_service_name();
  const ::viam::common::v1::ResourceName& slam_service_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_slam_service_name();
  ::viam::common::v1::ResourceName* mutable_slam_service_name();
  void set_allocated_slam_service_name(::viam::common::v1::ResourceName* slam_service_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_slam_service_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_slam_service_name();
  public:
  void unsafe_arena_set_allocated_slam_service_name(
      ::viam::common::v1::ResourceName* slam_service_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_slam_service_name();

  // optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 5 [json_name = "motionConfiguration"];
  bool has_motion_configuration() const;
  private:
  bool _internal_has_motion_configuration() const;
  public:
  void clear_motion_configuration();
  const ::viam::service::motion::v1::MotionConfiguration& motion_configuration() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::MotionConfiguration* release_motion_configuration();
  ::viam::service::motion::v1::MotionConfiguration* mutable_motion_configuration();
  void set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* motion_configuration);
  private:
  const ::viam::service::motion::v1::MotionConfiguration& _internal_motion_configuration() const;
  ::viam::service::motion::v1::MotionConfiguration* _internal_mutable_motion_configuration();
  public:
  void unsafe_arena_set_allocated_motion_configuration(
      ::viam::service::motion::v1::MotionConfiguration* motion_configuration);
  ::viam::service::motion::v1::MotionConfiguration* unsafe_arena_release_motion_configuration();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Geometry > obstacles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::viam::common::v1::Pose* destination_;
  ::viam::common::v1::ResourceName* component_name_;
  ::viam::common::v1::ResourceName* slam_service_name_;
  ::viam::service::motion::v1::MotionConfiguration* motion_configuration_;
  ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class MoveOnMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnMapResponse) */ {
 public:
  inline MoveOnMapResponse() : MoveOnMapResponse(nullptr) {}
  ~MoveOnMapResponse() override;
  explicit PROTOBUF_CONSTEXPR MoveOnMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveOnMapResponse(const MoveOnMapResponse& from);
  MoveOnMapResponse(MoveOnMapResponse&& from) noexcept
    : MoveOnMapResponse() {
    *this = ::std::move(from);
  }

  inline MoveOnMapResponse& operator=(const MoveOnMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnMapResponse& operator=(MoveOnMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnMapResponse* internal_default_instance() {
    return reinterpret_cast<const MoveOnMapResponse*>(
               &_MoveOnMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MoveOnMapResponse& a, MoveOnMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveOnMapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveOnMapResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveOnMapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.MoveOnMapResponse";
  }
  protected:
  explicit MoveOnMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionIdFieldNumber = 1,
  };
  // string execution_id = 1 [json_name = "executionId"];
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class ObstacleDetector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ObstacleDetector) */ {
 public:
  inline ObstacleDetector() : ObstacleDetector(nullptr) {}
  ~ObstacleDetector() override;
  explicit PROTOBUF_CONSTEXPR ObstacleDetector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleDetector(const ObstacleDetector& from);
  ObstacleDetector(ObstacleDetector&& from) noexcept
    : ObstacleDetector() {
    *this = ::std::move(from);
  }

  inline ObstacleDetector& operator=(const ObstacleDetector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleDetector& operator=(ObstacleDetector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleDetector& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleDetector* internal_default_instance() {
    return reinterpret_cast<const ObstacleDetector*>(
               &_ObstacleDetector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ObstacleDetector& a, ObstacleDetector& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleDetector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleDetector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleDetector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleDetector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleDetector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleDetector& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleDetector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.ObstacleDetector";
  }
  protected:
  explicit ObstacleDetector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisionServiceFieldNumber = 1,
    kCameraFieldNumber = 2,
  };
  // .viam.common.v1.ResourceName vision_service = 1 [json_name = "visionService"];
  bool has_vision_service() const;
  private:
  bool _internal_has_vision_service() const;
  public:
  void clear_vision_service();
  const ::viam::common::v1::ResourceName& vision_service() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_vision_service();
  ::viam::common::v1::ResourceName* mutable_vision_service();
  void set_allocated_vision_service(::viam::common::v1::ResourceName* vision_service);
  private:
  const ::viam::common::v1::ResourceName& _internal_vision_service() const;
  ::viam::common::v1::ResourceName* _internal_mutable_vision_service();
  public:
  void unsafe_arena_set_allocated_vision_service(
      ::viam::common::v1::ResourceName* vision_service);
  ::viam::common::v1::ResourceName* unsafe_arena_release_vision_service();

  // .viam.common.v1.ResourceName camera = 2 [json_name = "camera"];
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::viam::common::v1::ResourceName& camera() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_camera();
  ::viam::common::v1::ResourceName* mutable_camera();
  void set_allocated_camera(::viam::common::v1::ResourceName* camera);
  private:
  const ::viam::common::v1::ResourceName& _internal_camera() const;
  ::viam::common::v1::ResourceName* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::viam::common::v1::ResourceName* camera);
  ::viam::common::v1::ResourceName* unsafe_arena_release_camera();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ObstacleDetector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::common::v1::ResourceName* vision_service_;
  ::viam::common::v1::ResourceName* camera_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class MotionConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MotionConfiguration) */ {
 public:
  inline MotionConfiguration() : MotionConfiguration(nullptr) {}
  ~MotionConfiguration() override;
  explicit PROTOBUF_CONSTEXPR MotionConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionConfiguration(const MotionConfiguration& from);
  MotionConfiguration(MotionConfiguration&& from) noexcept
    : MotionConfiguration() {
    *this = ::std::move(from);
  }

  inline MotionConfiguration& operator=(const MotionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionConfiguration& operator=(MotionConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionConfiguration* internal_default_instance() {
    return reinterpret_cast<const MotionConfiguration*>(
               &_MotionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MotionConfiguration& a, MotionConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotionConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotionConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotionConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotionConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.MotionConfiguration";
  }
  protected:
  explicit MotionConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleDetectorsFieldNumber = 1,
    kPositionPollingFrequencyHzFieldNumber = 2,
    kObstaclePollingFrequencyHzFieldNumber = 3,
    kPlanDeviationMFieldNumber = 4,
    kLinearMPerSecFieldNumber = 5,
    kAngularDegsPerSecFieldNumber = 6,
  };
  // repeated .viam.service.motion.v1.ObstacleDetector obstacle_detectors = 1 [json_name = "obstacleDetectors"];
  int obstacle_detectors_size() const;
  private:
  int _internal_obstacle_detectors_size() const;
  public:
  void clear_obstacle_detectors();
  ::viam::service::motion::v1::ObstacleDetector* mutable_obstacle_detectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector >*
      mutable_obstacle_detectors();
  private:
  const ::viam::service::motion::v1::ObstacleDetector& _internal_obstacle_detectors(int index) const;
  ::viam::service::motion::v1::ObstacleDetector* _internal_add_obstacle_detectors();
  public:
  const ::viam::service::motion::v1::ObstacleDetector& obstacle_detectors(int index) const;
  ::viam::service::motion::v1::ObstacleDetector* add_obstacle_detectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector >&
      obstacle_detectors() const;

  // optional double position_polling_frequency_hz = 2 [json_name = "positionPollingFrequencyHz"];
  bool has_position_polling_frequency_hz() const;
  private:
  bool _internal_has_position_polling_frequency_hz() const;
  public:
  void clear_position_polling_frequency_hz();
  double position_polling_frequency_hz() const;
  void set_position_polling_frequency_hz(double value);
  private:
  double _internal_position_polling_frequency_hz() const;
  void _internal_set_position_polling_frequency_hz(double value);
  public:

  // optional double obstacle_polling_frequency_hz = 3 [json_name = "obstaclePollingFrequencyHz"];
  bool has_obstacle_polling_frequency_hz() const;
  private:
  bool _internal_has_obstacle_polling_frequency_hz() const;
  public:
  void clear_obstacle_polling_frequency_hz();
  double obstacle_polling_frequency_hz() const;
  void set_obstacle_polling_frequency_hz(double value);
  private:
  double _internal_obstacle_polling_frequency_hz() const;
  void _internal_set_obstacle_polling_frequency_hz(double value);
  public:

  // optional double plan_deviation_m = 4 [json_name = "planDeviationM"];
  bool has_plan_deviation_m() const;
  private:
  bool _internal_has_plan_deviation_m() const;
  public:
  void clear_plan_deviation_m();
  double plan_deviation_m() const;
  void set_plan_deviation_m(double value);
  private:
  double _internal_plan_deviation_m() const;
  void _internal_set_plan_deviation_m(double value);
  public:

  // optional double linear_m_per_sec = 5 [json_name = "linearMPerSec"];
  bool has_linear_m_per_sec() const;
  private:
  bool _internal_has_linear_m_per_sec() const;
  public:
  void clear_linear_m_per_sec();
  double linear_m_per_sec() const;
  void set_linear_m_per_sec(double value);
  private:
  double _internal_linear_m_per_sec() const;
  void _internal_set_linear_m_per_sec(double value);
  public:

  // optional double angular_degs_per_sec = 6 [json_name = "angularDegsPerSec"];
  bool has_angular_degs_per_sec() const;
  private:
  bool _internal_has_angular_degs_per_sec() const;
  public:
  void clear_angular_degs_per_sec();
  double angular_degs_per_sec() const;
  void set_angular_degs_per_sec(double value);
  private:
  double _internal_angular_degs_per_sec() const;
  void _internal_set_angular_degs_per_sec(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MotionConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector > obstacle_detectors_;
  double position_polling_frequency_hz_;
  double obstacle_polling_frequency_hz_;
  double plan_deviation_m_;
  double linear_m_per_sec_;
  double angular_degs_per_sec_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class MoveOnGlobeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnGlobeRequest) */ {
 public:
  inline MoveOnGlobeRequest() : MoveOnGlobeRequest(nullptr) {}
  ~MoveOnGlobeRequest() override;
  explicit PROTOBUF_CONSTEXPR MoveOnGlobeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveOnGlobeRequest(const MoveOnGlobeRequest& from);
  MoveOnGlobeRequest(MoveOnGlobeRequest&& from) noexcept
    : MoveOnGlobeRequest() {
    *this = ::std::move(from);
  }

  inline MoveOnGlobeRequest& operator=(const MoveOnGlobeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnGlobeRequest& operator=(MoveOnGlobeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnGlobeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnGlobeRequest* internal_default_instance() {
    return reinterpret_cast<const MoveOnGlobeRequest*>(
               &_MoveOnGlobeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MoveOnGlobeRequest& a, MoveOnGlobeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnGlobeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnGlobeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnGlobeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnGlobeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveOnGlobeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveOnGlobeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveOnGlobeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.MoveOnGlobeRequest";
  }
  protected:
  explicit MoveOnGlobeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstaclesFieldNumber = 6,
    kBoundingRegionsFieldNumber = 8,
    kNameFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kComponentNameFieldNumber = 4,
    kMovementSensorNameFieldNumber = 5,
    kMotionConfigurationFieldNumber = 7,
    kExtraFieldNumber = 99,
    kHeadingFieldNumber = 3,
  };
  // repeated .viam.common.v1.GeoGeometry obstacles = 6 [json_name = "obstacles"];
  int obstacles_size() const;
  private:
  int _internal_obstacles_size() const;
  public:
  void clear_obstacles();
  ::viam::common::v1::GeoGeometry* mutable_obstacles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >*
      mutable_obstacles();
  private:
  const ::viam::common::v1::GeoGeometry& _internal_obstacles(int index) const;
  ::viam::common::v1::GeoGeometry* _internal_add_obstacles();
  public:
  const ::viam::common::v1::GeoGeometry& obstacles(int index) const;
  ::viam::common::v1::GeoGeometry* add_obstacles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >&
      obstacles() const;

  // repeated .viam.common.v1.GeoGeometry bounding_regions = 8 [json_name = "boundingRegions"];
  int bounding_regions_size() const;
  private:
  int _internal_bounding_regions_size() const;
  public:
  void clear_bounding_regions();
  ::viam::common::v1::GeoGeometry* mutable_bounding_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >*
      mutable_bounding_regions();
  private:
  const ::viam::common::v1::GeoGeometry& _internal_bounding_regions(int index) const;
  ::viam::common::v1::GeoGeometry* _internal_add_bounding_regions();
  public:
  const ::viam::common::v1::GeoGeometry& bounding_regions(int index) const;
  ::viam::common::v1::GeoGeometry* add_bounding_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >&
      bounding_regions() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .viam.common.v1.GeoPoint destination = 2 [json_name = "destination"];
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::viam::common::v1::GeoPoint& destination() const;
  PROTOBUF_NODISCARD ::viam::common::v1::GeoPoint* release_destination();
  ::viam::common::v1::GeoPoint* mutable_destination();
  void set_allocated_destination(::viam::common::v1::GeoPoint* destination);
  private:
  const ::viam::common::v1::GeoPoint& _internal_destination() const;
  ::viam::common::v1::GeoPoint* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::viam::common::v1::GeoPoint* destination);
  ::viam::common::v1::GeoPoint* unsafe_arena_release_destination();

  // .viam.common.v1.ResourceName component_name = 4 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // .viam.common.v1.ResourceName movement_sensor_name = 5 [json_name = "movementSensorName"];
  bool has_movement_sensor_name() const;
  private:
  bool _internal_has_movement_sensor_name() const;
  public:
  void clear_movement_sensor_name();
  const ::viam::common::v1::ResourceName& movement_sensor_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_movement_sensor_name();
  ::viam::common::v1::ResourceName* mutable_movement_sensor_name();
  void set_allocated_movement_sensor_name(::viam::common::v1::ResourceName* movement_sensor_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_movement_sensor_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_movement_sensor_name();
  public:
  void unsafe_arena_set_allocated_movement_sensor_name(
      ::viam::common::v1::ResourceName* movement_sensor_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_movement_sensor_name();

  // optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 7 [json_name = "motionConfiguration"];
  bool has_motion_configuration() const;
  private:
  bool _internal_has_motion_configuration() const;
  public:
  void clear_motion_configuration();
  const ::viam::service::motion::v1::MotionConfiguration& motion_configuration() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::MotionConfiguration* release_motion_configuration();
  ::viam::service::motion::v1::MotionConfiguration* mutable_motion_configuration();
  void set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* motion_configuration);
  private:
  const ::viam::service::motion::v1::MotionConfiguration& _internal_motion_configuration() const;
  ::viam::service::motion::v1::MotionConfiguration* _internal_mutable_motion_configuration();
  public:
  void unsafe_arena_set_allocated_motion_configuration(
      ::viam::service::motion::v1::MotionConfiguration* motion_configuration);
  ::viam::service::motion::v1::MotionConfiguration* unsafe_arena_release_motion_configuration();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // optional double heading = 3 [json_name = "heading"];
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnGlobeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry > obstacles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry > bounding_regions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::viam::common::v1::GeoPoint* destination_;
  ::viam::common::v1::ResourceName* component_name_;
  ::viam::common::v1::ResourceName* movement_sensor_name_;
  ::viam::service::motion::v1::MotionConfiguration* motion_configuration_;
  ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
  double heading_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class MoveOnGlobeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.MoveOnGlobeResponse) */ {
 public:
  inline MoveOnGlobeResponse() : MoveOnGlobeResponse(nullptr) {}
  ~MoveOnGlobeResponse() override;
  explicit PROTOBUF_CONSTEXPR MoveOnGlobeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveOnGlobeResponse(const MoveOnGlobeResponse& from);
  MoveOnGlobeResponse(MoveOnGlobeResponse&& from) noexcept
    : MoveOnGlobeResponse() {
    *this = ::std::move(from);
  }

  inline MoveOnGlobeResponse& operator=(const MoveOnGlobeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOnGlobeResponse& operator=(MoveOnGlobeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOnGlobeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOnGlobeResponse* internal_default_instance() {
    return reinterpret_cast<const MoveOnGlobeResponse*>(
               &_MoveOnGlobeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MoveOnGlobeResponse& a, MoveOnGlobeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOnGlobeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOnGlobeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOnGlobeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOnGlobeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveOnGlobeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveOnGlobeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveOnGlobeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.MoveOnGlobeResponse";
  }
  protected:
  explicit MoveOnGlobeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionIdFieldNumber = 1,
  };
  // string execution_id = 1 [json_name = "executionId"];
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.MoveOnGlobeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class GetPoseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPoseRequest) */ {
 public:
  inline GetPoseRequest() : GetPoseRequest(nullptr) {}
  ~GetPoseRequest() override;
  explicit PROTOBUF_CONSTEXPR GetPoseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPoseRequest(const GetPoseRequest& from);
  GetPoseRequest(GetPoseRequest&& from) noexcept
    : GetPoseRequest() {
    *this = ::std::move(from);
  }

  inline GetPoseRequest& operator=(const GetPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoseRequest& operator=(GetPoseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPoseRequest* internal_default_instance() {
    return reinterpret_cast<const GetPoseRequest*>(
               &_GetPoseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetPoseRequest& a, GetPoseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPoseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPoseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPoseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPoseRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPoseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.GetPoseRequest";
  }
  protected:
  explicit GetPoseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupplementalTransformsFieldNumber = 4,
    kNameFieldNumber = 1,
    kDestinationFrameFieldNumber = 3,
    kComponentNameFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // repeated .viam.common.v1.Transform supplemental_transforms = 4 [json_name = "supplementalTransforms"];
  int supplemental_transforms_size() const;
  private:
  int _internal_supplemental_transforms_size() const;
  public:
  void clear_supplemental_transforms();
  ::viam::common::v1::Transform* mutable_supplemental_transforms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >*
      mutable_supplemental_transforms();
  private:
  const ::viam::common::v1::Transform& _internal_supplemental_transforms(int index) const;
  ::viam::common::v1::Transform* _internal_add_supplemental_transforms();
  public:
  const ::viam::common::v1::Transform& supplemental_transforms(int index) const;
  ::viam::common::v1::Transform* add_supplemental_transforms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >&
      supplemental_transforms() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string destination_frame = 3 [json_name = "destinationFrame"];
  void clear_destination_frame();
  const std::string& destination_frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_frame();
  PROTOBUF_NODISCARD std::string* release_destination_frame();
  void set_allocated_destination_frame(std::string* destination_frame);
  private:
  const std::string& _internal_destination_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_frame(const std::string& value);
  std::string* _internal_mutable_destination_frame();
  public:

  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPoseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform > supplemental_transforms_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_frame_;
  ::viam::common::v1::ResourceName* component_name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class GetPoseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPoseResponse) */ {
 public:
  inline GetPoseResponse() : GetPoseResponse(nullptr) {}
  ~GetPoseResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPoseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPoseResponse(const GetPoseResponse& from);
  GetPoseResponse(GetPoseResponse&& from) noexcept
    : GetPoseResponse() {
    *this = ::std::move(from);
  }

  inline GetPoseResponse& operator=(const GetPoseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPoseResponse& operator=(GetPoseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPoseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPoseResponse* internal_default_instance() {
    return reinterpret_cast<const GetPoseResponse*>(
               &_GetPoseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetPoseResponse& a, GetPoseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPoseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPoseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPoseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPoseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPoseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPoseResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPoseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.GetPoseResponse";
  }
  protected:
  explicit GetPoseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .viam.common.v1.PoseInFrame pose = 1 [json_name = "pose"];
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::viam::common::v1::PoseInFrame& pose() const;
  PROTOBUF_NODISCARD ::viam::common::v1::PoseInFrame* release_pose();
  ::viam::common::v1::PoseInFrame* mutable_pose();
  void set_allocated_pose(::viam::common::v1::PoseInFrame* pose);
  private:
  const ::viam::common::v1::PoseInFrame& _internal_pose() const;
  ::viam::common::v1::PoseInFrame* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::viam::common::v1::PoseInFrame* pose);
  ::viam::common::v1::PoseInFrame* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPoseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::common::v1::PoseInFrame* pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class StopPlanRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.StopPlanRequest) */ {
 public:
  inline StopPlanRequest() : StopPlanRequest(nullptr) {}
  ~StopPlanRequest() override;
  explicit PROTOBUF_CONSTEXPR StopPlanRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopPlanRequest(const StopPlanRequest& from);
  StopPlanRequest(StopPlanRequest&& from) noexcept
    : StopPlanRequest() {
    *this = ::std::move(from);
  }

  inline StopPlanRequest& operator=(const StopPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPlanRequest& operator=(StopPlanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPlanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPlanRequest* internal_default_instance() {
    return reinterpret_cast<const StopPlanRequest*>(
               &_StopPlanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StopPlanRequest& a, StopPlanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPlanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPlanRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPlanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPlanRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopPlanRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopPlanRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopPlanRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.StopPlanRequest";
  }
  protected:
  explicit StopPlanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kComponentNameFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.StopPlanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::viam::common::v1::ResourceName* component_name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class StopPlanResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.StopPlanResponse) */ {
 public:
  inline StopPlanResponse() : StopPlanResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopPlanResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopPlanResponse(const StopPlanResponse& from);
  StopPlanResponse(StopPlanResponse&& from) noexcept
    : StopPlanResponse() {
    *this = ::std::move(from);
  }

  inline StopPlanResponse& operator=(const StopPlanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPlanResponse& operator=(StopPlanResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPlanResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPlanResponse* internal_default_instance() {
    return reinterpret_cast<const StopPlanResponse*>(
               &_StopPlanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StopPlanResponse& a, StopPlanResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPlanResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPlanResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPlanResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPlanResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopPlanResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopPlanResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.StopPlanResponse";
  }
  protected:
  explicit StopPlanResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.StopPlanResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class ListPlanStatusesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ListPlanStatusesRequest) */ {
 public:
  inline ListPlanStatusesRequest() : ListPlanStatusesRequest(nullptr) {}
  ~ListPlanStatusesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListPlanStatusesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPlanStatusesRequest(const ListPlanStatusesRequest& from);
  ListPlanStatusesRequest(ListPlanStatusesRequest&& from) noexcept
    : ListPlanStatusesRequest() {
    *this = ::std::move(from);
  }

  inline ListPlanStatusesRequest& operator=(const ListPlanStatusesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPlanStatusesRequest& operator=(ListPlanStatusesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPlanStatusesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPlanStatusesRequest* internal_default_instance() {
    return reinterpret_cast<const ListPlanStatusesRequest*>(
               &_ListPlanStatusesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListPlanStatusesRequest& a, ListPlanStatusesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPlanStatusesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPlanStatusesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPlanStatusesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPlanStatusesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPlanStatusesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPlanStatusesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPlanStatusesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.ListPlanStatusesRequest";
  }
  protected:
  explicit ListPlanStatusesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExtraFieldNumber = 99,
    kOnlyActivePlansFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // bool only_active_plans = 2 [json_name = "onlyActivePlans"];
  void clear_only_active_plans();
  bool only_active_plans() const;
  void set_only_active_plans(bool value);
  private:
  bool _internal_only_active_plans() const;
  void _internal_set_only_active_plans(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ListPlanStatusesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
  bool only_active_plans_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class ListPlanStatusesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ListPlanStatusesResponse) */ {
 public:
  inline ListPlanStatusesResponse() : ListPlanStatusesResponse(nullptr) {}
  ~ListPlanStatusesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListPlanStatusesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPlanStatusesResponse(const ListPlanStatusesResponse& from);
  ListPlanStatusesResponse(ListPlanStatusesResponse&& from) noexcept
    : ListPlanStatusesResponse() {
    *this = ::std::move(from);
  }

  inline ListPlanStatusesResponse& operator=(const ListPlanStatusesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPlanStatusesResponse& operator=(ListPlanStatusesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPlanStatusesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPlanStatusesResponse* internal_default_instance() {
    return reinterpret_cast<const ListPlanStatusesResponse*>(
               &_ListPlanStatusesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListPlanStatusesResponse& a, ListPlanStatusesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPlanStatusesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPlanStatusesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPlanStatusesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPlanStatusesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPlanStatusesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPlanStatusesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPlanStatusesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.ListPlanStatusesResponse";
  }
  protected:
  explicit ListPlanStatusesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanStatusesWithIdsFieldNumber = 1,
  };
  // repeated .viam.service.motion.v1.PlanStatusWithID plan_statuses_with_ids = 1 [json_name = "planStatusesWithIds"];
  int plan_statuses_with_ids_size() const;
  private:
  int _internal_plan_statuses_with_ids_size() const;
  public:
  void clear_plan_statuses_with_ids();
  ::viam::service::motion::v1::PlanStatusWithID* mutable_plan_statuses_with_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID >*
      mutable_plan_statuses_with_ids();
  private:
  const ::viam::service::motion::v1::PlanStatusWithID& _internal_plan_statuses_with_ids(int index) const;
  ::viam::service::motion::v1::PlanStatusWithID* _internal_add_plan_statuses_with_ids();
  public:
  const ::viam::service::motion::v1::PlanStatusWithID& plan_statuses_with_ids(int index) const;
  ::viam::service::motion::v1::PlanStatusWithID* add_plan_statuses_with_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID >&
      plan_statuses_with_ids() const;

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ListPlanStatusesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID > plan_statuses_with_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class GetPlanRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPlanRequest) */ {
 public:
  inline GetPlanRequest() : GetPlanRequest(nullptr) {}
  ~GetPlanRequest() override;
  explicit PROTOBUF_CONSTEXPR GetPlanRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPlanRequest(const GetPlanRequest& from);
  GetPlanRequest(GetPlanRequest&& from) noexcept
    : GetPlanRequest() {
    *this = ::std::move(from);
  }

  inline GetPlanRequest& operator=(const GetPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlanRequest& operator=(GetPlanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlanRequest* internal_default_instance() {
    return reinterpret_cast<const GetPlanRequest*>(
               &_GetPlanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetPlanRequest& a, GetPlanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlanRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlanRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPlanRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPlanRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPlanRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.GetPlanRequest";
  }
  protected:
  explicit GetPlanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExecutionIdFieldNumber = 4,
    kComponentNameFieldNumber = 2,
    kExtraFieldNumber = 99,
    kLastPlanOnlyFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string execution_id = 4 [json_name = "executionId"];
  bool has_execution_id() const;
  private:
  bool _internal_has_execution_id() const;
  public:
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // bool last_plan_only = 3 [json_name = "lastPlanOnly"];
  void clear_last_plan_only();
  bool last_plan_only() const;
  void set_last_plan_only(bool value);
  private:
  bool _internal_last_plan_only() const;
  void _internal_set_last_plan_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPlanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
  ::viam::common::v1::ResourceName* component_name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
  bool last_plan_only_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class GetPlanResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.GetPlanResponse) */ {
 public:
  inline GetPlanResponse() : GetPlanResponse(nullptr) {}
  ~GetPlanResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPlanResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPlanResponse(const GetPlanResponse& from);
  GetPlanResponse(GetPlanResponse&& from) noexcept
    : GetPlanResponse() {
    *this = ::std::move(from);
  }

  inline GetPlanResponse& operator=(const GetPlanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlanResponse& operator=(GetPlanResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlanResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlanResponse* internal_default_instance() {
    return reinterpret_cast<const GetPlanResponse*>(
               &_GetPlanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetPlanResponse& a, GetPlanResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlanResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlanResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlanResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlanResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPlanResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPlanResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPlanResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.GetPlanResponse";
  }
  protected:
  explicit GetPlanResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplanHistoryFieldNumber = 2,
    kCurrentPlanWithStatusFieldNumber = 1,
  };
  // repeated .viam.service.motion.v1.PlanWithStatus replan_history = 2 [json_name = "replanHistory"];
  int replan_history_size() const;
  private:
  int _internal_replan_history_size() const;
  public:
  void clear_replan_history();
  ::viam::service::motion::v1::PlanWithStatus* mutable_replan_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus >*
      mutable_replan_history();
  private:
  const ::viam::service::motion::v1::PlanWithStatus& _internal_replan_history(int index) const;
  ::viam::service::motion::v1::PlanWithStatus* _internal_add_replan_history();
  public:
  const ::viam::service::motion::v1::PlanWithStatus& replan_history(int index) const;
  ::viam::service::motion::v1::PlanWithStatus* add_replan_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus >&
      replan_history() const;

  // .viam.service.motion.v1.PlanWithStatus current_plan_with_status = 1 [json_name = "currentPlanWithStatus"];
  bool has_current_plan_with_status() const;
  private:
  bool _internal_has_current_plan_with_status() const;
  public:
  void clear_current_plan_with_status();
  const ::viam::service::motion::v1::PlanWithStatus& current_plan_with_status() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::PlanWithStatus* release_current_plan_with_status();
  ::viam::service::motion::v1::PlanWithStatus* mutable_current_plan_with_status();
  void set_allocated_current_plan_with_status(::viam::service::motion::v1::PlanWithStatus* current_plan_with_status);
  private:
  const ::viam::service::motion::v1::PlanWithStatus& _internal_current_plan_with_status() const;
  ::viam::service::motion::v1::PlanWithStatus* _internal_mutable_current_plan_with_status();
  public:
  void unsafe_arena_set_allocated_current_plan_with_status(
      ::viam::service::motion::v1::PlanWithStatus* current_plan_with_status);
  ::viam::service::motion::v1::PlanWithStatus* unsafe_arena_release_current_plan_with_status();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.GetPlanResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus > replan_history_;
  ::viam::service::motion::v1::PlanWithStatus* current_plan_with_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class Constraints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.Constraints) */ {
 public:
  inline Constraints() : Constraints(nullptr) {}
  ~Constraints() override;
  explicit PROTOBUF_CONSTEXPR Constraints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Constraints(const Constraints& from);
  Constraints(Constraints&& from) noexcept
    : Constraints() {
    *this = ::std::move(from);
  }

  inline Constraints& operator=(const Constraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraints& operator=(Constraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Constraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Constraints* internal_default_instance() {
    return reinterpret_cast<const Constraints*>(
               &_Constraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Constraints& a, Constraints& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constraints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Constraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Constraints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Constraints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Constraints& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.Constraints";
  }
  protected:
  explicit Constraints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearConstraintFieldNumber = 1,
    kOrientationConstraintFieldNumber = 2,
    kCollisionSpecificationFieldNumber = 3,
  };
  // repeated .viam.service.motion.v1.LinearConstraint linear_constraint = 1 [json_name = "linearConstraint"];
  int linear_constraint_size() const;
  private:
  int _internal_linear_constraint_size() const;
  public:
  void clear_linear_constraint();
  ::viam::service::motion::v1::LinearConstraint* mutable_linear_constraint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint >*
      mutable_linear_constraint();
  private:
  const ::viam::service::motion::v1::LinearConstraint& _internal_linear_constraint(int index) const;
  ::viam::service::motion::v1::LinearConstraint* _internal_add_linear_constraint();
  public:
  const ::viam::service::motion::v1::LinearConstraint& linear_constraint(int index) const;
  ::viam::service::motion::v1::LinearConstraint* add_linear_constraint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint >&
      linear_constraint() const;

  // repeated .viam.service.motion.v1.OrientationConstraint orientation_constraint = 2 [json_name = "orientationConstraint"];
  int orientation_constraint_size() const;
  private:
  int _internal_orientation_constraint_size() const;
  public:
  void clear_orientation_constraint();
  ::viam::service::motion::v1::OrientationConstraint* mutable_orientation_constraint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint >*
      mutable_orientation_constraint();
  private:
  const ::viam::service::motion::v1::OrientationConstraint& _internal_orientation_constraint(int index) const;
  ::viam::service::motion::v1::OrientationConstraint* _internal_add_orientation_constraint();
  public:
  const ::viam::service::motion::v1::OrientationConstraint& orientation_constraint(int index) const;
  ::viam::service::motion::v1::OrientationConstraint* add_orientation_constraint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint >&
      orientation_constraint() const;

  // repeated .viam.service.motion.v1.CollisionSpecification collision_specification = 3 [json_name = "collisionSpecification"];
  int collision_specification_size() const;
  private:
  int _internal_collision_specification_size() const;
  public:
  void clear_collision_specification();
  ::viam::service::motion::v1::CollisionSpecification* mutable_collision_specification(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification >*
      mutable_collision_specification();
  private:
  const ::viam::service::motion::v1::CollisionSpecification& _internal_collision_specification(int index) const;
  ::viam::service::motion::v1::CollisionSpecification* _internal_add_collision_specification();
  public:
  const ::viam::service::motion::v1::CollisionSpecification& collision_specification(int index) const;
  ::viam::service::motion::v1::CollisionSpecification* add_collision_specification();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification >&
      collision_specification() const;

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.Constraints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint > linear_constraint_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint > orientation_constraint_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification > collision_specification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class LinearConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.LinearConstraint) */ {
 public:
  inline LinearConstraint() : LinearConstraint(nullptr) {}
  ~LinearConstraint() override;
  explicit PROTOBUF_CONSTEXPR LinearConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearConstraint(const LinearConstraint& from);
  LinearConstraint(LinearConstraint&& from) noexcept
    : LinearConstraint() {
    *this = ::std::move(from);
  }

  inline LinearConstraint& operator=(const LinearConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearConstraint& operator=(LinearConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearConstraint* internal_default_instance() {
    return reinterpret_cast<const LinearConstraint*>(
               &_LinearConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LinearConstraint& a, LinearConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearConstraint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinearConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinearConstraint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.LinearConstraint";
  }
  protected:
  explicit LinearConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineToleranceMmFieldNumber = 1,
    kOrientationToleranceDegsFieldNumber = 2,
  };
  // optional float line_tolerance_mm = 1 [json_name = "lineToleranceMm"];
  bool has_line_tolerance_mm() const;
  private:
  bool _internal_has_line_tolerance_mm() const;
  public:
  void clear_line_tolerance_mm();
  float line_tolerance_mm() const;
  void set_line_tolerance_mm(float value);
  private:
  float _internal_line_tolerance_mm() const;
  void _internal_set_line_tolerance_mm(float value);
  public:

  // optional float orientation_tolerance_degs = 2 [json_name = "orientationToleranceDegs"];
  bool has_orientation_tolerance_degs() const;
  private:
  bool _internal_has_orientation_tolerance_degs() const;
  public:
  void clear_orientation_tolerance_degs();
  float orientation_tolerance_degs() const;
  void set_orientation_tolerance_degs(float value);
  private:
  float _internal_orientation_tolerance_degs() const;
  void _internal_set_orientation_tolerance_degs(float value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.LinearConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float line_tolerance_mm_;
  float orientation_tolerance_degs_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class OrientationConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.OrientationConstraint) */ {
 public:
  inline OrientationConstraint() : OrientationConstraint(nullptr) {}
  ~OrientationConstraint() override;
  explicit PROTOBUF_CONSTEXPR OrientationConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrientationConstraint(const OrientationConstraint& from);
  OrientationConstraint(OrientationConstraint&& from) noexcept
    : OrientationConstraint() {
    *this = ::std::move(from);
  }

  inline OrientationConstraint& operator=(const OrientationConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrientationConstraint& operator=(OrientationConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrientationConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrientationConstraint* internal_default_instance() {
    return reinterpret_cast<const OrientationConstraint*>(
               &_OrientationConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OrientationConstraint& a, OrientationConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(OrientationConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrientationConstraint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrientationConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrientationConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrientationConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrientationConstraint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrientationConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.OrientationConstraint";
  }
  protected:
  explicit OrientationConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrientationToleranceDegsFieldNumber = 1,
  };
  // optional float orientation_tolerance_degs = 1 [json_name = "orientationToleranceDegs"];
  bool has_orientation_tolerance_degs() const;
  private:
  bool _internal_has_orientation_tolerance_degs() const;
  public:
  void clear_orientation_tolerance_degs();
  float orientation_tolerance_degs() const;
  void set_orientation_tolerance_degs(float value);
  private:
  float _internal_orientation_tolerance_degs() const;
  void _internal_set_orientation_tolerance_degs(float value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.OrientationConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float orientation_tolerance_degs_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class CollisionSpecification_AllowedFrameCollisions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions) */ {
 public:
  inline CollisionSpecification_AllowedFrameCollisions() : CollisionSpecification_AllowedFrameCollisions(nullptr) {}
  ~CollisionSpecification_AllowedFrameCollisions() override;
  explicit PROTOBUF_CONSTEXPR CollisionSpecification_AllowedFrameCollisions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollisionSpecification_AllowedFrameCollisions(const CollisionSpecification_AllowedFrameCollisions& from);
  CollisionSpecification_AllowedFrameCollisions(CollisionSpecification_AllowedFrameCollisions&& from) noexcept
    : CollisionSpecification_AllowedFrameCollisions() {
    *this = ::std::move(from);
  }

  inline CollisionSpecification_AllowedFrameCollisions& operator=(const CollisionSpecification_AllowedFrameCollisions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollisionSpecification_AllowedFrameCollisions& operator=(CollisionSpecification_AllowedFrameCollisions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollisionSpecification_AllowedFrameCollisions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollisionSpecification_AllowedFrameCollisions* internal_default_instance() {
    return reinterpret_cast<const CollisionSpecification_AllowedFrameCollisions*>(
               &_CollisionSpecification_AllowedFrameCollisions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CollisionSpecification_AllowedFrameCollisions& a, CollisionSpecification_AllowedFrameCollisions& b) {
    a.Swap(&b);
  }
  inline void Swap(CollisionSpecification_AllowedFrameCollisions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollisionSpecification_AllowedFrameCollisions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollisionSpecification_AllowedFrameCollisions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollisionSpecification_AllowedFrameCollisions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollisionSpecification_AllowedFrameCollisions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CollisionSpecification_AllowedFrameCollisions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollisionSpecification_AllowedFrameCollisions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions";
  }
  protected:
  explicit CollisionSpecification_AllowedFrameCollisions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrame1FieldNumber = 1,
    kFrame2FieldNumber = 2,
  };
  // string frame1 = 1 [json_name = "frame1"];
  void clear_frame1();
  const std::string& frame1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame1();
  PROTOBUF_NODISCARD std::string* release_frame1();
  void set_allocated_frame1(std::string* frame1);
  private:
  const std::string& _internal_frame1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame1(const std::string& value);
  std::string* _internal_mutable_frame1();
  public:

  // string frame2 = 2 [json_name = "frame2"];
  void clear_frame2();
  const std::string& frame2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame2();
  PROTOBUF_NODISCARD std::string* release_frame2();
  void set_allocated_frame2(std::string* frame2);
  private:
  const std::string& _internal_frame2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame2(const std::string& value);
  std::string* _internal_mutable_frame2();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class CollisionSpecification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.CollisionSpecification) */ {
 public:
  inline CollisionSpecification() : CollisionSpecification(nullptr) {}
  ~CollisionSpecification() override;
  explicit PROTOBUF_CONSTEXPR CollisionSpecification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollisionSpecification(const CollisionSpecification& from);
  CollisionSpecification(CollisionSpecification&& from) noexcept
    : CollisionSpecification() {
    *this = ::std::move(from);
  }

  inline CollisionSpecification& operator=(const CollisionSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollisionSpecification& operator=(CollisionSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollisionSpecification& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollisionSpecification* internal_default_instance() {
    return reinterpret_cast<const CollisionSpecification*>(
               &_CollisionSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CollisionSpecification& a, CollisionSpecification& b) {
    a.Swap(&b);
  }
  inline void Swap(CollisionSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollisionSpecification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollisionSpecification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollisionSpecification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollisionSpecification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CollisionSpecification& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollisionSpecification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.CollisionSpecification";
  }
  protected:
  explicit CollisionSpecification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CollisionSpecification_AllowedFrameCollisions AllowedFrameCollisions;

  // accessors -------------------------------------------------------

  enum : int {
    kAllowsFieldNumber = 1,
  };
  // repeated .viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions allows = 1 [json_name = "allows"];
  int allows_size() const;
  private:
  int _internal_allows_size() const;
  public:
  void clear_allows();
  ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* mutable_allows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions >*
      mutable_allows();
  private:
  const ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions& _internal_allows(int index) const;
  ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* _internal_add_allows();
  public:
  const ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions& allows(int index) const;
  ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* add_allows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions >&
      allows() const;

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.CollisionSpecification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions > allows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class PlanWithStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanWithStatus) */ {
 public:
  inline PlanWithStatus() : PlanWithStatus(nullptr) {}
  ~PlanWithStatus() override;
  explicit PROTOBUF_CONSTEXPR PlanWithStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanWithStatus(const PlanWithStatus& from);
  PlanWithStatus(PlanWithStatus&& from) noexcept
    : PlanWithStatus() {
    *this = ::std::move(from);
  }

  inline PlanWithStatus& operator=(const PlanWithStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanWithStatus& operator=(PlanWithStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanWithStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanWithStatus* internal_default_instance() {
    return reinterpret_cast<const PlanWithStatus*>(
               &_PlanWithStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PlanWithStatus& a, PlanWithStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanWithStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanWithStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanWithStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanWithStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanWithStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanWithStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanWithStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.PlanWithStatus";
  }
  protected:
  explicit PlanWithStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusHistoryFieldNumber = 3,
    kPlanFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .viam.service.motion.v1.PlanStatus status_history = 3 [json_name = "statusHistory"];
  int status_history_size() const;
  private:
  int _internal_status_history_size() const;
  public:
  void clear_status_history();
  ::viam::service::motion::v1::PlanStatus* mutable_status_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus >*
      mutable_status_history();
  private:
  const ::viam::service::motion::v1::PlanStatus& _internal_status_history(int index) const;
  ::viam::service::motion::v1::PlanStatus* _internal_add_status_history();
  public:
  const ::viam::service::motion::v1::PlanStatus& status_history(int index) const;
  ::viam::service::motion::v1::PlanStatus* add_status_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus >&
      status_history() const;

  // .viam.service.motion.v1.Plan plan = 1 [json_name = "plan"];
  bool has_plan() const;
  private:
  bool _internal_has_plan() const;
  public:
  void clear_plan();
  const ::viam::service::motion::v1::Plan& plan() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::Plan* release_plan();
  ::viam::service::motion::v1::Plan* mutable_plan();
  void set_allocated_plan(::viam::service::motion::v1::Plan* plan);
  private:
  const ::viam::service::motion::v1::Plan& _internal_plan() const;
  ::viam::service::motion::v1::Plan* _internal_mutable_plan();
  public:
  void unsafe_arena_set_allocated_plan(
      ::viam::service::motion::v1::Plan* plan);
  ::viam::service::motion::v1::Plan* unsafe_arena_release_plan();

  // .viam.service.motion.v1.PlanStatus status = 2 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::viam::service::motion::v1::PlanStatus& status() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::PlanStatus* release_status();
  ::viam::service::motion::v1::PlanStatus* mutable_status();
  void set_allocated_status(::viam::service::motion::v1::PlanStatus* status);
  private:
  const ::viam::service::motion::v1::PlanStatus& _internal_status() const;
  ::viam::service::motion::v1::PlanStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::viam::service::motion::v1::PlanStatus* status);
  ::viam::service::motion::v1::PlanStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanWithStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus > status_history_;
  ::viam::service::motion::v1::Plan* plan_;
  ::viam::service::motion::v1::PlanStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class PlanStatusWithID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanStatusWithID) */ {
 public:
  inline PlanStatusWithID() : PlanStatusWithID(nullptr) {}
  ~PlanStatusWithID() override;
  explicit PROTOBUF_CONSTEXPR PlanStatusWithID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanStatusWithID(const PlanStatusWithID& from);
  PlanStatusWithID(PlanStatusWithID&& from) noexcept
    : PlanStatusWithID() {
    *this = ::std::move(from);
  }

  inline PlanStatusWithID& operator=(const PlanStatusWithID& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanStatusWithID& operator=(PlanStatusWithID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanStatusWithID& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanStatusWithID* internal_default_instance() {
    return reinterpret_cast<const PlanStatusWithID*>(
               &_PlanStatusWithID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlanStatusWithID& a, PlanStatusWithID& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanStatusWithID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanStatusWithID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanStatusWithID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanStatusWithID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanStatusWithID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanStatusWithID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanStatusWithID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.PlanStatusWithID";
  }
  protected:
  explicit PlanStatusWithID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanIdFieldNumber = 1,
    kExecutionIdFieldNumber = 3,
    kComponentNameFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // string plan_id = 1 [json_name = "planId"];
  void clear_plan_id();
  const std::string& plan_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plan_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plan_id();
  PROTOBUF_NODISCARD std::string* release_plan_id();
  void set_allocated_plan_id(std::string* plan_id);
  private:
  const std::string& _internal_plan_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan_id(const std::string& value);
  std::string* _internal_mutable_plan_id();
  public:

  // string execution_id = 3 [json_name = "executionId"];
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // .viam.service.motion.v1.PlanStatus status = 4 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::viam::service::motion::v1::PlanStatus& status() const;
  PROTOBUF_NODISCARD ::viam::service::motion::v1::PlanStatus* release_status();
  ::viam::service::motion::v1::PlanStatus* mutable_status();
  void set_allocated_status(::viam::service::motion::v1::PlanStatus* status);
  private:
  const ::viam::service::motion::v1::PlanStatus& _internal_status() const;
  ::viam::service::motion::v1::PlanStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::viam::service::motion::v1::PlanStatus* status);
  ::viam::service::motion::v1::PlanStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanStatusWithID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plan_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
  ::viam::common::v1::ResourceName* component_name_;
  ::viam::service::motion::v1::PlanStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class PlanStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanStatus) */ {
 public:
  inline PlanStatus() : PlanStatus(nullptr) {}
  ~PlanStatus() override;
  explicit PROTOBUF_CONSTEXPR PlanStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanStatus(const PlanStatus& from);
  PlanStatus(PlanStatus&& from) noexcept
    : PlanStatus() {
    *this = ::std::move(from);
  }

  inline PlanStatus& operator=(const PlanStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanStatus& operator=(PlanStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanStatus* internal_default_instance() {
    return reinterpret_cast<const PlanStatus*>(
               &_PlanStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlanStatus& a, PlanStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.PlanStatus";
  }
  protected:
  explicit PlanStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // optional string reason = 3 [json_name = "reason"];
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .viam.service.motion.v1.PlanState state = 1 [json_name = "state"];
  void clear_state();
  ::viam::service::motion::v1::PlanState state() const;
  void set_state(::viam::service::motion::v1::PlanState value);
  private:
  ::viam::service::motion::v1::PlanState _internal_state() const;
  void _internal_set_state(::viam::service::motion::v1::PlanState value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  int state_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class Plan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.Plan) */ {
 public:
  inline Plan() : Plan(nullptr) {}
  ~Plan() override;
  explicit PROTOBUF_CONSTEXPR Plan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plan(const Plan& from);
  Plan(Plan&& from) noexcept
    : Plan() {
    *this = ::std::move(from);
  }

  inline Plan& operator=(const Plan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plan& operator=(Plan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plan* internal_default_instance() {
    return reinterpret_cast<const Plan*>(
               &_Plan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Plan& a, Plan& b) {
    a.Swap(&b);
  }
  inline void Swap(Plan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Plan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Plan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Plan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Plan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.Plan";
  }
  protected:
  explicit Plan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepsFieldNumber = 4,
    kIdFieldNumber = 1,
    kExecutionIdFieldNumber = 3,
    kComponentNameFieldNumber = 2,
  };
  // repeated .viam.service.motion.v1.PlanStep steps = 4 [json_name = "steps"];
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::viam::service::motion::v1::PlanStep* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStep >*
      mutable_steps();
  private:
  const ::viam::service::motion::v1::PlanStep& _internal_steps(int index) const;
  ::viam::service::motion::v1::PlanStep* _internal_add_steps();
  public:
  const ::viam::service::motion::v1::PlanStep& steps(int index) const;
  ::viam::service::motion::v1::PlanStep* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStep >&
      steps() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string execution_id = 3 [json_name = "executionId"];
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
  bool has_component_name() const;
  private:
  bool _internal_has_component_name() const;
  public:
  void clear_component_name();
  const ::viam::common::v1::ResourceName& component_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_component_name();
  ::viam::common::v1::ResourceName* mutable_component_name();
  void set_allocated_component_name(::viam::common::v1::ResourceName* component_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_component_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_component_name();
  public:
  void unsafe_arena_set_allocated_component_name(
      ::viam::common::v1::ResourceName* component_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_component_name();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.Plan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStep > steps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
  ::viam::common::v1::ResourceName* component_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class PlanStep_StepEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlanStep_StepEntry_DoNotUse, 
    std::string, ::viam::service::motion::v1::ComponentState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlanStep_StepEntry_DoNotUse, 
    std::string, ::viam::service::motion::v1::ComponentState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlanStep_StepEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PlanStep_StepEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PlanStep_StepEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlanStep_StepEntry_DoNotUse& other);
  static const PlanStep_StepEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlanStep_StepEntry_DoNotUse*>(&_PlanStep_StepEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.service.motion.v1.PlanStep.StepEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};

// -------------------------------------------------------------------

class PlanStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.PlanStep) */ {
 public:
  inline PlanStep() : PlanStep(nullptr) {}
  ~PlanStep() override;
  explicit PROTOBUF_CONSTEXPR PlanStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanStep(const PlanStep& from);
  PlanStep(PlanStep&& from) noexcept
    : PlanStep() {
    *this = ::std::move(from);
  }

  inline PlanStep& operator=(const PlanStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanStep& operator=(PlanStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanStep* internal_default_instance() {
    return reinterpret_cast<const PlanStep*>(
               &_PlanStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PlanStep& a, PlanStep& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanStep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.PlanStep";
  }
  protected:
  explicit PlanStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
  };
  // map<string, .viam.service.motion.v1.ComponentState> step = 1 [json_name = "step"];
  int step_size() const;
  private:
  int _internal_step_size() const;
  public:
  void clear_step();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >&
      _internal_step() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >*
      _internal_mutable_step();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >&
      step() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >*
      mutable_step();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.PlanStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlanStep_StepEntry_DoNotUse,
      std::string, ::viam::service::motion::v1::ComponentState,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> step_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// -------------------------------------------------------------------

class ComponentState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.motion.v1.ComponentState) */ {
 public:
  inline ComponentState() : ComponentState(nullptr) {}
  ~ComponentState() override;
  explicit PROTOBUF_CONSTEXPR ComponentState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComponentState(const ComponentState& from);
  ComponentState(ComponentState&& from) noexcept
    : ComponentState() {
    *this = ::std::move(from);
  }

  inline ComponentState& operator=(const ComponentState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComponentState& operator=(ComponentState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComponentState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComponentState* internal_default_instance() {
    return reinterpret_cast<const ComponentState*>(
               &_ComponentState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ComponentState& a, ComponentState& b) {
    a.Swap(&b);
  }
  inline void Swap(ComponentState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComponentState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComponentState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComponentState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComponentState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComponentState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComponentState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.motion.v1.ComponentState";
  }
  protected:
  explicit ComponentState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .viam.common.v1.Pose pose = 1 [json_name = "pose"];
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::viam::common::v1::Pose& pose() const;
  PROTOBUF_NODISCARD ::viam::common::v1::Pose* release_pose();
  ::viam::common::v1::Pose* mutable_pose();
  void set_allocated_pose(::viam::common::v1::Pose* pose);
  private:
  const ::viam::common::v1::Pose& _internal_pose() const;
  ::viam::common::v1::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::viam::common::v1::Pose* pose);
  ::viam::common::v1::Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:viam.service.motion.v1.ComponentState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::common::v1::Pose* pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2fmotion_2fv1_2fmotion_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MoveRequest

// string name = 1 [json_name = "name"];
inline void MoveRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MoveRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveRequest.name)
}
inline std::string* MoveRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.name)
  return _s;
}
inline const std::string& MoveRequest::_internal_name() const {
  return name_.Get();
}
inline void MoveRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.name)
  return name_.Release();
}
inline void MoveRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.name)
}

// .viam.common.v1.PoseInFrame destination = 2 [json_name = "destination"];
inline bool MoveRequest::_internal_has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline bool MoveRequest::has_destination() const {
  return _internal_has_destination();
}
inline const ::viam::common::v1::PoseInFrame& MoveRequest::_internal_destination() const {
  const ::viam::common::v1::PoseInFrame* p = destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::PoseInFrame&>(
      ::viam::common::v1::_PoseInFrame_default_instance_);
}
inline const ::viam::common::v1::PoseInFrame& MoveRequest::destination() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.destination)
  return _internal_destination();
}
inline void MoveRequest::unsafe_arena_set_allocated_destination(
    ::viam::common::v1::PoseInFrame* destination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  destination_ = destination;
  if (destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.destination)
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::release_destination() {
  
  ::viam::common::v1::PoseInFrame* temp = destination_;
  destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.destination)
  
  ::viam::common::v1::PoseInFrame* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::_internal_mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::PoseInFrame>(GetArenaForAllocation());
    destination_ = p;
  }
  return destination_;
}
inline ::viam::common::v1::PoseInFrame* MoveRequest::mutable_destination() {
  ::viam::common::v1::PoseInFrame* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.destination)
  return _msg;
}
inline void MoveRequest::set_allocated_destination(::viam::common::v1::PoseInFrame* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination));
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.destination)
}

// .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
inline bool MoveRequest::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool MoveRequest::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& MoveRequest::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveRequest::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.component_name)
  return _internal_component_name();
}
inline void MoveRequest::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.component_name)
}
inline ::viam::common::v1::ResourceName* MoveRequest::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveRequest::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveRequest::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* MoveRequest::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.component_name)
  return _msg;
}
inline void MoveRequest::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.component_name)
}

// optional .viam.common.v1.WorldState world_state = 4 [json_name = "worldState"];
inline bool MoveRequest::_internal_has_world_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || world_state_ != nullptr);
  return value;
}
inline bool MoveRequest::has_world_state() const {
  return _internal_has_world_state();
}
inline const ::viam::common::v1::WorldState& MoveRequest::_internal_world_state() const {
  const ::viam::common::v1::WorldState* p = world_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::WorldState&>(
      ::viam::common::v1::_WorldState_default_instance_);
}
inline const ::viam::common::v1::WorldState& MoveRequest::world_state() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.world_state)
  return _internal_world_state();
}
inline void MoveRequest::unsafe_arena_set_allocated_world_state(
    ::viam::common::v1::WorldState* world_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_state_);
  }
  world_state_ = world_state;
  if (world_state) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.world_state)
}
inline ::viam::common::v1::WorldState* MoveRequest::release_world_state() {
  _has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::WorldState* temp = world_state_;
  world_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::WorldState* MoveRequest::unsafe_arena_release_world_state() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.world_state)
  _has_bits_[0] &= ~0x00000001u;
  ::viam::common::v1::WorldState* temp = world_state_;
  world_state_ = nullptr;
  return temp;
}
inline ::viam::common::v1::WorldState* MoveRequest::_internal_mutable_world_state() {
  _has_bits_[0] |= 0x00000001u;
  if (world_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::WorldState>(GetArenaForAllocation());
    world_state_ = p;
  }
  return world_state_;
}
inline ::viam::common::v1::WorldState* MoveRequest::mutable_world_state() {
  ::viam::common::v1::WorldState* _msg = _internal_mutable_world_state();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.world_state)
  return _msg;
}
inline void MoveRequest::set_allocated_world_state(::viam::common::v1::WorldState* world_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_state_);
  }
  if (world_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_state));
    if (message_arena != submessage_arena) {
      world_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  world_state_ = world_state;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.world_state)
}

// optional .viam.service.motion.v1.Constraints constraints = 5 [json_name = "constraints"];
inline bool MoveRequest::_internal_has_constraints() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || constraints_ != nullptr);
  return value;
}
inline bool MoveRequest::has_constraints() const {
  return _internal_has_constraints();
}
inline void MoveRequest::clear_constraints() {
  if (constraints_ != nullptr) constraints_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::service::motion::v1::Constraints& MoveRequest::_internal_constraints() const {
  const ::viam::service::motion::v1::Constraints* p = constraints_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::Constraints&>(
      ::viam::service::motion::v1::_Constraints_default_instance_);
}
inline const ::viam::service::motion::v1::Constraints& MoveRequest::constraints() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.constraints)
  return _internal_constraints();
}
inline void MoveRequest::unsafe_arena_set_allocated_constraints(
    ::viam::service::motion::v1::Constraints* constraints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(constraints_);
  }
  constraints_ = constraints;
  if (constraints) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.constraints)
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::release_constraints() {
  _has_bits_[0] &= ~0x00000002u;
  ::viam::service::motion::v1::Constraints* temp = constraints_;
  constraints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::unsafe_arena_release_constraints() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.constraints)
  _has_bits_[0] &= ~0x00000002u;
  ::viam::service::motion::v1::Constraints* temp = constraints_;
  constraints_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::_internal_mutable_constraints() {
  _has_bits_[0] |= 0x00000002u;
  if (constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::Constraints>(GetArenaForAllocation());
    constraints_ = p;
  }
  return constraints_;
}
inline ::viam::service::motion::v1::Constraints* MoveRequest::mutable_constraints() {
  ::viam::service::motion::v1::Constraints* _msg = _internal_mutable_constraints();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.constraints)
  return _msg;
}
inline void MoveRequest::set_allocated_constraints(::viam::service::motion::v1::Constraints* constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete constraints_;
  }
  if (constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(constraints);
    if (message_arena != submessage_arena) {
      constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constraints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  constraints_ = constraints;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.constraints)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool MoveRequest::_internal_has_extra() const {
  return this != internal_default_instance() && extra_ != nullptr;
}
inline bool MoveRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MoveRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MoveRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveRequest.extra)
  return _internal_extra();
}
inline void MoveRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveRequest::_internal_mutable_extra() {
  
  if (extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    extra_ = p;
  }
  return extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveRequest.extra)
  return _msg;
}
inline void MoveRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveRequest.extra)
}

// -------------------------------------------------------------------

// MoveResponse

// bool success = 1 [json_name = "success"];
inline void MoveResponse::clear_success() {
  success_ = false;
}
inline bool MoveResponse::_internal_success() const {
  return success_;
}
inline bool MoveResponse::success() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveResponse.success)
  return _internal_success();
}
inline void MoveResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void MoveResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveResponse.success)
}

// -------------------------------------------------------------------

// MoveOnMapRequest

// string name = 1 [json_name = "name"];
inline void MoveOnMapRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MoveOnMapRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveOnMapRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnMapRequest.name)
}
inline std::string* MoveOnMapRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.name)
  return _s;
}
inline const std::string& MoveOnMapRequest::_internal_name() const {
  return name_.Get();
}
inline void MoveOnMapRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveOnMapRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveOnMapRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.name)
  return name_.Release();
}
inline void MoveOnMapRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.name)
}

// .viam.common.v1.Pose destination = 2 [json_name = "destination"];
inline bool MoveOnMapRequest::_internal_has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline bool MoveOnMapRequest::has_destination() const {
  return _internal_has_destination();
}
inline const ::viam::common::v1::Pose& MoveOnMapRequest::_internal_destination() const {
  const ::viam::common::v1::Pose* p = destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::Pose&>(
      ::viam::common::v1::_Pose_default_instance_);
}
inline const ::viam::common::v1::Pose& MoveOnMapRequest::destination() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.destination)
  return _internal_destination();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_destination(
    ::viam::common::v1::Pose* destination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  destination_ = destination;
  if (destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.destination)
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::release_destination() {
  
  ::viam::common::v1::Pose* temp = destination_;
  destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.destination)
  
  ::viam::common::v1::Pose* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::_internal_mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::Pose>(GetArenaForAllocation());
    destination_ = p;
  }
  return destination_;
}
inline ::viam::common::v1::Pose* MoveOnMapRequest::mutable_destination() {
  ::viam::common::v1::Pose* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.destination)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_destination(::viam::common::v1::Pose* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination));
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.destination)
}

// .viam.common.v1.ResourceName component_name = 3 [json_name = "componentName"];
inline bool MoveOnMapRequest::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool MoveOnMapRequest::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.component_name)
  return _internal_component_name();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.component_name)
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.component_name)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.component_name)
}

// .viam.common.v1.ResourceName slam_service_name = 4 [json_name = "slamServiceName"];
inline bool MoveOnMapRequest::_internal_has_slam_service_name() const {
  return this != internal_default_instance() && slam_service_name_ != nullptr;
}
inline bool MoveOnMapRequest::has_slam_service_name() const {
  return _internal_has_slam_service_name();
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::_internal_slam_service_name() const {
  const ::viam::common::v1::ResourceName* p = slam_service_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnMapRequest::slam_service_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
  return _internal_slam_service_name();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_slam_service_name(
    ::viam::common::v1::ResourceName* slam_service_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slam_service_name_);
  }
  slam_service_name_ = slam_service_name;
  if (slam_service_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::release_slam_service_name() {
  
  ::viam::common::v1::ResourceName* temp = slam_service_name_;
  slam_service_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::unsafe_arena_release_slam_service_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
  
  ::viam::common::v1::ResourceName* temp = slam_service_name_;
  slam_service_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::_internal_mutable_slam_service_name() {
  
  if (slam_service_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    slam_service_name_ = p;
  }
  return slam_service_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnMapRequest::mutable_slam_service_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_slam_service_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_slam_service_name(::viam::common::v1::ResourceName* slam_service_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(slam_service_name_);
  }
  if (slam_service_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slam_service_name));
    if (message_arena != submessage_arena) {
      slam_service_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slam_service_name, submessage_arena);
    }
    
  } else {
    
  }
  slam_service_name_ = slam_service_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.slam_service_name)
}

// optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 5 [json_name = "motionConfiguration"];
inline bool MoveOnMapRequest::_internal_has_motion_configuration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || motion_configuration_ != nullptr);
  return value;
}
inline bool MoveOnMapRequest::has_motion_configuration() const {
  return _internal_has_motion_configuration();
}
inline void MoveOnMapRequest::clear_motion_configuration() {
  if (motion_configuration_ != nullptr) motion_configuration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnMapRequest::_internal_motion_configuration() const {
  const ::viam::service::motion::v1::MotionConfiguration* p = motion_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::MotionConfiguration&>(
      ::viam::service::motion::v1::_MotionConfiguration_default_instance_);
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnMapRequest::motion_configuration() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
  return _internal_motion_configuration();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_motion_configuration(
    ::viam::service::motion::v1::MotionConfiguration* motion_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_configuration_);
  }
  motion_configuration_ = motion_configuration;
  if (motion_configuration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::release_motion_configuration() {
  _has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::MotionConfiguration* temp = motion_configuration_;
  motion_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::unsafe_arena_release_motion_configuration() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
  _has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::MotionConfiguration* temp = motion_configuration_;
  motion_configuration_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::_internal_mutable_motion_configuration() {
  _has_bits_[0] |= 0x00000001u;
  if (motion_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::MotionConfiguration>(GetArenaForAllocation());
    motion_configuration_ = p;
  }
  return motion_configuration_;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnMapRequest::mutable_motion_configuration() {
  ::viam::service::motion::v1::MotionConfiguration* _msg = _internal_mutable_motion_configuration();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* motion_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete motion_configuration_;
  }
  if (motion_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motion_configuration);
    if (message_arena != submessage_arena) {
      motion_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion_configuration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  motion_configuration_ = motion_configuration;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.motion_configuration)
}

// repeated .viam.common.v1.Geometry obstacles = 6 [json_name = "obstacles"];
inline int MoveOnMapRequest::_internal_obstacles_size() const {
  return obstacles_.size();
}
inline int MoveOnMapRequest::obstacles_size() const {
  return _internal_obstacles_size();
}
inline ::viam::common::v1::Geometry* MoveOnMapRequest::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return obstacles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Geometry >*
MoveOnMapRequest::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return &obstacles_;
}
inline const ::viam::common::v1::Geometry& MoveOnMapRequest::_internal_obstacles(int index) const {
  return obstacles_.Get(index);
}
inline const ::viam::common::v1::Geometry& MoveOnMapRequest::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return _internal_obstacles(index);
}
inline ::viam::common::v1::Geometry* MoveOnMapRequest::_internal_add_obstacles() {
  return obstacles_.Add();
}
inline ::viam::common::v1::Geometry* MoveOnMapRequest::add_obstacles() {
  ::viam::common::v1::Geometry* _add = _internal_add_obstacles();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Geometry >&
MoveOnMapRequest::obstacles() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MoveOnMapRequest.obstacles)
  return obstacles_;
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool MoveOnMapRequest::_internal_has_extra() const {
  return this != internal_default_instance() && extra_ != nullptr;
}
inline bool MoveOnMapRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MoveOnMapRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MoveOnMapRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapRequest.extra)
  return _internal_extra();
}
inline void MoveOnMapRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnMapRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnMapRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnMapRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnMapRequest::_internal_mutable_extra() {
  
  if (extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    extra_ = p;
  }
  return extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnMapRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapRequest.extra)
  return _msg;
}
inline void MoveOnMapRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapRequest.extra)
}

// -------------------------------------------------------------------

// MoveOnMapResponse

// string execution_id = 1 [json_name = "executionId"];
inline void MoveOnMapResponse::clear_execution_id() {
  execution_id_.ClearToEmpty();
}
inline const std::string& MoveOnMapResponse::execution_id() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnMapResponse.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveOnMapResponse::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnMapResponse.execution_id)
}
inline std::string* MoveOnMapResponse::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnMapResponse.execution_id)
  return _s;
}
inline const std::string& MoveOnMapResponse::_internal_execution_id() const {
  return execution_id_.Get();
}
inline void MoveOnMapResponse::_internal_set_execution_id(const std::string& value) {
  
  execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveOnMapResponse::_internal_mutable_execution_id() {
  
  return execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveOnMapResponse::release_execution_id() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnMapResponse.execution_id)
  return execution_id_.Release();
}
inline void MoveOnMapResponse::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (execution_id_.IsDefault()) {
    execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnMapResponse.execution_id)
}

// -------------------------------------------------------------------

// ObstacleDetector

// .viam.common.v1.ResourceName vision_service = 1 [json_name = "visionService"];
inline bool ObstacleDetector::_internal_has_vision_service() const {
  return this != internal_default_instance() && vision_service_ != nullptr;
}
inline bool ObstacleDetector::has_vision_service() const {
  return _internal_has_vision_service();
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::_internal_vision_service() const {
  const ::viam::common::v1::ResourceName* p = vision_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::vision_service() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ObstacleDetector.vision_service)
  return _internal_vision_service();
}
inline void ObstacleDetector::unsafe_arena_set_allocated_vision_service(
    ::viam::common::v1::ResourceName* vision_service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vision_service_);
  }
  vision_service_ = vision_service;
  if (vision_service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ObstacleDetector.vision_service)
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::release_vision_service() {
  
  ::viam::common::v1::ResourceName* temp = vision_service_;
  vision_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::unsafe_arena_release_vision_service() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ObstacleDetector.vision_service)
  
  ::viam::common::v1::ResourceName* temp = vision_service_;
  vision_service_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::_internal_mutable_vision_service() {
  
  if (vision_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    vision_service_ = p;
  }
  return vision_service_;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::mutable_vision_service() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_vision_service();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ObstacleDetector.vision_service)
  return _msg;
}
inline void ObstacleDetector::set_allocated_vision_service(::viam::common::v1::ResourceName* vision_service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vision_service_);
  }
  if (vision_service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vision_service));
    if (message_arena != submessage_arena) {
      vision_service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vision_service, submessage_arena);
    }
    
  } else {
    
  }
  vision_service_ = vision_service;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ObstacleDetector.vision_service)
}

// .viam.common.v1.ResourceName camera = 2 [json_name = "camera"];
inline bool ObstacleDetector::_internal_has_camera() const {
  return this != internal_default_instance() && camera_ != nullptr;
}
inline bool ObstacleDetector::has_camera() const {
  return _internal_has_camera();
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::_internal_camera() const {
  const ::viam::common::v1::ResourceName* p = camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& ObstacleDetector::camera() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ObstacleDetector.camera)
  return _internal_camera();
}
inline void ObstacleDetector::unsafe_arena_set_allocated_camera(
    ::viam::common::v1::ResourceName* camera) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  camera_ = camera;
  if (camera) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ObstacleDetector.camera)
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::release_camera() {
  
  ::viam::common::v1::ResourceName* temp = camera_;
  camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ObstacleDetector.camera)
  
  ::viam::common::v1::ResourceName* temp = camera_;
  camera_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::_internal_mutable_camera() {
  
  if (camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    camera_ = p;
  }
  return camera_;
}
inline ::viam::common::v1::ResourceName* ObstacleDetector::mutable_camera() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ObstacleDetector.camera)
  return _msg;
}
inline void ObstacleDetector::set_allocated_camera(::viam::common::v1::ResourceName* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera));
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    
  } else {
    
  }
  camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ObstacleDetector.camera)
}

// -------------------------------------------------------------------

// MotionConfiguration

// repeated .viam.service.motion.v1.ObstacleDetector obstacle_detectors = 1 [json_name = "obstacleDetectors"];
inline int MotionConfiguration::_internal_obstacle_detectors_size() const {
  return obstacle_detectors_.size();
}
inline int MotionConfiguration::obstacle_detectors_size() const {
  return _internal_obstacle_detectors_size();
}
inline void MotionConfiguration::clear_obstacle_detectors() {
  obstacle_detectors_.Clear();
}
inline ::viam::service::motion::v1::ObstacleDetector* MotionConfiguration::mutable_obstacle_detectors(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return obstacle_detectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector >*
MotionConfiguration::mutable_obstacle_detectors() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return &obstacle_detectors_;
}
inline const ::viam::service::motion::v1::ObstacleDetector& MotionConfiguration::_internal_obstacle_detectors(int index) const {
  return obstacle_detectors_.Get(index);
}
inline const ::viam::service::motion::v1::ObstacleDetector& MotionConfiguration::obstacle_detectors(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return _internal_obstacle_detectors(index);
}
inline ::viam::service::motion::v1::ObstacleDetector* MotionConfiguration::_internal_add_obstacle_detectors() {
  return obstacle_detectors_.Add();
}
inline ::viam::service::motion::v1::ObstacleDetector* MotionConfiguration::add_obstacle_detectors() {
  ::viam::service::motion::v1::ObstacleDetector* _add = _internal_add_obstacle_detectors();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::ObstacleDetector >&
MotionConfiguration::obstacle_detectors() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MotionConfiguration.obstacle_detectors)
  return obstacle_detectors_;
}

// optional double position_polling_frequency_hz = 2 [json_name = "positionPollingFrequencyHz"];
inline bool MotionConfiguration::_internal_has_position_polling_frequency_hz() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionConfiguration::has_position_polling_frequency_hz() const {
  return _internal_has_position_polling_frequency_hz();
}
inline void MotionConfiguration::clear_position_polling_frequency_hz() {
  position_polling_frequency_hz_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double MotionConfiguration::_internal_position_polling_frequency_hz() const {
  return position_polling_frequency_hz_;
}
inline double MotionConfiguration::position_polling_frequency_hz() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.position_polling_frequency_hz)
  return _internal_position_polling_frequency_hz();
}
inline void MotionConfiguration::_internal_set_position_polling_frequency_hz(double value) {
  _has_bits_[0] |= 0x00000001u;
  position_polling_frequency_hz_ = value;
}
inline void MotionConfiguration::set_position_polling_frequency_hz(double value) {
  _internal_set_position_polling_frequency_hz(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.position_polling_frequency_hz)
}

// optional double obstacle_polling_frequency_hz = 3 [json_name = "obstaclePollingFrequencyHz"];
inline bool MotionConfiguration::_internal_has_obstacle_polling_frequency_hz() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionConfiguration::has_obstacle_polling_frequency_hz() const {
  return _internal_has_obstacle_polling_frequency_hz();
}
inline void MotionConfiguration::clear_obstacle_polling_frequency_hz() {
  obstacle_polling_frequency_hz_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double MotionConfiguration::_internal_obstacle_polling_frequency_hz() const {
  return obstacle_polling_frequency_hz_;
}
inline double MotionConfiguration::obstacle_polling_frequency_hz() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.obstacle_polling_frequency_hz)
  return _internal_obstacle_polling_frequency_hz();
}
inline void MotionConfiguration::_internal_set_obstacle_polling_frequency_hz(double value) {
  _has_bits_[0] |= 0x00000002u;
  obstacle_polling_frequency_hz_ = value;
}
inline void MotionConfiguration::set_obstacle_polling_frequency_hz(double value) {
  _internal_set_obstacle_polling_frequency_hz(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.obstacle_polling_frequency_hz)
}

// optional double plan_deviation_m = 4 [json_name = "planDeviationM"];
inline bool MotionConfiguration::_internal_has_plan_deviation_m() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionConfiguration::has_plan_deviation_m() const {
  return _internal_has_plan_deviation_m();
}
inline void MotionConfiguration::clear_plan_deviation_m() {
  plan_deviation_m_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double MotionConfiguration::_internal_plan_deviation_m() const {
  return plan_deviation_m_;
}
inline double MotionConfiguration::plan_deviation_m() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.plan_deviation_m)
  return _internal_plan_deviation_m();
}
inline void MotionConfiguration::_internal_set_plan_deviation_m(double value) {
  _has_bits_[0] |= 0x00000004u;
  plan_deviation_m_ = value;
}
inline void MotionConfiguration::set_plan_deviation_m(double value) {
  _internal_set_plan_deviation_m(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.plan_deviation_m)
}

// optional double linear_m_per_sec = 5 [json_name = "linearMPerSec"];
inline bool MotionConfiguration::_internal_has_linear_m_per_sec() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionConfiguration::has_linear_m_per_sec() const {
  return _internal_has_linear_m_per_sec();
}
inline void MotionConfiguration::clear_linear_m_per_sec() {
  linear_m_per_sec_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double MotionConfiguration::_internal_linear_m_per_sec() const {
  return linear_m_per_sec_;
}
inline double MotionConfiguration::linear_m_per_sec() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.linear_m_per_sec)
  return _internal_linear_m_per_sec();
}
inline void MotionConfiguration::_internal_set_linear_m_per_sec(double value) {
  _has_bits_[0] |= 0x00000008u;
  linear_m_per_sec_ = value;
}
inline void MotionConfiguration::set_linear_m_per_sec(double value) {
  _internal_set_linear_m_per_sec(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.linear_m_per_sec)
}

// optional double angular_degs_per_sec = 6 [json_name = "angularDegsPerSec"];
inline bool MotionConfiguration::_internal_has_angular_degs_per_sec() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotionConfiguration::has_angular_degs_per_sec() const {
  return _internal_has_angular_degs_per_sec();
}
inline void MotionConfiguration::clear_angular_degs_per_sec() {
  angular_degs_per_sec_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double MotionConfiguration::_internal_angular_degs_per_sec() const {
  return angular_degs_per_sec_;
}
inline double MotionConfiguration::angular_degs_per_sec() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MotionConfiguration.angular_degs_per_sec)
  return _internal_angular_degs_per_sec();
}
inline void MotionConfiguration::_internal_set_angular_degs_per_sec(double value) {
  _has_bits_[0] |= 0x00000010u;
  angular_degs_per_sec_ = value;
}
inline void MotionConfiguration::set_angular_degs_per_sec(double value) {
  _internal_set_angular_degs_per_sec(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MotionConfiguration.angular_degs_per_sec)
}

// -------------------------------------------------------------------

// MoveOnGlobeRequest

// string name = 1 [json_name = "name"];
inline void MoveOnGlobeRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MoveOnGlobeRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveOnGlobeRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnGlobeRequest.name)
}
inline std::string* MoveOnGlobeRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.name)
  return _s;
}
inline const std::string& MoveOnGlobeRequest::_internal_name() const {
  return name_.Get();
}
inline void MoveOnGlobeRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveOnGlobeRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveOnGlobeRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.name)
  return name_.Release();
}
inline void MoveOnGlobeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.name)
}

// .viam.common.v1.GeoPoint destination = 2 [json_name = "destination"];
inline bool MoveOnGlobeRequest::_internal_has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline bool MoveOnGlobeRequest::has_destination() const {
  return _internal_has_destination();
}
inline const ::viam::common::v1::GeoPoint& MoveOnGlobeRequest::_internal_destination() const {
  const ::viam::common::v1::GeoPoint* p = destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::GeoPoint&>(
      ::viam::common::v1::_GeoPoint_default_instance_);
}
inline const ::viam::common::v1::GeoPoint& MoveOnGlobeRequest::destination() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.destination)
  return _internal_destination();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_destination(
    ::viam::common::v1::GeoPoint* destination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  destination_ = destination;
  if (destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.destination)
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::release_destination() {
  
  ::viam::common::v1::GeoPoint* temp = destination_;
  destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.destination)
  
  ::viam::common::v1::GeoPoint* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::_internal_mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::GeoPoint>(GetArenaForAllocation());
    destination_ = p;
  }
  return destination_;
}
inline ::viam::common::v1::GeoPoint* MoveOnGlobeRequest::mutable_destination() {
  ::viam::common::v1::GeoPoint* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.destination)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_destination(::viam::common::v1::GeoPoint* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination));
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.destination)
}

// optional double heading = 3 [json_name = "heading"];
inline bool MoveOnGlobeRequest::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoveOnGlobeRequest::has_heading() const {
  return _internal_has_heading();
}
inline void MoveOnGlobeRequest::clear_heading() {
  heading_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double MoveOnGlobeRequest::_internal_heading() const {
  return heading_;
}
inline double MoveOnGlobeRequest::heading() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.heading)
  return _internal_heading();
}
inline void MoveOnGlobeRequest::_internal_set_heading(double value) {
  _has_bits_[0] |= 0x00000002u;
  heading_ = value;
}
inline void MoveOnGlobeRequest::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnGlobeRequest.heading)
}

// .viam.common.v1.ResourceName component_name = 4 [json_name = "componentName"];
inline bool MoveOnGlobeRequest::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool MoveOnGlobeRequest::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
  return _internal_component_name();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.component_name)
}

// .viam.common.v1.ResourceName movement_sensor_name = 5 [json_name = "movementSensorName"];
inline bool MoveOnGlobeRequest::_internal_has_movement_sensor_name() const {
  return this != internal_default_instance() && movement_sensor_name_ != nullptr;
}
inline bool MoveOnGlobeRequest::has_movement_sensor_name() const {
  return _internal_has_movement_sensor_name();
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::_internal_movement_sensor_name() const {
  const ::viam::common::v1::ResourceName* p = movement_sensor_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MoveOnGlobeRequest::movement_sensor_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
  return _internal_movement_sensor_name();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_movement_sensor_name(
    ::viam::common::v1::ResourceName* movement_sensor_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_sensor_name_);
  }
  movement_sensor_name_ = movement_sensor_name;
  if (movement_sensor_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::release_movement_sensor_name() {
  
  ::viam::common::v1::ResourceName* temp = movement_sensor_name_;
  movement_sensor_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::unsafe_arena_release_movement_sensor_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
  
  ::viam::common::v1::ResourceName* temp = movement_sensor_name_;
  movement_sensor_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::_internal_mutable_movement_sensor_name() {
  
  if (movement_sensor_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    movement_sensor_name_ = p;
  }
  return movement_sensor_name_;
}
inline ::viam::common::v1::ResourceName* MoveOnGlobeRequest::mutable_movement_sensor_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_movement_sensor_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_movement_sensor_name(::viam::common::v1::ResourceName* movement_sensor_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_sensor_name_);
  }
  if (movement_sensor_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_sensor_name));
    if (message_arena != submessage_arena) {
      movement_sensor_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, movement_sensor_name, submessage_arena);
    }
    
  } else {
    
  }
  movement_sensor_name_ = movement_sensor_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.movement_sensor_name)
}

// repeated .viam.common.v1.GeoGeometry obstacles = 6 [json_name = "obstacles"];
inline int MoveOnGlobeRequest::_internal_obstacles_size() const {
  return obstacles_.size();
}
inline int MoveOnGlobeRequest::obstacles_size() const {
  return _internal_obstacles_size();
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return obstacles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >*
MoveOnGlobeRequest::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return &obstacles_;
}
inline const ::viam::common::v1::GeoGeometry& MoveOnGlobeRequest::_internal_obstacles(int index) const {
  return obstacles_.Get(index);
}
inline const ::viam::common::v1::GeoGeometry& MoveOnGlobeRequest::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return _internal_obstacles(index);
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::_internal_add_obstacles() {
  return obstacles_.Add();
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::add_obstacles() {
  ::viam::common::v1::GeoGeometry* _add = _internal_add_obstacles();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >&
MoveOnGlobeRequest::obstacles() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MoveOnGlobeRequest.obstacles)
  return obstacles_;
}

// optional .viam.service.motion.v1.MotionConfiguration motion_configuration = 7 [json_name = "motionConfiguration"];
inline bool MoveOnGlobeRequest::_internal_has_motion_configuration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || motion_configuration_ != nullptr);
  return value;
}
inline bool MoveOnGlobeRequest::has_motion_configuration() const {
  return _internal_has_motion_configuration();
}
inline void MoveOnGlobeRequest::clear_motion_configuration() {
  if (motion_configuration_ != nullptr) motion_configuration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnGlobeRequest::_internal_motion_configuration() const {
  const ::viam::service::motion::v1::MotionConfiguration* p = motion_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::MotionConfiguration&>(
      ::viam::service::motion::v1::_MotionConfiguration_default_instance_);
}
inline const ::viam::service::motion::v1::MotionConfiguration& MoveOnGlobeRequest::motion_configuration() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
  return _internal_motion_configuration();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_motion_configuration(
    ::viam::service::motion::v1::MotionConfiguration* motion_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_configuration_);
  }
  motion_configuration_ = motion_configuration;
  if (motion_configuration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::release_motion_configuration() {
  _has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::MotionConfiguration* temp = motion_configuration_;
  motion_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::unsafe_arena_release_motion_configuration() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
  _has_bits_[0] &= ~0x00000001u;
  ::viam::service::motion::v1::MotionConfiguration* temp = motion_configuration_;
  motion_configuration_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::_internal_mutable_motion_configuration() {
  _has_bits_[0] |= 0x00000001u;
  if (motion_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::MotionConfiguration>(GetArenaForAllocation());
    motion_configuration_ = p;
  }
  return motion_configuration_;
}
inline ::viam::service::motion::v1::MotionConfiguration* MoveOnGlobeRequest::mutable_motion_configuration() {
  ::viam::service::motion::v1::MotionConfiguration* _msg = _internal_mutable_motion_configuration();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_motion_configuration(::viam::service::motion::v1::MotionConfiguration* motion_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete motion_configuration_;
  }
  if (motion_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motion_configuration);
    if (message_arena != submessage_arena) {
      motion_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion_configuration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  motion_configuration_ = motion_configuration;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.motion_configuration)
}

// repeated .viam.common.v1.GeoGeometry bounding_regions = 8 [json_name = "boundingRegions"];
inline int MoveOnGlobeRequest::_internal_bounding_regions_size() const {
  return bounding_regions_.size();
}
inline int MoveOnGlobeRequest::bounding_regions_size() const {
  return _internal_bounding_regions_size();
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::mutable_bounding_regions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return bounding_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >*
MoveOnGlobeRequest::mutable_bounding_regions() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return &bounding_regions_;
}
inline const ::viam::common::v1::GeoGeometry& MoveOnGlobeRequest::_internal_bounding_regions(int index) const {
  return bounding_regions_.Get(index);
}
inline const ::viam::common::v1::GeoGeometry& MoveOnGlobeRequest::bounding_regions(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return _internal_bounding_regions(index);
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::_internal_add_bounding_regions() {
  return bounding_regions_.Add();
}
inline ::viam::common::v1::GeoGeometry* MoveOnGlobeRequest::add_bounding_regions() {
  ::viam::common::v1::GeoGeometry* _add = _internal_add_bounding_regions();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::GeoGeometry >&
MoveOnGlobeRequest::bounding_regions() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.MoveOnGlobeRequest.bounding_regions)
  return bounding_regions_;
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool MoveOnGlobeRequest::_internal_has_extra() const {
  return this != internal_default_instance() && extra_ != nullptr;
}
inline bool MoveOnGlobeRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MoveOnGlobeRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MoveOnGlobeRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeRequest.extra)
  return _internal_extra();
}
inline void MoveOnGlobeRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnGlobeRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnGlobeRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnGlobeRequest::_internal_mutable_extra() {
  
  if (extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    extra_ = p;
  }
  return extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MoveOnGlobeRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeRequest.extra)
  return _msg;
}
inline void MoveOnGlobeRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeRequest.extra)
}

// -------------------------------------------------------------------

// MoveOnGlobeResponse

// string execution_id = 1 [json_name = "executionId"];
inline void MoveOnGlobeResponse::clear_execution_id() {
  execution_id_.ClearToEmpty();
}
inline const std::string& MoveOnGlobeResponse::execution_id() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveOnGlobeResponse::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
}
inline std::string* MoveOnGlobeResponse::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
  return _s;
}
inline const std::string& MoveOnGlobeResponse::_internal_execution_id() const {
  return execution_id_.Get();
}
inline void MoveOnGlobeResponse::_internal_set_execution_id(const std::string& value) {
  
  execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveOnGlobeResponse::_internal_mutable_execution_id() {
  
  return execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveOnGlobeResponse::release_execution_id() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
  return execution_id_.Release();
}
inline void MoveOnGlobeResponse::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (execution_id_.IsDefault()) {
    execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.MoveOnGlobeResponse.execution_id)
}

// -------------------------------------------------------------------

// GetPoseRequest

// string name = 1 [json_name = "name"];
inline void GetPoseRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetPoseRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPoseRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPoseRequest.name)
}
inline std::string* GetPoseRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.name)
  return _s;
}
inline const std::string& GetPoseRequest::_internal_name() const {
  return name_.Get();
}
inline void GetPoseRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPoseRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPoseRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.name)
  return name_.Release();
}
inline void GetPoseRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.name)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool GetPoseRequest::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool GetPoseRequest::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& GetPoseRequest::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& GetPoseRequest::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.component_name)
  return _internal_component_name();
}
inline void GetPoseRequest::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPoseRequest.component_name)
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* GetPoseRequest::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.component_name)
  return _msg;
}
inline void GetPoseRequest::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.component_name)
}

// string destination_frame = 3 [json_name = "destinationFrame"];
inline void GetPoseRequest::clear_destination_frame() {
  destination_frame_.ClearToEmpty();
}
inline const std::string& GetPoseRequest::destination_frame() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.destination_frame)
  return _internal_destination_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPoseRequest::set_destination_frame(ArgT0&& arg0, ArgT... args) {
 
 destination_frame_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPoseRequest.destination_frame)
}
inline std::string* GetPoseRequest::mutable_destination_frame() {
  std::string* _s = _internal_mutable_destination_frame();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.destination_frame)
  return _s;
}
inline const std::string& GetPoseRequest::_internal_destination_frame() const {
  return destination_frame_.Get();
}
inline void GetPoseRequest::_internal_set_destination_frame(const std::string& value) {
  
  destination_frame_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPoseRequest::_internal_mutable_destination_frame() {
  
  return destination_frame_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPoseRequest::release_destination_frame() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.destination_frame)
  return destination_frame_.Release();
}
inline void GetPoseRequest::set_allocated_destination_frame(std::string* destination_frame) {
  if (destination_frame != nullptr) {
    
  } else {
    
  }
  destination_frame_.SetAllocated(destination_frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_frame_.IsDefault()) {
    destination_frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.destination_frame)
}

// repeated .viam.common.v1.Transform supplemental_transforms = 4 [json_name = "supplementalTransforms"];
inline int GetPoseRequest::_internal_supplemental_transforms_size() const {
  return supplemental_transforms_.size();
}
inline int GetPoseRequest::supplemental_transforms_size() const {
  return _internal_supplemental_transforms_size();
}
inline ::viam::common::v1::Transform* GetPoseRequest::mutable_supplemental_transforms(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return supplemental_transforms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >*
GetPoseRequest::mutable_supplemental_transforms() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return &supplemental_transforms_;
}
inline const ::viam::common::v1::Transform& GetPoseRequest::_internal_supplemental_transforms(int index) const {
  return supplemental_transforms_.Get(index);
}
inline const ::viam::common::v1::Transform& GetPoseRequest::supplemental_transforms(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return _internal_supplemental_transforms(index);
}
inline ::viam::common::v1::Transform* GetPoseRequest::_internal_add_supplemental_transforms() {
  return supplemental_transforms_.Add();
}
inline ::viam::common::v1::Transform* GetPoseRequest::add_supplemental_transforms() {
  ::viam::common::v1::Transform* _add = _internal_add_supplemental_transforms();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >&
GetPoseRequest::supplemental_transforms() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.GetPoseRequest.supplemental_transforms)
  return supplemental_transforms_;
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetPoseRequest::_internal_has_extra() const {
  return this != internal_default_instance() && extra_ != nullptr;
}
inline bool GetPoseRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetPoseRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetPoseRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseRequest.extra)
  return _internal_extra();
}
inline void GetPoseRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPoseRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPoseRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPoseRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPoseRequest::_internal_mutable_extra() {
  
  if (extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    extra_ = p;
  }
  return extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPoseRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseRequest.extra)
  return _msg;
}
inline void GetPoseRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseRequest.extra)
}

// -------------------------------------------------------------------

// GetPoseResponse

// .viam.common.v1.PoseInFrame pose = 1 [json_name = "pose"];
inline bool GetPoseResponse::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool GetPoseResponse::has_pose() const {
  return _internal_has_pose();
}
inline const ::viam::common::v1::PoseInFrame& GetPoseResponse::_internal_pose() const {
  const ::viam::common::v1::PoseInFrame* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::PoseInFrame&>(
      ::viam::common::v1::_PoseInFrame_default_instance_);
}
inline const ::viam::common::v1::PoseInFrame& GetPoseResponse::pose() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPoseResponse.pose)
  return _internal_pose();
}
inline void GetPoseResponse::unsafe_arena_set_allocated_pose(
    ::viam::common::v1::PoseInFrame* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPoseResponse.pose)
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::release_pose() {
  
  ::viam::common::v1::PoseInFrame* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPoseResponse.pose)
  
  ::viam::common::v1::PoseInFrame* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::PoseInFrame>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::viam::common::v1::PoseInFrame* GetPoseResponse::mutable_pose() {
  ::viam::common::v1::PoseInFrame* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPoseResponse.pose)
  return _msg;
}
inline void GetPoseResponse::set_allocated_pose(::viam::common::v1::PoseInFrame* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPoseResponse.pose)
}

// -------------------------------------------------------------------

// StopPlanRequest

// string name = 1 [json_name = "name"];
inline void StopPlanRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& StopPlanRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.StopPlanRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopPlanRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.StopPlanRequest.name)
}
inline std::string* StopPlanRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.StopPlanRequest.name)
  return _s;
}
inline const std::string& StopPlanRequest::_internal_name() const {
  return name_.Get();
}
inline void StopPlanRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* StopPlanRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* StopPlanRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.StopPlanRequest.name)
  return name_.Release();
}
inline void StopPlanRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.StopPlanRequest.name)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool StopPlanRequest::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool StopPlanRequest::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& StopPlanRequest::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& StopPlanRequest::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.StopPlanRequest.component_name)
  return _internal_component_name();
}
inline void StopPlanRequest::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.StopPlanRequest.component_name)
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.StopPlanRequest.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* StopPlanRequest::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.StopPlanRequest.component_name)
  return _msg;
}
inline void StopPlanRequest::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.StopPlanRequest.component_name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool StopPlanRequest::_internal_has_extra() const {
  return this != internal_default_instance() && extra_ != nullptr;
}
inline bool StopPlanRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StopPlanRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StopPlanRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.StopPlanRequest.extra)
  return _internal_extra();
}
inline void StopPlanRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.StopPlanRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopPlanRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopPlanRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.StopPlanRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopPlanRequest::_internal_mutable_extra() {
  
  if (extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    extra_ = p;
  }
  return extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopPlanRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.StopPlanRequest.extra)
  return _msg;
}
inline void StopPlanRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.StopPlanRequest.extra)
}

// -------------------------------------------------------------------

// StopPlanResponse

// -------------------------------------------------------------------

// ListPlanStatusesRequest

// string name = 1 [json_name = "name"];
inline void ListPlanStatusesRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ListPlanStatusesRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPlanStatusesRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.ListPlanStatusesRequest.name)
}
inline std::string* ListPlanStatusesRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ListPlanStatusesRequest.name)
  return _s;
}
inline const std::string& ListPlanStatusesRequest::_internal_name() const {
  return name_.Get();
}
inline void ListPlanStatusesRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListPlanStatusesRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListPlanStatusesRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ListPlanStatusesRequest.name)
  return name_.Release();
}
inline void ListPlanStatusesRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ListPlanStatusesRequest.name)
}

// bool only_active_plans = 2 [json_name = "onlyActivePlans"];
inline void ListPlanStatusesRequest::clear_only_active_plans() {
  only_active_plans_ = false;
}
inline bool ListPlanStatusesRequest::_internal_only_active_plans() const {
  return only_active_plans_;
}
inline bool ListPlanStatusesRequest::only_active_plans() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesRequest.only_active_plans)
  return _internal_only_active_plans();
}
inline void ListPlanStatusesRequest::_internal_set_only_active_plans(bool value) {
  
  only_active_plans_ = value;
}
inline void ListPlanStatusesRequest::set_only_active_plans(bool value) {
  _internal_set_only_active_plans(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.ListPlanStatusesRequest.only_active_plans)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool ListPlanStatusesRequest::_internal_has_extra() const {
  return this != internal_default_instance() && extra_ != nullptr;
}
inline bool ListPlanStatusesRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListPlanStatusesRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListPlanStatusesRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesRequest.extra)
  return _internal_extra();
}
inline void ListPlanStatusesRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ListPlanStatusesRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListPlanStatusesRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListPlanStatusesRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ListPlanStatusesRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListPlanStatusesRequest::_internal_mutable_extra() {
  
  if (extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    extra_ = p;
  }
  return extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListPlanStatusesRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ListPlanStatusesRequest.extra)
  return _msg;
}
inline void ListPlanStatusesRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ListPlanStatusesRequest.extra)
}

// -------------------------------------------------------------------

// ListPlanStatusesResponse

// repeated .viam.service.motion.v1.PlanStatusWithID plan_statuses_with_ids = 1 [json_name = "planStatusesWithIds"];
inline int ListPlanStatusesResponse::_internal_plan_statuses_with_ids_size() const {
  return plan_statuses_with_ids_.size();
}
inline int ListPlanStatusesResponse::plan_statuses_with_ids_size() const {
  return _internal_plan_statuses_with_ids_size();
}
inline void ListPlanStatusesResponse::clear_plan_statuses_with_ids() {
  plan_statuses_with_ids_.Clear();
}
inline ::viam::service::motion::v1::PlanStatusWithID* ListPlanStatusesResponse::mutable_plan_statuses_with_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return plan_statuses_with_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID >*
ListPlanStatusesResponse::mutable_plan_statuses_with_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return &plan_statuses_with_ids_;
}
inline const ::viam::service::motion::v1::PlanStatusWithID& ListPlanStatusesResponse::_internal_plan_statuses_with_ids(int index) const {
  return plan_statuses_with_ids_.Get(index);
}
inline const ::viam::service::motion::v1::PlanStatusWithID& ListPlanStatusesResponse::plan_statuses_with_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return _internal_plan_statuses_with_ids(index);
}
inline ::viam::service::motion::v1::PlanStatusWithID* ListPlanStatusesResponse::_internal_add_plan_statuses_with_ids() {
  return plan_statuses_with_ids_.Add();
}
inline ::viam::service::motion::v1::PlanStatusWithID* ListPlanStatusesResponse::add_plan_statuses_with_ids() {
  ::viam::service::motion::v1::PlanStatusWithID* _add = _internal_add_plan_statuses_with_ids();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatusWithID >&
ListPlanStatusesResponse::plan_statuses_with_ids() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.ListPlanStatusesResponse.plan_statuses_with_ids)
  return plan_statuses_with_ids_;
}

// -------------------------------------------------------------------

// GetPlanRequest

// string name = 1 [json_name = "name"];
inline void GetPlanRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetPlanRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPlanRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPlanRequest.name)
}
inline std::string* GetPlanRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.name)
  return _s;
}
inline const std::string& GetPlanRequest::_internal_name() const {
  return name_.Get();
}
inline void GetPlanRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPlanRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPlanRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.name)
  return name_.Release();
}
inline void GetPlanRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.name)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool GetPlanRequest::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool GetPlanRequest::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& GetPlanRequest::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& GetPlanRequest::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.component_name)
  return _internal_component_name();
}
inline void GetPlanRequest::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPlanRequest.component_name)
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* GetPlanRequest::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.component_name)
  return _msg;
}
inline void GetPlanRequest::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.component_name)
}

// bool last_plan_only = 3 [json_name = "lastPlanOnly"];
inline void GetPlanRequest::clear_last_plan_only() {
  last_plan_only_ = false;
}
inline bool GetPlanRequest::_internal_last_plan_only() const {
  return last_plan_only_;
}
inline bool GetPlanRequest::last_plan_only() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.last_plan_only)
  return _internal_last_plan_only();
}
inline void GetPlanRequest::_internal_set_last_plan_only(bool value) {
  
  last_plan_only_ = value;
}
inline void GetPlanRequest::set_last_plan_only(bool value) {
  _internal_set_last_plan_only(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPlanRequest.last_plan_only)
}

// optional string execution_id = 4 [json_name = "executionId"];
inline bool GetPlanRequest::_internal_has_execution_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetPlanRequest::has_execution_id() const {
  return _internal_has_execution_id();
}
inline void GetPlanRequest::clear_execution_id() {
  execution_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetPlanRequest::execution_id() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPlanRequest::set_execution_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.GetPlanRequest.execution_id)
}
inline std::string* GetPlanRequest::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.execution_id)
  return _s;
}
inline const std::string& GetPlanRequest::_internal_execution_id() const {
  return execution_id_.Get();
}
inline void GetPlanRequest::_internal_set_execution_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPlanRequest::_internal_mutable_execution_id() {
  _has_bits_[0] |= 0x00000001u;
  return execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPlanRequest::release_execution_id() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.execution_id)
  if (!_internal_has_execution_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = execution_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (execution_id_.IsDefault()) {
    execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetPlanRequest::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (execution_id_.IsDefault()) {
    execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.execution_id)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetPlanRequest::_internal_has_extra() const {
  return this != internal_default_instance() && extra_ != nullptr;
}
inline bool GetPlanRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetPlanRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetPlanRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanRequest.extra)
  return _internal_extra();
}
inline void GetPlanRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPlanRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlanRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlanRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = extra_;
  extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlanRequest::_internal_mutable_extra() {
  
  if (extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    extra_ = p;
  }
  return extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlanRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanRequest.extra)
  return _msg;
}
inline void GetPlanRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanRequest.extra)
}

// -------------------------------------------------------------------

// GetPlanResponse

// .viam.service.motion.v1.PlanWithStatus current_plan_with_status = 1 [json_name = "currentPlanWithStatus"];
inline bool GetPlanResponse::_internal_has_current_plan_with_status() const {
  return this != internal_default_instance() && current_plan_with_status_ != nullptr;
}
inline bool GetPlanResponse::has_current_plan_with_status() const {
  return _internal_has_current_plan_with_status();
}
inline void GetPlanResponse::clear_current_plan_with_status() {
  if (GetArenaForAllocation() == nullptr && current_plan_with_status_ != nullptr) {
    delete current_plan_with_status_;
  }
  current_plan_with_status_ = nullptr;
}
inline const ::viam::service::motion::v1::PlanWithStatus& GetPlanResponse::_internal_current_plan_with_status() const {
  const ::viam::service::motion::v1::PlanWithStatus* p = current_plan_with_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::PlanWithStatus&>(
      ::viam::service::motion::v1::_PlanWithStatus_default_instance_);
}
inline const ::viam::service::motion::v1::PlanWithStatus& GetPlanResponse::current_plan_with_status() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
  return _internal_current_plan_with_status();
}
inline void GetPlanResponse::unsafe_arena_set_allocated_current_plan_with_status(
    ::viam::service::motion::v1::PlanWithStatus* current_plan_with_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_plan_with_status_);
  }
  current_plan_with_status_ = current_plan_with_status;
  if (current_plan_with_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::release_current_plan_with_status() {
  
  ::viam::service::motion::v1::PlanWithStatus* temp = current_plan_with_status_;
  current_plan_with_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::unsafe_arena_release_current_plan_with_status() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
  
  ::viam::service::motion::v1::PlanWithStatus* temp = current_plan_with_status_;
  current_plan_with_status_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::_internal_mutable_current_plan_with_status() {
  
  if (current_plan_with_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::PlanWithStatus>(GetArenaForAllocation());
    current_plan_with_status_ = p;
  }
  return current_plan_with_status_;
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::mutable_current_plan_with_status() {
  ::viam::service::motion::v1::PlanWithStatus* _msg = _internal_mutable_current_plan_with_status();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
  return _msg;
}
inline void GetPlanResponse::set_allocated_current_plan_with_status(::viam::service::motion::v1::PlanWithStatus* current_plan_with_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete current_plan_with_status_;
  }
  if (current_plan_with_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(current_plan_with_status);
    if (message_arena != submessage_arena) {
      current_plan_with_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_plan_with_status, submessage_arena);
    }
    
  } else {
    
  }
  current_plan_with_status_ = current_plan_with_status;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.GetPlanResponse.current_plan_with_status)
}

// repeated .viam.service.motion.v1.PlanWithStatus replan_history = 2 [json_name = "replanHistory"];
inline int GetPlanResponse::_internal_replan_history_size() const {
  return replan_history_.size();
}
inline int GetPlanResponse::replan_history_size() const {
  return _internal_replan_history_size();
}
inline void GetPlanResponse::clear_replan_history() {
  replan_history_.Clear();
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::mutable_replan_history(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.GetPlanResponse.replan_history)
  return replan_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus >*
GetPlanResponse::mutable_replan_history() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.GetPlanResponse.replan_history)
  return &replan_history_;
}
inline const ::viam::service::motion::v1::PlanWithStatus& GetPlanResponse::_internal_replan_history(int index) const {
  return replan_history_.Get(index);
}
inline const ::viam::service::motion::v1::PlanWithStatus& GetPlanResponse::replan_history(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.GetPlanResponse.replan_history)
  return _internal_replan_history(index);
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::_internal_add_replan_history() {
  return replan_history_.Add();
}
inline ::viam::service::motion::v1::PlanWithStatus* GetPlanResponse::add_replan_history() {
  ::viam::service::motion::v1::PlanWithStatus* _add = _internal_add_replan_history();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.GetPlanResponse.replan_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanWithStatus >&
GetPlanResponse::replan_history() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.GetPlanResponse.replan_history)
  return replan_history_;
}

// -------------------------------------------------------------------

// Constraints

// repeated .viam.service.motion.v1.LinearConstraint linear_constraint = 1 [json_name = "linearConstraint"];
inline int Constraints::_internal_linear_constraint_size() const {
  return linear_constraint_.size();
}
inline int Constraints::linear_constraint_size() const {
  return _internal_linear_constraint_size();
}
inline void Constraints::clear_linear_constraint() {
  linear_constraint_.Clear();
}
inline ::viam::service::motion::v1::LinearConstraint* Constraints::mutable_linear_constraint(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Constraints.linear_constraint)
  return linear_constraint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint >*
Constraints::mutable_linear_constraint() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Constraints.linear_constraint)
  return &linear_constraint_;
}
inline const ::viam::service::motion::v1::LinearConstraint& Constraints::_internal_linear_constraint(int index) const {
  return linear_constraint_.Get(index);
}
inline const ::viam::service::motion::v1::LinearConstraint& Constraints::linear_constraint(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Constraints.linear_constraint)
  return _internal_linear_constraint(index);
}
inline ::viam::service::motion::v1::LinearConstraint* Constraints::_internal_add_linear_constraint() {
  return linear_constraint_.Add();
}
inline ::viam::service::motion::v1::LinearConstraint* Constraints::add_linear_constraint() {
  ::viam::service::motion::v1::LinearConstraint* _add = _internal_add_linear_constraint();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Constraints.linear_constraint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::LinearConstraint >&
Constraints::linear_constraint() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Constraints.linear_constraint)
  return linear_constraint_;
}

// repeated .viam.service.motion.v1.OrientationConstraint orientation_constraint = 2 [json_name = "orientationConstraint"];
inline int Constraints::_internal_orientation_constraint_size() const {
  return orientation_constraint_.size();
}
inline int Constraints::orientation_constraint_size() const {
  return _internal_orientation_constraint_size();
}
inline void Constraints::clear_orientation_constraint() {
  orientation_constraint_.Clear();
}
inline ::viam::service::motion::v1::OrientationConstraint* Constraints::mutable_orientation_constraint(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Constraints.orientation_constraint)
  return orientation_constraint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint >*
Constraints::mutable_orientation_constraint() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Constraints.orientation_constraint)
  return &orientation_constraint_;
}
inline const ::viam::service::motion::v1::OrientationConstraint& Constraints::_internal_orientation_constraint(int index) const {
  return orientation_constraint_.Get(index);
}
inline const ::viam::service::motion::v1::OrientationConstraint& Constraints::orientation_constraint(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Constraints.orientation_constraint)
  return _internal_orientation_constraint(index);
}
inline ::viam::service::motion::v1::OrientationConstraint* Constraints::_internal_add_orientation_constraint() {
  return orientation_constraint_.Add();
}
inline ::viam::service::motion::v1::OrientationConstraint* Constraints::add_orientation_constraint() {
  ::viam::service::motion::v1::OrientationConstraint* _add = _internal_add_orientation_constraint();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Constraints.orientation_constraint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::OrientationConstraint >&
Constraints::orientation_constraint() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Constraints.orientation_constraint)
  return orientation_constraint_;
}

// repeated .viam.service.motion.v1.CollisionSpecification collision_specification = 3 [json_name = "collisionSpecification"];
inline int Constraints::_internal_collision_specification_size() const {
  return collision_specification_.size();
}
inline int Constraints::collision_specification_size() const {
  return _internal_collision_specification_size();
}
inline void Constraints::clear_collision_specification() {
  collision_specification_.Clear();
}
inline ::viam::service::motion::v1::CollisionSpecification* Constraints::mutable_collision_specification(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Constraints.collision_specification)
  return collision_specification_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification >*
Constraints::mutable_collision_specification() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Constraints.collision_specification)
  return &collision_specification_;
}
inline const ::viam::service::motion::v1::CollisionSpecification& Constraints::_internal_collision_specification(int index) const {
  return collision_specification_.Get(index);
}
inline const ::viam::service::motion::v1::CollisionSpecification& Constraints::collision_specification(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Constraints.collision_specification)
  return _internal_collision_specification(index);
}
inline ::viam::service::motion::v1::CollisionSpecification* Constraints::_internal_add_collision_specification() {
  return collision_specification_.Add();
}
inline ::viam::service::motion::v1::CollisionSpecification* Constraints::add_collision_specification() {
  ::viam::service::motion::v1::CollisionSpecification* _add = _internal_add_collision_specification();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Constraints.collision_specification)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification >&
Constraints::collision_specification() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Constraints.collision_specification)
  return collision_specification_;
}

// -------------------------------------------------------------------

// LinearConstraint

// optional float line_tolerance_mm = 1 [json_name = "lineToleranceMm"];
inline bool LinearConstraint::_internal_has_line_tolerance_mm() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinearConstraint::has_line_tolerance_mm() const {
  return _internal_has_line_tolerance_mm();
}
inline void LinearConstraint::clear_line_tolerance_mm() {
  line_tolerance_mm_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float LinearConstraint::_internal_line_tolerance_mm() const {
  return line_tolerance_mm_;
}
inline float LinearConstraint::line_tolerance_mm() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.LinearConstraint.line_tolerance_mm)
  return _internal_line_tolerance_mm();
}
inline void LinearConstraint::_internal_set_line_tolerance_mm(float value) {
  _has_bits_[0] |= 0x00000001u;
  line_tolerance_mm_ = value;
}
inline void LinearConstraint::set_line_tolerance_mm(float value) {
  _internal_set_line_tolerance_mm(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.LinearConstraint.line_tolerance_mm)
}

// optional float orientation_tolerance_degs = 2 [json_name = "orientationToleranceDegs"];
inline bool LinearConstraint::_internal_has_orientation_tolerance_degs() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LinearConstraint::has_orientation_tolerance_degs() const {
  return _internal_has_orientation_tolerance_degs();
}
inline void LinearConstraint::clear_orientation_tolerance_degs() {
  orientation_tolerance_degs_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float LinearConstraint::_internal_orientation_tolerance_degs() const {
  return orientation_tolerance_degs_;
}
inline float LinearConstraint::orientation_tolerance_degs() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.LinearConstraint.orientation_tolerance_degs)
  return _internal_orientation_tolerance_degs();
}
inline void LinearConstraint::_internal_set_orientation_tolerance_degs(float value) {
  _has_bits_[0] |= 0x00000002u;
  orientation_tolerance_degs_ = value;
}
inline void LinearConstraint::set_orientation_tolerance_degs(float value) {
  _internal_set_orientation_tolerance_degs(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.LinearConstraint.orientation_tolerance_degs)
}

// -------------------------------------------------------------------

// OrientationConstraint

// optional float orientation_tolerance_degs = 1 [json_name = "orientationToleranceDegs"];
inline bool OrientationConstraint::_internal_has_orientation_tolerance_degs() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrientationConstraint::has_orientation_tolerance_degs() const {
  return _internal_has_orientation_tolerance_degs();
}
inline void OrientationConstraint::clear_orientation_tolerance_degs() {
  orientation_tolerance_degs_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float OrientationConstraint::_internal_orientation_tolerance_degs() const {
  return orientation_tolerance_degs_;
}
inline float OrientationConstraint::orientation_tolerance_degs() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.OrientationConstraint.orientation_tolerance_degs)
  return _internal_orientation_tolerance_degs();
}
inline void OrientationConstraint::_internal_set_orientation_tolerance_degs(float value) {
  _has_bits_[0] |= 0x00000001u;
  orientation_tolerance_degs_ = value;
}
inline void OrientationConstraint::set_orientation_tolerance_degs(float value) {
  _internal_set_orientation_tolerance_degs(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.OrientationConstraint.orientation_tolerance_degs)
}

// -------------------------------------------------------------------

// CollisionSpecification_AllowedFrameCollisions

// string frame1 = 1 [json_name = "frame1"];
inline void CollisionSpecification_AllowedFrameCollisions::clear_frame1() {
  frame1_.ClearToEmpty();
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::frame1() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
  return _internal_frame1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollisionSpecification_AllowedFrameCollisions::set_frame1(ArgT0&& arg0, ArgT... args) {
 
 frame1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::mutable_frame1() {
  std::string* _s = _internal_mutable_frame1();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
  return _s;
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::_internal_frame1() const {
  return frame1_.Get();
}
inline void CollisionSpecification_AllowedFrameCollisions::_internal_set_frame1(const std::string& value) {
  
  frame1_.Set(value, GetArenaForAllocation());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::_internal_mutable_frame1() {
  
  return frame1_.Mutable(GetArenaForAllocation());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::release_frame1() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
  return frame1_.Release();
}
inline void CollisionSpecification_AllowedFrameCollisions::set_allocated_frame1(std::string* frame1) {
  if (frame1 != nullptr) {
    
  } else {
    
  }
  frame1_.SetAllocated(frame1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frame1_.IsDefault()) {
    frame1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame1)
}

// string frame2 = 2 [json_name = "frame2"];
inline void CollisionSpecification_AllowedFrameCollisions::clear_frame2() {
  frame2_.ClearToEmpty();
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::frame2() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
  return _internal_frame2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollisionSpecification_AllowedFrameCollisions::set_frame2(ArgT0&& arg0, ArgT... args) {
 
 frame2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::mutable_frame2() {
  std::string* _s = _internal_mutable_frame2();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
  return _s;
}
inline const std::string& CollisionSpecification_AllowedFrameCollisions::_internal_frame2() const {
  return frame2_.Get();
}
inline void CollisionSpecification_AllowedFrameCollisions::_internal_set_frame2(const std::string& value) {
  
  frame2_.Set(value, GetArenaForAllocation());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::_internal_mutable_frame2() {
  
  return frame2_.Mutable(GetArenaForAllocation());
}
inline std::string* CollisionSpecification_AllowedFrameCollisions::release_frame2() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
  return frame2_.Release();
}
inline void CollisionSpecification_AllowedFrameCollisions::set_allocated_frame2(std::string* frame2) {
  if (frame2 != nullptr) {
    
  } else {
    
  }
  frame2_.SetAllocated(frame2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frame2_.IsDefault()) {
    frame2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions.frame2)
}

// -------------------------------------------------------------------

// CollisionSpecification

// repeated .viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions allows = 1 [json_name = "allows"];
inline int CollisionSpecification::_internal_allows_size() const {
  return allows_.size();
}
inline int CollisionSpecification::allows_size() const {
  return _internal_allows_size();
}
inline void CollisionSpecification::clear_allows() {
  allows_.Clear();
}
inline ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* CollisionSpecification::mutable_allows(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.CollisionSpecification.allows)
  return allows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions >*
CollisionSpecification::mutable_allows() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.CollisionSpecification.allows)
  return &allows_;
}
inline const ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions& CollisionSpecification::_internal_allows(int index) const {
  return allows_.Get(index);
}
inline const ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions& CollisionSpecification::allows(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.CollisionSpecification.allows)
  return _internal_allows(index);
}
inline ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* CollisionSpecification::_internal_add_allows() {
  return allows_.Add();
}
inline ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* CollisionSpecification::add_allows() {
  ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions* _add = _internal_add_allows();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.CollisionSpecification.allows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::CollisionSpecification_AllowedFrameCollisions >&
CollisionSpecification::allows() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.CollisionSpecification.allows)
  return allows_;
}

// -------------------------------------------------------------------

// PlanWithStatus

// .viam.service.motion.v1.Plan plan = 1 [json_name = "plan"];
inline bool PlanWithStatus::_internal_has_plan() const {
  return this != internal_default_instance() && plan_ != nullptr;
}
inline bool PlanWithStatus::has_plan() const {
  return _internal_has_plan();
}
inline void PlanWithStatus::clear_plan() {
  if (GetArenaForAllocation() == nullptr && plan_ != nullptr) {
    delete plan_;
  }
  plan_ = nullptr;
}
inline const ::viam::service::motion::v1::Plan& PlanWithStatus::_internal_plan() const {
  const ::viam::service::motion::v1::Plan* p = plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::Plan&>(
      ::viam::service::motion::v1::_Plan_default_instance_);
}
inline const ::viam::service::motion::v1::Plan& PlanWithStatus::plan() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanWithStatus.plan)
  return _internal_plan();
}
inline void PlanWithStatus::unsafe_arena_set_allocated_plan(
    ::viam::service::motion::v1::Plan* plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  plan_ = plan;
  if (plan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanWithStatus.plan)
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::release_plan() {
  
  ::viam::service::motion::v1::Plan* temp = plan_;
  plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::unsafe_arena_release_plan() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanWithStatus.plan)
  
  ::viam::service::motion::v1::Plan* temp = plan_;
  plan_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::_internal_mutable_plan() {
  
  if (plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::Plan>(GetArenaForAllocation());
    plan_ = p;
  }
  return plan_;
}
inline ::viam::service::motion::v1::Plan* PlanWithStatus::mutable_plan() {
  ::viam::service::motion::v1::Plan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanWithStatus.plan)
  return _msg;
}
inline void PlanWithStatus::set_allocated_plan(::viam::service::motion::v1::Plan* plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete plan_;
  }
  if (plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(plan);
    if (message_arena != submessage_arena) {
      plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plan, submessage_arena);
    }
    
  } else {
    
  }
  plan_ = plan;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanWithStatus.plan)
}

// .viam.service.motion.v1.PlanStatus status = 2 [json_name = "status"];
inline bool PlanWithStatus::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool PlanWithStatus::has_status() const {
  return _internal_has_status();
}
inline void PlanWithStatus::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::viam::service::motion::v1::PlanStatus& PlanWithStatus::_internal_status() const {
  const ::viam::service::motion::v1::PlanStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::PlanStatus&>(
      ::viam::service::motion::v1::_PlanStatus_default_instance_);
}
inline const ::viam::service::motion::v1::PlanStatus& PlanWithStatus::status() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanWithStatus.status)
  return _internal_status();
}
inline void PlanWithStatus::unsafe_arena_set_allocated_status(
    ::viam::service::motion::v1::PlanStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanWithStatus.status)
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::release_status() {
  
  ::viam::service::motion::v1::PlanStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanWithStatus.status)
  
  ::viam::service::motion::v1::PlanStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::PlanStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::mutable_status() {
  ::viam::service::motion::v1::PlanStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanWithStatus.status)
  return _msg;
}
inline void PlanWithStatus::set_allocated_status(::viam::service::motion::v1::PlanStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanWithStatus.status)
}

// repeated .viam.service.motion.v1.PlanStatus status_history = 3 [json_name = "statusHistory"];
inline int PlanWithStatus::_internal_status_history_size() const {
  return status_history_.size();
}
inline int PlanWithStatus::status_history_size() const {
  return _internal_status_history_size();
}
inline void PlanWithStatus::clear_status_history() {
  status_history_.Clear();
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::mutable_status_history(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanWithStatus.status_history)
  return status_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus >*
PlanWithStatus::mutable_status_history() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.PlanWithStatus.status_history)
  return &status_history_;
}
inline const ::viam::service::motion::v1::PlanStatus& PlanWithStatus::_internal_status_history(int index) const {
  return status_history_.Get(index);
}
inline const ::viam::service::motion::v1::PlanStatus& PlanWithStatus::status_history(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanWithStatus.status_history)
  return _internal_status_history(index);
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::_internal_add_status_history() {
  return status_history_.Add();
}
inline ::viam::service::motion::v1::PlanStatus* PlanWithStatus::add_status_history() {
  ::viam::service::motion::v1::PlanStatus* _add = _internal_add_status_history();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.PlanWithStatus.status_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStatus >&
PlanWithStatus::status_history() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.PlanWithStatus.status_history)
  return status_history_;
}

// -------------------------------------------------------------------

// PlanStatusWithID

// string plan_id = 1 [json_name = "planId"];
inline void PlanStatusWithID::clear_plan_id() {
  plan_id_.ClearToEmpty();
}
inline const std::string& PlanStatusWithID::plan_id() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.plan_id)
  return _internal_plan_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanStatusWithID::set_plan_id(ArgT0&& arg0, ArgT... args) {
 
 plan_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatusWithID.plan_id)
}
inline std::string* PlanStatusWithID::mutable_plan_id() {
  std::string* _s = _internal_mutable_plan_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.plan_id)
  return _s;
}
inline const std::string& PlanStatusWithID::_internal_plan_id() const {
  return plan_id_.Get();
}
inline void PlanStatusWithID::_internal_set_plan_id(const std::string& value) {
  
  plan_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanStatusWithID::_internal_mutable_plan_id() {
  
  return plan_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanStatusWithID::release_plan_id() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.plan_id)
  return plan_id_.Release();
}
inline void PlanStatusWithID::set_allocated_plan_id(std::string* plan_id) {
  if (plan_id != nullptr) {
    
  } else {
    
  }
  plan_id_.SetAllocated(plan_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plan_id_.IsDefault()) {
    plan_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.plan_id)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool PlanStatusWithID::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool PlanStatusWithID::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& PlanStatusWithID::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& PlanStatusWithID::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.component_name)
  return _internal_component_name();
}
inline void PlanStatusWithID::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanStatusWithID.component_name)
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* PlanStatusWithID::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.component_name)
  return _msg;
}
inline void PlanStatusWithID::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.component_name)
}

// string execution_id = 3 [json_name = "executionId"];
inline void PlanStatusWithID::clear_execution_id() {
  execution_id_.ClearToEmpty();
}
inline const std::string& PlanStatusWithID::execution_id() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanStatusWithID::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatusWithID.execution_id)
}
inline std::string* PlanStatusWithID::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.execution_id)
  return _s;
}
inline const std::string& PlanStatusWithID::_internal_execution_id() const {
  return execution_id_.Get();
}
inline void PlanStatusWithID::_internal_set_execution_id(const std::string& value) {
  
  execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanStatusWithID::_internal_mutable_execution_id() {
  
  return execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanStatusWithID::release_execution_id() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.execution_id)
  return execution_id_.Release();
}
inline void PlanStatusWithID::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (execution_id_.IsDefault()) {
    execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.execution_id)
}

// .viam.service.motion.v1.PlanStatus status = 4 [json_name = "status"];
inline bool PlanStatusWithID::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool PlanStatusWithID::has_status() const {
  return _internal_has_status();
}
inline void PlanStatusWithID::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::viam::service::motion::v1::PlanStatus& PlanStatusWithID::_internal_status() const {
  const ::viam::service::motion::v1::PlanStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::service::motion::v1::PlanStatus&>(
      ::viam::service::motion::v1::_PlanStatus_default_instance_);
}
inline const ::viam::service::motion::v1::PlanStatus& PlanStatusWithID::status() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatusWithID.status)
  return _internal_status();
}
inline void PlanStatusWithID::unsafe_arena_set_allocated_status(
    ::viam::service::motion::v1::PlanStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanStatusWithID.status)
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::release_status() {
  
  ::viam::service::motion::v1::PlanStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatusWithID.status)
  
  ::viam::service::motion::v1::PlanStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::service::motion::v1::PlanStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::viam::service::motion::v1::PlanStatus* PlanStatusWithID::mutable_status() {
  ::viam::service::motion::v1::PlanStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatusWithID.status)
  return _msg;
}
inline void PlanStatusWithID::set_allocated_status(::viam::service::motion::v1::PlanStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatusWithID.status)
}

// -------------------------------------------------------------------

// PlanStatus

// .viam.service.motion.v1.PlanState state = 1 [json_name = "state"];
inline void PlanStatus::clear_state() {
  state_ = 0;
}
inline ::viam::service::motion::v1::PlanState PlanStatus::_internal_state() const {
  return static_cast< ::viam::service::motion::v1::PlanState >(state_);
}
inline ::viam::service::motion::v1::PlanState PlanStatus::state() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatus.state)
  return _internal_state();
}
inline void PlanStatus::_internal_set_state(::viam::service::motion::v1::PlanState value) {
  
  state_ = value;
}
inline void PlanStatus::set_state(::viam::service::motion::v1::PlanState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatus.state)
}

// .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
inline bool PlanStatus::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool PlanStatus::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PlanStatus::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PlanStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatus.timestamp)
  return _internal_timestamp();
}
inline void PlanStatus::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.PlanStatus.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PlanStatus::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PlanStatus::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatus.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PlanStatus::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PlanStatus::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatus.timestamp)
  return _msg;
}
inline void PlanStatus::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatus.timestamp)
}

// optional string reason = 3 [json_name = "reason"];
inline bool PlanStatus::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlanStatus::has_reason() const {
  return _internal_has_reason();
}
inline void PlanStatus::clear_reason() {
  reason_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlanStatus::reason() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.PlanStatus.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanStatus::set_reason(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.PlanStatus.reason)
}
inline std::string* PlanStatus::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.PlanStatus.reason)
  return _s;
}
inline const std::string& PlanStatus::_internal_reason() const {
  return reason_.Get();
}
inline void PlanStatus::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanStatus::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanStatus::release_reason() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.PlanStatus.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault()) {
    reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PlanStatus::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault()) {
    reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.PlanStatus.reason)
}

// -------------------------------------------------------------------

// Plan

// string id = 1 [json_name = "id"];
inline void Plan::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Plan::id() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plan::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.Plan.id)
}
inline std::string* Plan::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.id)
  return _s;
}
inline const std::string& Plan::_internal_id() const {
  return id_.Get();
}
inline void Plan::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Plan::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Plan::release_id() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.Plan.id)
  return id_.Release();
}
inline void Plan::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.Plan.id)
}

// .viam.common.v1.ResourceName component_name = 2 [json_name = "componentName"];
inline bool Plan::_internal_has_component_name() const {
  return this != internal_default_instance() && component_name_ != nullptr;
}
inline bool Plan::has_component_name() const {
  return _internal_has_component_name();
}
inline const ::viam::common::v1::ResourceName& Plan::_internal_component_name() const {
  const ::viam::common::v1::ResourceName* p = component_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& Plan::component_name() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.component_name)
  return _internal_component_name();
}
inline void Plan::unsafe_arena_set_allocated_component_name(
    ::viam::common::v1::ResourceName* component_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  component_name_ = component_name;
  if (component_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.Plan.component_name)
}
inline ::viam::common::v1::ResourceName* Plan::release_component_name() {
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* Plan::unsafe_arena_release_component_name() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.Plan.component_name)
  
  ::viam::common::v1::ResourceName* temp = component_name_;
  component_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* Plan::_internal_mutable_component_name() {
  
  if (component_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    component_name_ = p;
  }
  return component_name_;
}
inline ::viam::common::v1::ResourceName* Plan::mutable_component_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.component_name)
  return _msg;
}
inline void Plan::set_allocated_component_name(::viam::common::v1::ResourceName* component_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name_);
  }
  if (component_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(component_name));
    if (message_arena != submessage_arena) {
      component_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, component_name, submessage_arena);
    }
    
  } else {
    
  }
  component_name_ = component_name;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.Plan.component_name)
}

// string execution_id = 3 [json_name = "executionId"];
inline void Plan::clear_execution_id() {
  execution_id_.ClearToEmpty();
}
inline const std::string& Plan::execution_id() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plan::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.motion.v1.Plan.execution_id)
}
inline std::string* Plan::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.execution_id)
  return _s;
}
inline const std::string& Plan::_internal_execution_id() const {
  return execution_id_.Get();
}
inline void Plan::_internal_set_execution_id(const std::string& value) {
  
  execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Plan::_internal_mutable_execution_id() {
  
  return execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Plan::release_execution_id() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.Plan.execution_id)
  return execution_id_.Release();
}
inline void Plan::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (execution_id_.IsDefault()) {
    execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.Plan.execution_id)
}

// repeated .viam.service.motion.v1.PlanStep steps = 4 [json_name = "steps"];
inline int Plan::_internal_steps_size() const {
  return steps_.size();
}
inline int Plan::steps_size() const {
  return _internal_steps_size();
}
inline void Plan::clear_steps() {
  steps_.Clear();
}
inline ::viam::service::motion::v1::PlanStep* Plan::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.Plan.steps)
  return steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStep >*
Plan::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.motion.v1.Plan.steps)
  return &steps_;
}
inline const ::viam::service::motion::v1::PlanStep& Plan::_internal_steps(int index) const {
  return steps_.Get(index);
}
inline const ::viam::service::motion::v1::PlanStep& Plan::steps(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.Plan.steps)
  return _internal_steps(index);
}
inline ::viam::service::motion::v1::PlanStep* Plan::_internal_add_steps() {
  return steps_.Add();
}
inline ::viam::service::motion::v1::PlanStep* Plan::add_steps() {
  ::viam::service::motion::v1::PlanStep* _add = _internal_add_steps();
  // @@protoc_insertion_point(field_add:viam.service.motion.v1.Plan.steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::motion::v1::PlanStep >&
Plan::steps() const {
  // @@protoc_insertion_point(field_list:viam.service.motion.v1.Plan.steps)
  return steps_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PlanStep

// map<string, .viam.service.motion.v1.ComponentState> step = 1 [json_name = "step"];
inline int PlanStep::_internal_step_size() const {
  return step_.size();
}
inline int PlanStep::step_size() const {
  return _internal_step_size();
}
inline void PlanStep::clear_step() {
  step_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >&
PlanStep::_internal_step() const {
  return step_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >&
PlanStep::step() const {
  // @@protoc_insertion_point(field_map:viam.service.motion.v1.PlanStep.step)
  return _internal_step();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >*
PlanStep::_internal_mutable_step() {
  return step_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::service::motion::v1::ComponentState >*
PlanStep::mutable_step() {
  // @@protoc_insertion_point(field_mutable_map:viam.service.motion.v1.PlanStep.step)
  return _internal_mutable_step();
}

// -------------------------------------------------------------------

// ComponentState

// .viam.common.v1.Pose pose = 1 [json_name = "pose"];
inline bool ComponentState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool ComponentState::has_pose() const {
  return _internal_has_pose();
}
inline const ::viam::common::v1::Pose& ComponentState::_internal_pose() const {
  const ::viam::common::v1::Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::Pose&>(
      ::viam::common::v1::_Pose_default_instance_);
}
inline const ::viam::common::v1::Pose& ComponentState::pose() const {
  // @@protoc_insertion_point(field_get:viam.service.motion.v1.ComponentState.pose)
  return _internal_pose();
}
inline void ComponentState::unsafe_arena_set_allocated_pose(
    ::viam::common::v1::Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.motion.v1.ComponentState.pose)
}
inline ::viam::common::v1::Pose* ComponentState::release_pose() {
  
  ::viam::common::v1::Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::Pose* ComponentState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:viam.service.motion.v1.ComponentState.pose)
  
  ::viam::common::v1::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::viam::common::v1::Pose* ComponentState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::viam::common::v1::Pose* ComponentState::mutable_pose() {
  ::viam::common::v1::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:viam.service.motion.v1.ComponentState.pose)
  return _msg;
}
inline void ComponentState::set_allocated_pose(::viam::common::v1::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:viam.service.motion.v1.ComponentState.pose)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace motion
}  // namespace service
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::service::motion::v1::PlanState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::service::motion::v1::PlanState>() {
  return ::viam::service::motion::v1::PlanState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_2fmotion_2fv1_2fmotion_2eproto
