// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/rpc/webrtc/v1/signaling.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/api/annotations.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
namespace proto {
namespace rpc {
namespace webrtc {
namespace v1 {
class AnswerRequest;
struct AnswerRequestDefaultTypeInternal;
extern AnswerRequestDefaultTypeInternal _AnswerRequest_default_instance_;
class AnswerRequestDoneStage;
struct AnswerRequestDoneStageDefaultTypeInternal;
extern AnswerRequestDoneStageDefaultTypeInternal _AnswerRequestDoneStage_default_instance_;
class AnswerRequestErrorStage;
struct AnswerRequestErrorStageDefaultTypeInternal;
extern AnswerRequestErrorStageDefaultTypeInternal _AnswerRequestErrorStage_default_instance_;
class AnswerRequestHeartbeatStage;
struct AnswerRequestHeartbeatStageDefaultTypeInternal;
extern AnswerRequestHeartbeatStageDefaultTypeInternal _AnswerRequestHeartbeatStage_default_instance_;
class AnswerRequestInitStage;
struct AnswerRequestInitStageDefaultTypeInternal;
extern AnswerRequestInitStageDefaultTypeInternal _AnswerRequestInitStage_default_instance_;
class AnswerRequestUpdateStage;
struct AnswerRequestUpdateStageDefaultTypeInternal;
extern AnswerRequestUpdateStageDefaultTypeInternal _AnswerRequestUpdateStage_default_instance_;
class AnswerResponse;
struct AnswerResponseDefaultTypeInternal;
extern AnswerResponseDefaultTypeInternal _AnswerResponse_default_instance_;
class AnswerResponseDoneStage;
struct AnswerResponseDoneStageDefaultTypeInternal;
extern AnswerResponseDoneStageDefaultTypeInternal _AnswerResponseDoneStage_default_instance_;
class AnswerResponseErrorStage;
struct AnswerResponseErrorStageDefaultTypeInternal;
extern AnswerResponseErrorStageDefaultTypeInternal _AnswerResponseErrorStage_default_instance_;
class AnswerResponseInitStage;
struct AnswerResponseInitStageDefaultTypeInternal;
extern AnswerResponseInitStageDefaultTypeInternal _AnswerResponseInitStage_default_instance_;
class AnswerResponseUpdateStage;
struct AnswerResponseUpdateStageDefaultTypeInternal;
extern AnswerResponseUpdateStageDefaultTypeInternal _AnswerResponseUpdateStage_default_instance_;
class CallRequest;
struct CallRequestDefaultTypeInternal;
extern CallRequestDefaultTypeInternal _CallRequest_default_instance_;
class CallResponse;
struct CallResponseDefaultTypeInternal;
extern CallResponseDefaultTypeInternal _CallResponse_default_instance_;
class CallResponseInitStage;
struct CallResponseInitStageDefaultTypeInternal;
extern CallResponseInitStageDefaultTypeInternal _CallResponseInitStage_default_instance_;
class CallResponseUpdateStage;
struct CallResponseUpdateStageDefaultTypeInternal;
extern CallResponseUpdateStageDefaultTypeInternal _CallResponseUpdateStage_default_instance_;
class CallUpdateRequest;
struct CallUpdateRequestDefaultTypeInternal;
extern CallUpdateRequestDefaultTypeInternal _CallUpdateRequest_default_instance_;
class CallUpdateResponse;
struct CallUpdateResponseDefaultTypeInternal;
extern CallUpdateResponseDefaultTypeInternal _CallUpdateResponse_default_instance_;
class ICECandidate;
struct ICECandidateDefaultTypeInternal;
extern ICECandidateDefaultTypeInternal _ICECandidate_default_instance_;
class ICEServer;
struct ICEServerDefaultTypeInternal;
extern ICEServerDefaultTypeInternal _ICEServer_default_instance_;
class OptionalWebRTCConfigRequest;
struct OptionalWebRTCConfigRequestDefaultTypeInternal;
extern OptionalWebRTCConfigRequestDefaultTypeInternal _OptionalWebRTCConfigRequest_default_instance_;
class OptionalWebRTCConfigResponse;
struct OptionalWebRTCConfigResponseDefaultTypeInternal;
extern OptionalWebRTCConfigResponseDefaultTypeInternal _OptionalWebRTCConfigResponse_default_instance_;
class WebRTCConfig;
struct WebRTCConfigDefaultTypeInternal;
extern WebRTCConfigDefaultTypeInternal _WebRTCConfig_default_instance_;
}  // namespace v1
}  // namespace webrtc
}  // namespace rpc
}  // namespace proto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace proto {
namespace rpc {
namespace webrtc {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class OptionalWebRTCConfigRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.OptionalWebRTCConfigRequest) */ {
 public:
  inline OptionalWebRTCConfigRequest() : OptionalWebRTCConfigRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalWebRTCConfigRequest(::google::protobuf::internal::ConstantInitialized);

  inline OptionalWebRTCConfigRequest(const OptionalWebRTCConfigRequest& from)
      : OptionalWebRTCConfigRequest(nullptr, from) {}
  OptionalWebRTCConfigRequest(OptionalWebRTCConfigRequest&& from) noexcept
    : OptionalWebRTCConfigRequest() {
    *this = ::std::move(from);
  }

  inline OptionalWebRTCConfigRequest& operator=(const OptionalWebRTCConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalWebRTCConfigRequest& operator=(OptionalWebRTCConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalWebRTCConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionalWebRTCConfigRequest* internal_default_instance() {
    return reinterpret_cast<const OptionalWebRTCConfigRequest*>(
               &_OptionalWebRTCConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(OptionalWebRTCConfigRequest& a, OptionalWebRTCConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionalWebRTCConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalWebRTCConfigRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalWebRTCConfigRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptionalWebRTCConfigRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OptionalWebRTCConfigRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OptionalWebRTCConfigRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.OptionalWebRTCConfigRequest";
  }
  protected:
  explicit OptionalWebRTCConfigRequest(::google::protobuf::Arena* arena);
  OptionalWebRTCConfigRequest(::google::protobuf::Arena* arena, const OptionalWebRTCConfigRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.OptionalWebRTCConfigRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class ICEServer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.ICEServer) */ {
 public:
  inline ICEServer() : ICEServer(nullptr) {}
  ~ICEServer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ICEServer(::google::protobuf::internal::ConstantInitialized);

  inline ICEServer(const ICEServer& from)
      : ICEServer(nullptr, from) {}
  ICEServer(ICEServer&& from) noexcept
    : ICEServer() {
    *this = ::std::move(from);
  }

  inline ICEServer& operator=(const ICEServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICEServer& operator=(ICEServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICEServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ICEServer* internal_default_instance() {
    return reinterpret_cast<const ICEServer*>(
               &_ICEServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ICEServer& a, ICEServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ICEServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICEServer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICEServer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICEServer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ICEServer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ICEServer& from) {
    ICEServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ICEServer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.ICEServer";
  }
  protected:
  explicit ICEServer(::google::protobuf::Arena* arena);
  ICEServer(::google::protobuf::Arena* arena, const ICEServer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kCredentialFieldNumber = 3,
  };
  // repeated string urls = 1 [json_name = "urls"];
  int urls_size() const;
  private:
  int _internal_urls_size() const;

  public:
  void clear_urls() ;
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, std::size_t size);
  void set_urls(int index, absl::string_view value);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, std::size_t size);
  void add_urls(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_urls();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_urls();

  public:
  // string username = 2 [json_name = "username"];
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string credential = 3 [json_name = "credential"];
  void clear_credential() ;
  const std::string& credential() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_credential(Arg_&& arg, Args_... args);
  std::string* mutable_credential();
  PROTOBUF_NODISCARD std::string* release_credential();
  void set_allocated_credential(std::string* value);

  private:
  const std::string& _internal_credential() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credential(
      const std::string& value);
  std::string* _internal_mutable_credential();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.ICEServer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> urls_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr credential_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class ICECandidate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.ICECandidate) */ {
 public:
  inline ICECandidate() : ICECandidate(nullptr) {}
  ~ICECandidate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ICECandidate(::google::protobuf::internal::ConstantInitialized);

  inline ICECandidate(const ICECandidate& from)
      : ICECandidate(nullptr, from) {}
  ICECandidate(ICECandidate&& from) noexcept
    : ICECandidate() {
    *this = ::std::move(from);
  }

  inline ICECandidate& operator=(const ICECandidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICECandidate& operator=(ICECandidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICECandidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ICECandidate* internal_default_instance() {
    return reinterpret_cast<const ICECandidate*>(
               &_ICECandidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ICECandidate& a, ICECandidate& b) {
    a.Swap(&b);
  }
  inline void Swap(ICECandidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICECandidate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICECandidate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICECandidate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ICECandidate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ICECandidate& from) {
    ICECandidate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ICECandidate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.ICECandidate";
  }
  protected:
  explicit ICECandidate(::google::protobuf::Arena* arena);
  ICECandidate(::google::protobuf::Arena* arena, const ICECandidate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
    kSdpMidFieldNumber = 2,
    kUsernameFragmentFieldNumber = 4,
    kSdpmLineIndexFieldNumber = 3,
  };
  // string candidate = 1 [json_name = "candidate"];
  void clear_candidate() ;
  const std::string& candidate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_candidate(Arg_&& arg, Args_... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* value);

  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(
      const std::string& value);
  std::string* _internal_mutable_candidate();

  public:
  // optional string sdp_mid = 2 [json_name = "sdpMid"];
  bool has_sdp_mid() const;
  void clear_sdp_mid() ;
  const std::string& sdp_mid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdp_mid(Arg_&& arg, Args_... args);
  std::string* mutable_sdp_mid();
  PROTOBUF_NODISCARD std::string* release_sdp_mid();
  void set_allocated_sdp_mid(std::string* value);

  private:
  const std::string& _internal_sdp_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp_mid(
      const std::string& value);
  std::string* _internal_mutable_sdp_mid();

  public:
  // optional string username_fragment = 4 [json_name = "usernameFragment"];
  bool has_username_fragment() const;
  void clear_username_fragment() ;
  const std::string& username_fragment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username_fragment(Arg_&& arg, Args_... args);
  std::string* mutable_username_fragment();
  PROTOBUF_NODISCARD std::string* release_username_fragment();
  void set_allocated_username_fragment(std::string* value);

  private:
  const std::string& _internal_username_fragment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username_fragment(
      const std::string& value);
  std::string* _internal_mutable_username_fragment();

  public:
  // optional uint32 sdpm_line_index = 3 [json_name = "sdpmLineIndex"];
  bool has_sdpm_line_index() const;
  void clear_sdpm_line_index() ;
  ::uint32_t sdpm_line_index() const;
  void set_sdpm_line_index(::uint32_t value);

  private:
  ::uint32_t _internal_sdpm_line_index() const;
  void _internal_set_sdpm_line_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.ICECandidate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr candidate_;
    ::google::protobuf::internal::ArenaStringPtr sdp_mid_;
    ::google::protobuf::internal::ArenaStringPtr username_fragment_;
    ::uint32_t sdpm_line_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class CallUpdateResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallUpdateResponse) */ {
 public:
  inline CallUpdateResponse() : CallUpdateResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CallUpdateResponse(::google::protobuf::internal::ConstantInitialized);

  inline CallUpdateResponse(const CallUpdateResponse& from)
      : CallUpdateResponse(nullptr, from) {}
  CallUpdateResponse(CallUpdateResponse&& from) noexcept
    : CallUpdateResponse() {
    *this = ::std::move(from);
  }

  inline CallUpdateResponse& operator=(const CallUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallUpdateResponse& operator=(CallUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const CallUpdateResponse*>(
               &_CallUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CallUpdateResponse& a, CallUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallUpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallUpdateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallUpdateResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CallUpdateResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CallUpdateResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.CallUpdateResponse";
  }
  protected:
  explicit CallUpdateResponse(::google::protobuf::Arena* arena);
  CallUpdateResponse(::google::protobuf::Arena* arena, const CallUpdateResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallUpdateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class CallResponseInitStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallResponseInitStage) */ {
 public:
  inline CallResponseInitStage() : CallResponseInitStage(nullptr) {}
  ~CallResponseInitStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CallResponseInitStage(::google::protobuf::internal::ConstantInitialized);

  inline CallResponseInitStage(const CallResponseInitStage& from)
      : CallResponseInitStage(nullptr, from) {}
  CallResponseInitStage(CallResponseInitStage&& from) noexcept
    : CallResponseInitStage() {
    *this = ::std::move(from);
  }

  inline CallResponseInitStage& operator=(const CallResponseInitStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponseInitStage& operator=(CallResponseInitStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponseInitStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallResponseInitStage* internal_default_instance() {
    return reinterpret_cast<const CallResponseInitStage*>(
               &_CallResponseInitStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CallResponseInitStage& a, CallResponseInitStage& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponseInitStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponseInitStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponseInitStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponseInitStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CallResponseInitStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CallResponseInitStage& from) {
    CallResponseInitStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CallResponseInitStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.CallResponseInitStage";
  }
  protected:
  explicit CallResponseInitStage(::google::protobuf::Arena* arena);
  CallResponseInitStage(::google::protobuf::Arena* arena, const CallResponseInitStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp() ;
  const std::string& sdp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdp(Arg_&& arg, Args_... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* value);

  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(
      const std::string& value);
  std::string* _internal_mutable_sdp();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallResponseInitStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sdp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class CallRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallRequest) */ {
 public:
  inline CallRequest() : CallRequest(nullptr) {}
  ~CallRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CallRequest(::google::protobuf::internal::ConstantInitialized);

  inline CallRequest(const CallRequest& from)
      : CallRequest(nullptr, from) {}
  CallRequest(CallRequest&& from) noexcept
    : CallRequest() {
    *this = ::std::move(from);
  }

  inline CallRequest& operator=(const CallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallRequest& operator=(CallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallRequest* internal_default_instance() {
    return reinterpret_cast<const CallRequest*>(
               &_CallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CallRequest& a, CallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CallRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CallRequest& from) {
    CallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CallRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.CallRequest";
  }
  protected:
  explicit CallRequest(::google::protobuf::Arena* arena);
  CallRequest(::google::protobuf::Arena* arena, const CallRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
    kDisableTrickleFieldNumber = 2,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp() ;
  const std::string& sdp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdp(Arg_&& arg, Args_... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* value);

  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(
      const std::string& value);
  std::string* _internal_mutable_sdp();

  public:
  // bool disable_trickle = 2 [json_name = "disableTrickle"];
  void clear_disable_trickle() ;
  bool disable_trickle() const;
  void set_disable_trickle(bool value);

  private:
  bool _internal_disable_trickle() const;
  void _internal_set_disable_trickle(bool value);

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sdp_;
    bool disable_trickle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerResponseInitStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseInitStage) */ {
 public:
  inline AnswerResponseInitStage() : AnswerResponseInitStage(nullptr) {}
  ~AnswerResponseInitStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerResponseInitStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerResponseInitStage(const AnswerResponseInitStage& from)
      : AnswerResponseInitStage(nullptr, from) {}
  AnswerResponseInitStage(AnswerResponseInitStage&& from) noexcept
    : AnswerResponseInitStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseInitStage& operator=(const AnswerResponseInitStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseInitStage& operator=(AnswerResponseInitStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseInitStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseInitStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseInitStage*>(
               &_AnswerResponseInitStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AnswerResponseInitStage& a, AnswerResponseInitStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseInitStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseInitStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseInitStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseInitStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerResponseInitStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerResponseInitStage& from) {
    AnswerResponseInitStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerResponseInitStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseInitStage";
  }
  protected:
  explicit AnswerResponseInitStage(::google::protobuf::Arena* arena);
  AnswerResponseInitStage(::google::protobuf::Arena* arena, const AnswerResponseInitStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp() ;
  const std::string& sdp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdp(Arg_&& arg, Args_... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* value);

  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(
      const std::string& value);
  std::string* _internal_mutable_sdp();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseInitStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sdp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerResponseDoneStage final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseDoneStage) */ {
 public:
  inline AnswerResponseDoneStage() : AnswerResponseDoneStage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerResponseDoneStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerResponseDoneStage(const AnswerResponseDoneStage& from)
      : AnswerResponseDoneStage(nullptr, from) {}
  AnswerResponseDoneStage(AnswerResponseDoneStage&& from) noexcept
    : AnswerResponseDoneStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseDoneStage& operator=(const AnswerResponseDoneStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseDoneStage& operator=(AnswerResponseDoneStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseDoneStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseDoneStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseDoneStage*>(
               &_AnswerResponseDoneStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AnswerResponseDoneStage& a, AnswerResponseDoneStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseDoneStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseDoneStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseDoneStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseDoneStage>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnswerResponseDoneStage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnswerResponseDoneStage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseDoneStage";
  }
  protected:
  explicit AnswerResponseDoneStage(::google::protobuf::Arena* arena);
  AnswerResponseDoneStage(::google::protobuf::Arena* arena, const AnswerResponseDoneStage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseDoneStage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerRequestHeartbeatStage final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestHeartbeatStage) */ {
 public:
  inline AnswerRequestHeartbeatStage() : AnswerRequestHeartbeatStage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerRequestHeartbeatStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerRequestHeartbeatStage(const AnswerRequestHeartbeatStage& from)
      : AnswerRequestHeartbeatStage(nullptr, from) {}
  AnswerRequestHeartbeatStage(AnswerRequestHeartbeatStage&& from) noexcept
    : AnswerRequestHeartbeatStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestHeartbeatStage& operator=(const AnswerRequestHeartbeatStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestHeartbeatStage& operator=(AnswerRequestHeartbeatStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestHeartbeatStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestHeartbeatStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestHeartbeatStage*>(
               &_AnswerRequestHeartbeatStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AnswerRequestHeartbeatStage& a, AnswerRequestHeartbeatStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestHeartbeatStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestHeartbeatStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestHeartbeatStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestHeartbeatStage>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnswerRequestHeartbeatStage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnswerRequestHeartbeatStage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestHeartbeatStage";
  }
  protected:
  explicit AnswerRequestHeartbeatStage(::google::protobuf::Arena* arena);
  AnswerRequestHeartbeatStage(::google::protobuf::Arena* arena, const AnswerRequestHeartbeatStage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestHeartbeatStage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerRequestDoneStage final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestDoneStage) */ {
 public:
  inline AnswerRequestDoneStage() : AnswerRequestDoneStage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerRequestDoneStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerRequestDoneStage(const AnswerRequestDoneStage& from)
      : AnswerRequestDoneStage(nullptr, from) {}
  AnswerRequestDoneStage(AnswerRequestDoneStage&& from) noexcept
    : AnswerRequestDoneStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestDoneStage& operator=(const AnswerRequestDoneStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestDoneStage& operator=(AnswerRequestDoneStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestDoneStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestDoneStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestDoneStage*>(
               &_AnswerRequestDoneStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AnswerRequestDoneStage& a, AnswerRequestDoneStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestDoneStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestDoneStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestDoneStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestDoneStage>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnswerRequestDoneStage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnswerRequestDoneStage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestDoneStage";
  }
  protected:
  explicit AnswerRequestDoneStage(::google::protobuf::Arena* arena);
  AnswerRequestDoneStage(::google::protobuf::Arena* arena, const AnswerRequestDoneStage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestDoneStage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class WebRTCConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.WebRTCConfig) */ {
 public:
  inline WebRTCConfig() : WebRTCConfig(nullptr) {}
  ~WebRTCConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WebRTCConfig(::google::protobuf::internal::ConstantInitialized);

  inline WebRTCConfig(const WebRTCConfig& from)
      : WebRTCConfig(nullptr, from) {}
  WebRTCConfig(WebRTCConfig&& from) noexcept
    : WebRTCConfig() {
    *this = ::std::move(from);
  }

  inline WebRTCConfig& operator=(const WebRTCConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebRTCConfig& operator=(WebRTCConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebRTCConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebRTCConfig* internal_default_instance() {
    return reinterpret_cast<const WebRTCConfig*>(
               &_WebRTCConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WebRTCConfig& a, WebRTCConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(WebRTCConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebRTCConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebRTCConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebRTCConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WebRTCConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WebRTCConfig& from) {
    WebRTCConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WebRTCConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.WebRTCConfig";
  }
  protected:
  explicit WebRTCConfig(::google::protobuf::Arena* arena);
  WebRTCConfig(::google::protobuf::Arena* arena, const WebRTCConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalIceServersFieldNumber = 1,
    kDisableTrickleFieldNumber = 2,
  };
  // repeated .proto.rpc.webrtc.v1.ICEServer additional_ice_servers = 1 [json_name = "additionalIceServers"];
  int additional_ice_servers_size() const;
  private:
  int _internal_additional_ice_servers_size() const;

  public:
  void clear_additional_ice_servers() ;
  ::proto::rpc::webrtc::v1::ICEServer* mutable_additional_ice_servers(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer >*
      mutable_additional_ice_servers();
  private:
  const ::google::protobuf::RepeatedPtrField<::proto::rpc::webrtc::v1::ICEServer>& _internal_additional_ice_servers() const;
  ::google::protobuf::RepeatedPtrField<::proto::rpc::webrtc::v1::ICEServer>* _internal_mutable_additional_ice_servers();
  public:
  const ::proto::rpc::webrtc::v1::ICEServer& additional_ice_servers(int index) const;
  ::proto::rpc::webrtc::v1::ICEServer* add_additional_ice_servers();
  const ::google::protobuf::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer >&
      additional_ice_servers() const;
  // bool disable_trickle = 2 [json_name = "disableTrickle"];
  void clear_disable_trickle() ;
  bool disable_trickle() const;
  void set_disable_trickle(bool value);

  private:
  bool _internal_disable_trickle() const;
  void _internal_set_disable_trickle(bool value);

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.WebRTCConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer > additional_ice_servers_;
    bool disable_trickle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class CallResponseUpdateStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallResponseUpdateStage) */ {
 public:
  inline CallResponseUpdateStage() : CallResponseUpdateStage(nullptr) {}
  ~CallResponseUpdateStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CallResponseUpdateStage(::google::protobuf::internal::ConstantInitialized);

  inline CallResponseUpdateStage(const CallResponseUpdateStage& from)
      : CallResponseUpdateStage(nullptr, from) {}
  CallResponseUpdateStage(CallResponseUpdateStage&& from) noexcept
    : CallResponseUpdateStage() {
    *this = ::std::move(from);
  }

  inline CallResponseUpdateStage& operator=(const CallResponseUpdateStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponseUpdateStage& operator=(CallResponseUpdateStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponseUpdateStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallResponseUpdateStage* internal_default_instance() {
    return reinterpret_cast<const CallResponseUpdateStage*>(
               &_CallResponseUpdateStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CallResponseUpdateStage& a, CallResponseUpdateStage& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponseUpdateStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponseUpdateStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponseUpdateStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponseUpdateStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CallResponseUpdateStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CallResponseUpdateStage& from) {
    CallResponseUpdateStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CallResponseUpdateStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.CallResponseUpdateStage";
  }
  protected:
  explicit CallResponseUpdateStage(::google::protobuf::Arena* arena);
  CallResponseUpdateStage(::google::protobuf::Arena* arena, const CallResponseUpdateStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
  bool has_candidate() const;
  void clear_candidate() ;
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  void unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallResponseUpdateStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerResponseUpdateStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseUpdateStage) */ {
 public:
  inline AnswerResponseUpdateStage() : AnswerResponseUpdateStage(nullptr) {}
  ~AnswerResponseUpdateStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerResponseUpdateStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerResponseUpdateStage(const AnswerResponseUpdateStage& from)
      : AnswerResponseUpdateStage(nullptr, from) {}
  AnswerResponseUpdateStage(AnswerResponseUpdateStage&& from) noexcept
    : AnswerResponseUpdateStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseUpdateStage& operator=(const AnswerResponseUpdateStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseUpdateStage& operator=(AnswerResponseUpdateStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseUpdateStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseUpdateStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseUpdateStage*>(
               &_AnswerResponseUpdateStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AnswerResponseUpdateStage& a, AnswerResponseUpdateStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseUpdateStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseUpdateStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseUpdateStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseUpdateStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerResponseUpdateStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerResponseUpdateStage& from) {
    AnswerResponseUpdateStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerResponseUpdateStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseUpdateStage";
  }
  protected:
  explicit AnswerResponseUpdateStage(::google::protobuf::Arena* arena);
  AnswerResponseUpdateStage(::google::protobuf::Arena* arena, const AnswerResponseUpdateStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
  bool has_candidate() const;
  void clear_candidate() ;
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  void unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseUpdateStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerRequestUpdateStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestUpdateStage) */ {
 public:
  inline AnswerRequestUpdateStage() : AnswerRequestUpdateStage(nullptr) {}
  ~AnswerRequestUpdateStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerRequestUpdateStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerRequestUpdateStage(const AnswerRequestUpdateStage& from)
      : AnswerRequestUpdateStage(nullptr, from) {}
  AnswerRequestUpdateStage(AnswerRequestUpdateStage&& from) noexcept
    : AnswerRequestUpdateStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestUpdateStage& operator=(const AnswerRequestUpdateStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestUpdateStage& operator=(AnswerRequestUpdateStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestUpdateStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestUpdateStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestUpdateStage*>(
               &_AnswerRequestUpdateStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AnswerRequestUpdateStage& a, AnswerRequestUpdateStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestUpdateStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestUpdateStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestUpdateStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestUpdateStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerRequestUpdateStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerRequestUpdateStage& from) {
    AnswerRequestUpdateStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerRequestUpdateStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestUpdateStage";
  }
  protected:
  explicit AnswerRequestUpdateStage(::google::protobuf::Arena* arena);
  AnswerRequestUpdateStage(::google::protobuf::Arena* arena, const AnswerRequestUpdateStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
  bool has_candidate() const;
  void clear_candidate() ;
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  void unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestUpdateStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class OptionalWebRTCConfigResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse) */ {
 public:
  inline OptionalWebRTCConfigResponse() : OptionalWebRTCConfigResponse(nullptr) {}
  ~OptionalWebRTCConfigResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalWebRTCConfigResponse(::google::protobuf::internal::ConstantInitialized);

  inline OptionalWebRTCConfigResponse(const OptionalWebRTCConfigResponse& from)
      : OptionalWebRTCConfigResponse(nullptr, from) {}
  OptionalWebRTCConfigResponse(OptionalWebRTCConfigResponse&& from) noexcept
    : OptionalWebRTCConfigResponse() {
    *this = ::std::move(from);
  }

  inline OptionalWebRTCConfigResponse& operator=(const OptionalWebRTCConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalWebRTCConfigResponse& operator=(OptionalWebRTCConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalWebRTCConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionalWebRTCConfigResponse* internal_default_instance() {
    return reinterpret_cast<const OptionalWebRTCConfigResponse*>(
               &_OptionalWebRTCConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(OptionalWebRTCConfigResponse& a, OptionalWebRTCConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionalWebRTCConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalWebRTCConfigResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalWebRTCConfigResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptionalWebRTCConfigResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionalWebRTCConfigResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OptionalWebRTCConfigResponse& from) {
    OptionalWebRTCConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OptionalWebRTCConfigResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse";
  }
  protected:
  explicit OptionalWebRTCConfigResponse(::google::protobuf::Arena* arena);
  OptionalWebRTCConfigResponse(::google::protobuf::Arena* arena, const OptionalWebRTCConfigResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.WebRTCConfig config = 1 [json_name = "config"];
  bool has_config() const;
  void clear_config() ;
  const ::proto::rpc::webrtc::v1::WebRTCConfig& config() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::WebRTCConfig* release_config();
  ::proto::rpc::webrtc::v1::WebRTCConfig* mutable_config();
  void set_allocated_config(::proto::rpc::webrtc::v1::WebRTCConfig* value);
  void unsafe_arena_set_allocated_config(::proto::rpc::webrtc::v1::WebRTCConfig* value);
  ::proto::rpc::webrtc::v1::WebRTCConfig* unsafe_arena_release_config();

  private:
  const ::proto::rpc::webrtc::v1::WebRTCConfig& _internal_config() const;
  ::proto::rpc::webrtc::v1::WebRTCConfig* _internal_mutable_config();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::proto::rpc::webrtc::v1::WebRTCConfig* config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class CallUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallUpdateRequest) */ {
 public:
  inline CallUpdateRequest() : CallUpdateRequest(nullptr) {}
  ~CallUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CallUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline CallUpdateRequest(const CallUpdateRequest& from)
      : CallUpdateRequest(nullptr, from) {}
  CallUpdateRequest(CallUpdateRequest&& from) noexcept
    : CallUpdateRequest() {
    *this = ::std::move(from);
  }

  inline CallUpdateRequest& operator=(const CallUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallUpdateRequest& operator=(CallUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  enum UpdateCase {
    kCandidate = 2,
    kDone = 3,
    kError = 4,
    UPDATE_NOT_SET = 0,
  };

  static inline const CallUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const CallUpdateRequest*>(
               &_CallUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CallUpdateRequest& a, CallUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CallUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CallUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CallUpdateRequest& from) {
    CallUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CallUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.CallUpdateRequest";
  }
  protected:
  explicit CallUpdateRequest(::google::protobuf::Arena* arena);
  CallUpdateRequest(::google::protobuf::Arena* arena, const CallUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kCandidateFieldNumber = 2,
    kDoneFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // .proto.rpc.webrtc.v1.ICECandidate candidate = 2 [json_name = "candidate"];
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;

  public:
  void clear_candidate() ;
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  void unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();

  public:
  // bool done = 3 [json_name = "done"];
  bool has_done() const;
  void clear_done() ;
  bool done() const;
  void set_done(bool value);

  private:
  bool _internal_done() const;
  void _internal_set_done(bool value);

  public:
  // .google.rpc.Status error = 4 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;

  public:
  void clear_error() ;
  const ::google::rpc::Status& error() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_error();
  ::google::rpc::Status* mutable_error();
  void set_allocated_error(::google::rpc::Status* value);
  void unsafe_arena_set_allocated_error(::google::rpc::Status* value);
  ::google::rpc::Status* unsafe_arena_release_error();

  private:
  const ::google::rpc::Status& _internal_error() const;
  ::google::rpc::Status* _internal_mutable_error();

  public:
  void clear_update();
  UpdateCase update_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallUpdateRequest)
 private:
  class _Internal;
  void set_has_candidate();
  void set_has_done();
  void set_has_error();

  inline bool has_update() const;
  inline void clear_has_update();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 2,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    union UpdateUnion {
      constexpr UpdateUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
      bool done_;
      ::google::rpc::Status* error_;
    } update_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class CallResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallResponse) */ {
 public:
  inline CallResponse() : CallResponse(nullptr) {}
  ~CallResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CallResponse(::google::protobuf::internal::ConstantInitialized);

  inline CallResponse(const CallResponse& from)
      : CallResponse(nullptr, from) {}
  CallResponse(CallResponse&& from) noexcept
    : CallResponse() {
    *this = ::std::move(from);
  }

  inline CallResponse& operator=(const CallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponse& operator=(CallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StageCase {
    kInit = 2,
    kUpdate = 3,
    STAGE_NOT_SET = 0,
  };

  static inline const CallResponse* internal_default_instance() {
    return reinterpret_cast<const CallResponse*>(
               &_CallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CallResponse& a, CallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CallResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CallResponse& from) {
    CallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CallResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.CallResponse";
  }
  protected:
  explicit CallResponse(::google::protobuf::Arena* arena);
  CallResponse(::google::protobuf::Arena* arena, const CallResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kInitFieldNumber = 2,
    kUpdateFieldNumber = 3,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // .proto.rpc.webrtc.v1.CallResponseInitStage init = 2 [json_name = "init"];
  bool has_init() const;
  private:
  bool _internal_has_init() const;

  public:
  void clear_init() ;
  const ::proto::rpc::webrtc::v1::CallResponseInitStage& init() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::CallResponseInitStage* release_init();
  ::proto::rpc::webrtc::v1::CallResponseInitStage* mutable_init();
  void set_allocated_init(::proto::rpc::webrtc::v1::CallResponseInitStage* value);
  void unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::CallResponseInitStage* value);
  ::proto::rpc::webrtc::v1::CallResponseInitStage* unsafe_arena_release_init();

  private:
  const ::proto::rpc::webrtc::v1::CallResponseInitStage& _internal_init() const;
  ::proto::rpc::webrtc::v1::CallResponseInitStage* _internal_mutable_init();

  public:
  // .proto.rpc.webrtc.v1.CallResponseUpdateStage update = 3 [json_name = "update"];
  bool has_update() const;
  private:
  bool _internal_has_update() const;

  public:
  void clear_update() ;
  const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& update() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::CallResponseUpdateStage* release_update();
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* mutable_update();
  void set_allocated_update(::proto::rpc::webrtc::v1::CallResponseUpdateStage* value);
  void unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::CallResponseUpdateStage* value);
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* unsafe_arena_release_update();

  private:
  const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& _internal_update() const;
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* _internal_mutable_update();

  public:
  void clear_stage();
  StageCase stage_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallResponse)
 private:
  class _Internal;
  void set_has_init();
  void set_has_update();

  inline bool has_stage() const;
  inline void clear_has_stage();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    union StageUnion {
      constexpr StageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::CallResponseInitStage* init_;
      ::proto::rpc::webrtc::v1::CallResponseUpdateStage* update_;
    } stage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerResponseErrorStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseErrorStage) */ {
 public:
  inline AnswerResponseErrorStage() : AnswerResponseErrorStage(nullptr) {}
  ~AnswerResponseErrorStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerResponseErrorStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerResponseErrorStage(const AnswerResponseErrorStage& from)
      : AnswerResponseErrorStage(nullptr, from) {}
  AnswerResponseErrorStage(AnswerResponseErrorStage&& from) noexcept
    : AnswerResponseErrorStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseErrorStage& operator=(const AnswerResponseErrorStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseErrorStage& operator=(AnswerResponseErrorStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseErrorStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseErrorStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseErrorStage*>(
               &_AnswerResponseErrorStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AnswerResponseErrorStage& a, AnswerResponseErrorStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseErrorStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseErrorStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseErrorStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseErrorStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerResponseErrorStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerResponseErrorStage& from) {
    AnswerResponseErrorStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerResponseErrorStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseErrorStage";
  }
  protected:
  explicit AnswerResponseErrorStage(::google::protobuf::Arena* arena);
  AnswerResponseErrorStage(::google::protobuf::Arena* arena, const AnswerResponseErrorStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .google.rpc.Status status = 1 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::google::rpc::Status& status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* value);
  void unsafe_arena_set_allocated_status(::google::rpc::Status* value);
  ::google::rpc::Status* unsafe_arena_release_status();

  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseErrorStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::rpc::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerRequestInitStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestInitStage) */ {
 public:
  inline AnswerRequestInitStage() : AnswerRequestInitStage(nullptr) {}
  ~AnswerRequestInitStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerRequestInitStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerRequestInitStage(const AnswerRequestInitStage& from)
      : AnswerRequestInitStage(nullptr, from) {}
  AnswerRequestInitStage(AnswerRequestInitStage&& from) noexcept
    : AnswerRequestInitStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestInitStage& operator=(const AnswerRequestInitStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestInitStage& operator=(AnswerRequestInitStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestInitStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestInitStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestInitStage*>(
               &_AnswerRequestInitStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AnswerRequestInitStage& a, AnswerRequestInitStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestInitStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestInitStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestInitStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestInitStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerRequestInitStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerRequestInitStage& from) {
    AnswerRequestInitStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerRequestInitStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestInitStage";
  }
  protected:
  explicit AnswerRequestInitStage(::google::protobuf::Arena* arena);
  AnswerRequestInitStage(::google::protobuf::Arena* arena, const AnswerRequestInitStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
    kOptionalConfigFieldNumber = 2,
    kDeadlineFieldNumber = 3,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp() ;
  const std::string& sdp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdp(Arg_&& arg, Args_... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* value);

  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(
      const std::string& value);
  std::string* _internal_mutable_sdp();

  public:
  // .proto.rpc.webrtc.v1.WebRTCConfig optional_config = 2 [json_name = "optionalConfig"];
  bool has_optional_config() const;
  void clear_optional_config() ;
  const ::proto::rpc::webrtc::v1::WebRTCConfig& optional_config() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::WebRTCConfig* release_optional_config();
  ::proto::rpc::webrtc::v1::WebRTCConfig* mutable_optional_config();
  void set_allocated_optional_config(::proto::rpc::webrtc::v1::WebRTCConfig* value);
  void unsafe_arena_set_allocated_optional_config(::proto::rpc::webrtc::v1::WebRTCConfig* value);
  ::proto::rpc::webrtc::v1::WebRTCConfig* unsafe_arena_release_optional_config();

  private:
  const ::proto::rpc::webrtc::v1::WebRTCConfig& _internal_optional_config() const;
  ::proto::rpc::webrtc::v1::WebRTCConfig* _internal_mutable_optional_config();

  public:
  // optional .google.protobuf.Timestamp deadline = 3 [json_name = "deadline"];
  bool has_deadline() const;
  void clear_deadline() ;
  const ::google::protobuf::Timestamp& deadline() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_deadline();
  ::google::protobuf::Timestamp* mutable_deadline();
  void set_allocated_deadline(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_deadline(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_deadline();

  private:
  const ::google::protobuf::Timestamp& _internal_deadline() const;
  ::google::protobuf::Timestamp* _internal_mutable_deadline();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestInitStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sdp_;
    ::proto::rpc::webrtc::v1::WebRTCConfig* optional_config_;
    ::google::protobuf::Timestamp* deadline_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerRequestErrorStage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestErrorStage) */ {
 public:
  inline AnswerRequestErrorStage() : AnswerRequestErrorStage(nullptr) {}
  ~AnswerRequestErrorStage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerRequestErrorStage(::google::protobuf::internal::ConstantInitialized);

  inline AnswerRequestErrorStage(const AnswerRequestErrorStage& from)
      : AnswerRequestErrorStage(nullptr, from) {}
  AnswerRequestErrorStage(AnswerRequestErrorStage&& from) noexcept
    : AnswerRequestErrorStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestErrorStage& operator=(const AnswerRequestErrorStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestErrorStage& operator=(AnswerRequestErrorStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestErrorStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestErrorStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestErrorStage*>(
               &_AnswerRequestErrorStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AnswerRequestErrorStage& a, AnswerRequestErrorStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestErrorStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestErrorStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestErrorStage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestErrorStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerRequestErrorStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerRequestErrorStage& from) {
    AnswerRequestErrorStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerRequestErrorStage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestErrorStage";
  }
  protected:
  explicit AnswerRequestErrorStage(::google::protobuf::Arena* arena);
  AnswerRequestErrorStage(::google::protobuf::Arena* arena, const AnswerRequestErrorStage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .google.rpc.Status status = 1 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::google::rpc::Status& status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* value);
  void unsafe_arena_set_allocated_status(::google::rpc::Status* value);
  ::google::rpc::Status* unsafe_arena_release_status();

  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestErrorStage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::rpc::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponse) */ {
 public:
  inline AnswerResponse() : AnswerResponse(nullptr) {}
  ~AnswerResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerResponse(::google::protobuf::internal::ConstantInitialized);

  inline AnswerResponse(const AnswerResponse& from)
      : AnswerResponse(nullptr, from) {}
  AnswerResponse(AnswerResponse&& from) noexcept
    : AnswerResponse() {
    *this = ::std::move(from);
  }

  inline AnswerResponse& operator=(const AnswerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponse& operator=(AnswerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StageCase {
    kInit = 2,
    kUpdate = 3,
    kDone = 4,
    kError = 5,
    STAGE_NOT_SET = 0,
  };

  static inline const AnswerResponse* internal_default_instance() {
    return reinterpret_cast<const AnswerResponse*>(
               &_AnswerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AnswerResponse& a, AnswerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerResponse& from) {
    AnswerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponse";
  }
  protected:
  explicit AnswerResponse(::google::protobuf::Arena* arena);
  AnswerResponse(::google::protobuf::Arena* arena, const AnswerResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kInitFieldNumber = 2,
    kUpdateFieldNumber = 3,
    kDoneFieldNumber = 4,
    kErrorFieldNumber = 5,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // .proto.rpc.webrtc.v1.AnswerResponseInitStage init = 2 [json_name = "init"];
  bool has_init() const;
  private:
  bool _internal_has_init() const;

  public:
  void clear_init() ;
  const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& init() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseInitStage* release_init();
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* mutable_init();
  void set_allocated_init(::proto::rpc::webrtc::v1::AnswerResponseInitStage* value);
  void unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::AnswerResponseInitStage* value);
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* unsafe_arena_release_init();

  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& _internal_init() const;
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* _internal_mutable_init();

  public:
  // .proto.rpc.webrtc.v1.AnswerResponseUpdateStage update = 3 [json_name = "update"];
  bool has_update() const;
  private:
  bool _internal_has_update() const;

  public:
  void clear_update() ;
  const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& update() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* release_update();
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* mutable_update();
  void set_allocated_update(::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* value);
  void unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* value);
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* unsafe_arena_release_update();

  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& _internal_update() const;
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* _internal_mutable_update();

  public:
  // .proto.rpc.webrtc.v1.AnswerResponseDoneStage done = 4 [json_name = "done"];
  bool has_done() const;
  private:
  bool _internal_has_done() const;

  public:
  void clear_done() ;
  const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& done() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* release_done();
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* mutable_done();
  void set_allocated_done(::proto::rpc::webrtc::v1::AnswerResponseDoneStage* value);
  void unsafe_arena_set_allocated_done(::proto::rpc::webrtc::v1::AnswerResponseDoneStage* value);
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* unsafe_arena_release_done();

  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& _internal_done() const;
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* _internal_mutable_done();

  public:
  // .proto.rpc.webrtc.v1.AnswerResponseErrorStage error = 5 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;

  public:
  void clear_error() ;
  const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& error() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* release_error();
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* mutable_error();
  void set_allocated_error(::proto::rpc::webrtc::v1::AnswerResponseErrorStage* value);
  void unsafe_arena_set_allocated_error(::proto::rpc::webrtc::v1::AnswerResponseErrorStage* value);
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* unsafe_arena_release_error();

  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& _internal_error() const;
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* _internal_mutable_error();

  public:
  void clear_stage();
  StageCase stage_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponse)
 private:
  class _Internal;
  void set_has_init();
  void set_has_update();
  void set_has_done();
  void set_has_error();

  inline bool has_stage() const;
  inline void clear_has_stage();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 4,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    union StageUnion {
      constexpr StageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::AnswerResponseInitStage* init_;
      ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* update_;
      ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* done_;
      ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* error_;
    } stage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};// -------------------------------------------------------------------

class AnswerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequest) */ {
 public:
  inline AnswerRequest() : AnswerRequest(nullptr) {}
  ~AnswerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnswerRequest(::google::protobuf::internal::ConstantInitialized);

  inline AnswerRequest(const AnswerRequest& from)
      : AnswerRequest(nullptr, from) {}
  AnswerRequest(AnswerRequest&& from) noexcept
    : AnswerRequest() {
    *this = ::std::move(from);
  }

  inline AnswerRequest& operator=(const AnswerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequest& operator=(AnswerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StageCase {
    kInit = 2,
    kUpdate = 3,
    kDone = 4,
    kError = 5,
    kHeartbeat = 6,
    STAGE_NOT_SET = 0,
  };

  static inline const AnswerRequest* internal_default_instance() {
    return reinterpret_cast<const AnswerRequest*>(
               &_AnswerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AnswerRequest& a, AnswerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnswerRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnswerRequest& from) {
    AnswerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnswerRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequest";
  }
  protected:
  explicit AnswerRequest(::google::protobuf::Arena* arena);
  AnswerRequest(::google::protobuf::Arena* arena, const AnswerRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kInitFieldNumber = 2,
    kUpdateFieldNumber = 3,
    kDoneFieldNumber = 4,
    kErrorFieldNumber = 5,
    kHeartbeatFieldNumber = 6,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // .proto.rpc.webrtc.v1.AnswerRequestInitStage init = 2 [json_name = "init"];
  bool has_init() const;
  private:
  bool _internal_has_init() const;

  public:
  void clear_init() ;
  const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& init() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestInitStage* release_init();
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* mutable_init();
  void set_allocated_init(::proto::rpc::webrtc::v1::AnswerRequestInitStage* value);
  void unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::AnswerRequestInitStage* value);
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* unsafe_arena_release_init();

  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& _internal_init() const;
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* _internal_mutable_init();

  public:
  // .proto.rpc.webrtc.v1.AnswerRequestUpdateStage update = 3 [json_name = "update"];
  bool has_update() const;
  private:
  bool _internal_has_update() const;

  public:
  void clear_update() ;
  const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& update() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* release_update();
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* mutable_update();
  void set_allocated_update(::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* value);
  void unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* value);
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* unsafe_arena_release_update();

  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& _internal_update() const;
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* _internal_mutable_update();

  public:
  // .proto.rpc.webrtc.v1.AnswerRequestDoneStage done = 4 [json_name = "done"];
  bool has_done() const;
  private:
  bool _internal_has_done() const;

  public:
  void clear_done() ;
  const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& done() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* release_done();
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* mutable_done();
  void set_allocated_done(::proto::rpc::webrtc::v1::AnswerRequestDoneStage* value);
  void unsafe_arena_set_allocated_done(::proto::rpc::webrtc::v1::AnswerRequestDoneStage* value);
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* unsafe_arena_release_done();

  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& _internal_done() const;
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* _internal_mutable_done();

  public:
  // .proto.rpc.webrtc.v1.AnswerRequestErrorStage error = 5 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;

  public:
  void clear_error() ;
  const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& error() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* release_error();
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* mutable_error();
  void set_allocated_error(::proto::rpc::webrtc::v1::AnswerRequestErrorStage* value);
  void unsafe_arena_set_allocated_error(::proto::rpc::webrtc::v1::AnswerRequestErrorStage* value);
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* unsafe_arena_release_error();

  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& _internal_error() const;
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* _internal_mutable_error();

  public:
  // .proto.rpc.webrtc.v1.AnswerRequestHeartbeatStage heartbeat = 6 [json_name = "heartbeat"];
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage& heartbeat() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* release_heartbeat();
  ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* mutable_heartbeat();
  void set_allocated_heartbeat(::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* value);
  void unsafe_arena_set_allocated_heartbeat(::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* value);
  ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* unsafe_arena_release_heartbeat();

  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage& _internal_heartbeat() const;
  ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* _internal_mutable_heartbeat();

  public:
  void clear_stage();
  StageCase stage_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequest)
 private:
  class _Internal;
  void set_has_init();
  void set_has_update();
  void set_has_done();
  void set_has_error();
  void set_has_heartbeat();

  inline bool has_stage() const;
  inline void clear_has_stage();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 5,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    union StageUnion {
      constexpr StageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::AnswerRequestInitStage* init_;
      ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* update_;
      ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* done_;
      ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* error_;
      ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* heartbeat_;
    } stage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ICECandidate

// string candidate = 1 [json_name = "candidate"];
inline void ICECandidate::clear_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_.ClearToEmpty();
}
inline const std::string& ICECandidate::candidate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.candidate)
  return _internal_candidate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ICECandidate::set_candidate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.candidate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.candidate)
}
inline std::string* ICECandidate::mutable_candidate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICECandidate.candidate)
  return _s;
}
inline const std::string& ICECandidate::_internal_candidate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.candidate_.Get();
}
inline void ICECandidate::_internal_set_candidate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.candidate_.Set(value, GetArena());
}
inline std::string* ICECandidate::_internal_mutable_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.candidate_.Mutable( GetArena());
}
inline std::string* ICECandidate::release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICECandidate.candidate)
  return _impl_.candidate_.Release();
}
inline void ICECandidate::set_allocated_candidate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.candidate_.IsDefault()) {
          _impl_.candidate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICECandidate.candidate)
}

// optional string sdp_mid = 2 [json_name = "sdpMid"];
inline bool ICECandidate::has_sdp_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ICECandidate::clear_sdp_mid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_mid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ICECandidate::sdp_mid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
  return _internal_sdp_mid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ICECandidate::set_sdp_mid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sdp_mid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
}
inline std::string* ICECandidate::mutable_sdp_mid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sdp_mid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
  return _s;
}
inline const std::string& ICECandidate::_internal_sdp_mid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdp_mid_.Get();
}
inline void ICECandidate::_internal_set_sdp_mid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sdp_mid_.Set(value, GetArena());
}
inline std::string* ICECandidate::_internal_mutable_sdp_mid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sdp_mid_.Mutable( GetArena());
}
inline std::string* ICECandidate::release_sdp_mid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sdp_mid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sdp_mid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ICECandidate::set_allocated_sdp_mid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sdp_mid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sdp_mid_.IsDefault()) {
          _impl_.sdp_mid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
}

// optional uint32 sdpm_line_index = 3 [json_name = "sdpmLineIndex"];
inline bool ICECandidate::has_sdpm_line_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ICECandidate::clear_sdpm_line_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdpm_line_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ICECandidate::sdpm_line_index() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.sdpm_line_index)
  return _internal_sdpm_line_index();
}
inline void ICECandidate::set_sdpm_line_index(::uint32_t value) {
  _internal_set_sdpm_line_index(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.sdpm_line_index)
}
inline ::uint32_t ICECandidate::_internal_sdpm_line_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdpm_line_index_;
}
inline void ICECandidate::_internal_set_sdpm_line_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sdpm_line_index_ = value;
}

// optional string username_fragment = 4 [json_name = "usernameFragment"];
inline bool ICECandidate::has_username_fragment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ICECandidate::clear_username_fragment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_fragment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ICECandidate::username_fragment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
  return _internal_username_fragment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ICECandidate::set_username_fragment(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.username_fragment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
}
inline std::string* ICECandidate::mutable_username_fragment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username_fragment();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
  return _s;
}
inline const std::string& ICECandidate::_internal_username_fragment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_fragment_.Get();
}
inline void ICECandidate::_internal_set_username_fragment(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.username_fragment_.Set(value, GetArena());
}
inline std::string* ICECandidate::_internal_mutable_username_fragment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.username_fragment_.Mutable( GetArena());
}
inline std::string* ICECandidate::release_username_fragment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.username_fragment_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.username_fragment_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ICECandidate::set_allocated_username_fragment(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.username_fragment_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_fragment_.IsDefault()) {
          _impl_.username_fragment_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
}

// -------------------------------------------------------------------

// CallRequest

// string sdp = 1 [json_name = "sdp"];
inline void CallRequest::clear_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& CallRequest::sdp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallRequest.sdp)
  return _internal_sdp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CallRequest::set_sdp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallRequest.sdp)
}
inline std::string* CallRequest::mutable_sdp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallRequest.sdp)
  return _s;
}
inline const std::string& CallRequest::_internal_sdp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdp_.Get();
}
inline void CallRequest::_internal_set_sdp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(value, GetArena());
}
inline std::string* CallRequest::_internal_mutable_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sdp_.Mutable( GetArena());
}
inline std::string* CallRequest::release_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallRequest.sdp)
  return _impl_.sdp_.Release();
}
inline void CallRequest::set_allocated_sdp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sdp_.IsDefault()) {
          _impl_.sdp_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallRequest.sdp)
}

// bool disable_trickle = 2 [json_name = "disableTrickle"];
inline void CallRequest::clear_disable_trickle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_trickle_ = false;
}
inline bool CallRequest::disable_trickle() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallRequest.disable_trickle)
  return _internal_disable_trickle();
}
inline void CallRequest::set_disable_trickle(bool value) {
  _internal_set_disable_trickle(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallRequest.disable_trickle)
}
inline bool CallRequest::_internal_disable_trickle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_trickle_;
}
inline void CallRequest::_internal_set_disable_trickle(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disable_trickle_ = value;
}

// -------------------------------------------------------------------

// CallResponseInitStage

// string sdp = 1 [json_name = "sdp"];
inline void CallResponseInitStage::clear_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& CallResponseInitStage::sdp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
  return _internal_sdp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CallResponseInitStage::set_sdp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
}
inline std::string* CallResponseInitStage::mutable_sdp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
  return _s;
}
inline const std::string& CallResponseInitStage::_internal_sdp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdp_.Get();
}
inline void CallResponseInitStage::_internal_set_sdp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(value, GetArena());
}
inline std::string* CallResponseInitStage::_internal_mutable_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sdp_.Mutable( GetArena());
}
inline std::string* CallResponseInitStage::release_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
  return _impl_.sdp_.Release();
}
inline void CallResponseInitStage::set_allocated_sdp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sdp_.IsDefault()) {
          _impl_.sdp_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
}

// -------------------------------------------------------------------

// CallResponseUpdateStage

// .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
inline bool CallResponseUpdateStage::has_candidate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.candidate_ != nullptr);
  return value;
}
inline void CallResponseUpdateStage::clear_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.candidate_ != nullptr) _impl_.candidate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallResponseUpdateStage::_internal_candidate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::rpc::webrtc::v1::ICECandidate* p = _impl_.candidate_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::ICECandidate&>(::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallResponseUpdateStage::candidate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
  return _internal_candidate();
}
inline void CallResponseUpdateStage::unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.candidate_);
  }
  _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::ICECandidate* released = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::unsafe_arena_release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::_internal_mutable_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.candidate_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(GetArena());
    _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(p);
  }
  return _impl_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::mutable_candidate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
  return _msg;
}
inline void CallResponseUpdateStage::set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(_impl_.candidate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
}

// -------------------------------------------------------------------

// CallResponse

// string uuid = 1 [json_name = "uuid"];
inline void CallResponse::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& CallResponse::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponse.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CallResponse::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallResponse.uuid)
}
inline std::string* CallResponse::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponse.uuid)
  return _s;
}
inline const std::string& CallResponse::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_.Get();
}
inline void CallResponse::_internal_set_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* CallResponse::_internal_mutable_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* CallResponse::release_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponse.uuid)
  return _impl_.uuid_.Release();
}
inline void CallResponse::set_allocated_uuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uuid_.IsDefault()) {
          _impl_.uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallResponse.uuid)
}

// .proto.rpc.webrtc.v1.CallResponseInitStage init = 2 [json_name = "init"];
inline bool CallResponse::has_init() const {
  return stage_case() == kInit;
}
inline bool CallResponse::_internal_has_init() const {
  return stage_case() == kInit;
}
inline void CallResponse::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void CallResponse::clear_init() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kInit) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.init_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::release_init() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponse.init)
  if (stage_case() == kInit) {
    clear_has_stage();
    auto* temp = _impl_.stage_.init_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::CallResponseInitStage& CallResponse::_internal_init() const {
  return stage_case() == kInit ? *_impl_.stage_.init_ : reinterpret_cast<::proto::rpc::webrtc::v1::CallResponseInitStage&>(::proto::rpc::webrtc::v1::_CallResponseInitStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::CallResponseInitStage& CallResponse::init() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponse.init)
  return _internal_init();
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallResponse.init)
  if (stage_case() == kInit) {
    clear_has_stage();
    auto* temp = _impl_.stage_.init_;
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallResponse::unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::CallResponseInitStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_init();
    _impl_.stage_.init_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallResponse.init)
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::_internal_mutable_init() {
  if (stage_case() != kInit) {
    clear_stage();
    set_has_init();
    _impl_.stage_.init_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::CallResponseInitStage>(GetArena());
  }
  return _impl_.stage_.init_;
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::mutable_init() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::CallResponseInitStage* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponse.init)
  return _msg;
}

// .proto.rpc.webrtc.v1.CallResponseUpdateStage update = 3 [json_name = "update"];
inline bool CallResponse::has_update() const {
  return stage_case() == kUpdate;
}
inline bool CallResponse::_internal_has_update() const {
  return stage_case() == kUpdate;
}
inline void CallResponse::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void CallResponse::clear_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.update_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::release_update() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponse.update)
  if (stage_case() == kUpdate) {
    clear_has_stage();
    auto* temp = _impl_.stage_.update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& CallResponse::_internal_update() const {
  return stage_case() == kUpdate ? *_impl_.stage_.update_ : reinterpret_cast<::proto::rpc::webrtc::v1::CallResponseUpdateStage&>(::proto::rpc::webrtc::v1::_CallResponseUpdateStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& CallResponse::update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponse.update)
  return _internal_update();
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallResponse.update)
  if (stage_case() == kUpdate) {
    clear_has_stage();
    auto* temp = _impl_.stage_.update_;
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallResponse::unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::CallResponseUpdateStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_update();
    _impl_.stage_.update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallResponse.update)
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::_internal_mutable_update() {
  if (stage_case() != kUpdate) {
    clear_stage();
    set_has_update();
    _impl_.stage_.update_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::CallResponseUpdateStage>(GetArena());
  }
  return _impl_.stage_.update_;
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::mutable_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponse.update)
  return _msg;
}

inline bool CallResponse::has_stage() const {
  return stage_case() != STAGE_NOT_SET;
}
inline void CallResponse::clear_has_stage() {
  _impl_._oneof_case_[0] = STAGE_NOT_SET;
}
inline CallResponse::StageCase CallResponse::stage_case() const {
  return CallResponse::StageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallUpdateRequest

// string uuid = 1 [json_name = "uuid"];
inline void CallUpdateRequest::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& CallUpdateRequest::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CallUpdateRequest::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
}
inline std::string* CallUpdateRequest::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
  return _s;
}
inline const std::string& CallUpdateRequest::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_.Get();
}
inline void CallUpdateRequest::_internal_set_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* CallUpdateRequest::_internal_mutable_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* CallUpdateRequest::release_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
  return _impl_.uuid_.Release();
}
inline void CallUpdateRequest::set_allocated_uuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uuid_.IsDefault()) {
          _impl_.uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
}

// .proto.rpc.webrtc.v1.ICECandidate candidate = 2 [json_name = "candidate"];
inline bool CallUpdateRequest::has_candidate() const {
  return update_case() == kCandidate;
}
inline bool CallUpdateRequest::_internal_has_candidate() const {
  return update_case() == kCandidate;
}
inline void CallUpdateRequest::set_has_candidate() {
  _impl_._oneof_case_[0] = kCandidate;
}
inline void CallUpdateRequest::clear_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (update_case() == kCandidate) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.candidate_;
    }
    clear_has_update();
  }
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::release_candidate() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  if (update_case() == kCandidate) {
    clear_has_update();
    auto* temp = _impl_.update_.candidate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.candidate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallUpdateRequest::_internal_candidate() const {
  return update_case() == kCandidate ? *_impl_.update_.candidate_ : reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate&>(::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallUpdateRequest::candidate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  return _internal_candidate();
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::unsafe_arena_release_candidate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  if (update_case() == kCandidate) {
    clear_has_update();
    auto* temp = _impl_.update_.candidate_;
    _impl_.update_.candidate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallUpdateRequest::unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_candidate();
    _impl_.update_.candidate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::_internal_mutable_candidate() {
  if (update_case() != kCandidate) {
    clear_update();
    set_has_candidate();
    _impl_.update_.candidate_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(GetArena());
  }
  return _impl_.update_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::mutable_candidate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  return _msg;
}

// bool done = 3 [json_name = "done"];
inline bool CallUpdateRequest::has_done() const {
  return update_case() == kDone;
}
inline void CallUpdateRequest::set_has_done() {
  _impl_._oneof_case_[0] = kDone;
}
inline void CallUpdateRequest::clear_done() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (update_case() == kDone) {
    _impl_.update_.done_ = false;
    clear_has_update();
  }
}
inline bool CallUpdateRequest::done() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.done)
  return _internal_done();
}
inline void CallUpdateRequest::set_done(bool value) {
  _internal_set_done(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallUpdateRequest.done)
}
inline bool CallUpdateRequest::_internal_done() const {
  if (update_case() == kDone) {
    return _impl_.update_.done_;
  }
  return false;
}
inline void CallUpdateRequest::_internal_set_done(bool value) {
  if (update_case() != kDone) {
    clear_update();
    set_has_done();
  }
  _impl_.update_.done_ = value;
}

// .google.rpc.Status error = 4 [json_name = "error"];
inline bool CallUpdateRequest::has_error() const {
  return update_case() == kError;
}
inline bool CallUpdateRequest::_internal_has_error() const {
  return update_case() == kError;
}
inline void CallUpdateRequest::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline ::google::rpc::Status* CallUpdateRequest::release_error() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  if (update_case() == kError) {
    clear_has_update();
    auto* temp = _impl_.update_.error_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::rpc::Status& CallUpdateRequest::_internal_error() const {
  return update_case() == kError ? *_impl_.update_.error_ : reinterpret_cast<::google::rpc::Status&>(::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& CallUpdateRequest::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  return _internal_error();
}
inline ::google::rpc::Status* CallUpdateRequest::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  if (update_case() == kError) {
    clear_has_update();
    auto* temp = _impl_.update_.error_;
    _impl_.update_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallUpdateRequest::unsafe_arena_set_allocated_error(::google::rpc::Status* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_error();
    _impl_.update_.error_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallUpdateRequest.error)
}
inline ::google::rpc::Status* CallUpdateRequest::_internal_mutable_error() {
  if (update_case() != kError) {
    clear_update();
    set_has_error();
    _impl_.update_.error_ = CreateMaybeMessage<::google::rpc::Status>(GetArena());
  }
  return _impl_.update_.error_;
}
inline ::google::rpc::Status* CallUpdateRequest::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::rpc::Status* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  return _msg;
}

inline bool CallUpdateRequest::has_update() const {
  return update_case() != UPDATE_NOT_SET;
}
inline void CallUpdateRequest::clear_has_update() {
  _impl_._oneof_case_[0] = UPDATE_NOT_SET;
}
inline CallUpdateRequest::UpdateCase CallUpdateRequest::update_case() const {
  return CallUpdateRequest::UpdateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallUpdateResponse

// -------------------------------------------------------------------

// ICEServer

// repeated string urls = 1 [json_name = "urls"];
inline int ICEServer::_internal_urls_size() const {
  return _internal_urls().size();
}
inline int ICEServer::urls_size() const {
  return _internal_urls_size();
}
inline void ICEServer::clear_urls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.urls_.Clear();
}
inline std::string* ICEServer::add_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_urls()->Add();
  // @@protoc_insertion_point(field_add_mutable:proto.rpc.webrtc.v1.ICEServer.urls)
  return _s;
}
inline const std::string& ICEServer::urls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICEServer.urls)
  return _internal_urls().Get(index);
}
inline std::string* ICEServer::mutable_urls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICEServer.urls)
  return _internal_mutable_urls()->Mutable(index);
}
inline void ICEServer::set_urls(int index, const std::string& value) {
  _internal_mutable_urls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, std::string&& value) {
  _internal_mutable_urls()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_urls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_urls()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, absl::string_view value) {
  _internal_mutable_urls()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_urls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_urls()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_urls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_urls()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_urls()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ICEServer::urls() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:proto.rpc.webrtc.v1.ICEServer.urls)
  return _internal_urls();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ICEServer::mutable_urls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:proto.rpc.webrtc.v1.ICEServer.urls)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_urls();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ICEServer::_internal_urls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.urls_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ICEServer::_internal_mutable_urls() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.urls_;
}

// string username = 2 [json_name = "username"];
inline void ICEServer::clear_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ICEServer::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICEServer.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ICEServer::set_username(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.username)
}
inline std::string* ICEServer::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICEServer.username)
  return _s;
}
inline const std::string& ICEServer::_internal_username() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_.Get();
}
inline void ICEServer::_internal_set_username(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* ICEServer::_internal_mutable_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* ICEServer::release_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICEServer.username)
  return _impl_.username_.Release();
}
inline void ICEServer::set_allocated_username(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICEServer.username)
}

// string credential = 3 [json_name = "credential"];
inline void ICEServer::clear_credential() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.credential_.ClearToEmpty();
}
inline const std::string& ICEServer::credential() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICEServer.credential)
  return _internal_credential();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ICEServer::set_credential(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.credential_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.credential)
}
inline std::string* ICEServer::mutable_credential() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_credential();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICEServer.credential)
  return _s;
}
inline const std::string& ICEServer::_internal_credential() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.credential_.Get();
}
inline void ICEServer::_internal_set_credential(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.credential_.Set(value, GetArena());
}
inline std::string* ICEServer::_internal_mutable_credential() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.credential_.Mutable( GetArena());
}
inline std::string* ICEServer::release_credential() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICEServer.credential)
  return _impl_.credential_.Release();
}
inline void ICEServer::set_allocated_credential(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.credential_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.credential_.IsDefault()) {
          _impl_.credential_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICEServer.credential)
}

// -------------------------------------------------------------------

// WebRTCConfig

// repeated .proto.rpc.webrtc.v1.ICEServer additional_ice_servers = 1 [json_name = "additionalIceServers"];
inline int WebRTCConfig::_internal_additional_ice_servers_size() const {
  return _internal_additional_ice_servers().size();
}
inline int WebRTCConfig::additional_ice_servers_size() const {
  return _internal_additional_ice_servers_size();
}
inline void WebRTCConfig::clear_additional_ice_servers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.additional_ice_servers_.Clear();
}
inline ::proto::rpc::webrtc::v1::ICEServer* WebRTCConfig::mutable_additional_ice_servers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _internal_mutable_additional_ice_servers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::proto::rpc::webrtc::v1::ICEServer>* WebRTCConfig::mutable_additional_ice_servers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_additional_ice_servers();
}
inline const ::proto::rpc::webrtc::v1::ICEServer& WebRTCConfig::additional_ice_servers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _internal_additional_ice_servers().Get(index);
}
inline ::proto::rpc::webrtc::v1::ICEServer* WebRTCConfig::add_additional_ice_servers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::proto::rpc::webrtc::v1::ICEServer* _add = _internal_mutable_additional_ice_servers()->Add();
  // @@protoc_insertion_point(field_add:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::proto::rpc::webrtc::v1::ICEServer>& WebRTCConfig::additional_ice_servers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _internal_additional_ice_servers();
}
inline const ::google::protobuf::RepeatedPtrField<::proto::rpc::webrtc::v1::ICEServer>&
WebRTCConfig::_internal_additional_ice_servers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.additional_ice_servers_;
}
inline ::google::protobuf::RepeatedPtrField<::proto::rpc::webrtc::v1::ICEServer>*
WebRTCConfig::_internal_mutable_additional_ice_servers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.additional_ice_servers_;
}

// bool disable_trickle = 2 [json_name = "disableTrickle"];
inline void WebRTCConfig::clear_disable_trickle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_trickle_ = false;
}
inline bool WebRTCConfig::disable_trickle() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.WebRTCConfig.disable_trickle)
  return _internal_disable_trickle();
}
inline void WebRTCConfig::set_disable_trickle(bool value) {
  _internal_set_disable_trickle(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.WebRTCConfig.disable_trickle)
}
inline bool WebRTCConfig::_internal_disable_trickle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_trickle_;
}
inline void WebRTCConfig::_internal_set_disable_trickle(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disable_trickle_ = value;
}

// -------------------------------------------------------------------

// AnswerRequestInitStage

// string sdp = 1 [json_name = "sdp"];
inline void AnswerRequestInitStage::clear_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& AnswerRequestInitStage::sdp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
  return _internal_sdp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnswerRequestInitStage::set_sdp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
}
inline std::string* AnswerRequestInitStage::mutable_sdp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
  return _s;
}
inline const std::string& AnswerRequestInitStage::_internal_sdp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdp_.Get();
}
inline void AnswerRequestInitStage::_internal_set_sdp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(value, GetArena());
}
inline std::string* AnswerRequestInitStage::_internal_mutable_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sdp_.Mutable( GetArena());
}
inline std::string* AnswerRequestInitStage::release_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
  return _impl_.sdp_.Release();
}
inline void AnswerRequestInitStage::set_allocated_sdp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sdp_.IsDefault()) {
          _impl_.sdp_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
}

// .proto.rpc.webrtc.v1.WebRTCConfig optional_config = 2 [json_name = "optionalConfig"];
inline bool AnswerRequestInitStage::has_optional_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.optional_config_ != nullptr);
  return value;
}
inline void AnswerRequestInitStage::clear_optional_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.optional_config_ != nullptr) _impl_.optional_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& AnswerRequestInitStage::_internal_optional_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::rpc::webrtc::v1::WebRTCConfig* p = _impl_.optional_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::WebRTCConfig&>(::proto::rpc::webrtc::v1::_WebRTCConfig_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& AnswerRequestInitStage::optional_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
  return _internal_optional_config();
}
inline void AnswerRequestInitStage::unsafe_arena_set_allocated_optional_config(::proto::rpc::webrtc::v1::WebRTCConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optional_config_);
  }
  _impl_.optional_config_ = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::release_optional_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::WebRTCConfig* released = _impl_.optional_config_;
  _impl_.optional_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::unsafe_arena_release_optional_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::WebRTCConfig* temp = _impl_.optional_config_;
  _impl_.optional_config_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::_internal_mutable_optional_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.optional_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::WebRTCConfig>(GetArena());
    _impl_.optional_config_ = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(p);
  }
  return _impl_.optional_config_;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::mutable_optional_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::WebRTCConfig* _msg = _internal_mutable_optional_config();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
  return _msg;
}
inline void AnswerRequestInitStage::set_allocated_optional_config(::proto::rpc::webrtc::v1::WebRTCConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(_impl_.optional_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.optional_config_ = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
}

// optional .google.protobuf.Timestamp deadline = 3 [json_name = "deadline"];
inline bool AnswerRequestInitStage::has_deadline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deadline_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& AnswerRequestInitStage::_internal_deadline() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.deadline_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& AnswerRequestInitStage::deadline() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
  return _internal_deadline();
}
inline void AnswerRequestInitStage::unsafe_arena_set_allocated_deadline(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deadline_);
  }
  _impl_.deadline_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
}
inline ::google::protobuf::Timestamp* AnswerRequestInitStage::release_deadline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.deadline_;
  _impl_.deadline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* AnswerRequestInitStage::unsafe_arena_release_deadline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.deadline_;
  _impl_.deadline_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AnswerRequestInitStage::_internal_mutable_deadline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.deadline_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.deadline_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.deadline_;
}
inline ::google::protobuf::Timestamp* AnswerRequestInitStage::mutable_deadline() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_deadline();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
  return _msg;
}
inline void AnswerRequestInitStage::set_allocated_deadline(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deadline_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.deadline_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
}

// -------------------------------------------------------------------

// AnswerRequestUpdateStage

// .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
inline bool AnswerRequestUpdateStage::has_candidate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.candidate_ != nullptr);
  return value;
}
inline void AnswerRequestUpdateStage::clear_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.candidate_ != nullptr) _impl_.candidate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerRequestUpdateStage::_internal_candidate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::rpc::webrtc::v1::ICECandidate* p = _impl_.candidate_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::ICECandidate&>(::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerRequestUpdateStage::candidate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
  return _internal_candidate();
}
inline void AnswerRequestUpdateStage::unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.candidate_);
  }
  _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::ICECandidate* released = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::unsafe_arena_release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::_internal_mutable_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.candidate_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(GetArena());
    _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(p);
  }
  return _impl_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::mutable_candidate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
  return _msg;
}
inline void AnswerRequestUpdateStage::set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(_impl_.candidate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
}

// -------------------------------------------------------------------

// AnswerRequestDoneStage

// -------------------------------------------------------------------

// AnswerRequestErrorStage

// .google.rpc.Status status = 1 [json_name = "status"];
inline bool AnswerRequestErrorStage::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline const ::google::rpc::Status& AnswerRequestErrorStage::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::rpc::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& AnswerRequestErrorStage::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
  return _internal_status();
}
inline void AnswerRequestErrorStage::unsafe_arena_set_allocated_status(::google::rpc::Status* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::google::rpc::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
}
inline ::google::rpc::Status* AnswerRequestErrorStage::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::rpc::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::rpc::Status* AnswerRequestErrorStage::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* AnswerRequestErrorStage::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::google::rpc::Status*>(p);
  }
  return _impl_.status_;
}
inline ::google::rpc::Status* AnswerRequestErrorStage::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
  return _msg;
}
inline void AnswerRequestErrorStage::set_allocated_status(::google::rpc::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::google::rpc::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
}

// -------------------------------------------------------------------

// AnswerRequestHeartbeatStage

// -------------------------------------------------------------------

// AnswerRequest

// string uuid = 1 [json_name = "uuid"];
inline void AnswerRequest::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& AnswerRequest::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnswerRequest::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerRequest.uuid)
}
inline std::string* AnswerRequest::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.uuid)
  return _s;
}
inline const std::string& AnswerRequest::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_.Get();
}
inline void AnswerRequest::_internal_set_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* AnswerRequest::_internal_mutable_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* AnswerRequest::release_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.uuid)
  return _impl_.uuid_.Release();
}
inline void AnswerRequest::set_allocated_uuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uuid_.IsDefault()) {
          _impl_.uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.uuid)
}

// .proto.rpc.webrtc.v1.AnswerRequestInitStage init = 2 [json_name = "init"];
inline bool AnswerRequest::has_init() const {
  return stage_case() == kInit;
}
inline bool AnswerRequest::_internal_has_init() const {
  return stage_case() == kInit;
}
inline void AnswerRequest::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void AnswerRequest::clear_init() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kInit) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.init_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::release_init() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.init)
  if (stage_case() == kInit) {
    clear_has_stage();
    auto* temp = _impl_.stage_.init_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& AnswerRequest::_internal_init() const {
  return stage_case() == kInit ? *_impl_.stage_.init_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerRequestInitStage&>(::proto::rpc::webrtc::v1::_AnswerRequestInitStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& AnswerRequest::init() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.init)
  return _internal_init();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.init)
  if (stage_case() == kInit) {
    clear_has_stage();
    auto* temp = _impl_.stage_.init_;
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::AnswerRequestInitStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_init();
    _impl_.stage_.init_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.init)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::_internal_mutable_init() {
  if (stage_case() != kInit) {
    clear_stage();
    set_has_init();
    _impl_.stage_.init_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestInitStage>(GetArena());
  }
  return _impl_.stage_.init_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::mutable_init() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.init)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerRequestUpdateStage update = 3 [json_name = "update"];
inline bool AnswerRequest::has_update() const {
  return stage_case() == kUpdate;
}
inline bool AnswerRequest::_internal_has_update() const {
  return stage_case() == kUpdate;
}
inline void AnswerRequest::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void AnswerRequest::clear_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.update_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::release_update() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.update)
  if (stage_case() == kUpdate) {
    clear_has_stage();
    auto* temp = _impl_.stage_.update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& AnswerRequest::_internal_update() const {
  return stage_case() == kUpdate ? *_impl_.stage_.update_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerRequestUpdateStage&>(::proto::rpc::webrtc::v1::_AnswerRequestUpdateStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& AnswerRequest::update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.update)
  return _internal_update();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.update)
  if (stage_case() == kUpdate) {
    clear_has_stage();
    auto* temp = _impl_.stage_.update_;
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_update();
    _impl_.stage_.update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.update)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::_internal_mutable_update() {
  if (stage_case() != kUpdate) {
    clear_stage();
    set_has_update();
    _impl_.stage_.update_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestUpdateStage>(GetArena());
  }
  return _impl_.stage_.update_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::mutable_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.update)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerRequestDoneStage done = 4 [json_name = "done"];
inline bool AnswerRequest::has_done() const {
  return stage_case() == kDone;
}
inline bool AnswerRequest::_internal_has_done() const {
  return stage_case() == kDone;
}
inline void AnswerRequest::set_has_done() {
  _impl_._oneof_case_[0] = kDone;
}
inline void AnswerRequest::clear_done() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kDone) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.done_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::release_done() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.done)
  if (stage_case() == kDone) {
    clear_has_stage();
    auto* temp = _impl_.stage_.done_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& AnswerRequest::_internal_done() const {
  return stage_case() == kDone ? *_impl_.stage_.done_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerRequestDoneStage&>(::proto::rpc::webrtc::v1::_AnswerRequestDoneStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& AnswerRequest::done() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.done)
  return _internal_done();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::unsafe_arena_release_done() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.done)
  if (stage_case() == kDone) {
    clear_has_stage();
    auto* temp = _impl_.stage_.done_;
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_done(::proto::rpc::webrtc::v1::AnswerRequestDoneStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_done();
    _impl_.stage_.done_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.done)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::_internal_mutable_done() {
  if (stage_case() != kDone) {
    clear_stage();
    set_has_done();
    _impl_.stage_.done_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestDoneStage>(GetArena());
  }
  return _impl_.stage_.done_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::mutable_done() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* _msg = _internal_mutable_done();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.done)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerRequestErrorStage error = 5 [json_name = "error"];
inline bool AnswerRequest::has_error() const {
  return stage_case() == kError;
}
inline bool AnswerRequest::_internal_has_error() const {
  return stage_case() == kError;
}
inline void AnswerRequest::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void AnswerRequest::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kError) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.error_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::release_error() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.error)
  if (stage_case() == kError) {
    clear_has_stage();
    auto* temp = _impl_.stage_.error_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& AnswerRequest::_internal_error() const {
  return stage_case() == kError ? *_impl_.stage_.error_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerRequestErrorStage&>(::proto::rpc::webrtc::v1::_AnswerRequestErrorStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& AnswerRequest::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.error)
  return _internal_error();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.error)
  if (stage_case() == kError) {
    clear_has_stage();
    auto* temp = _impl_.stage_.error_;
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_error(::proto::rpc::webrtc::v1::AnswerRequestErrorStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_error();
    _impl_.stage_.error_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.error)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::_internal_mutable_error() {
  if (stage_case() != kError) {
    clear_stage();
    set_has_error();
    _impl_.stage_.error_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestErrorStage>(GetArena());
  }
  return _impl_.stage_.error_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.error)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerRequestHeartbeatStage heartbeat = 6 [json_name = "heartbeat"];
inline bool AnswerRequest::has_heartbeat() const {
  return stage_case() == kHeartbeat;
}
inline bool AnswerRequest::_internal_has_heartbeat() const {
  return stage_case() == kHeartbeat;
}
inline void AnswerRequest::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void AnswerRequest::clear_heartbeat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kHeartbeat) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.heartbeat_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* AnswerRequest::release_heartbeat() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.heartbeat)
  if (stage_case() == kHeartbeat) {
    clear_has_stage();
    auto* temp = _impl_.stage_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage& AnswerRequest::_internal_heartbeat() const {
  return stage_case() == kHeartbeat ? *_impl_.stage_.heartbeat_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage&>(::proto::rpc::webrtc::v1::_AnswerRequestHeartbeatStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage& AnswerRequest::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.heartbeat)
  return _internal_heartbeat();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* AnswerRequest::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.heartbeat)
  if (stage_case() == kHeartbeat) {
    clear_has_stage();
    auto* temp = _impl_.stage_.heartbeat_;
    _impl_.stage_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_heartbeat(::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_heartbeat();
    _impl_.stage_.heartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.heartbeat)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* AnswerRequest::_internal_mutable_heartbeat() {
  if (stage_case() != kHeartbeat) {
    clear_stage();
    set_has_heartbeat();
    _impl_.stage_.heartbeat_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage>(GetArena());
  }
  return _impl_.stage_.heartbeat_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* AnswerRequest::mutable_heartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerRequestHeartbeatStage* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.heartbeat)
  return _msg;
}

inline bool AnswerRequest::has_stage() const {
  return stage_case() != STAGE_NOT_SET;
}
inline void AnswerRequest::clear_has_stage() {
  _impl_._oneof_case_[0] = STAGE_NOT_SET;
}
inline AnswerRequest::StageCase AnswerRequest::stage_case() const {
  return AnswerRequest::StageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnswerResponseInitStage

// string sdp = 1 [json_name = "sdp"];
inline void AnswerResponseInitStage::clear_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& AnswerResponseInitStage::sdp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
  return _internal_sdp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnswerResponseInitStage::set_sdp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
}
inline std::string* AnswerResponseInitStage::mutable_sdp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
  return _s;
}
inline const std::string& AnswerResponseInitStage::_internal_sdp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdp_.Get();
}
inline void AnswerResponseInitStage::_internal_set_sdp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sdp_.Set(value, GetArena());
}
inline std::string* AnswerResponseInitStage::_internal_mutable_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sdp_.Mutable( GetArena());
}
inline std::string* AnswerResponseInitStage::release_sdp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
  return _impl_.sdp_.Release();
}
inline void AnswerResponseInitStage::set_allocated_sdp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdp_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sdp_.IsDefault()) {
          _impl_.sdp_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
}

// -------------------------------------------------------------------

// AnswerResponseUpdateStage

// .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
inline bool AnswerResponseUpdateStage::has_candidate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.candidate_ != nullptr);
  return value;
}
inline void AnswerResponseUpdateStage::clear_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.candidate_ != nullptr) _impl_.candidate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerResponseUpdateStage::_internal_candidate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::rpc::webrtc::v1::ICECandidate* p = _impl_.candidate_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::ICECandidate&>(::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerResponseUpdateStage::candidate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
  return _internal_candidate();
}
inline void AnswerResponseUpdateStage::unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.candidate_);
  }
  _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::ICECandidate* released = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::unsafe_arena_release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::_internal_mutable_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.candidate_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(GetArena());
    _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(p);
  }
  return _impl_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::mutable_candidate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
  return _msg;
}
inline void AnswerResponseUpdateStage::set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(_impl_.candidate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.candidate_ = reinterpret_cast<::proto::rpc::webrtc::v1::ICECandidate*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
}

// -------------------------------------------------------------------

// AnswerResponseDoneStage

// -------------------------------------------------------------------

// AnswerResponseErrorStage

// .google.rpc.Status status = 1 [json_name = "status"];
inline bool AnswerResponseErrorStage::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline const ::google::rpc::Status& AnswerResponseErrorStage::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::rpc::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& AnswerResponseErrorStage::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
  return _internal_status();
}
inline void AnswerResponseErrorStage::unsafe_arena_set_allocated_status(::google::rpc::Status* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::google::rpc::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
}
inline ::google::rpc::Status* AnswerResponseErrorStage::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::rpc::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::rpc::Status* AnswerResponseErrorStage::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* AnswerResponseErrorStage::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::google::rpc::Status*>(p);
  }
  return _impl_.status_;
}
inline ::google::rpc::Status* AnswerResponseErrorStage::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
  return _msg;
}
inline void AnswerResponseErrorStage::set_allocated_status(::google::rpc::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::google::rpc::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
}

// -------------------------------------------------------------------

// AnswerResponse

// string uuid = 1 [json_name = "uuid"];
inline void AnswerResponse::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& AnswerResponse::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnswerResponse::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerResponse.uuid)
}
inline std::string* AnswerResponse::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.uuid)
  return _s;
}
inline const std::string& AnswerResponse::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_.Get();
}
inline void AnswerResponse::_internal_set_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* AnswerResponse::_internal_mutable_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* AnswerResponse::release_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.uuid)
  return _impl_.uuid_.Release();
}
inline void AnswerResponse::set_allocated_uuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uuid_.IsDefault()) {
          _impl_.uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.uuid)
}

// .proto.rpc.webrtc.v1.AnswerResponseInitStage init = 2 [json_name = "init"];
inline bool AnswerResponse::has_init() const {
  return stage_case() == kInit;
}
inline bool AnswerResponse::_internal_has_init() const {
  return stage_case() == kInit;
}
inline void AnswerResponse::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void AnswerResponse::clear_init() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kInit) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.init_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::release_init() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.init)
  if (stage_case() == kInit) {
    clear_has_stage();
    auto* temp = _impl_.stage_.init_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& AnswerResponse::_internal_init() const {
  return stage_case() == kInit ? *_impl_.stage_.init_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerResponseInitStage&>(::proto::rpc::webrtc::v1::_AnswerResponseInitStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& AnswerResponse::init() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.init)
  return _internal_init();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.init)
  if (stage_case() == kInit) {
    clear_has_stage();
    auto* temp = _impl_.stage_.init_;
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::AnswerResponseInitStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_init();
    _impl_.stage_.init_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.init)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::_internal_mutable_init() {
  if (stage_case() != kInit) {
    clear_stage();
    set_has_init();
    _impl_.stage_.init_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseInitStage>(GetArena());
  }
  return _impl_.stage_.init_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::mutable_init() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.init)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerResponseUpdateStage update = 3 [json_name = "update"];
inline bool AnswerResponse::has_update() const {
  return stage_case() == kUpdate;
}
inline bool AnswerResponse::_internal_has_update() const {
  return stage_case() == kUpdate;
}
inline void AnswerResponse::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void AnswerResponse::clear_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.update_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::release_update() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.update)
  if (stage_case() == kUpdate) {
    clear_has_stage();
    auto* temp = _impl_.stage_.update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& AnswerResponse::_internal_update() const {
  return stage_case() == kUpdate ? *_impl_.stage_.update_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerResponseUpdateStage&>(::proto::rpc::webrtc::v1::_AnswerResponseUpdateStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& AnswerResponse::update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.update)
  return _internal_update();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.update)
  if (stage_case() == kUpdate) {
    clear_has_stage();
    auto* temp = _impl_.stage_.update_;
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_update();
    _impl_.stage_.update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.update)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::_internal_mutable_update() {
  if (stage_case() != kUpdate) {
    clear_stage();
    set_has_update();
    _impl_.stage_.update_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseUpdateStage>(GetArena());
  }
  return _impl_.stage_.update_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::mutable_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.update)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerResponseDoneStage done = 4 [json_name = "done"];
inline bool AnswerResponse::has_done() const {
  return stage_case() == kDone;
}
inline bool AnswerResponse::_internal_has_done() const {
  return stage_case() == kDone;
}
inline void AnswerResponse::set_has_done() {
  _impl_._oneof_case_[0] = kDone;
}
inline void AnswerResponse::clear_done() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kDone) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.done_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::release_done() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.done)
  if (stage_case() == kDone) {
    clear_has_stage();
    auto* temp = _impl_.stage_.done_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& AnswerResponse::_internal_done() const {
  return stage_case() == kDone ? *_impl_.stage_.done_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerResponseDoneStage&>(::proto::rpc::webrtc::v1::_AnswerResponseDoneStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& AnswerResponse::done() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.done)
  return _internal_done();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::unsafe_arena_release_done() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.done)
  if (stage_case() == kDone) {
    clear_has_stage();
    auto* temp = _impl_.stage_.done_;
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_done(::proto::rpc::webrtc::v1::AnswerResponseDoneStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_done();
    _impl_.stage_.done_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.done)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::_internal_mutable_done() {
  if (stage_case() != kDone) {
    clear_stage();
    set_has_done();
    _impl_.stage_.done_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseDoneStage>(GetArena());
  }
  return _impl_.stage_.done_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::mutable_done() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* _msg = _internal_mutable_done();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.done)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerResponseErrorStage error = 5 [json_name = "error"];
inline bool AnswerResponse::has_error() const {
  return stage_case() == kError;
}
inline bool AnswerResponse::_internal_has_error() const {
  return stage_case() == kError;
}
inline void AnswerResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void AnswerResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (stage_case() == kError) {
    if (GetArena() == nullptr) {
      delete _impl_.stage_.error_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::release_error() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.error)
  if (stage_case() == kError) {
    clear_has_stage();
    auto* temp = _impl_.stage_.error_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& AnswerResponse::_internal_error() const {
  return stage_case() == kError ? *_impl_.stage_.error_ : reinterpret_cast<::proto::rpc::webrtc::v1::AnswerResponseErrorStage&>(::proto::rpc::webrtc::v1::_AnswerResponseErrorStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& AnswerResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.error)
  return _internal_error();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.error)
  if (stage_case() == kError) {
    clear_has_stage();
    auto* temp = _impl_.stage_.error_;
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_error(::proto::rpc::webrtc::v1::AnswerResponseErrorStage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_stage();
  if (value) {
    set_has_error();
    _impl_.stage_.error_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.error)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::_internal_mutable_error() {
  if (stage_case() != kError) {
    clear_stage();
    set_has_error();
    _impl_.stage_.error_ = CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseErrorStage>(GetArena());
  }
  return _impl_.stage_.error_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.error)
  return _msg;
}

inline bool AnswerResponse::has_stage() const {
  return stage_case() != STAGE_NOT_SET;
}
inline void AnswerResponse::clear_has_stage() {
  _impl_._oneof_case_[0] = STAGE_NOT_SET;
}
inline AnswerResponse::StageCase AnswerResponse::stage_case() const {
  return AnswerResponse::StageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OptionalWebRTCConfigRequest

// -------------------------------------------------------------------

// OptionalWebRTCConfigResponse

// .proto.rpc.webrtc.v1.WebRTCConfig config = 1 [json_name = "config"];
inline bool OptionalWebRTCConfigResponse::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void OptionalWebRTCConfigResponse::clear_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& OptionalWebRTCConfigResponse::_internal_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::proto::rpc::webrtc::v1::WebRTCConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::WebRTCConfig&>(::proto::rpc::webrtc::v1::_WebRTCConfig_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& OptionalWebRTCConfigResponse::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
  return _internal_config();
}
inline void OptionalWebRTCConfigResponse::unsafe_arena_set_allocated_config(::proto::rpc::webrtc::v1::WebRTCConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::WebRTCConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::unsafe_arena_release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::rpc::webrtc::v1::WebRTCConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::_internal_mutable_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::WebRTCConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(p);
  }
  return _impl_.config_;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::proto::rpc::webrtc::v1::WebRTCConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
  return _msg;
}
inline void OptionalWebRTCConfigResponse::set_allocated_config(::proto::rpc::webrtc::v1::WebRTCConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::proto::rpc::webrtc::v1::WebRTCConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace webrtc
}  // namespace rpc
}  // namespace proto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto_2epb_2eh
