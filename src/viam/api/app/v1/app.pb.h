// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/v1/app.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "app/mltraining/v1/ml_training.pb.h"
#include "app/packages/v1/packages.pb.h"
#include "common/v1/common.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fv1_2fapp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fv1_2fapp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fv1_2fapp_2eproto;
namespace viam {
namespace app {
namespace v1 {
class APIKey;
struct APIKeyDefaultTypeInternal;
extern APIKeyDefaultTypeInternal _APIKey_default_instance_;
class APIKeyWithAuthorizations;
struct APIKeyWithAuthorizationsDefaultTypeInternal;
extern APIKeyWithAuthorizationsDefaultTypeInternal _APIKeyWithAuthorizations_default_instance_;
class AddRoleRequest;
struct AddRoleRequestDefaultTypeInternal;
extern AddRoleRequestDefaultTypeInternal _AddRoleRequest_default_instance_;
class AddRoleResponse;
struct AddRoleResponseDefaultTypeInternal;
extern AddRoleResponseDefaultTypeInternal _AddRoleResponse_default_instance_;
class AdditionalFragment;
struct AdditionalFragmentDefaultTypeInternal;
extern AdditionalFragmentDefaultTypeInternal _AdditionalFragment_default_instance_;
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class AppCustomizations;
struct AppCustomizationsDefaultTypeInternal;
extern AppCustomizationsDefaultTypeInternal _AppCustomizations_default_instance_;
class AuthenticatorInfo;
struct AuthenticatorInfoDefaultTypeInternal;
extern AuthenticatorInfoDefaultTypeInternal _AuthenticatorInfo_default_instance_;
class Authorization;
struct AuthorizationDefaultTypeInternal;
extern AuthorizationDefaultTypeInternal _Authorization_default_instance_;
class AuthorizationDetails;
struct AuthorizationDetailsDefaultTypeInternal;
extern AuthorizationDetailsDefaultTypeInternal _AuthorizationDetails_default_instance_;
class AuthorizedPermissions;
struct AuthorizedPermissionsDefaultTypeInternal;
extern AuthorizedPermissionsDefaultTypeInternal _AuthorizedPermissions_default_instance_;
class BillingAddress;
struct BillingAddressDefaultTypeInternal;
extern BillingAddressDefaultTypeInternal _BillingAddress_default_instance_;
class ChangeRoleRequest;
struct ChangeRoleRequestDefaultTypeInternal;
extern ChangeRoleRequestDefaultTypeInternal _ChangeRoleRequest_default_instance_;
class ChangeRoleResponse;
struct ChangeRoleResponseDefaultTypeInternal;
extern ChangeRoleResponseDefaultTypeInternal _ChangeRoleResponse_default_instance_;
class CheckPermissionsRequest;
struct CheckPermissionsRequestDefaultTypeInternal;
extern CheckPermissionsRequestDefaultTypeInternal _CheckPermissionsRequest_default_instance_;
class CheckPermissionsResponse;
struct CheckPermissionsResponseDefaultTypeInternal;
extern CheckPermissionsResponseDefaultTypeInternal _CheckPermissionsResponse_default_instance_;
class CreateFragmentRequest;
struct CreateFragmentRequestDefaultTypeInternal;
extern CreateFragmentRequestDefaultTypeInternal _CreateFragmentRequest_default_instance_;
class CreateFragmentResponse;
struct CreateFragmentResponseDefaultTypeInternal;
extern CreateFragmentResponseDefaultTypeInternal _CreateFragmentResponse_default_instance_;
class CreateKeyFromExistingKeyAuthorizationsRequest;
struct CreateKeyFromExistingKeyAuthorizationsRequestDefaultTypeInternal;
extern CreateKeyFromExistingKeyAuthorizationsRequestDefaultTypeInternal _CreateKeyFromExistingKeyAuthorizationsRequest_default_instance_;
class CreateKeyFromExistingKeyAuthorizationsResponse;
struct CreateKeyFromExistingKeyAuthorizationsResponseDefaultTypeInternal;
extern CreateKeyFromExistingKeyAuthorizationsResponseDefaultTypeInternal _CreateKeyFromExistingKeyAuthorizationsResponse_default_instance_;
class CreateKeyRequest;
struct CreateKeyRequestDefaultTypeInternal;
extern CreateKeyRequestDefaultTypeInternal _CreateKeyRequest_default_instance_;
class CreateKeyResponse;
struct CreateKeyResponseDefaultTypeInternal;
extern CreateKeyResponseDefaultTypeInternal _CreateKeyResponse_default_instance_;
class CreateLocationRequest;
struct CreateLocationRequestDefaultTypeInternal;
extern CreateLocationRequestDefaultTypeInternal _CreateLocationRequest_default_instance_;
class CreateLocationResponse;
struct CreateLocationResponseDefaultTypeInternal;
extern CreateLocationResponseDefaultTypeInternal _CreateLocationResponse_default_instance_;
class CreateLocationSecretRequest;
struct CreateLocationSecretRequestDefaultTypeInternal;
extern CreateLocationSecretRequestDefaultTypeInternal _CreateLocationSecretRequest_default_instance_;
class CreateLocationSecretResponse;
struct CreateLocationSecretResponseDefaultTypeInternal;
extern CreateLocationSecretResponseDefaultTypeInternal _CreateLocationSecretResponse_default_instance_;
class CreateModuleRequest;
struct CreateModuleRequestDefaultTypeInternal;
extern CreateModuleRequestDefaultTypeInternal _CreateModuleRequest_default_instance_;
class CreateModuleResponse;
struct CreateModuleResponseDefaultTypeInternal;
extern CreateModuleResponseDefaultTypeInternal _CreateModuleResponse_default_instance_;
class CreateOAuthAppRequest;
struct CreateOAuthAppRequestDefaultTypeInternal;
extern CreateOAuthAppRequestDefaultTypeInternal _CreateOAuthAppRequest_default_instance_;
class CreateOAuthAppResponse;
struct CreateOAuthAppResponseDefaultTypeInternal;
extern CreateOAuthAppResponseDefaultTypeInternal _CreateOAuthAppResponse_default_instance_;
class CreateOrganizationInviteRequest;
struct CreateOrganizationInviteRequestDefaultTypeInternal;
extern CreateOrganizationInviteRequestDefaultTypeInternal _CreateOrganizationInviteRequest_default_instance_;
class CreateOrganizationInviteResponse;
struct CreateOrganizationInviteResponseDefaultTypeInternal;
extern CreateOrganizationInviteResponseDefaultTypeInternal _CreateOrganizationInviteResponse_default_instance_;
class CreateOrganizationRequest;
struct CreateOrganizationRequestDefaultTypeInternal;
extern CreateOrganizationRequestDefaultTypeInternal _CreateOrganizationRequest_default_instance_;
class CreateOrganizationResponse;
struct CreateOrganizationResponseDefaultTypeInternal;
extern CreateOrganizationResponseDefaultTypeInternal _CreateOrganizationResponse_default_instance_;
class CreateRegistryItemRequest;
struct CreateRegistryItemRequestDefaultTypeInternal;
extern CreateRegistryItemRequestDefaultTypeInternal _CreateRegistryItemRequest_default_instance_;
class CreateRegistryItemResponse;
struct CreateRegistryItemResponseDefaultTypeInternal;
extern CreateRegistryItemResponseDefaultTypeInternal _CreateRegistryItemResponse_default_instance_;
class CreateRobotPartSecretRequest;
struct CreateRobotPartSecretRequestDefaultTypeInternal;
extern CreateRobotPartSecretRequestDefaultTypeInternal _CreateRobotPartSecretRequest_default_instance_;
class CreateRobotPartSecretResponse;
struct CreateRobotPartSecretResponseDefaultTypeInternal;
extern CreateRobotPartSecretResponseDefaultTypeInternal _CreateRobotPartSecretResponse_default_instance_;
class DeleteFragmentRequest;
struct DeleteFragmentRequestDefaultTypeInternal;
extern DeleteFragmentRequestDefaultTypeInternal _DeleteFragmentRequest_default_instance_;
class DeleteFragmentResponse;
struct DeleteFragmentResponseDefaultTypeInternal;
extern DeleteFragmentResponseDefaultTypeInternal _DeleteFragmentResponse_default_instance_;
class DeleteFragmentTagRequest;
struct DeleteFragmentTagRequestDefaultTypeInternal;
extern DeleteFragmentTagRequestDefaultTypeInternal _DeleteFragmentTagRequest_default_instance_;
class DeleteFragmentTagResponse;
struct DeleteFragmentTagResponseDefaultTypeInternal;
extern DeleteFragmentTagResponseDefaultTypeInternal _DeleteFragmentTagResponse_default_instance_;
class DeleteKeyRequest;
struct DeleteKeyRequestDefaultTypeInternal;
extern DeleteKeyRequestDefaultTypeInternal _DeleteKeyRequest_default_instance_;
class DeleteKeyResponse;
struct DeleteKeyResponseDefaultTypeInternal;
extern DeleteKeyResponseDefaultTypeInternal _DeleteKeyResponse_default_instance_;
class DeleteLocationRequest;
struct DeleteLocationRequestDefaultTypeInternal;
extern DeleteLocationRequestDefaultTypeInternal _DeleteLocationRequest_default_instance_;
class DeleteLocationResponse;
struct DeleteLocationResponseDefaultTypeInternal;
extern DeleteLocationResponseDefaultTypeInternal _DeleteLocationResponse_default_instance_;
class DeleteLocationSecretRequest;
struct DeleteLocationSecretRequestDefaultTypeInternal;
extern DeleteLocationSecretRequestDefaultTypeInternal _DeleteLocationSecretRequest_default_instance_;
class DeleteLocationSecretResponse;
struct DeleteLocationSecretResponseDefaultTypeInternal;
extern DeleteLocationSecretResponseDefaultTypeInternal _DeleteLocationSecretResponse_default_instance_;
class DeleteOAuthAppRequest;
struct DeleteOAuthAppRequestDefaultTypeInternal;
extern DeleteOAuthAppRequestDefaultTypeInternal _DeleteOAuthAppRequest_default_instance_;
class DeleteOAuthAppResponse;
struct DeleteOAuthAppResponseDefaultTypeInternal;
extern DeleteOAuthAppResponseDefaultTypeInternal _DeleteOAuthAppResponse_default_instance_;
class DeleteOrganizationInviteRequest;
struct DeleteOrganizationInviteRequestDefaultTypeInternal;
extern DeleteOrganizationInviteRequestDefaultTypeInternal _DeleteOrganizationInviteRequest_default_instance_;
class DeleteOrganizationInviteResponse;
struct DeleteOrganizationInviteResponseDefaultTypeInternal;
extern DeleteOrganizationInviteResponseDefaultTypeInternal _DeleteOrganizationInviteResponse_default_instance_;
class DeleteOrganizationMemberRequest;
struct DeleteOrganizationMemberRequestDefaultTypeInternal;
extern DeleteOrganizationMemberRequestDefaultTypeInternal _DeleteOrganizationMemberRequest_default_instance_;
class DeleteOrganizationMemberResponse;
struct DeleteOrganizationMemberResponseDefaultTypeInternal;
extern DeleteOrganizationMemberResponseDefaultTypeInternal _DeleteOrganizationMemberResponse_default_instance_;
class DeleteOrganizationRequest;
struct DeleteOrganizationRequestDefaultTypeInternal;
extern DeleteOrganizationRequestDefaultTypeInternal _DeleteOrganizationRequest_default_instance_;
class DeleteOrganizationResponse;
struct DeleteOrganizationResponseDefaultTypeInternal;
extern DeleteOrganizationResponseDefaultTypeInternal _DeleteOrganizationResponse_default_instance_;
class DeleteRegistryItemRequest;
struct DeleteRegistryItemRequestDefaultTypeInternal;
extern DeleteRegistryItemRequestDefaultTypeInternal _DeleteRegistryItemRequest_default_instance_;
class DeleteRegistryItemResponse;
struct DeleteRegistryItemResponseDefaultTypeInternal;
extern DeleteRegistryItemResponseDefaultTypeInternal _DeleteRegistryItemResponse_default_instance_;
class DeleteRobotPartRequest;
struct DeleteRobotPartRequestDefaultTypeInternal;
extern DeleteRobotPartRequestDefaultTypeInternal _DeleteRobotPartRequest_default_instance_;
class DeleteRobotPartResponse;
struct DeleteRobotPartResponseDefaultTypeInternal;
extern DeleteRobotPartResponseDefaultTypeInternal _DeleteRobotPartResponse_default_instance_;
class DeleteRobotPartSecretRequest;
struct DeleteRobotPartSecretRequestDefaultTypeInternal;
extern DeleteRobotPartSecretRequestDefaultTypeInternal _DeleteRobotPartSecretRequest_default_instance_;
class DeleteRobotPartSecretResponse;
struct DeleteRobotPartSecretResponseDefaultTypeInternal;
extern DeleteRobotPartSecretResponseDefaultTypeInternal _DeleteRobotPartSecretResponse_default_instance_;
class DeleteRobotRequest;
struct DeleteRobotRequestDefaultTypeInternal;
extern DeleteRobotRequestDefaultTypeInternal _DeleteRobotRequest_default_instance_;
class DeleteRobotResponse;
struct DeleteRobotResponseDefaultTypeInternal;
extern DeleteRobotResponseDefaultTypeInternal _DeleteRobotResponse_default_instance_;
class DisableAuthServiceRequest;
struct DisableAuthServiceRequestDefaultTypeInternal;
extern DisableAuthServiceRequestDefaultTypeInternal _DisableAuthServiceRequest_default_instance_;
class DisableAuthServiceResponse;
struct DisableAuthServiceResponseDefaultTypeInternal;
extern DisableAuthServiceResponseDefaultTypeInternal _DisableAuthServiceResponse_default_instance_;
class DisableBillingServiceRequest;
struct DisableBillingServiceRequestDefaultTypeInternal;
extern DisableBillingServiceRequestDefaultTypeInternal _DisableBillingServiceRequest_default_instance_;
class DisableBillingServiceResponse;
struct DisableBillingServiceResponseDefaultTypeInternal;
extern DisableBillingServiceResponseDefaultTypeInternal _DisableBillingServiceResponse_default_instance_;
class EnableAuthServiceRequest;
struct EnableAuthServiceRequestDefaultTypeInternal;
extern EnableAuthServiceRequestDefaultTypeInternal _EnableAuthServiceRequest_default_instance_;
class EnableAuthServiceResponse;
struct EnableAuthServiceResponseDefaultTypeInternal;
extern EnableAuthServiceResponseDefaultTypeInternal _EnableAuthServiceResponse_default_instance_;
class EnableBillingServiceRequest;
struct EnableBillingServiceRequestDefaultTypeInternal;
extern EnableBillingServiceRequestDefaultTypeInternal _EnableBillingServiceRequest_default_instance_;
class EnableBillingServiceResponse;
struct EnableBillingServiceResponseDefaultTypeInternal;
extern EnableBillingServiceResponseDefaultTypeInternal _EnableBillingServiceResponse_default_instance_;
class Fragment;
struct FragmentDefaultTypeInternal;
extern FragmentDefaultTypeInternal _Fragment_default_instance_;
class FragmentError;
struct FragmentErrorDefaultTypeInternal;
extern FragmentErrorDefaultTypeInternal _FragmentError_default_instance_;
class FragmentHistoryEntry;
struct FragmentHistoryEntryDefaultTypeInternal;
extern FragmentHistoryEntryDefaultTypeInternal _FragmentHistoryEntry_default_instance_;
class FragmentImport;
struct FragmentImportDefaultTypeInternal;
extern FragmentImportDefaultTypeInternal _FragmentImport_default_instance_;
class FragmentImportList;
struct FragmentImportListDefaultTypeInternal;
extern FragmentImportListDefaultTypeInternal _FragmentImportList_default_instance_;
class FragmentImport_VariablesEntry_DoNotUse;
struct FragmentImport_VariablesEntry_DoNotUseDefaultTypeInternal;
extern FragmentImport_VariablesEntry_DoNotUseDefaultTypeInternal _FragmentImport_VariablesEntry_DoNotUse_default_instance_;
class FragmentRevision;
struct FragmentRevisionDefaultTypeInternal;
extern FragmentRevisionDefaultTypeInternal _FragmentRevision_default_instance_;
class FragmentSummary;
struct FragmentSummaryDefaultTypeInternal;
extern FragmentSummaryDefaultTypeInternal _FragmentSummary_default_instance_;
class FragmentTag;
struct FragmentTagDefaultTypeInternal;
extern FragmentTagDefaultTypeInternal _FragmentTag_default_instance_;
class FragmentUsage;
struct FragmentUsageDefaultTypeInternal;
extern FragmentUsageDefaultTypeInternal _FragmentUsage_default_instance_;
class GetAppBrandingRequest;
struct GetAppBrandingRequestDefaultTypeInternal;
extern GetAppBrandingRequestDefaultTypeInternal _GetAppBrandingRequest_default_instance_;
class GetAppBrandingResponse;
struct GetAppBrandingResponseDefaultTypeInternal;
extern GetAppBrandingResponseDefaultTypeInternal _GetAppBrandingResponse_default_instance_;
class GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse;
struct GetAppBrandingResponse_TextCustomizationsEntry_DoNotUseDefaultTypeInternal;
extern GetAppBrandingResponse_TextCustomizationsEntry_DoNotUseDefaultTypeInternal _GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse_default_instance_;
class GetAppContentRequest;
struct GetAppContentRequestDefaultTypeInternal;
extern GetAppContentRequestDefaultTypeInternal _GetAppContentRequest_default_instance_;
class GetAppContentResponse;
struct GetAppContentResponseDefaultTypeInternal;
extern GetAppContentResponseDefaultTypeInternal _GetAppContentResponse_default_instance_;
class GetBillingServiceConfigRequest;
struct GetBillingServiceConfigRequestDefaultTypeInternal;
extern GetBillingServiceConfigRequestDefaultTypeInternal _GetBillingServiceConfigRequest_default_instance_;
class GetBillingServiceConfigResponse;
struct GetBillingServiceConfigResponseDefaultTypeInternal;
extern GetBillingServiceConfigResponseDefaultTypeInternal _GetBillingServiceConfigResponse_default_instance_;
class GetFragmentHistoryRequest;
struct GetFragmentHistoryRequestDefaultTypeInternal;
extern GetFragmentHistoryRequestDefaultTypeInternal _GetFragmentHistoryRequest_default_instance_;
class GetFragmentHistoryResponse;
struct GetFragmentHistoryResponseDefaultTypeInternal;
extern GetFragmentHistoryResponseDefaultTypeInternal _GetFragmentHistoryResponse_default_instance_;
class GetFragmentRequest;
struct GetFragmentRequestDefaultTypeInternal;
extern GetFragmentRequestDefaultTypeInternal _GetFragmentRequest_default_instance_;
class GetFragmentResponse;
struct GetFragmentResponseDefaultTypeInternal;
extern GetFragmentResponseDefaultTypeInternal _GetFragmentResponse_default_instance_;
class GetFragmentUsageRequest;
struct GetFragmentUsageRequestDefaultTypeInternal;
extern GetFragmentUsageRequestDefaultTypeInternal _GetFragmentUsageRequest_default_instance_;
class GetFragmentUsageResponse;
struct GetFragmentUsageResponseDefaultTypeInternal;
extern GetFragmentUsageResponseDefaultTypeInternal _GetFragmentUsageResponse_default_instance_;
class GetLocationMetadataRequest;
struct GetLocationMetadataRequestDefaultTypeInternal;
extern GetLocationMetadataRequestDefaultTypeInternal _GetLocationMetadataRequest_default_instance_;
class GetLocationMetadataResponse;
struct GetLocationMetadataResponseDefaultTypeInternal;
extern GetLocationMetadataResponseDefaultTypeInternal _GetLocationMetadataResponse_default_instance_;
class GetLocationRequest;
struct GetLocationRequestDefaultTypeInternal;
extern GetLocationRequestDefaultTypeInternal _GetLocationRequest_default_instance_;
class GetLocationResponse;
struct GetLocationResponseDefaultTypeInternal;
extern GetLocationResponseDefaultTypeInternal _GetLocationResponse_default_instance_;
class GetModuleRequest;
struct GetModuleRequestDefaultTypeInternal;
extern GetModuleRequestDefaultTypeInternal _GetModuleRequest_default_instance_;
class GetModuleResponse;
struct GetModuleResponseDefaultTypeInternal;
extern GetModuleResponseDefaultTypeInternal _GetModuleResponse_default_instance_;
class GetOrganizationMetadataRequest;
struct GetOrganizationMetadataRequestDefaultTypeInternal;
extern GetOrganizationMetadataRequestDefaultTypeInternal _GetOrganizationMetadataRequest_default_instance_;
class GetOrganizationMetadataResponse;
struct GetOrganizationMetadataResponseDefaultTypeInternal;
extern GetOrganizationMetadataResponseDefaultTypeInternal _GetOrganizationMetadataResponse_default_instance_;
class GetOrganizationNamespaceAvailabilityRequest;
struct GetOrganizationNamespaceAvailabilityRequestDefaultTypeInternal;
extern GetOrganizationNamespaceAvailabilityRequestDefaultTypeInternal _GetOrganizationNamespaceAvailabilityRequest_default_instance_;
class GetOrganizationNamespaceAvailabilityResponse;
struct GetOrganizationNamespaceAvailabilityResponseDefaultTypeInternal;
extern GetOrganizationNamespaceAvailabilityResponseDefaultTypeInternal _GetOrganizationNamespaceAvailabilityResponse_default_instance_;
class GetOrganizationRequest;
struct GetOrganizationRequestDefaultTypeInternal;
extern GetOrganizationRequestDefaultTypeInternal _GetOrganizationRequest_default_instance_;
class GetOrganizationResponse;
struct GetOrganizationResponseDefaultTypeInternal;
extern GetOrganizationResponseDefaultTypeInternal _GetOrganizationResponse_default_instance_;
class GetOrganizationsWithAccessToLocationRequest;
struct GetOrganizationsWithAccessToLocationRequestDefaultTypeInternal;
extern GetOrganizationsWithAccessToLocationRequestDefaultTypeInternal _GetOrganizationsWithAccessToLocationRequest_default_instance_;
class GetOrganizationsWithAccessToLocationResponse;
struct GetOrganizationsWithAccessToLocationResponseDefaultTypeInternal;
extern GetOrganizationsWithAccessToLocationResponseDefaultTypeInternal _GetOrganizationsWithAccessToLocationResponse_default_instance_;
class GetRegistryItemRequest;
struct GetRegistryItemRequestDefaultTypeInternal;
extern GetRegistryItemRequestDefaultTypeInternal _GetRegistryItemRequest_default_instance_;
class GetRegistryItemResponse;
struct GetRegistryItemResponseDefaultTypeInternal;
extern GetRegistryItemResponseDefaultTypeInternal _GetRegistryItemResponse_default_instance_;
class GetRobotAPIKeysRequest;
struct GetRobotAPIKeysRequestDefaultTypeInternal;
extern GetRobotAPIKeysRequestDefaultTypeInternal _GetRobotAPIKeysRequest_default_instance_;
class GetRobotAPIKeysResponse;
struct GetRobotAPIKeysResponseDefaultTypeInternal;
extern GetRobotAPIKeysResponseDefaultTypeInternal _GetRobotAPIKeysResponse_default_instance_;
class GetRobotMetadataRequest;
struct GetRobotMetadataRequestDefaultTypeInternal;
extern GetRobotMetadataRequestDefaultTypeInternal _GetRobotMetadataRequest_default_instance_;
class GetRobotMetadataResponse;
struct GetRobotMetadataResponseDefaultTypeInternal;
extern GetRobotMetadataResponseDefaultTypeInternal _GetRobotMetadataResponse_default_instance_;
class GetRobotPartByNameAndLocationRequest;
struct GetRobotPartByNameAndLocationRequestDefaultTypeInternal;
extern GetRobotPartByNameAndLocationRequestDefaultTypeInternal _GetRobotPartByNameAndLocationRequest_default_instance_;
class GetRobotPartByNameAndLocationResponse;
struct GetRobotPartByNameAndLocationResponseDefaultTypeInternal;
extern GetRobotPartByNameAndLocationResponseDefaultTypeInternal _GetRobotPartByNameAndLocationResponse_default_instance_;
class GetRobotPartHistoryRequest;
struct GetRobotPartHistoryRequestDefaultTypeInternal;
extern GetRobotPartHistoryRequestDefaultTypeInternal _GetRobotPartHistoryRequest_default_instance_;
class GetRobotPartHistoryResponse;
struct GetRobotPartHistoryResponseDefaultTypeInternal;
extern GetRobotPartHistoryResponseDefaultTypeInternal _GetRobotPartHistoryResponse_default_instance_;
class GetRobotPartLogsRequest;
struct GetRobotPartLogsRequestDefaultTypeInternal;
extern GetRobotPartLogsRequestDefaultTypeInternal _GetRobotPartLogsRequest_default_instance_;
class GetRobotPartLogsResponse;
struct GetRobotPartLogsResponseDefaultTypeInternal;
extern GetRobotPartLogsResponseDefaultTypeInternal _GetRobotPartLogsResponse_default_instance_;
class GetRobotPartMetadataRequest;
struct GetRobotPartMetadataRequestDefaultTypeInternal;
extern GetRobotPartMetadataRequestDefaultTypeInternal _GetRobotPartMetadataRequest_default_instance_;
class GetRobotPartMetadataResponse;
struct GetRobotPartMetadataResponseDefaultTypeInternal;
extern GetRobotPartMetadataResponseDefaultTypeInternal _GetRobotPartMetadataResponse_default_instance_;
class GetRobotPartRequest;
struct GetRobotPartRequestDefaultTypeInternal;
extern GetRobotPartRequestDefaultTypeInternal _GetRobotPartRequest_default_instance_;
class GetRobotPartResponse;
struct GetRobotPartResponseDefaultTypeInternal;
extern GetRobotPartResponseDefaultTypeInternal _GetRobotPartResponse_default_instance_;
class GetRobotPartsRequest;
struct GetRobotPartsRequestDefaultTypeInternal;
extern GetRobotPartsRequestDefaultTypeInternal _GetRobotPartsRequest_default_instance_;
class GetRobotPartsResponse;
struct GetRobotPartsResponseDefaultTypeInternal;
extern GetRobotPartsResponseDefaultTypeInternal _GetRobotPartsResponse_default_instance_;
class GetRobotRequest;
struct GetRobotRequestDefaultTypeInternal;
extern GetRobotRequestDefaultTypeInternal _GetRobotRequest_default_instance_;
class GetRobotResponse;
struct GetRobotResponseDefaultTypeInternal;
extern GetRobotResponseDefaultTypeInternal _GetRobotResponse_default_instance_;
class GetRoverRentalRobotsRequest;
struct GetRoverRentalRobotsRequestDefaultTypeInternal;
extern GetRoverRentalRobotsRequestDefaultTypeInternal _GetRoverRentalRobotsRequest_default_instance_;
class GetRoverRentalRobotsResponse;
struct GetRoverRentalRobotsResponseDefaultTypeInternal;
extern GetRoverRentalRobotsResponseDefaultTypeInternal _GetRoverRentalRobotsResponse_default_instance_;
class GetUserIDByEmailRequest;
struct GetUserIDByEmailRequestDefaultTypeInternal;
extern GetUserIDByEmailRequestDefaultTypeInternal _GetUserIDByEmailRequest_default_instance_;
class GetUserIDByEmailResponse;
struct GetUserIDByEmailResponseDefaultTypeInternal;
extern GetUserIDByEmailResponseDefaultTypeInternal _GetUserIDByEmailResponse_default_instance_;
class ListAuthorizationsRequest;
struct ListAuthorizationsRequestDefaultTypeInternal;
extern ListAuthorizationsRequestDefaultTypeInternal _ListAuthorizationsRequest_default_instance_;
class ListAuthorizationsResponse;
struct ListAuthorizationsResponseDefaultTypeInternal;
extern ListAuthorizationsResponseDefaultTypeInternal _ListAuthorizationsResponse_default_instance_;
class ListFragmentsRequest;
struct ListFragmentsRequestDefaultTypeInternal;
extern ListFragmentsRequestDefaultTypeInternal _ListFragmentsRequest_default_instance_;
class ListFragmentsResponse;
struct ListFragmentsResponseDefaultTypeInternal;
extern ListFragmentsResponseDefaultTypeInternal _ListFragmentsResponse_default_instance_;
class ListKeysRequest;
struct ListKeysRequestDefaultTypeInternal;
extern ListKeysRequestDefaultTypeInternal _ListKeysRequest_default_instance_;
class ListKeysResponse;
struct ListKeysResponseDefaultTypeInternal;
extern ListKeysResponseDefaultTypeInternal _ListKeysResponse_default_instance_;
class ListLocationsRequest;
struct ListLocationsRequestDefaultTypeInternal;
extern ListLocationsRequestDefaultTypeInternal _ListLocationsRequest_default_instance_;
class ListLocationsResponse;
struct ListLocationsResponseDefaultTypeInternal;
extern ListLocationsResponseDefaultTypeInternal _ListLocationsResponse_default_instance_;
class ListMachineFragmentsRequest;
struct ListMachineFragmentsRequestDefaultTypeInternal;
extern ListMachineFragmentsRequestDefaultTypeInternal _ListMachineFragmentsRequest_default_instance_;
class ListMachineFragmentsResponse;
struct ListMachineFragmentsResponseDefaultTypeInternal;
extern ListMachineFragmentsResponseDefaultTypeInternal _ListMachineFragmentsResponse_default_instance_;
class ListMachineSummariesRequest;
struct ListMachineSummariesRequestDefaultTypeInternal;
extern ListMachineSummariesRequestDefaultTypeInternal _ListMachineSummariesRequest_default_instance_;
class ListMachineSummariesResponse;
struct ListMachineSummariesResponseDefaultTypeInternal;
extern ListMachineSummariesResponseDefaultTypeInternal _ListMachineSummariesResponse_default_instance_;
class ListModulesRequest;
struct ListModulesRequestDefaultTypeInternal;
extern ListModulesRequestDefaultTypeInternal _ListModulesRequest_default_instance_;
class ListModulesResponse;
struct ListModulesResponseDefaultTypeInternal;
extern ListModulesResponseDefaultTypeInternal _ListModulesResponse_default_instance_;
class ListNestedFragmentsRequest;
struct ListNestedFragmentsRequestDefaultTypeInternal;
extern ListNestedFragmentsRequestDefaultTypeInternal _ListNestedFragmentsRequest_default_instance_;
class ListNestedFragmentsResponse;
struct ListNestedFragmentsResponseDefaultTypeInternal;
extern ListNestedFragmentsResponseDefaultTypeInternal _ListNestedFragmentsResponse_default_instance_;
class ListOAuthAppsRequest;
struct ListOAuthAppsRequestDefaultTypeInternal;
extern ListOAuthAppsRequestDefaultTypeInternal _ListOAuthAppsRequest_default_instance_;
class ListOAuthAppsResponse;
struct ListOAuthAppsResponseDefaultTypeInternal;
extern ListOAuthAppsResponseDefaultTypeInternal _ListOAuthAppsResponse_default_instance_;
class ListOrganizationMembersRequest;
struct ListOrganizationMembersRequestDefaultTypeInternal;
extern ListOrganizationMembersRequestDefaultTypeInternal _ListOrganizationMembersRequest_default_instance_;
class ListOrganizationMembersResponse;
struct ListOrganizationMembersResponseDefaultTypeInternal;
extern ListOrganizationMembersResponseDefaultTypeInternal _ListOrganizationMembersResponse_default_instance_;
class ListOrganizationsByUserRequest;
struct ListOrganizationsByUserRequestDefaultTypeInternal;
extern ListOrganizationsByUserRequestDefaultTypeInternal _ListOrganizationsByUserRequest_default_instance_;
class ListOrganizationsByUserResponse;
struct ListOrganizationsByUserResponseDefaultTypeInternal;
extern ListOrganizationsByUserResponseDefaultTypeInternal _ListOrganizationsByUserResponse_default_instance_;
class ListOrganizationsRequest;
struct ListOrganizationsRequestDefaultTypeInternal;
extern ListOrganizationsRequestDefaultTypeInternal _ListOrganizationsRequest_default_instance_;
class ListOrganizationsResponse;
struct ListOrganizationsResponseDefaultTypeInternal;
extern ListOrganizationsResponseDefaultTypeInternal _ListOrganizationsResponse_default_instance_;
class ListRegistryItemsRequest;
struct ListRegistryItemsRequestDefaultTypeInternal;
extern ListRegistryItemsRequestDefaultTypeInternal _ListRegistryItemsRequest_default_instance_;
class ListRegistryItemsResponse;
struct ListRegistryItemsResponseDefaultTypeInternal;
extern ListRegistryItemsResponseDefaultTypeInternal _ListRegistryItemsResponse_default_instance_;
class ListRobotsForLocationsRequest;
struct ListRobotsForLocationsRequestDefaultTypeInternal;
extern ListRobotsForLocationsRequestDefaultTypeInternal _ListRobotsForLocationsRequest_default_instance_;
class ListRobotsForLocationsResponse;
struct ListRobotsForLocationsResponseDefaultTypeInternal;
extern ListRobotsForLocationsResponseDefaultTypeInternal _ListRobotsForLocationsResponse_default_instance_;
class ListRobotsForOrgRequest;
struct ListRobotsForOrgRequestDefaultTypeInternal;
extern ListRobotsForOrgRequestDefaultTypeInternal _ListRobotsForOrgRequest_default_instance_;
class ListRobotsForOrgResponse;
struct ListRobotsForOrgResponseDefaultTypeInternal;
extern ListRobotsForOrgResponseDefaultTypeInternal _ListRobotsForOrgResponse_default_instance_;
class ListRobotsRequest;
struct ListRobotsRequestDefaultTypeInternal;
extern ListRobotsRequestDefaultTypeInternal _ListRobotsRequest_default_instance_;
class ListRobotsResponse;
struct ListRobotsResponseDefaultTypeInternal;
extern ListRobotsResponseDefaultTypeInternal _ListRobotsResponse_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class LocationAuth;
struct LocationAuthDefaultTypeInternal;
extern LocationAuthDefaultTypeInternal _LocationAuth_default_instance_;
class LocationAuthRequest;
struct LocationAuthRequestDefaultTypeInternal;
extern LocationAuthRequestDefaultTypeInternal _LocationAuthRequest_default_instance_;
class LocationAuthResponse;
struct LocationAuthResponseDefaultTypeInternal;
extern LocationAuthResponseDefaultTypeInternal _LocationAuthResponse_default_instance_;
class LocationOrganization;
struct LocationOrganizationDefaultTypeInternal;
extern LocationOrganizationDefaultTypeInternal _LocationOrganization_default_instance_;
class LocationSummary;
struct LocationSummaryDefaultTypeInternal;
extern LocationSummaryDefaultTypeInternal _LocationSummary_default_instance_;
class MLModelMetadata;
struct MLModelMetadataDefaultTypeInternal;
extern MLModelMetadataDefaultTypeInternal _MLModelMetadata_default_instance_;
class MLTrainingMetadata;
struct MLTrainingMetadataDefaultTypeInternal;
extern MLTrainingMetadataDefaultTypeInternal _MLTrainingMetadata_default_instance_;
class MLTrainingVersion;
struct MLTrainingVersionDefaultTypeInternal;
extern MLTrainingVersionDefaultTypeInternal _MLTrainingVersion_default_instance_;
class MachinePickerCustomizations;
struct MachinePickerCustomizationsDefaultTypeInternal;
extern MachinePickerCustomizationsDefaultTypeInternal _MachinePickerCustomizations_default_instance_;
class MachineSummary;
struct MachineSummaryDefaultTypeInternal;
extern MachineSummaryDefaultTypeInternal _MachineSummary_default_instance_;
class MarkPartAsMainRequest;
struct MarkPartAsMainRequestDefaultTypeInternal;
extern MarkPartAsMainRequestDefaultTypeInternal _MarkPartAsMainRequest_default_instance_;
class MarkPartAsMainResponse;
struct MarkPartAsMainResponseDefaultTypeInternal;
extern MarkPartAsMainResponseDefaultTypeInternal _MarkPartAsMainResponse_default_instance_;
class MarkPartForRestartRequest;
struct MarkPartForRestartRequestDefaultTypeInternal;
extern MarkPartForRestartRequestDefaultTypeInternal _MarkPartForRestartRequest_default_instance_;
class MarkPartForRestartResponse;
struct MarkPartForRestartResponseDefaultTypeInternal;
extern MarkPartForRestartResponseDefaultTypeInternal _MarkPartForRestartResponse_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Module;
struct ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class ModuleFileInfo;
struct ModuleFileInfoDefaultTypeInternal;
extern ModuleFileInfoDefaultTypeInternal _ModuleFileInfo_default_instance_;
class ModuleMetadata;
struct ModuleMetadataDefaultTypeInternal;
extern ModuleMetadataDefaultTypeInternal _ModuleMetadata_default_instance_;
class ModuleVersion;
struct ModuleVersionDefaultTypeInternal;
extern ModuleVersionDefaultTypeInternal _ModuleVersion_default_instance_;
class NewRobotPartRequest;
struct NewRobotPartRequestDefaultTypeInternal;
extern NewRobotPartRequestDefaultTypeInternal _NewRobotPartRequest_default_instance_;
class NewRobotPartResponse;
struct NewRobotPartResponseDefaultTypeInternal;
extern NewRobotPartResponseDefaultTypeInternal _NewRobotPartResponse_default_instance_;
class NewRobotRequest;
struct NewRobotRequestDefaultTypeInternal;
extern NewRobotRequestDefaultTypeInternal _NewRobotRequest_default_instance_;
class NewRobotResponse;
struct NewRobotResponseDefaultTypeInternal;
extern NewRobotResponseDefaultTypeInternal _NewRobotResponse_default_instance_;
class OAuthConfig;
struct OAuthConfigDefaultTypeInternal;
extern OAuthConfigDefaultTypeInternal _OAuthConfig_default_instance_;
class OrgDetails;
struct OrgDetailsDefaultTypeInternal;
extern OrgDetailsDefaultTypeInternal _OrgDetails_default_instance_;
class Organization;
struct OrganizationDefaultTypeInternal;
extern OrganizationDefaultTypeInternal _Organization_default_instance_;
class OrganizationGetLogoRequest;
struct OrganizationGetLogoRequestDefaultTypeInternal;
extern OrganizationGetLogoRequestDefaultTypeInternal _OrganizationGetLogoRequest_default_instance_;
class OrganizationGetLogoResponse;
struct OrganizationGetLogoResponseDefaultTypeInternal;
extern OrganizationGetLogoResponseDefaultTypeInternal _OrganizationGetLogoResponse_default_instance_;
class OrganizationGetSupportEmailRequest;
struct OrganizationGetSupportEmailRequestDefaultTypeInternal;
extern OrganizationGetSupportEmailRequestDefaultTypeInternal _OrganizationGetSupportEmailRequest_default_instance_;
class OrganizationGetSupportEmailResponse;
struct OrganizationGetSupportEmailResponseDefaultTypeInternal;
extern OrganizationGetSupportEmailResponseDefaultTypeInternal _OrganizationGetSupportEmailResponse_default_instance_;
class OrganizationIdentity;
struct OrganizationIdentityDefaultTypeInternal;
extern OrganizationIdentityDefaultTypeInternal _OrganizationIdentity_default_instance_;
class OrganizationInvite;
struct OrganizationInviteDefaultTypeInternal;
extern OrganizationInviteDefaultTypeInternal _OrganizationInvite_default_instance_;
class OrganizationMember;
struct OrganizationMemberDefaultTypeInternal;
extern OrganizationMemberDefaultTypeInternal _OrganizationMember_default_instance_;
class OrganizationSetLogoRequest;
struct OrganizationSetLogoRequestDefaultTypeInternal;
extern OrganizationSetLogoRequestDefaultTypeInternal _OrganizationSetLogoRequest_default_instance_;
class OrganizationSetLogoResponse;
struct OrganizationSetLogoResponseDefaultTypeInternal;
extern OrganizationSetLogoResponseDefaultTypeInternal _OrganizationSetLogoResponse_default_instance_;
class OrganizationSetSupportEmailRequest;
struct OrganizationSetSupportEmailRequestDefaultTypeInternal;
extern OrganizationSetSupportEmailRequestDefaultTypeInternal _OrganizationSetSupportEmailRequest_default_instance_;
class OrganizationSetSupportEmailResponse;
struct OrganizationSetSupportEmailResponseDefaultTypeInternal;
extern OrganizationSetSupportEmailResponseDefaultTypeInternal _OrganizationSetSupportEmailResponse_default_instance_;
class PartSummary;
struct PartSummaryDefaultTypeInternal;
extern PartSummaryDefaultTypeInternal _PartSummary_default_instance_;
class ReadOAuthAppRequest;
struct ReadOAuthAppRequestDefaultTypeInternal;
extern ReadOAuthAppRequestDefaultTypeInternal _ReadOAuthAppRequest_default_instance_;
class ReadOAuthAppResponse;
struct ReadOAuthAppResponseDefaultTypeInternal;
extern ReadOAuthAppResponseDefaultTypeInternal _ReadOAuthAppResponse_default_instance_;
class RegistryItem;
struct RegistryItemDefaultTypeInternal;
extern RegistryItemDefaultTypeInternal _RegistryItem_default_instance_;
class RemoveRoleRequest;
struct RemoveRoleRequestDefaultTypeInternal;
extern RemoveRoleRequestDefaultTypeInternal _RemoveRoleRequest_default_instance_;
class RemoveRoleResponse;
struct RemoveRoleResponseDefaultTypeInternal;
extern RemoveRoleResponseDefaultTypeInternal _RemoveRoleResponse_default_instance_;
class RenameKeyRequest;
struct RenameKeyRequestDefaultTypeInternal;
extern RenameKeyRequestDefaultTypeInternal _RenameKeyRequest_default_instance_;
class RenameKeyResponse;
struct RenameKeyResponseDefaultTypeInternal;
extern RenameKeyResponseDefaultTypeInternal _RenameKeyResponse_default_instance_;
class RenameRegistryItemRequest;
struct RenameRegistryItemRequestDefaultTypeInternal;
extern RenameRegistryItemRequestDefaultTypeInternal _RenameRegistryItemRequest_default_instance_;
class RenameRegistryItemResponse;
struct RenameRegistryItemResponseDefaultTypeInternal;
extern RenameRegistryItemResponseDefaultTypeInternal _RenameRegistryItemResponse_default_instance_;
class ResendOrganizationInviteRequest;
struct ResendOrganizationInviteRequestDefaultTypeInternal;
extern ResendOrganizationInviteRequestDefaultTypeInternal _ResendOrganizationInviteRequest_default_instance_;
class ResendOrganizationInviteResponse;
struct ResendOrganizationInviteResponseDefaultTypeInternal;
extern ResendOrganizationInviteResponseDefaultTypeInternal _ResendOrganizationInviteResponse_default_instance_;
class ResolvedFragment;
struct ResolvedFragmentDefaultTypeInternal;
extern ResolvedFragmentDefaultTypeInternal _ResolvedFragment_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class RobotPart;
struct RobotPartDefaultTypeInternal;
extern RobotPartDefaultTypeInternal _RobotPart_default_instance_;
class RobotPartHistoryEntry;
struct RobotPartHistoryEntryDefaultTypeInternal;
extern RobotPartHistoryEntryDefaultTypeInternal _RobotPartHistoryEntry_default_instance_;
class RotateKeyRequest;
struct RotateKeyRequestDefaultTypeInternal;
extern RotateKeyRequestDefaultTypeInternal _RotateKeyRequest_default_instance_;
class RotateKeyResponse;
struct RotateKeyResponseDefaultTypeInternal;
extern RotateKeyResponseDefaultTypeInternal _RotateKeyResponse_default_instance_;
class RoverRentalRobot;
struct RoverRentalRobotDefaultTypeInternal;
extern RoverRentalRobotDefaultTypeInternal _RoverRentalRobot_default_instance_;
class SearchOrganizationsRequest;
struct SearchOrganizationsRequestDefaultTypeInternal;
extern SearchOrganizationsRequestDefaultTypeInternal _SearchOrganizationsRequest_default_instance_;
class SearchOrganizationsResponse;
struct SearchOrganizationsResponseDefaultTypeInternal;
extern SearchOrganizationsResponseDefaultTypeInternal _SearchOrganizationsResponse_default_instance_;
class SetFragmentTagRequest;
struct SetFragmentTagRequestDefaultTypeInternal;
extern SetFragmentTagRequestDefaultTypeInternal _SetFragmentTagRequest_default_instance_;
class SetFragmentTagResponse;
struct SetFragmentTagResponseDefaultTypeInternal;
extern SetFragmentTagResponseDefaultTypeInternal _SetFragmentTagResponse_default_instance_;
class ShareLocationRequest;
struct ShareLocationRequestDefaultTypeInternal;
extern ShareLocationRequestDefaultTypeInternal _ShareLocationRequest_default_instance_;
class ShareLocationResponse;
struct ShareLocationResponseDefaultTypeInternal;
extern ShareLocationResponseDefaultTypeInternal _ShareLocationResponse_default_instance_;
class SharedSecret;
struct SharedSecretDefaultTypeInternal;
extern SharedSecretDefaultTypeInternal _SharedSecret_default_instance_;
class StorageConfig;
struct StorageConfigDefaultTypeInternal;
extern StorageConfigDefaultTypeInternal _StorageConfig_default_instance_;
class TailRobotPartLogsRequest;
struct TailRobotPartLogsRequestDefaultTypeInternal;
extern TailRobotPartLogsRequestDefaultTypeInternal _TailRobotPartLogsRequest_default_instance_;
class TailRobotPartLogsResponse;
struct TailRobotPartLogsResponseDefaultTypeInternal;
extern TailRobotPartLogsResponseDefaultTypeInternal _TailRobotPartLogsResponse_default_instance_;
class TextOverrides;
struct TextOverridesDefaultTypeInternal;
extern TextOverridesDefaultTypeInternal _TextOverrides_default_instance_;
class TextOverrides_FieldsEntry_DoNotUse;
struct TextOverrides_FieldsEntry_DoNotUseDefaultTypeInternal;
extern TextOverrides_FieldsEntry_DoNotUseDefaultTypeInternal _TextOverrides_FieldsEntry_DoNotUse_default_instance_;
class TransferRegistryItemRequest;
struct TransferRegistryItemRequestDefaultTypeInternal;
extern TransferRegistryItemRequestDefaultTypeInternal _TransferRegistryItemRequest_default_instance_;
class TransferRegistryItemResponse;
struct TransferRegistryItemResponseDefaultTypeInternal;
extern TransferRegistryItemResponseDefaultTypeInternal _TransferRegistryItemResponse_default_instance_;
class UnshareLocationRequest;
struct UnshareLocationRequestDefaultTypeInternal;
extern UnshareLocationRequestDefaultTypeInternal _UnshareLocationRequest_default_instance_;
class UnshareLocationResponse;
struct UnshareLocationResponseDefaultTypeInternal;
extern UnshareLocationResponseDefaultTypeInternal _UnshareLocationResponse_default_instance_;
class UpdateBillingServiceRequest;
struct UpdateBillingServiceRequestDefaultTypeInternal;
extern UpdateBillingServiceRequestDefaultTypeInternal _UpdateBillingServiceRequest_default_instance_;
class UpdateBillingServiceResponse;
struct UpdateBillingServiceResponseDefaultTypeInternal;
extern UpdateBillingServiceResponseDefaultTypeInternal _UpdateBillingServiceResponse_default_instance_;
class UpdateFragmentRequest;
struct UpdateFragmentRequestDefaultTypeInternal;
extern UpdateFragmentRequestDefaultTypeInternal _UpdateFragmentRequest_default_instance_;
class UpdateFragmentResponse;
struct UpdateFragmentResponseDefaultTypeInternal;
extern UpdateFragmentResponseDefaultTypeInternal _UpdateFragmentResponse_default_instance_;
class UpdateLocationMetadataRequest;
struct UpdateLocationMetadataRequestDefaultTypeInternal;
extern UpdateLocationMetadataRequestDefaultTypeInternal _UpdateLocationMetadataRequest_default_instance_;
class UpdateLocationMetadataResponse;
struct UpdateLocationMetadataResponseDefaultTypeInternal;
extern UpdateLocationMetadataResponseDefaultTypeInternal _UpdateLocationMetadataResponse_default_instance_;
class UpdateLocationRequest;
struct UpdateLocationRequestDefaultTypeInternal;
extern UpdateLocationRequestDefaultTypeInternal _UpdateLocationRequest_default_instance_;
class UpdateLocationResponse;
struct UpdateLocationResponseDefaultTypeInternal;
extern UpdateLocationResponseDefaultTypeInternal _UpdateLocationResponse_default_instance_;
class UpdateMLModelMetadata;
struct UpdateMLModelMetadataDefaultTypeInternal;
extern UpdateMLModelMetadataDefaultTypeInternal _UpdateMLModelMetadata_default_instance_;
class UpdateMLTrainingMetadata;
struct UpdateMLTrainingMetadataDefaultTypeInternal;
extern UpdateMLTrainingMetadataDefaultTypeInternal _UpdateMLTrainingMetadata_default_instance_;
class UpdateModuleMetadata;
struct UpdateModuleMetadataDefaultTypeInternal;
extern UpdateModuleMetadataDefaultTypeInternal _UpdateModuleMetadata_default_instance_;
class UpdateModuleRequest;
struct UpdateModuleRequestDefaultTypeInternal;
extern UpdateModuleRequestDefaultTypeInternal _UpdateModuleRequest_default_instance_;
class UpdateModuleResponse;
struct UpdateModuleResponseDefaultTypeInternal;
extern UpdateModuleResponseDefaultTypeInternal _UpdateModuleResponse_default_instance_;
class UpdateOAuthAppRequest;
struct UpdateOAuthAppRequestDefaultTypeInternal;
extern UpdateOAuthAppRequestDefaultTypeInternal _UpdateOAuthAppRequest_default_instance_;
class UpdateOAuthAppResponse;
struct UpdateOAuthAppResponseDefaultTypeInternal;
extern UpdateOAuthAppResponseDefaultTypeInternal _UpdateOAuthAppResponse_default_instance_;
class UpdateOrganizationInviteAuthorizationsRequest;
struct UpdateOrganizationInviteAuthorizationsRequestDefaultTypeInternal;
extern UpdateOrganizationInviteAuthorizationsRequestDefaultTypeInternal _UpdateOrganizationInviteAuthorizationsRequest_default_instance_;
class UpdateOrganizationInviteAuthorizationsResponse;
struct UpdateOrganizationInviteAuthorizationsResponseDefaultTypeInternal;
extern UpdateOrganizationInviteAuthorizationsResponseDefaultTypeInternal _UpdateOrganizationInviteAuthorizationsResponse_default_instance_;
class UpdateOrganizationMetadataRequest;
struct UpdateOrganizationMetadataRequestDefaultTypeInternal;
extern UpdateOrganizationMetadataRequestDefaultTypeInternal _UpdateOrganizationMetadataRequest_default_instance_;
class UpdateOrganizationMetadataResponse;
struct UpdateOrganizationMetadataResponseDefaultTypeInternal;
extern UpdateOrganizationMetadataResponseDefaultTypeInternal _UpdateOrganizationMetadataResponse_default_instance_;
class UpdateOrganizationNamespaceRequest;
struct UpdateOrganizationNamespaceRequestDefaultTypeInternal;
extern UpdateOrganizationNamespaceRequestDefaultTypeInternal _UpdateOrganizationNamespaceRequest_default_instance_;
class UpdateOrganizationNamespaceResponse;
struct UpdateOrganizationNamespaceResponseDefaultTypeInternal;
extern UpdateOrganizationNamespaceResponseDefaultTypeInternal _UpdateOrganizationNamespaceResponse_default_instance_;
class UpdateOrganizationRequest;
struct UpdateOrganizationRequestDefaultTypeInternal;
extern UpdateOrganizationRequestDefaultTypeInternal _UpdateOrganizationRequest_default_instance_;
class UpdateOrganizationResponse;
struct UpdateOrganizationResponseDefaultTypeInternal;
extern UpdateOrganizationResponseDefaultTypeInternal _UpdateOrganizationResponse_default_instance_;
class UpdateRegistryItemRequest;
struct UpdateRegistryItemRequestDefaultTypeInternal;
extern UpdateRegistryItemRequestDefaultTypeInternal _UpdateRegistryItemRequest_default_instance_;
class UpdateRegistryItemResponse;
struct UpdateRegistryItemResponseDefaultTypeInternal;
extern UpdateRegistryItemResponseDefaultTypeInternal _UpdateRegistryItemResponse_default_instance_;
class UpdateRobotMetadataRequest;
struct UpdateRobotMetadataRequestDefaultTypeInternal;
extern UpdateRobotMetadataRequestDefaultTypeInternal _UpdateRobotMetadataRequest_default_instance_;
class UpdateRobotMetadataResponse;
struct UpdateRobotMetadataResponseDefaultTypeInternal;
extern UpdateRobotMetadataResponseDefaultTypeInternal _UpdateRobotMetadataResponse_default_instance_;
class UpdateRobotPartMetadataRequest;
struct UpdateRobotPartMetadataRequestDefaultTypeInternal;
extern UpdateRobotPartMetadataRequestDefaultTypeInternal _UpdateRobotPartMetadataRequest_default_instance_;
class UpdateRobotPartMetadataResponse;
struct UpdateRobotPartMetadataResponseDefaultTypeInternal;
extern UpdateRobotPartMetadataResponseDefaultTypeInternal _UpdateRobotPartMetadataResponse_default_instance_;
class UpdateRobotPartRequest;
struct UpdateRobotPartRequestDefaultTypeInternal;
extern UpdateRobotPartRequestDefaultTypeInternal _UpdateRobotPartRequest_default_instance_;
class UpdateRobotPartResponse;
struct UpdateRobotPartResponseDefaultTypeInternal;
extern UpdateRobotPartResponseDefaultTypeInternal _UpdateRobotPartResponse_default_instance_;
class UpdateRobotRequest;
struct UpdateRobotRequestDefaultTypeInternal;
extern UpdateRobotRequestDefaultTypeInternal _UpdateRobotRequest_default_instance_;
class UpdateRobotResponse;
struct UpdateRobotResponseDefaultTypeInternal;
extern UpdateRobotResponseDefaultTypeInternal _UpdateRobotResponse_default_instance_;
class UploadModuleFileRequest;
struct UploadModuleFileRequestDefaultTypeInternal;
extern UploadModuleFileRequestDefaultTypeInternal _UploadModuleFileRequest_default_instance_;
class UploadModuleFileResponse;
struct UploadModuleFileResponseDefaultTypeInternal;
extern UploadModuleFileResponseDefaultTypeInternal _UploadModuleFileResponse_default_instance_;
class Uploads;
struct UploadsDefaultTypeInternal;
extern UploadsDefaultTypeInternal _Uploads_default_instance_;
class VersionHistory;
struct VersionHistoryDefaultTypeInternal;
extern VersionHistoryDefaultTypeInternal _VersionHistory_default_instance_;
class ViamAgentVersion;
struct ViamAgentVersionDefaultTypeInternal;
extern ViamAgentVersionDefaultTypeInternal _ViamAgentVersion_default_instance_;
class ViamServerVersion;
struct ViamServerVersionDefaultTypeInternal;
extern ViamServerVersionDefaultTypeInternal _ViamServerVersion_default_instance_;
}  // namespace v1
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::v1::APIKey* Arena::CreateMaybeMessage<::viam::app::v1::APIKey>(Arena*);
template<> ::viam::app::v1::APIKeyWithAuthorizations* Arena::CreateMaybeMessage<::viam::app::v1::APIKeyWithAuthorizations>(Arena*);
template<> ::viam::app::v1::AddRoleRequest* Arena::CreateMaybeMessage<::viam::app::v1::AddRoleRequest>(Arena*);
template<> ::viam::app::v1::AddRoleResponse* Arena::CreateMaybeMessage<::viam::app::v1::AddRoleResponse>(Arena*);
template<> ::viam::app::v1::AdditionalFragment* Arena::CreateMaybeMessage<::viam::app::v1::AdditionalFragment>(Arena*);
template<> ::viam::app::v1::App* Arena::CreateMaybeMessage<::viam::app::v1::App>(Arena*);
template<> ::viam::app::v1::AppCustomizations* Arena::CreateMaybeMessage<::viam::app::v1::AppCustomizations>(Arena*);
template<> ::viam::app::v1::AuthenticatorInfo* Arena::CreateMaybeMessage<::viam::app::v1::AuthenticatorInfo>(Arena*);
template<> ::viam::app::v1::Authorization* Arena::CreateMaybeMessage<::viam::app::v1::Authorization>(Arena*);
template<> ::viam::app::v1::AuthorizationDetails* Arena::CreateMaybeMessage<::viam::app::v1::AuthorizationDetails>(Arena*);
template<> ::viam::app::v1::AuthorizedPermissions* Arena::CreateMaybeMessage<::viam::app::v1::AuthorizedPermissions>(Arena*);
template<> ::viam::app::v1::BillingAddress* Arena::CreateMaybeMessage<::viam::app::v1::BillingAddress>(Arena*);
template<> ::viam::app::v1::ChangeRoleRequest* Arena::CreateMaybeMessage<::viam::app::v1::ChangeRoleRequest>(Arena*);
template<> ::viam::app::v1::ChangeRoleResponse* Arena::CreateMaybeMessage<::viam::app::v1::ChangeRoleResponse>(Arena*);
template<> ::viam::app::v1::CheckPermissionsRequest* Arena::CreateMaybeMessage<::viam::app::v1::CheckPermissionsRequest>(Arena*);
template<> ::viam::app::v1::CheckPermissionsResponse* Arena::CreateMaybeMessage<::viam::app::v1::CheckPermissionsResponse>(Arena*);
template<> ::viam::app::v1::CreateFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateFragmentRequest>(Arena*);
template<> ::viam::app::v1::CreateFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateFragmentResponse>(Arena*);
template<> ::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsRequest>(Arena*);
template<> ::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsResponse>(Arena*);
template<> ::viam::app::v1::CreateKeyRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyRequest>(Arena*);
template<> ::viam::app::v1::CreateKeyResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyResponse>(Arena*);
template<> ::viam::app::v1::CreateLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationRequest>(Arena*);
template<> ::viam::app::v1::CreateLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationResponse>(Arena*);
template<> ::viam::app::v1::CreateLocationSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationSecretRequest>(Arena*);
template<> ::viam::app::v1::CreateLocationSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationSecretResponse>(Arena*);
template<> ::viam::app::v1::CreateModuleRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateModuleRequest>(Arena*);
template<> ::viam::app::v1::CreateModuleResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateModuleResponse>(Arena*);
template<> ::viam::app::v1::CreateOAuthAppRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateOAuthAppRequest>(Arena*);
template<> ::viam::app::v1::CreateOAuthAppResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateOAuthAppResponse>(Arena*);
template<> ::viam::app::v1::CreateOrganizationInviteRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationInviteRequest>(Arena*);
template<> ::viam::app::v1::CreateOrganizationInviteResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationInviteResponse>(Arena*);
template<> ::viam::app::v1::CreateOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationRequest>(Arena*);
template<> ::viam::app::v1::CreateOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationResponse>(Arena*);
template<> ::viam::app::v1::CreateRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::CreateRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::CreateRobotPartSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateRobotPartSecretRequest>(Arena*);
template<> ::viam::app::v1::CreateRobotPartSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateRobotPartSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteFragmentRequest>(Arena*);
template<> ::viam::app::v1::DeleteFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteFragmentResponse>(Arena*);
template<> ::viam::app::v1::DeleteFragmentTagRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteFragmentTagRequest>(Arena*);
template<> ::viam::app::v1::DeleteFragmentTagResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteFragmentTagResponse>(Arena*);
template<> ::viam::app::v1::DeleteKeyRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteKeyRequest>(Arena*);
template<> ::viam::app::v1::DeleteKeyResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteKeyResponse>(Arena*);
template<> ::viam::app::v1::DeleteLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationRequest>(Arena*);
template<> ::viam::app::v1::DeleteLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationResponse>(Arena*);
template<> ::viam::app::v1::DeleteLocationSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationSecretRequest>(Arena*);
template<> ::viam::app::v1::DeleteLocationSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteOAuthAppRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOAuthAppRequest>(Arena*);
template<> ::viam::app::v1::DeleteOAuthAppResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOAuthAppResponse>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationInviteRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationInviteRequest>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationInviteResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationInviteResponse>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationMemberRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationMemberRequest>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationMemberResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationMemberResponse>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationRequest>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationResponse>(Arena*);
template<> ::viam::app::v1::DeleteRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::DeleteRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartSecretRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotResponse>(Arena*);
template<> ::viam::app::v1::DisableAuthServiceRequest* Arena::CreateMaybeMessage<::viam::app::v1::DisableAuthServiceRequest>(Arena*);
template<> ::viam::app::v1::DisableAuthServiceResponse* Arena::CreateMaybeMessage<::viam::app::v1::DisableAuthServiceResponse>(Arena*);
template<> ::viam::app::v1::DisableBillingServiceRequest* Arena::CreateMaybeMessage<::viam::app::v1::DisableBillingServiceRequest>(Arena*);
template<> ::viam::app::v1::DisableBillingServiceResponse* Arena::CreateMaybeMessage<::viam::app::v1::DisableBillingServiceResponse>(Arena*);
template<> ::viam::app::v1::EnableAuthServiceRequest* Arena::CreateMaybeMessage<::viam::app::v1::EnableAuthServiceRequest>(Arena*);
template<> ::viam::app::v1::EnableAuthServiceResponse* Arena::CreateMaybeMessage<::viam::app::v1::EnableAuthServiceResponse>(Arena*);
template<> ::viam::app::v1::EnableBillingServiceRequest* Arena::CreateMaybeMessage<::viam::app::v1::EnableBillingServiceRequest>(Arena*);
template<> ::viam::app::v1::EnableBillingServiceResponse* Arena::CreateMaybeMessage<::viam::app::v1::EnableBillingServiceResponse>(Arena*);
template<> ::viam::app::v1::Fragment* Arena::CreateMaybeMessage<::viam::app::v1::Fragment>(Arena*);
template<> ::viam::app::v1::FragmentError* Arena::CreateMaybeMessage<::viam::app::v1::FragmentError>(Arena*);
template<> ::viam::app::v1::FragmentHistoryEntry* Arena::CreateMaybeMessage<::viam::app::v1::FragmentHistoryEntry>(Arena*);
template<> ::viam::app::v1::FragmentImport* Arena::CreateMaybeMessage<::viam::app::v1::FragmentImport>(Arena*);
template<> ::viam::app::v1::FragmentImportList* Arena::CreateMaybeMessage<::viam::app::v1::FragmentImportList>(Arena*);
template<> ::viam::app::v1::FragmentImport_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::v1::FragmentImport_VariablesEntry_DoNotUse>(Arena*);
template<> ::viam::app::v1::FragmentRevision* Arena::CreateMaybeMessage<::viam::app::v1::FragmentRevision>(Arena*);
template<> ::viam::app::v1::FragmentSummary* Arena::CreateMaybeMessage<::viam::app::v1::FragmentSummary>(Arena*);
template<> ::viam::app::v1::FragmentTag* Arena::CreateMaybeMessage<::viam::app::v1::FragmentTag>(Arena*);
template<> ::viam::app::v1::FragmentUsage* Arena::CreateMaybeMessage<::viam::app::v1::FragmentUsage>(Arena*);
template<> ::viam::app::v1::GetAppBrandingRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetAppBrandingRequest>(Arena*);
template<> ::viam::app::v1::GetAppBrandingResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetAppBrandingResponse>(Arena*);
template<> ::viam::app::v1::GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::v1::GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse>(Arena*);
template<> ::viam::app::v1::GetAppContentRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetAppContentRequest>(Arena*);
template<> ::viam::app::v1::GetAppContentResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetAppContentResponse>(Arena*);
template<> ::viam::app::v1::GetBillingServiceConfigRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetBillingServiceConfigRequest>(Arena*);
template<> ::viam::app::v1::GetBillingServiceConfigResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetBillingServiceConfigResponse>(Arena*);
template<> ::viam::app::v1::GetFragmentHistoryRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentHistoryRequest>(Arena*);
template<> ::viam::app::v1::GetFragmentHistoryResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentHistoryResponse>(Arena*);
template<> ::viam::app::v1::GetFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentRequest>(Arena*);
template<> ::viam::app::v1::GetFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentResponse>(Arena*);
template<> ::viam::app::v1::GetFragmentUsageRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentUsageRequest>(Arena*);
template<> ::viam::app::v1::GetFragmentUsageResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentUsageResponse>(Arena*);
template<> ::viam::app::v1::GetLocationMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetLocationMetadataRequest>(Arena*);
template<> ::viam::app::v1::GetLocationMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetLocationMetadataResponse>(Arena*);
template<> ::viam::app::v1::GetLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetLocationRequest>(Arena*);
template<> ::viam::app::v1::GetLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetLocationResponse>(Arena*);
template<> ::viam::app::v1::GetModuleRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetModuleRequest>(Arena*);
template<> ::viam::app::v1::GetModuleResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetModuleResponse>(Arena*);
template<> ::viam::app::v1::GetOrganizationMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationMetadataRequest>(Arena*);
template<> ::viam::app::v1::GetOrganizationMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationMetadataResponse>(Arena*);
template<> ::viam::app::v1::GetOrganizationNamespaceAvailabilityRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationNamespaceAvailabilityRequest>(Arena*);
template<> ::viam::app::v1::GetOrganizationNamespaceAvailabilityResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationNamespaceAvailabilityResponse>(Arena*);
template<> ::viam::app::v1::GetOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationRequest>(Arena*);
template<> ::viam::app::v1::GetOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationResponse>(Arena*);
template<> ::viam::app::v1::GetOrganizationsWithAccessToLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationsWithAccessToLocationRequest>(Arena*);
template<> ::viam::app::v1::GetOrganizationsWithAccessToLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationsWithAccessToLocationResponse>(Arena*);
template<> ::viam::app::v1::GetRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::GetRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::GetRobotAPIKeysRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotAPIKeysRequest>(Arena*);
template<> ::viam::app::v1::GetRobotAPIKeysResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotAPIKeysResponse>(Arena*);
template<> ::viam::app::v1::GetRobotMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotMetadataRequest>(Arena*);
template<> ::viam::app::v1::GetRobotMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotMetadataResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartByNameAndLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartByNameAndLocationRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartByNameAndLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartByNameAndLocationResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartHistoryRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartHistoryRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartHistoryResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartHistoryResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartLogsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartLogsRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartLogsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartLogsResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartMetadataRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartMetadataResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartsRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartsResponse>(Arena*);
template<> ::viam::app::v1::GetRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotRequest>(Arena*);
template<> ::viam::app::v1::GetRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotResponse>(Arena*);
template<> ::viam::app::v1::GetRoverRentalRobotsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRoverRentalRobotsRequest>(Arena*);
template<> ::viam::app::v1::GetRoverRentalRobotsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRoverRentalRobotsResponse>(Arena*);
template<> ::viam::app::v1::GetUserIDByEmailRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetUserIDByEmailRequest>(Arena*);
template<> ::viam::app::v1::GetUserIDByEmailResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetUserIDByEmailResponse>(Arena*);
template<> ::viam::app::v1::ListAuthorizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListAuthorizationsRequest>(Arena*);
template<> ::viam::app::v1::ListAuthorizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListAuthorizationsResponse>(Arena*);
template<> ::viam::app::v1::ListFragmentsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListFragmentsRequest>(Arena*);
template<> ::viam::app::v1::ListFragmentsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListFragmentsResponse>(Arena*);
template<> ::viam::app::v1::ListKeysRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListKeysRequest>(Arena*);
template<> ::viam::app::v1::ListKeysResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListKeysResponse>(Arena*);
template<> ::viam::app::v1::ListLocationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListLocationsRequest>(Arena*);
template<> ::viam::app::v1::ListLocationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListLocationsResponse>(Arena*);
template<> ::viam::app::v1::ListMachineFragmentsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListMachineFragmentsRequest>(Arena*);
template<> ::viam::app::v1::ListMachineFragmentsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListMachineFragmentsResponse>(Arena*);
template<> ::viam::app::v1::ListMachineSummariesRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListMachineSummariesRequest>(Arena*);
template<> ::viam::app::v1::ListMachineSummariesResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListMachineSummariesResponse>(Arena*);
template<> ::viam::app::v1::ListModulesRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListModulesRequest>(Arena*);
template<> ::viam::app::v1::ListModulesResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListModulesResponse>(Arena*);
template<> ::viam::app::v1::ListNestedFragmentsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListNestedFragmentsRequest>(Arena*);
template<> ::viam::app::v1::ListNestedFragmentsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListNestedFragmentsResponse>(Arena*);
template<> ::viam::app::v1::ListOAuthAppsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOAuthAppsRequest>(Arena*);
template<> ::viam::app::v1::ListOAuthAppsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOAuthAppsResponse>(Arena*);
template<> ::viam::app::v1::ListOrganizationMembersRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationMembersRequest>(Arena*);
template<> ::viam::app::v1::ListOrganizationMembersResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationMembersResponse>(Arena*);
template<> ::viam::app::v1::ListOrganizationsByUserRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsByUserRequest>(Arena*);
template<> ::viam::app::v1::ListOrganizationsByUserResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsByUserResponse>(Arena*);
template<> ::viam::app::v1::ListOrganizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsRequest>(Arena*);
template<> ::viam::app::v1::ListOrganizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsResponse>(Arena*);
template<> ::viam::app::v1::ListRegistryItemsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListRegistryItemsRequest>(Arena*);
template<> ::viam::app::v1::ListRegistryItemsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListRegistryItemsResponse>(Arena*);
template<> ::viam::app::v1::ListRobotsForLocationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsForLocationsRequest>(Arena*);
template<> ::viam::app::v1::ListRobotsForLocationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsForLocationsResponse>(Arena*);
template<> ::viam::app::v1::ListRobotsForOrgRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsForOrgRequest>(Arena*);
template<> ::viam::app::v1::ListRobotsForOrgResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsForOrgResponse>(Arena*);
template<> ::viam::app::v1::ListRobotsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsRequest>(Arena*);
template<> ::viam::app::v1::ListRobotsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsResponse>(Arena*);
template<> ::viam::app::v1::Location* Arena::CreateMaybeMessage<::viam::app::v1::Location>(Arena*);
template<> ::viam::app::v1::LocationAuth* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuth>(Arena*);
template<> ::viam::app::v1::LocationAuthRequest* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuthRequest>(Arena*);
template<> ::viam::app::v1::LocationAuthResponse* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuthResponse>(Arena*);
template<> ::viam::app::v1::LocationOrganization* Arena::CreateMaybeMessage<::viam::app::v1::LocationOrganization>(Arena*);
template<> ::viam::app::v1::LocationSummary* Arena::CreateMaybeMessage<::viam::app::v1::LocationSummary>(Arena*);
template<> ::viam::app::v1::MLModelMetadata* Arena::CreateMaybeMessage<::viam::app::v1::MLModelMetadata>(Arena*);
template<> ::viam::app::v1::MLTrainingMetadata* Arena::CreateMaybeMessage<::viam::app::v1::MLTrainingMetadata>(Arena*);
template<> ::viam::app::v1::MLTrainingVersion* Arena::CreateMaybeMessage<::viam::app::v1::MLTrainingVersion>(Arena*);
template<> ::viam::app::v1::MachinePickerCustomizations* Arena::CreateMaybeMessage<::viam::app::v1::MachinePickerCustomizations>(Arena*);
template<> ::viam::app::v1::MachineSummary* Arena::CreateMaybeMessage<::viam::app::v1::MachineSummary>(Arena*);
template<> ::viam::app::v1::MarkPartAsMainRequest* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartAsMainRequest>(Arena*);
template<> ::viam::app::v1::MarkPartAsMainResponse* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartAsMainResponse>(Arena*);
template<> ::viam::app::v1::MarkPartForRestartRequest* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartForRestartRequest>(Arena*);
template<> ::viam::app::v1::MarkPartForRestartResponse* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartForRestartResponse>(Arena*);
template<> ::viam::app::v1::Model* Arena::CreateMaybeMessage<::viam::app::v1::Model>(Arena*);
template<> ::viam::app::v1::Module* Arena::CreateMaybeMessage<::viam::app::v1::Module>(Arena*);
template<> ::viam::app::v1::ModuleFileInfo* Arena::CreateMaybeMessage<::viam::app::v1::ModuleFileInfo>(Arena*);
template<> ::viam::app::v1::ModuleMetadata* Arena::CreateMaybeMessage<::viam::app::v1::ModuleMetadata>(Arena*);
template<> ::viam::app::v1::ModuleVersion* Arena::CreateMaybeMessage<::viam::app::v1::ModuleVersion>(Arena*);
template<> ::viam::app::v1::NewRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotPartRequest>(Arena*);
template<> ::viam::app::v1::NewRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotPartResponse>(Arena*);
template<> ::viam::app::v1::NewRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotRequest>(Arena*);
template<> ::viam::app::v1::NewRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotResponse>(Arena*);
template<> ::viam::app::v1::OAuthConfig* Arena::CreateMaybeMessage<::viam::app::v1::OAuthConfig>(Arena*);
template<> ::viam::app::v1::OrgDetails* Arena::CreateMaybeMessage<::viam::app::v1::OrgDetails>(Arena*);
template<> ::viam::app::v1::Organization* Arena::CreateMaybeMessage<::viam::app::v1::Organization>(Arena*);
template<> ::viam::app::v1::OrganizationGetLogoRequest* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationGetLogoRequest>(Arena*);
template<> ::viam::app::v1::OrganizationGetLogoResponse* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationGetLogoResponse>(Arena*);
template<> ::viam::app::v1::OrganizationGetSupportEmailRequest* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationGetSupportEmailRequest>(Arena*);
template<> ::viam::app::v1::OrganizationGetSupportEmailResponse* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationGetSupportEmailResponse>(Arena*);
template<> ::viam::app::v1::OrganizationIdentity* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationIdentity>(Arena*);
template<> ::viam::app::v1::OrganizationInvite* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(Arena*);
template<> ::viam::app::v1::OrganizationMember* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationMember>(Arena*);
template<> ::viam::app::v1::OrganizationSetLogoRequest* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationSetLogoRequest>(Arena*);
template<> ::viam::app::v1::OrganizationSetLogoResponse* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationSetLogoResponse>(Arena*);
template<> ::viam::app::v1::OrganizationSetSupportEmailRequest* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationSetSupportEmailRequest>(Arena*);
template<> ::viam::app::v1::OrganizationSetSupportEmailResponse* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationSetSupportEmailResponse>(Arena*);
template<> ::viam::app::v1::PartSummary* Arena::CreateMaybeMessage<::viam::app::v1::PartSummary>(Arena*);
template<> ::viam::app::v1::ReadOAuthAppRequest* Arena::CreateMaybeMessage<::viam::app::v1::ReadOAuthAppRequest>(Arena*);
template<> ::viam::app::v1::ReadOAuthAppResponse* Arena::CreateMaybeMessage<::viam::app::v1::ReadOAuthAppResponse>(Arena*);
template<> ::viam::app::v1::RegistryItem* Arena::CreateMaybeMessage<::viam::app::v1::RegistryItem>(Arena*);
template<> ::viam::app::v1::RemoveRoleRequest* Arena::CreateMaybeMessage<::viam::app::v1::RemoveRoleRequest>(Arena*);
template<> ::viam::app::v1::RemoveRoleResponse* Arena::CreateMaybeMessage<::viam::app::v1::RemoveRoleResponse>(Arena*);
template<> ::viam::app::v1::RenameKeyRequest* Arena::CreateMaybeMessage<::viam::app::v1::RenameKeyRequest>(Arena*);
template<> ::viam::app::v1::RenameKeyResponse* Arena::CreateMaybeMessage<::viam::app::v1::RenameKeyResponse>(Arena*);
template<> ::viam::app::v1::RenameRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::RenameRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::RenameRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::RenameRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::ResendOrganizationInviteRequest* Arena::CreateMaybeMessage<::viam::app::v1::ResendOrganizationInviteRequest>(Arena*);
template<> ::viam::app::v1::ResendOrganizationInviteResponse* Arena::CreateMaybeMessage<::viam::app::v1::ResendOrganizationInviteResponse>(Arena*);
template<> ::viam::app::v1::ResolvedFragment* Arena::CreateMaybeMessage<::viam::app::v1::ResolvedFragment>(Arena*);
template<> ::viam::app::v1::Robot* Arena::CreateMaybeMessage<::viam::app::v1::Robot>(Arena*);
template<> ::viam::app::v1::RobotPart* Arena::CreateMaybeMessage<::viam::app::v1::RobotPart>(Arena*);
template<> ::viam::app::v1::RobotPartHistoryEntry* Arena::CreateMaybeMessage<::viam::app::v1::RobotPartHistoryEntry>(Arena*);
template<> ::viam::app::v1::RotateKeyRequest* Arena::CreateMaybeMessage<::viam::app::v1::RotateKeyRequest>(Arena*);
template<> ::viam::app::v1::RotateKeyResponse* Arena::CreateMaybeMessage<::viam::app::v1::RotateKeyResponse>(Arena*);
template<> ::viam::app::v1::RoverRentalRobot* Arena::CreateMaybeMessage<::viam::app::v1::RoverRentalRobot>(Arena*);
template<> ::viam::app::v1::SearchOrganizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::SearchOrganizationsRequest>(Arena*);
template<> ::viam::app::v1::SearchOrganizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::SearchOrganizationsResponse>(Arena*);
template<> ::viam::app::v1::SetFragmentTagRequest* Arena::CreateMaybeMessage<::viam::app::v1::SetFragmentTagRequest>(Arena*);
template<> ::viam::app::v1::SetFragmentTagResponse* Arena::CreateMaybeMessage<::viam::app::v1::SetFragmentTagResponse>(Arena*);
template<> ::viam::app::v1::ShareLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::ShareLocationRequest>(Arena*);
template<> ::viam::app::v1::ShareLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::ShareLocationResponse>(Arena*);
template<> ::viam::app::v1::SharedSecret* Arena::CreateMaybeMessage<::viam::app::v1::SharedSecret>(Arena*);
template<> ::viam::app::v1::StorageConfig* Arena::CreateMaybeMessage<::viam::app::v1::StorageConfig>(Arena*);
template<> ::viam::app::v1::TailRobotPartLogsRequest* Arena::CreateMaybeMessage<::viam::app::v1::TailRobotPartLogsRequest>(Arena*);
template<> ::viam::app::v1::TailRobotPartLogsResponse* Arena::CreateMaybeMessage<::viam::app::v1::TailRobotPartLogsResponse>(Arena*);
template<> ::viam::app::v1::TextOverrides* Arena::CreateMaybeMessage<::viam::app::v1::TextOverrides>(Arena*);
template<> ::viam::app::v1::TextOverrides_FieldsEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::v1::TextOverrides_FieldsEntry_DoNotUse>(Arena*);
template<> ::viam::app::v1::TransferRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::TransferRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::TransferRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::TransferRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::UnshareLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::UnshareLocationRequest>(Arena*);
template<> ::viam::app::v1::UnshareLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::UnshareLocationResponse>(Arena*);
template<> ::viam::app::v1::UpdateBillingServiceRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateBillingServiceRequest>(Arena*);
template<> ::viam::app::v1::UpdateBillingServiceResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateBillingServiceResponse>(Arena*);
template<> ::viam::app::v1::UpdateFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateFragmentRequest>(Arena*);
template<> ::viam::app::v1::UpdateFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateFragmentResponse>(Arena*);
template<> ::viam::app::v1::UpdateLocationMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateLocationMetadataRequest>(Arena*);
template<> ::viam::app::v1::UpdateLocationMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateLocationMetadataResponse>(Arena*);
template<> ::viam::app::v1::UpdateLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateLocationRequest>(Arena*);
template<> ::viam::app::v1::UpdateLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateLocationResponse>(Arena*);
template<> ::viam::app::v1::UpdateMLModelMetadata* Arena::CreateMaybeMessage<::viam::app::v1::UpdateMLModelMetadata>(Arena*);
template<> ::viam::app::v1::UpdateMLTrainingMetadata* Arena::CreateMaybeMessage<::viam::app::v1::UpdateMLTrainingMetadata>(Arena*);
template<> ::viam::app::v1::UpdateModuleMetadata* Arena::CreateMaybeMessage<::viam::app::v1::UpdateModuleMetadata>(Arena*);
template<> ::viam::app::v1::UpdateModuleRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateModuleRequest>(Arena*);
template<> ::viam::app::v1::UpdateModuleResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateModuleResponse>(Arena*);
template<> ::viam::app::v1::UpdateOAuthAppRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOAuthAppRequest>(Arena*);
template<> ::viam::app::v1::UpdateOAuthAppResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOAuthAppResponse>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationInviteAuthorizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationInviteAuthorizationsRequest>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationInviteAuthorizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationInviteAuthorizationsResponse>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationMetadataRequest>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationMetadataResponse>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationNamespaceRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationNamespaceRequest>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationNamespaceResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationNamespaceResponse>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationRequest>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationResponse>(Arena*);
template<> ::viam::app::v1::UpdateRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::UpdateRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotMetadataRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotMetadataResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartMetadataRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartMetadataRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartMetadataResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartMetadataResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotResponse>(Arena*);
template<> ::viam::app::v1::UploadModuleFileRequest* Arena::CreateMaybeMessage<::viam::app::v1::UploadModuleFileRequest>(Arena*);
template<> ::viam::app::v1::UploadModuleFileResponse* Arena::CreateMaybeMessage<::viam::app::v1::UploadModuleFileResponse>(Arena*);
template<> ::viam::app::v1::Uploads* Arena::CreateMaybeMessage<::viam::app::v1::Uploads>(Arena*);
template<> ::viam::app::v1::VersionHistory* Arena::CreateMaybeMessage<::viam::app::v1::VersionHistory>(Arena*);
template<> ::viam::app::v1::ViamAgentVersion* Arena::CreateMaybeMessage<::viam::app::v1::ViamAgentVersion>(Arena*);
template<> ::viam::app::v1::ViamServerVersion* Arena::CreateMaybeMessage<::viam::app::v1::ViamServerVersion>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace v1 {

enum SharedSecret_State : int {
  SharedSecret_State_STATE_UNSPECIFIED = 0,
  SharedSecret_State_STATE_ENABLED = 1,
  SharedSecret_State_STATE_DISABLED = 2,
  SharedSecret_State_SharedSecret_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SharedSecret_State_SharedSecret_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SharedSecret_State_IsValid(int value);
constexpr SharedSecret_State SharedSecret_State_State_MIN = SharedSecret_State_STATE_UNSPECIFIED;
constexpr SharedSecret_State SharedSecret_State_State_MAX = SharedSecret_State_STATE_DISABLED;
constexpr int SharedSecret_State_State_ARRAYSIZE = SharedSecret_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SharedSecret_State_descriptor();
template<typename T>
inline const std::string& SharedSecret_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SharedSecret_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SharedSecret_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SharedSecret_State_descriptor(), enum_t_value);
}
inline bool SharedSecret_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharedSecret_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SharedSecret_State>(
    SharedSecret_State_descriptor(), name, value);
}
enum OnlineState : int {
  ONLINE_STATE_UNSPECIFIED = 0,
  ONLINE_STATE_ONLINE = 1,
  ONLINE_STATE_OFFLINE = 2,
  ONLINE_STATE_AWAITING_SETUP = 3,
  OnlineState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OnlineState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OnlineState_IsValid(int value);
constexpr OnlineState OnlineState_MIN = ONLINE_STATE_UNSPECIFIED;
constexpr OnlineState OnlineState_MAX = ONLINE_STATE_AWAITING_SETUP;
constexpr int OnlineState_ARRAYSIZE = OnlineState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OnlineState_descriptor();
template<typename T>
inline const std::string& OnlineState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OnlineState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OnlineState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OnlineState_descriptor(), enum_t_value);
}
inline bool OnlineState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OnlineState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OnlineState>(
    OnlineState_descriptor(), name, value);
}
enum AuthenticationType : int {
  AUTHENTICATION_TYPE_UNSPECIFIED = 0,
  AUTHENTICATION_TYPE_WEB_OAUTH = 1,
  AUTHENTICATION_TYPE_API_KEY = 2,
  AUTHENTICATION_TYPE_ROBOT_PART_SECRET = 3,
  AUTHENTICATION_TYPE_LOCATION_SECRET = 4,
  AuthenticationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AuthenticationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AuthenticationType_IsValid(int value);
constexpr AuthenticationType AuthenticationType_MIN = AUTHENTICATION_TYPE_UNSPECIFIED;
constexpr AuthenticationType AuthenticationType_MAX = AUTHENTICATION_TYPE_LOCATION_SECRET;
constexpr int AuthenticationType_ARRAYSIZE = AuthenticationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AuthenticationType_descriptor();
template<typename T>
inline const std::string& AuthenticationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuthenticationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuthenticationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AuthenticationType_descriptor(), enum_t_value);
}
inline bool AuthenticationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AuthenticationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AuthenticationType>(
    AuthenticationType_descriptor(), name, value);
}
enum FragmentVisibility : int {
  FRAGMENT_VISIBILITY_UNSPECIFIED = 0,
  FRAGMENT_VISIBILITY_PRIVATE = 1,
  FRAGMENT_VISIBILITY_PUBLIC = 2,
  FRAGMENT_VISIBILITY_PUBLIC_UNLISTED = 3,
  FragmentVisibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FragmentVisibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FragmentVisibility_IsValid(int value);
constexpr FragmentVisibility FragmentVisibility_MIN = FRAGMENT_VISIBILITY_UNSPECIFIED;
constexpr FragmentVisibility FragmentVisibility_MAX = FRAGMENT_VISIBILITY_PUBLIC_UNLISTED;
constexpr int FragmentVisibility_ARRAYSIZE = FragmentVisibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FragmentVisibility_descriptor();
template<typename T>
inline const std::string& FragmentVisibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FragmentVisibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FragmentVisibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FragmentVisibility_descriptor(), enum_t_value);
}
inline bool FragmentVisibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FragmentVisibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FragmentVisibility>(
    FragmentVisibility_descriptor(), name, value);
}
enum FragmentErrorType : int {
  FRAGMENT_ERROR_TYPE_UNSPECIFIED = 0,
  FRAGMENT_ERROR_TYPE_NO_ACCESS = 1,
  FRAGMENT_ERROR_TYPE_NESTING_LIMIT_EXCEEDED = 2,
  FRAGMENT_ERROR_TYPE_CHILD_ID_INVALID = 3,
  FRAGMENT_ERROR_TYPE_CYCLE_DETECTED = 4,
  FragmentErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FragmentErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FragmentErrorType_IsValid(int value);
constexpr FragmentErrorType FragmentErrorType_MIN = FRAGMENT_ERROR_TYPE_UNSPECIFIED;
constexpr FragmentErrorType FragmentErrorType_MAX = FRAGMENT_ERROR_TYPE_CYCLE_DETECTED;
constexpr int FragmentErrorType_ARRAYSIZE = FragmentErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FragmentErrorType_descriptor();
template<typename T>
inline const std::string& FragmentErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FragmentErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FragmentErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FragmentErrorType_descriptor(), enum_t_value);
}
inline bool FragmentErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FragmentErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FragmentErrorType>(
    FragmentErrorType_descriptor(), name, value);
}
enum ModuleSourceType : int {
  MODULE_SOURCE_TYPE_UNSPECIFIED = 0,
  MODULE_SOURCE_TYPE_EXTERNAL = 1,
  MODULE_SOURCE_TYPE_VIAM_HOSTED = 2,
  ModuleSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModuleSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModuleSourceType_IsValid(int value);
constexpr ModuleSourceType ModuleSourceType_MIN = MODULE_SOURCE_TYPE_UNSPECIFIED;
constexpr ModuleSourceType ModuleSourceType_MAX = MODULE_SOURCE_TYPE_VIAM_HOSTED;
constexpr int ModuleSourceType_ARRAYSIZE = ModuleSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleSourceType_descriptor();
template<typename T>
inline const std::string& ModuleSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModuleSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModuleSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModuleSourceType_descriptor(), enum_t_value);
}
inline bool ModuleSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModuleSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModuleSourceType>(
    ModuleSourceType_descriptor(), name, value);
}
enum ModuleLanguage : int {
  MODULE_LANGUAGE_UNSPECIFIED = 0,
  MODULE_LANGUAGE_GOLANG = 1,
  MODULE_LANGUAGE_PYTHON = 2,
  MODULE_LANGUAGE_CPP = 3,
  ModuleLanguage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModuleLanguage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModuleLanguage_IsValid(int value);
constexpr ModuleLanguage ModuleLanguage_MIN = MODULE_LANGUAGE_UNSPECIFIED;
constexpr ModuleLanguage ModuleLanguage_MAX = MODULE_LANGUAGE_CPP;
constexpr int ModuleLanguage_ARRAYSIZE = ModuleLanguage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleLanguage_descriptor();
template<typename T>
inline const std::string& ModuleLanguage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModuleLanguage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModuleLanguage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModuleLanguage_descriptor(), enum_t_value);
}
inline bool ModuleLanguage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModuleLanguage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModuleLanguage>(
    ModuleLanguage_descriptor(), name, value);
}
enum RegistryItemStatus : int {
  REGISTRY_ITEM_STATUS_UNSPECIFIED = 0,
  REGISTRY_ITEM_STATUS_PUBLISHED = 1,
  REGISTRY_ITEM_STATUS_IN_DEVELOPMENT = 2,
  RegistryItemStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegistryItemStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegistryItemStatus_IsValid(int value);
constexpr RegistryItemStatus RegistryItemStatus_MIN = REGISTRY_ITEM_STATUS_UNSPECIFIED;
constexpr RegistryItemStatus RegistryItemStatus_MAX = REGISTRY_ITEM_STATUS_IN_DEVELOPMENT;
constexpr int RegistryItemStatus_ARRAYSIZE = RegistryItemStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegistryItemStatus_descriptor();
template<typename T>
inline const std::string& RegistryItemStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegistryItemStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegistryItemStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegistryItemStatus_descriptor(), enum_t_value);
}
inline bool RegistryItemStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegistryItemStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegistryItemStatus>(
    RegistryItemStatus_descriptor(), name, value);
}
enum Visibility : int {
  VISIBILITY_UNSPECIFIED = 0,
  VISIBILITY_PRIVATE = 1,
  VISIBILITY_PUBLIC = 2,
  VISIBILITY_PUBLIC_UNLISTED = 3,
  Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Visibility_IsValid(int value);
constexpr Visibility Visibility_MIN = VISIBILITY_UNSPECIFIED;
constexpr Visibility Visibility_MAX = VISIBILITY_PUBLIC_UNLISTED;
constexpr int Visibility_ARRAYSIZE = Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_descriptor();
template<typename T>
inline const std::string& Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Visibility_descriptor(), enum_t_value);
}
inline bool Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility>(
    Visibility_descriptor(), name, value);
}
enum AppType : int {
  APP_TYPE_UNSPECIFIED = 0,
  APP_TYPE_SINGLE_MACHINE = 1,
  APP_TYPE_MULTI_MACHINE = 2,
  AppType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AppType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AppType_IsValid(int value);
constexpr AppType AppType_MIN = APP_TYPE_UNSPECIFIED;
constexpr AppType AppType_MAX = APP_TYPE_MULTI_MACHINE;
constexpr int AppType_ARRAYSIZE = AppType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppType_descriptor();
template<typename T>
inline const std::string& AppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppType_descriptor(), enum_t_value);
}
inline bool AppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppType>(
    AppType_descriptor(), name, value);
}
enum ClientAuthentication : int {
  CLIENT_AUTHENTICATION_UNSPECIFIED = 0,
  CLIENT_AUTHENTICATION_REQUIRED = 1,
  CLIENT_AUTHENTICATION_NOT_REQUIRED = 2,
  CLIENT_AUTHENTICATION_NOT_REQUIRED_WHEN_USING_PKCE = 3,
  ClientAuthentication_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClientAuthentication_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClientAuthentication_IsValid(int value);
constexpr ClientAuthentication ClientAuthentication_MIN = CLIENT_AUTHENTICATION_UNSPECIFIED;
constexpr ClientAuthentication ClientAuthentication_MAX = CLIENT_AUTHENTICATION_NOT_REQUIRED_WHEN_USING_PKCE;
constexpr int ClientAuthentication_ARRAYSIZE = ClientAuthentication_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientAuthentication_descriptor();
template<typename T>
inline const std::string& ClientAuthentication_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientAuthentication>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientAuthentication_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientAuthentication_descriptor(), enum_t_value);
}
inline bool ClientAuthentication_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientAuthentication* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientAuthentication>(
    ClientAuthentication_descriptor(), name, value);
}
enum PKCE : int {
  PKCE_UNSPECIFIED = 0,
  PKCE_REQUIRED = 1,
  PKCE_NOT_REQUIRED = 2,
  PKCE_NOT_REQUIRED_WHEN_USING_CLIENT_AUTHENTICATION = 3,
  PKCE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PKCE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PKCE_IsValid(int value);
constexpr PKCE PKCE_MIN = PKCE_UNSPECIFIED;
constexpr PKCE PKCE_MAX = PKCE_NOT_REQUIRED_WHEN_USING_CLIENT_AUTHENTICATION;
constexpr int PKCE_ARRAYSIZE = PKCE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PKCE_descriptor();
template<typename T>
inline const std::string& PKCE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PKCE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PKCE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PKCE_descriptor(), enum_t_value);
}
inline bool PKCE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PKCE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PKCE>(
    PKCE_descriptor(), name, value);
}
enum URLValidation : int {
  URL_VALIDATION_UNSPECIFIED = 0,
  URL_VALIDATION_EXACT_MATCH = 1,
  URL_VALIDATION_ALLOW_WILDCARDS = 2,
  URLValidation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  URLValidation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool URLValidation_IsValid(int value);
constexpr URLValidation URLValidation_MIN = URL_VALIDATION_UNSPECIFIED;
constexpr URLValidation URLValidation_MAX = URL_VALIDATION_ALLOW_WILDCARDS;
constexpr int URLValidation_ARRAYSIZE = URLValidation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* URLValidation_descriptor();
template<typename T>
inline const std::string& URLValidation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, URLValidation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function URLValidation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    URLValidation_descriptor(), enum_t_value);
}
inline bool URLValidation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, URLValidation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<URLValidation>(
    URLValidation_descriptor(), name, value);
}
enum EnabledGrant : int {
  ENABLED_GRANT_UNSPECIFIED = 0,
  ENABLED_GRANT_AUTHORIZATION_CODE = 1,
  ENABLED_GRANT_IMPLICIT = 2,
  ENABLED_GRANT_PASSWORD = 3,
  ENABLED_GRANT_REFRESH_TOKEN = 4,
  ENABLED_GRANT_DEVICE_CODE = 5,
  EnabledGrant_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EnabledGrant_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EnabledGrant_IsValid(int value);
constexpr EnabledGrant EnabledGrant_MIN = ENABLED_GRANT_UNSPECIFIED;
constexpr EnabledGrant EnabledGrant_MAX = ENABLED_GRANT_DEVICE_CODE;
constexpr int EnabledGrant_ARRAYSIZE = EnabledGrant_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EnabledGrant_descriptor();
template<typename T>
inline const std::string& EnabledGrant_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnabledGrant>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnabledGrant_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EnabledGrant_descriptor(), enum_t_value);
}
inline bool EnabledGrant_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EnabledGrant* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EnabledGrant>(
    EnabledGrant_descriptor(), name, value);
}
// ===================================================================

class Robot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  explicit PROTOBUF_CONSTEXPR Robot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLocationFieldNumber = 3,
    kLastAccessFieldNumber = 4,
    kCreatedOnFieldNumber = 5,
    kSecondsSinceOnlineFieldNumber = 7,
    kOnlineStateFieldNumber = 6,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 3 [json_name = "location", (.tagger.v1.tags) = "bson:\"location\" json:\"location\""];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // .google.protobuf.Timestamp last_access = 4 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // .google.protobuf.Timestamp created_on = 5 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // int64 seconds_since_online = 7 [json_name = "secondsSinceOnline", (.tagger.v1.tags) = "bson:\"seconds_since_online\" json:\"seconds_since_online,omitempty\""];
  void clear_seconds_since_online();
  int64_t seconds_since_online() const;
  void set_seconds_since_online(int64_t value);
  private:
  int64_t _internal_seconds_since_online() const;
  void _internal_set_seconds_since_online(int64_t value);
  public:

  // .viam.app.v1.OnlineState online_state = 6 [json_name = "onlineState", (.tagger.v1.tags) = "bson:\"online_state\" json:\"online_state,omitempty\""];
  void clear_online_state();
  ::viam::app::v1::OnlineState online_state() const;
  void set_online_state(::viam::app::v1::OnlineState value);
  private:
  ::viam::app::v1::OnlineState _internal_online_state() const;
  void _internal_set_online_state(::viam::app::v1::OnlineState value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  int64_t seconds_since_online_;
  int online_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RobotPart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotPart) */ {
 public:
  inline RobotPart() : RobotPart(nullptr) {}
  ~RobotPart() override;
  explicit PROTOBUF_CONSTEXPR RobotPart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotPart(const RobotPart& from);
  RobotPart(RobotPart&& from) noexcept
    : RobotPart() {
    *this = ::std::move(from);
  }

  inline RobotPart& operator=(const RobotPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPart& operator=(RobotPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotPart* internal_default_instance() {
    return reinterpret_cast<const RobotPart*>(
               &_RobotPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RobotPart& a, RobotPart& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotPart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotPart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotPart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotPart& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RobotPart";
  }
  protected:
  explicit RobotPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 14,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSecretFieldNumber = 3,
    kRobotFieldNumber = 4,
    kFqdnFieldNumber = 9,
    kDnsNameFieldNumber = 10,
    kLocalFqdnFieldNumber = 11,
    kLocationIdFieldNumber = 12,
    kRobotConfigFieldNumber = 5,
    kLastAccessFieldNumber = 6,
    kUserSuppliedInfoFieldNumber = 7,
    kCreatedOnFieldNumber = 13,
    kLastUpdatedFieldNumber = 15,
    kMainPartFieldNumber = 8,
    kOnlineStateFieldNumber = 16,
    kSecondsSinceOnlineFieldNumber = 17,
  };
  // repeated .viam.app.v1.SharedSecret secrets = 14 [json_name = "secrets", (.tagger.v1.tags) = "bson:\"secrets\""];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  ::viam::app::v1::SharedSecret* mutable_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
      mutable_secrets();
  private:
  const ::viam::app::v1::SharedSecret& _internal_secrets(int index) const;
  ::viam::app::v1::SharedSecret* _internal_add_secrets();
  public:
  const ::viam::app::v1::SharedSecret& secrets(int index) const;
  ::viam::app::v1::SharedSecret* add_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
      secrets() const;

  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string secret = 3 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\" json:\"secret,omitempty\""];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string robot = 4 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
  void clear_robot();
  const std::string& robot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot();
  PROTOBUF_NODISCARD std::string* release_robot();
  void set_allocated_robot(std::string* robot);
  private:
  const std::string& _internal_robot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot(const std::string& value);
  std::string* _internal_mutable_robot();
  public:

  // string fqdn = 9 [json_name = "fqdn"];
  void clear_fqdn();
  const std::string& fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fqdn();
  PROTOBUF_NODISCARD std::string* release_fqdn();
  void set_allocated_fqdn(std::string* fqdn);
  private:
  const std::string& _internal_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fqdn(const std::string& value);
  std::string* _internal_mutable_fqdn();
  public:

  // string dns_name = 10 [json_name = "dnsName", (.tagger.v1.tags) = "bson:\"dns_name\" json:\"dns_name\""];
  void clear_dns_name();
  const std::string& dns_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dns_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dns_name();
  PROTOBUF_NODISCARD std::string* release_dns_name();
  void set_allocated_dns_name(std::string* dns_name);
  private:
  const std::string& _internal_dns_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns_name(const std::string& value);
  std::string* _internal_mutable_dns_name();
  public:

  // string local_fqdn = 11 [json_name = "localFqdn"];
  void clear_local_fqdn();
  const std::string& local_fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_fqdn();
  PROTOBUF_NODISCARD std::string* release_local_fqdn();
  void set_allocated_local_fqdn(std::string* local_fqdn);
  private:
  const std::string& _internal_local_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_fqdn(const std::string& value);
  std::string* _internal_mutable_local_fqdn();
  public:

  // string location_id = 12 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"-\""];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // .google.protobuf.Struct robot_config = 5 [json_name = "robotConfig", (.tagger.v1.tags) = "bson:\"config\" json:\"robot_config\""];
  bool has_robot_config() const;
  private:
  bool _internal_has_robot_config() const;
  public:
  void clear_robot_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& robot_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_robot_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_robot_config();
  void set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_robot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_robot_config();
  public:
  void unsafe_arena_set_allocated_robot_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_robot_config();

  // .google.protobuf.Timestamp last_access = 6 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // .google.protobuf.Struct user_supplied_info = 7 [json_name = "userSuppliedInfo", (.tagger.v1.tags) = "bson:\"user_supplied_info\" json:\"user_supplied_info\""];
  bool has_user_supplied_info() const;
  private:
  bool _internal_has_user_supplied_info() const;
  public:
  void clear_user_supplied_info();
  const ::PROTOBUF_NAMESPACE_ID::Struct& user_supplied_info() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_user_supplied_info();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_user_supplied_info();
  void set_allocated_user_supplied_info(::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_user_supplied_info() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_user_supplied_info();
  public:
  void unsafe_arena_set_allocated_user_supplied_info(
      ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_user_supplied_info();

  // .google.protobuf.Timestamp created_on = 13 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .google.protobuf.Timestamp last_updated = 15 [json_name = "lastUpdated", (.tagger.v1.tags) = "bson:\"last_updated_at\""];
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // bool main_part = 8 [json_name = "mainPart", (.tagger.v1.tags) = "bson:\"main_part\" json:\"main_part\""];
  void clear_main_part();
  bool main_part() const;
  void set_main_part(bool value);
  private:
  bool _internal_main_part() const;
  void _internal_set_main_part(bool value);
  public:

  // .viam.app.v1.OnlineState online_state = 16 [json_name = "onlineState", (.tagger.v1.tags) = "bson:\"online_state\" json:\"online_state,omitempty\""];
  void clear_online_state();
  ::viam::app::v1::OnlineState online_state() const;
  void set_online_state(::viam::app::v1::OnlineState value);
  private:
  ::viam::app::v1::OnlineState _internal_online_state() const;
  void _internal_set_online_state(::viam::app::v1::OnlineState value);
  public:

  // int64 seconds_since_online = 17 [json_name = "secondsSinceOnline", (.tagger.v1.tags) = "bson:\"seconds_since_online\" json:\"seconds_since_online,omitempty\""];
  void clear_seconds_since_online();
  int64_t seconds_since_online() const;
  void set_seconds_since_online(int64_t value);
  private:
  int64_t _internal_seconds_since_online() const;
  void _internal_set_seconds_since_online(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotPart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fqdn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dns_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_fqdn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* robot_config_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
  ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
  bool main_part_;
  int online_state_;
  int64_t seconds_since_online_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RobotPartHistoryEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotPartHistoryEntry) */ {
 public:
  inline RobotPartHistoryEntry() : RobotPartHistoryEntry(nullptr) {}
  ~RobotPartHistoryEntry() override;
  explicit PROTOBUF_CONSTEXPR RobotPartHistoryEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotPartHistoryEntry(const RobotPartHistoryEntry& from);
  RobotPartHistoryEntry(RobotPartHistoryEntry&& from) noexcept
    : RobotPartHistoryEntry() {
    *this = ::std::move(from);
  }

  inline RobotPartHistoryEntry& operator=(const RobotPartHistoryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPartHistoryEntry& operator=(RobotPartHistoryEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotPartHistoryEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotPartHistoryEntry* internal_default_instance() {
    return reinterpret_cast<const RobotPartHistoryEntry*>(
               &_RobotPartHistoryEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotPartHistoryEntry& a, RobotPartHistoryEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPartHistoryEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPartHistoryEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotPartHistoryEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotPartHistoryEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotPartHistoryEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotPartHistoryEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPartHistoryEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RobotPartHistoryEntry";
  }
  protected:
  explicit RobotPartHistoryEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
    kRobotFieldNumber = 2,
    kWhenFieldNumber = 3,
    kOldFieldNumber = 4,
    kEditedByFieldNumber = 5,
  };
  // string part = 1 [json_name = "part", (.tagger.v1.tags) = "bson:\"part\" json:\"part\""];
  void clear_part();
  const std::string& part() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part();
  PROTOBUF_NODISCARD std::string* release_part();
  void set_allocated_part(std::string* part);
  private:
  const std::string& _internal_part() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part(const std::string& value);
  std::string* _internal_mutable_part();
  public:

  // string robot = 2 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
  void clear_robot();
  const std::string& robot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot();
  PROTOBUF_NODISCARD std::string* release_robot();
  void set_allocated_robot(std::string* robot);
  private:
  const std::string& _internal_robot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot(const std::string& value);
  std::string* _internal_mutable_robot();
  public:

  // .google.protobuf.Timestamp when = 3 [json_name = "when", (.tagger.v1.tags) = "bson:\"when\" json:\"when\""];
  bool has_when() const;
  private:
  bool _internal_has_when() const;
  public:
  void clear_when();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& when() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_when();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_when();
  void set_allocated_when(::PROTOBUF_NAMESPACE_ID::Timestamp* when);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_when() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_when();
  public:
  void unsafe_arena_set_allocated_when(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* when);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_when();

  // .viam.app.v1.RobotPart old = 4 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
  bool has_old() const;
  private:
  bool _internal_has_old() const;
  public:
  void clear_old();
  const ::viam::app::v1::RobotPart& old() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_old();
  ::viam::app::v1::RobotPart* mutable_old();
  void set_allocated_old(::viam::app::v1::RobotPart* old);
  private:
  const ::viam::app::v1::RobotPart& _internal_old() const;
  ::viam::app::v1::RobotPart* _internal_mutable_old();
  public:
  void unsafe_arena_set_allocated_old(
      ::viam::app::v1::RobotPart* old);
  ::viam::app::v1::RobotPart* unsafe_arena_release_old();

  // .viam.app.v1.AuthenticatorInfo edited_by = 5 [json_name = "editedBy", (.tagger.v1.tags) = "bson:\"edited_by\" json:\"edited_by\""];
  bool has_edited_by() const;
  private:
  bool _internal_has_edited_by() const;
  public:
  void clear_edited_by();
  const ::viam::app::v1::AuthenticatorInfo& edited_by() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AuthenticatorInfo* release_edited_by();
  ::viam::app::v1::AuthenticatorInfo* mutable_edited_by();
  void set_allocated_edited_by(::viam::app::v1::AuthenticatorInfo* edited_by);
  private:
  const ::viam::app::v1::AuthenticatorInfo& _internal_edited_by() const;
  ::viam::app::v1::AuthenticatorInfo* _internal_mutable_edited_by();
  public:
  void unsafe_arena_set_allocated_edited_by(
      ::viam::app::v1::AuthenticatorInfo* edited_by);
  ::viam::app::v1::AuthenticatorInfo* unsafe_arena_release_edited_by();

  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotPartHistoryEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* when_;
  ::viam::app::v1::RobotPart* old_;
  ::viam::app::v1::AuthenticatorInfo* edited_by_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AuthenticatorInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthenticatorInfo) */ {
 public:
  inline AuthenticatorInfo() : AuthenticatorInfo(nullptr) {}
  ~AuthenticatorInfo() override;
  explicit PROTOBUF_CONSTEXPR AuthenticatorInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticatorInfo(const AuthenticatorInfo& from);
  AuthenticatorInfo(AuthenticatorInfo&& from) noexcept
    : AuthenticatorInfo() {
    *this = ::std::move(from);
  }

  inline AuthenticatorInfo& operator=(const AuthenticatorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticatorInfo& operator=(AuthenticatorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticatorInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticatorInfo* internal_default_instance() {
    return reinterpret_cast<const AuthenticatorInfo*>(
               &_AuthenticatorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AuthenticatorInfo& a, AuthenticatorInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticatorInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticatorInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticatorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticatorInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticatorInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticatorInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticatorInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AuthenticatorInfo";
  }
  protected:
  explicit AuthenticatorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIsDeactivatedFieldNumber = 3,
  };
  // string value = 2 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .viam.app.v1.AuthenticationType type = 1 [json_name = "type"];
  void clear_type();
  ::viam::app::v1::AuthenticationType type() const;
  void set_type(::viam::app::v1::AuthenticationType value);
  private:
  ::viam::app::v1::AuthenticationType _internal_type() const;
  void _internal_set_type(::viam::app::v1::AuthenticationType value);
  public:

  // bool is_deactivated = 3 [json_name = "isDeactivated"];
  void clear_is_deactivated();
  bool is_deactivated() const;
  void set_is_deactivated(bool value);
  private:
  bool _internal_is_deactivated() const;
  void _internal_set_is_deactivated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthenticatorInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int type_;
  bool is_deactivated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsRequest) */ {
 public:
  inline ListOrganizationsRequest() : ListOrganizationsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsRequest(const ListOrganizationsRequest& from);
  ListOrganizationsRequest(ListOrganizationsRequest&& from) noexcept
    : ListOrganizationsRequest() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsRequest& operator=(const ListOrganizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsRequest& operator=(ListOrganizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsRequest*>(
               &_ListOrganizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListOrganizationsRequest& a, ListOrganizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListOrganizationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListOrganizationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsRequest";
  }
  protected:
  explicit ListOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Organization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Organization) */ {
 public:
  inline Organization() : Organization(nullptr) {}
  ~Organization() override;
  explicit PROTOBUF_CONSTEXPR Organization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Organization(const Organization& from);
  Organization(Organization&& from) noexcept
    : Organization() {
    *this = ::std::move(from);
  }

  inline Organization& operator=(const Organization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Organization& operator=(Organization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Organization& default_instance() {
    return *internal_default_instance();
  }
  static inline const Organization* internal_default_instance() {
    return reinterpret_cast<const Organization*>(
               &_Organization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Organization& a, Organization& b) {
    a.Swap(&b);
  }
  inline void Swap(Organization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Organization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Organization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Organization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Organization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Organization& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Organization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Organization";
  }
  protected:
  explicit Organization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPublicNamespaceFieldNumber = 4,
    kDefaultRegionFieldNumber = 5,
    kCidFieldNumber = 6,
    kCreatedOnFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string public_namespace = 4 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // string default_region = 5 [json_name = "defaultRegion"];
  void clear_default_region();
  const std::string& default_region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_region();
  PROTOBUF_NODISCARD std::string* release_default_region();
  void set_allocated_default_region(std::string* default_region);
  private:
  const std::string& _internal_default_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_region(const std::string& value);
  std::string* _internal_mutable_default_region();
  public:

  // optional string cid = 6 [json_name = "cid"];
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Organization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationMember) */ {
 public:
  inline OrganizationMember() : OrganizationMember(nullptr) {}
  ~OrganizationMember() override;
  explicit PROTOBUF_CONSTEXPR OrganizationMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationMember(const OrganizationMember& from);
  OrganizationMember(OrganizationMember&& from) noexcept
    : OrganizationMember() {
    *this = ::std::move(from);
  }

  inline OrganizationMember& operator=(const OrganizationMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationMember& operator=(OrganizationMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationMember* internal_default_instance() {
    return reinterpret_cast<const OrganizationMember*>(
               &_OrganizationMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OrganizationMember& a, OrganizationMember& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationMember& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationMember";
  }
  protected:
  explicit OrganizationMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailsFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kDateAddedFieldNumber = 3,
    kLastLoginFieldNumber = 4,
    kLastAccessFieldNumber = 5,
  };
  // repeated string emails = 2 [json_name = "emails"];
  int emails_size() const;
  private:
  int _internal_emails_size() const;
  public:
  void clear_emails();
  const std::string& emails(int index) const;
  std::string* mutable_emails(int index);
  void set_emails(int index, const std::string& value);
  void set_emails(int index, std::string&& value);
  void set_emails(int index, const char* value);
  void set_emails(int index, const char* value, size_t size);
  std::string* add_emails();
  void add_emails(const std::string& value);
  void add_emails(std::string&& value);
  void add_emails(const char* value);
  void add_emails(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& emails() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_emails();
  private:
  const std::string& _internal_emails(int index) const;
  std::string* _internal_add_emails();
  public:

  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .google.protobuf.Timestamp date_added = 3 [json_name = "dateAdded"];
  bool has_date_added() const;
  private:
  bool _internal_has_date_added() const;
  public:
  void clear_date_added();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_added() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_added();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_added();
  void set_allocated_date_added(::PROTOBUF_NAMESPACE_ID::Timestamp* date_added);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_added() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_added();
  public:
  void unsafe_arena_set_allocated_date_added(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_added);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_added();

  // optional .google.protobuf.Timestamp last_login = 4 [json_name = "lastLogin"];
  bool has_last_login() const;
  private:
  bool _internal_has_last_login() const;
  public:
  void clear_last_login();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_login() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_login();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_login();
  void set_allocated_last_login(::PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_login() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_login();
  public:
  void unsafe_arena_set_allocated_last_login(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_login();

  // optional .google.protobuf.Timestamp last_access = 5 [json_name = "lastAccess"];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> emails_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* date_added_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_login_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsResponse) */ {
 public:
  inline ListOrganizationsResponse() : ListOrganizationsResponse(nullptr) {}
  ~ListOrganizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsResponse(const ListOrganizationsResponse& from);
  ListOrganizationsResponse(ListOrganizationsResponse&& from) noexcept
    : ListOrganizationsResponse() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsResponse& operator=(const ListOrganizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsResponse& operator=(ListOrganizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsResponse*>(
               &_ListOrganizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListOrganizationsResponse& a, ListOrganizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsResponse";
  }
  protected:
  explicit ListOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Organization organizations = 1 [json_name = "organizations"];
  int organizations_size() const;
  private:
  int _internal_organizations_size() const;
  public:
  void clear_organizations();
  ::viam::app::v1::Organization* mutable_organizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >*
      mutable_organizations();
  private:
  const ::viam::app::v1::Organization& _internal_organizations(int index) const;
  ::viam::app::v1::Organization* _internal_add_organizations();
  public:
  const ::viam::app::v1::Organization& organizations(int index) const;
  ::viam::app::v1::Organization* add_organizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >&
      organizations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization > organizations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationInvite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationInvite) */ {
 public:
  inline OrganizationInvite() : OrganizationInvite(nullptr) {}
  ~OrganizationInvite() override;
  explicit PROTOBUF_CONSTEXPR OrganizationInvite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationInvite(const OrganizationInvite& from);
  OrganizationInvite(OrganizationInvite&& from) noexcept
    : OrganizationInvite() {
    *this = ::std::move(from);
  }

  inline OrganizationInvite& operator=(const OrganizationInvite& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationInvite& operator=(OrganizationInvite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationInvite& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationInvite* internal_default_instance() {
    return reinterpret_cast<const OrganizationInvite*>(
               &_OrganizationInvite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OrganizationInvite& a, OrganizationInvite& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationInvite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationInvite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationInvite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationInvite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationInvite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationInvite& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationInvite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationInvite";
  }
  protected:
  explicit OrganizationInvite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 4,
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kCreatedOnFieldNumber = 3,
  };
  // repeated .viam.app.v1.Authorization authorizations = 4 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationInvite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationRequest) */ {
 public:
  inline CreateOrganizationRequest() : CreateOrganizationRequest(nullptr) {}
  ~CreateOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationRequest(const CreateOrganizationRequest& from);
  CreateOrganizationRequest(CreateOrganizationRequest&& from) noexcept
    : CreateOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationRequest& operator=(const CreateOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationRequest& operator=(CreateOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationRequest*>(
               &_CreateOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateOrganizationRequest& a, CreateOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationRequest";
  }
  protected:
  explicit CreateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationResponse) */ {
 public:
  inline CreateOrganizationResponse() : CreateOrganizationResponse(nullptr) {}
  ~CreateOrganizationResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationResponse(const CreateOrganizationResponse& from);
  CreateOrganizationResponse(CreateOrganizationResponse&& from) noexcept
    : CreateOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationResponse& operator=(const CreateOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationResponse& operator=(CreateOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationResponse*>(
               &_CreateOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateOrganizationResponse& a, CreateOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationResponse";
  }
  protected:
  explicit CreateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
  };
  // .viam.app.v1.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::viam::app::v1::Organization& organization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Organization* release_organization();
  ::viam::app::v1::Organization* mutable_organization();
  void set_allocated_organization(::viam::app::v1::Organization* organization);
  private:
  const ::viam::app::v1::Organization& _internal_organization() const;
  ::viam::app::v1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::viam::app::v1::Organization* organization);
  ::viam::app::v1::Organization* unsafe_arena_release_organization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Organization* organization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationRequest) */ {
 public:
  inline GetOrganizationRequest() : GetOrganizationRequest(nullptr) {}
  ~GetOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationRequest(const GetOrganizationRequest& from);
  GetOrganizationRequest(GetOrganizationRequest&& from) noexcept
    : GetOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationRequest& operator=(const GetOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationRequest& operator=(GetOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationRequest*>(
               &_GetOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetOrganizationRequest& a, GetOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationRequest";
  }
  protected:
  explicit GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationResponse) */ {
 public:
  inline GetOrganizationResponse() : GetOrganizationResponse(nullptr) {}
  ~GetOrganizationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationResponse(const GetOrganizationResponse& from);
  GetOrganizationResponse(GetOrganizationResponse&& from) noexcept
    : GetOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationResponse& operator=(const GetOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationResponse& operator=(GetOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationResponse*>(
               &_GetOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetOrganizationResponse& a, GetOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationResponse";
  }
  protected:
  explicit GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
  };
  // .viam.app.v1.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::viam::app::v1::Organization& organization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Organization* release_organization();
  ::viam::app::v1::Organization* mutable_organization();
  void set_allocated_organization(::viam::app::v1::Organization* organization);
  private:
  const ::viam::app::v1::Organization& _internal_organization() const;
  ::viam::app::v1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::viam::app::v1::Organization* organization);
  ::viam::app::v1::Organization* unsafe_arena_release_organization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Organization* organization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationNamespaceAvailabilityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest) */ {
 public:
  inline GetOrganizationNamespaceAvailabilityRequest() : GetOrganizationNamespaceAvailabilityRequest(nullptr) {}
  ~GetOrganizationNamespaceAvailabilityRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationNamespaceAvailabilityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationNamespaceAvailabilityRequest(const GetOrganizationNamespaceAvailabilityRequest& from);
  GetOrganizationNamespaceAvailabilityRequest(GetOrganizationNamespaceAvailabilityRequest&& from) noexcept
    : GetOrganizationNamespaceAvailabilityRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationNamespaceAvailabilityRequest& operator=(const GetOrganizationNamespaceAvailabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationNamespaceAvailabilityRequest& operator=(GetOrganizationNamespaceAvailabilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationNamespaceAvailabilityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationNamespaceAvailabilityRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationNamespaceAvailabilityRequest*>(
               &_GetOrganizationNamespaceAvailabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetOrganizationNamespaceAvailabilityRequest& a, GetOrganizationNamespaceAvailabilityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationNamespaceAvailabilityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationNamespaceAvailabilityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationNamespaceAvailabilityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationNamespaceAvailabilityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationNamespaceAvailabilityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationNamespaceAvailabilityRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationNamespaceAvailabilityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationNamespaceAvailabilityRequest";
  }
  protected:
  explicit GetOrganizationNamespaceAvailabilityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicNamespaceFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // string public_namespace = 1 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationNamespaceAvailabilityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse) */ {
 public:
  inline GetOrganizationNamespaceAvailabilityResponse() : GetOrganizationNamespaceAvailabilityResponse(nullptr) {}
  ~GetOrganizationNamespaceAvailabilityResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationNamespaceAvailabilityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationNamespaceAvailabilityResponse(const GetOrganizationNamespaceAvailabilityResponse& from);
  GetOrganizationNamespaceAvailabilityResponse(GetOrganizationNamespaceAvailabilityResponse&& from) noexcept
    : GetOrganizationNamespaceAvailabilityResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationNamespaceAvailabilityResponse& operator=(const GetOrganizationNamespaceAvailabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationNamespaceAvailabilityResponse& operator=(GetOrganizationNamespaceAvailabilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationNamespaceAvailabilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationNamespaceAvailabilityResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationNamespaceAvailabilityResponse*>(
               &_GetOrganizationNamespaceAvailabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetOrganizationNamespaceAvailabilityResponse& a, GetOrganizationNamespaceAvailabilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationNamespaceAvailabilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationNamespaceAvailabilityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationNamespaceAvailabilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationNamespaceAvailabilityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationNamespaceAvailabilityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationNamespaceAvailabilityResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationNamespaceAvailabilityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationNamespaceAvailabilityResponse";
  }
  protected:
  explicit GetOrganizationNamespaceAvailabilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableFieldNumber = 1,
  };
  // bool available = 1 [json_name = "available"];
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool available_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentImportList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentImportList) */ {
 public:
  inline FragmentImportList() : FragmentImportList(nullptr) {}
  ~FragmentImportList() override;
  explicit PROTOBUF_CONSTEXPR FragmentImportList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentImportList(const FragmentImportList& from);
  FragmentImportList(FragmentImportList&& from) noexcept
    : FragmentImportList() {
    *this = ::std::move(from);
  }

  inline FragmentImportList& operator=(const FragmentImportList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentImportList& operator=(FragmentImportList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentImportList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentImportList* internal_default_instance() {
    return reinterpret_cast<const FragmentImportList*>(
               &_FragmentImportList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FragmentImportList& a, FragmentImportList& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentImportList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentImportList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentImportList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentImportList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentImportList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentImportList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentImportList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentImportList";
  }
  protected:
  explicit FragmentImportList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 1,
  };
  // repeated .viam.app.v1.FragmentImport fragments = 1 [json_name = "fragments"];
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;
  public:
  void clear_fragments();
  ::viam::app::v1::FragmentImport* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentImport >*
      mutable_fragments();
  private:
  const ::viam::app::v1::FragmentImport& _internal_fragments(int index) const;
  ::viam::app::v1::FragmentImport* _internal_add_fragments();
  public:
  const ::viam::app::v1::FragmentImport& fragments(int index) const;
  ::viam::app::v1::FragmentImport* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentImport >&
      fragments() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentImportList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentImport > fragments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationRequest) */ {
 public:
  inline UpdateOrganizationRequest() : UpdateOrganizationRequest(nullptr) {}
  ~UpdateOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationRequest(const UpdateOrganizationRequest& from);
  UpdateOrganizationRequest(UpdateOrganizationRequest&& from) noexcept
    : UpdateOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationRequest& operator=(const UpdateOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationRequest& operator=(UpdateOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationRequest*>(
               &_UpdateOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateOrganizationRequest& a, UpdateOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationRequest";
  }
  protected:
  explicit UpdateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPublicNamespaceFieldNumber = 3,
    kRegionFieldNumber = 4,
    kCidFieldNumber = 5,
    kDefaultFragmentsFieldNumber = 6,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string public_namespace = 3 [json_name = "publicNamespace"];
  bool has_public_namespace() const;
  private:
  bool _internal_has_public_namespace() const;
  public:
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // optional string region = 4 [json_name = "region"];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional string cid = 5 [json_name = "cid"];
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // optional .viam.app.v1.FragmentImportList default_fragments = 6 [json_name = "defaultFragments"];
  bool has_default_fragments() const;
  private:
  bool _internal_has_default_fragments() const;
  public:
  void clear_default_fragments();
  const ::viam::app::v1::FragmentImportList& default_fragments() const;
  PROTOBUF_NODISCARD ::viam::app::v1::FragmentImportList* release_default_fragments();
  ::viam::app::v1::FragmentImportList* mutable_default_fragments();
  void set_allocated_default_fragments(::viam::app::v1::FragmentImportList* default_fragments);
  private:
  const ::viam::app::v1::FragmentImportList& _internal_default_fragments() const;
  ::viam::app::v1::FragmentImportList* _internal_mutable_default_fragments();
  public:
  void unsafe_arena_set_allocated_default_fragments(
      ::viam::app::v1::FragmentImportList* default_fragments);
  ::viam::app::v1::FragmentImportList* unsafe_arena_release_default_fragments();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::viam::app::v1::FragmentImportList* default_fragments_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationResponse) */ {
 public:
  inline UpdateOrganizationResponse() : UpdateOrganizationResponse(nullptr) {}
  ~UpdateOrganizationResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationResponse(const UpdateOrganizationResponse& from);
  UpdateOrganizationResponse(UpdateOrganizationResponse&& from) noexcept
    : UpdateOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationResponse& operator=(const UpdateOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationResponse& operator=(UpdateOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationResponse*>(
               &_UpdateOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateOrganizationResponse& a, UpdateOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationResponse";
  }
  protected:
  explicit UpdateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
  };
  // .viam.app.v1.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::viam::app::v1::Organization& organization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Organization* release_organization();
  ::viam::app::v1::Organization* mutable_organization();
  void set_allocated_organization(::viam::app::v1::Organization* organization);
  private:
  const ::viam::app::v1::Organization& _internal_organization() const;
  ::viam::app::v1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::viam::app::v1::Organization* organization);
  ::viam::app::v1::Organization* unsafe_arena_release_organization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Organization* organization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationNamespaceRequest) */ {
 public:
  inline UpdateOrganizationNamespaceRequest() : UpdateOrganizationNamespaceRequest(nullptr) {}
  ~UpdateOrganizationNamespaceRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationNamespaceRequest(const UpdateOrganizationNamespaceRequest& from);
  UpdateOrganizationNamespaceRequest(UpdateOrganizationNamespaceRequest&& from) noexcept
    : UpdateOrganizationNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationNamespaceRequest& operator=(const UpdateOrganizationNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationNamespaceRequest& operator=(UpdateOrganizationNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationNamespaceRequest*>(
               &_UpdateOrganizationNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateOrganizationNamespaceRequest& a, UpdateOrganizationNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationNamespaceRequest";
  }
  protected:
  explicit UpdateOrganizationNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNewPublicNamespaceFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string new_public_namespace = 2 [json_name = "newPublicNamespace"];
  void clear_new_public_namespace();
  const std::string& new_public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_namespace();
  PROTOBUF_NODISCARD std::string* release_new_public_namespace();
  void set_allocated_new_public_namespace(std::string* new_public_namespace);
  private:
  const std::string& _internal_new_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_namespace(const std::string& value);
  std::string* _internal_mutable_new_public_namespace();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_namespace_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationNamespaceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationNamespaceResponse) */ {
 public:
  inline UpdateOrganizationNamespaceResponse() : UpdateOrganizationNamespaceResponse(nullptr) {}
  ~UpdateOrganizationNamespaceResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationNamespaceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationNamespaceResponse(const UpdateOrganizationNamespaceResponse& from);
  UpdateOrganizationNamespaceResponse(UpdateOrganizationNamespaceResponse&& from) noexcept
    : UpdateOrganizationNamespaceResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationNamespaceResponse& operator=(const UpdateOrganizationNamespaceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationNamespaceResponse& operator=(UpdateOrganizationNamespaceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationNamespaceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationNamespaceResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationNamespaceResponse*>(
               &_UpdateOrganizationNamespaceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateOrganizationNamespaceResponse& a, UpdateOrganizationNamespaceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationNamespaceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationNamespaceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationNamespaceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationNamespaceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationNamespaceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationNamespaceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationNamespaceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationNamespaceResponse";
  }
  protected:
  explicit UpdateOrganizationNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
  };
  // .viam.app.v1.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::viam::app::v1::Organization& organization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Organization* release_organization();
  ::viam::app::v1::Organization* mutable_organization();
  void set_allocated_organization(::viam::app::v1::Organization* organization);
  private:
  const ::viam::app::v1::Organization& _internal_organization() const;
  ::viam::app::v1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::viam::app::v1::Organization* organization);
  ::viam::app::v1::Organization* unsafe_arena_release_organization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationNamespaceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Organization* organization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationRequest) */ {
 public:
  inline DeleteOrganizationRequest() : DeleteOrganizationRequest(nullptr) {}
  ~DeleteOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationRequest(const DeleteOrganizationRequest& from);
  DeleteOrganizationRequest(DeleteOrganizationRequest&& from) noexcept
    : DeleteOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationRequest& operator=(const DeleteOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationRequest& operator=(DeleteOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationRequest*>(
               &_DeleteOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DeleteOrganizationRequest& a, DeleteOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationRequest";
  }
  protected:
  explicit DeleteOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationResponse) */ {
 public:
  inline DeleteOrganizationResponse() : DeleteOrganizationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationResponse(const DeleteOrganizationResponse& from);
  DeleteOrganizationResponse(DeleteOrganizationResponse&& from) noexcept
    : DeleteOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationResponse& operator=(const DeleteOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationResponse& operator=(DeleteOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationResponse*>(
               &_DeleteOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeleteOrganizationResponse& a, DeleteOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteOrganizationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteOrganizationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationResponse";
  }
  protected:
  explicit DeleteOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationMetadataRequest) */ {
 public:
  inline GetOrganizationMetadataRequest() : GetOrganizationMetadataRequest(nullptr) {}
  ~GetOrganizationMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationMetadataRequest(const GetOrganizationMetadataRequest& from);
  GetOrganizationMetadataRequest(GetOrganizationMetadataRequest&& from) noexcept
    : GetOrganizationMetadataRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationMetadataRequest& operator=(const GetOrganizationMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationMetadataRequest& operator=(GetOrganizationMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationMetadataRequest*>(
               &_GetOrganizationMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetOrganizationMetadataRequest& a, GetOrganizationMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationMetadataRequest";
  }
  protected:
  explicit GetOrganizationMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationMetadataResponse) */ {
 public:
  inline GetOrganizationMetadataResponse() : GetOrganizationMetadataResponse(nullptr) {}
  ~GetOrganizationMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationMetadataResponse(const GetOrganizationMetadataResponse& from);
  GetOrganizationMetadataResponse(GetOrganizationMetadataResponse&& from) noexcept
    : GetOrganizationMetadataResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationMetadataResponse& operator=(const GetOrganizationMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationMetadataResponse& operator=(GetOrganizationMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationMetadataResponse*>(
               &_GetOrganizationMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetOrganizationMetadataResponse& a, GetOrganizationMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationMetadataResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationMetadataResponse";
  }
  protected:
  explicit GetOrganizationMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .google.protobuf.Struct data = 1 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationMetadataRequest) */ {
 public:
  inline UpdateOrganizationMetadataRequest() : UpdateOrganizationMetadataRequest(nullptr) {}
  ~UpdateOrganizationMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationMetadataRequest(const UpdateOrganizationMetadataRequest& from);
  UpdateOrganizationMetadataRequest(UpdateOrganizationMetadataRequest&& from) noexcept
    : UpdateOrganizationMetadataRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationMetadataRequest& operator=(const UpdateOrganizationMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationMetadataRequest& operator=(UpdateOrganizationMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationMetadataRequest*>(
               &_UpdateOrganizationMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UpdateOrganizationMetadataRequest& a, UpdateOrganizationMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationMetadataRequest";
  }
  protected:
  explicit UpdateOrganizationMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // .google.protobuf.Struct data = 2 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationMetadataResponse) */ {
 public:
  inline UpdateOrganizationMetadataResponse() : UpdateOrganizationMetadataResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationMetadataResponse(const UpdateOrganizationMetadataResponse& from);
  UpdateOrganizationMetadataResponse(UpdateOrganizationMetadataResponse&& from) noexcept
    : UpdateOrganizationMetadataResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationMetadataResponse& operator=(const UpdateOrganizationMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationMetadataResponse& operator=(UpdateOrganizationMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationMetadataResponse*>(
               &_UpdateOrganizationMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UpdateOrganizationMetadataResponse& a, UpdateOrganizationMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateOrganizationMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateOrganizationMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationMetadataResponse";
  }
  protected:
  explicit UpdateOrganizationMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationMembersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationMembersRequest) */ {
 public:
  inline ListOrganizationMembersRequest() : ListOrganizationMembersRequest(nullptr) {}
  ~ListOrganizationMembersRequest() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationMembersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationMembersRequest(const ListOrganizationMembersRequest& from);
  ListOrganizationMembersRequest(ListOrganizationMembersRequest&& from) noexcept
    : ListOrganizationMembersRequest() {
    *this = ::std::move(from);
  }

  inline ListOrganizationMembersRequest& operator=(const ListOrganizationMembersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationMembersRequest& operator=(ListOrganizationMembersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationMembersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationMembersRequest* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationMembersRequest*>(
               &_ListOrganizationMembersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ListOrganizationMembersRequest& a, ListOrganizationMembersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationMembersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationMembersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationMembersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationMembersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationMembersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationMembersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationMembersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationMembersRequest";
  }
  protected:
  explicit ListOrganizationMembersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationMembersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationMembersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationMembersResponse) */ {
 public:
  inline ListOrganizationMembersResponse() : ListOrganizationMembersResponse(nullptr) {}
  ~ListOrganizationMembersResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationMembersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationMembersResponse(const ListOrganizationMembersResponse& from);
  ListOrganizationMembersResponse(ListOrganizationMembersResponse&& from) noexcept
    : ListOrganizationMembersResponse() {
    *this = ::std::move(from);
  }

  inline ListOrganizationMembersResponse& operator=(const ListOrganizationMembersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationMembersResponse& operator=(ListOrganizationMembersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationMembersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationMembersResponse* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationMembersResponse*>(
               &_ListOrganizationMembersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListOrganizationMembersResponse& a, ListOrganizationMembersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationMembersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationMembersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationMembersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationMembersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationMembersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationMembersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationMembersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationMembersResponse";
  }
  protected:
  explicit ListOrganizationMembersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kInvitesFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // repeated .viam.app.v1.OrganizationMember members = 2 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::viam::app::v1::OrganizationMember* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >*
      mutable_members();
  private:
  const ::viam::app::v1::OrganizationMember& _internal_members(int index) const;
  ::viam::app::v1::OrganizationMember* _internal_add_members();
  public:
  const ::viam::app::v1::OrganizationMember& members(int index) const;
  ::viam::app::v1::OrganizationMember* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >&
      members() const;

  // repeated .viam.app.v1.OrganizationInvite invites = 3 [json_name = "invites"];
  int invites_size() const;
  private:
  int _internal_invites_size() const;
  public:
  void clear_invites();
  ::viam::app::v1::OrganizationInvite* mutable_invites(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >*
      mutable_invites();
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invites(int index) const;
  ::viam::app::v1::OrganizationInvite* _internal_add_invites();
  public:
  const ::viam::app::v1::OrganizationInvite& invites(int index) const;
  ::viam::app::v1::OrganizationInvite* add_invites();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >&
      invites() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationMembersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember > members_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite > invites_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationInviteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationInviteRequest) */ {
 public:
  inline CreateOrganizationInviteRequest() : CreateOrganizationInviteRequest(nullptr) {}
  ~CreateOrganizationInviteRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationInviteRequest(const CreateOrganizationInviteRequest& from);
  CreateOrganizationInviteRequest(CreateOrganizationInviteRequest&& from) noexcept
    : CreateOrganizationInviteRequest() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationInviteRequest& operator=(const CreateOrganizationInviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationInviteRequest& operator=(CreateOrganizationInviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationInviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationInviteRequest* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationInviteRequest*>(
               &_CreateOrganizationInviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CreateOrganizationInviteRequest& a, CreateOrganizationInviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationInviteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationInviteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationInviteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationInviteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationInviteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationInviteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationInviteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationInviteRequest";
  }
  protected:
  explicit CreateOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kSendEmailInviteFieldNumber = 4,
  };
  // repeated .viam.app.v1.Authorization authorizations = 3 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // optional bool send_email_invite = 4 [json_name = "sendEmailInvite"];
  bool has_send_email_invite() const;
  private:
  bool _internal_has_send_email_invite() const;
  public:
  void clear_send_email_invite();
  bool send_email_invite() const;
  void set_send_email_invite(bool value);
  private:
  bool _internal_send_email_invite() const;
  void _internal_set_send_email_invite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationInviteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  bool send_email_invite_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationInviteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationInviteResponse) */ {
 public:
  inline CreateOrganizationInviteResponse() : CreateOrganizationInviteResponse(nullptr) {}
  ~CreateOrganizationInviteResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationInviteResponse(const CreateOrganizationInviteResponse& from);
  CreateOrganizationInviteResponse(CreateOrganizationInviteResponse&& from) noexcept
    : CreateOrganizationInviteResponse() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationInviteResponse& operator=(const CreateOrganizationInviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationInviteResponse& operator=(CreateOrganizationInviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationInviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationInviteResponse* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationInviteResponse*>(
               &_CreateOrganizationInviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CreateOrganizationInviteResponse& a, CreateOrganizationInviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationInviteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationInviteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationInviteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationInviteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationInviteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationInviteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationInviteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationInviteResponse";
  }
  protected:
  explicit CreateOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteFieldNumber = 1,
  };
  // .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
  bool has_invite() const;
  private:
  bool _internal_has_invite() const;
  public:
  void clear_invite();
  const ::viam::app::v1::OrganizationInvite& invite() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OrganizationInvite* release_invite();
  ::viam::app::v1::OrganizationInvite* mutable_invite();
  void set_allocated_invite(::viam::app::v1::OrganizationInvite* invite);
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invite() const;
  ::viam::app::v1::OrganizationInvite* _internal_mutable_invite();
  public:
  void unsafe_arena_set_allocated_invite(
      ::viam::app::v1::OrganizationInvite* invite);
  ::viam::app::v1::OrganizationInvite* unsafe_arena_release_invite();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationInviteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::OrganizationInvite* invite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationInviteAuthorizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest) */ {
 public:
  inline UpdateOrganizationInviteAuthorizationsRequest() : UpdateOrganizationInviteAuthorizationsRequest(nullptr) {}
  ~UpdateOrganizationInviteAuthorizationsRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationInviteAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationInviteAuthorizationsRequest(const UpdateOrganizationInviteAuthorizationsRequest& from);
  UpdateOrganizationInviteAuthorizationsRequest(UpdateOrganizationInviteAuthorizationsRequest&& from) noexcept
    : UpdateOrganizationInviteAuthorizationsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationInviteAuthorizationsRequest& operator=(const UpdateOrganizationInviteAuthorizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationInviteAuthorizationsRequest& operator=(UpdateOrganizationInviteAuthorizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationInviteAuthorizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationInviteAuthorizationsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationInviteAuthorizationsRequest*>(
               &_UpdateOrganizationInviteAuthorizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UpdateOrganizationInviteAuthorizationsRequest& a, UpdateOrganizationInviteAuthorizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationInviteAuthorizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationInviteAuthorizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationInviteAuthorizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationInviteAuthorizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationInviteAuthorizationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationInviteAuthorizationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationInviteAuthorizationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest";
  }
  protected:
  explicit UpdateOrganizationInviteAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddAuthorizationsFieldNumber = 3,
    kRemoveAuthorizationsFieldNumber = 4,
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
  };
  // repeated .viam.app.v1.Authorization add_authorizations = 3 [json_name = "addAuthorizations"];
  int add_authorizations_size() const;
  private:
  int _internal_add_authorizations_size() const;
  public:
  void clear_add_authorizations();
  ::viam::app::v1::Authorization* mutable_add_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_add_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_add_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& add_authorizations(int index) const;
  ::viam::app::v1::Authorization* add_add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      add_authorizations() const;

  // repeated .viam.app.v1.Authorization remove_authorizations = 4 [json_name = "removeAuthorizations"];
  int remove_authorizations_size() const;
  private:
  int _internal_remove_authorizations_size() const;
  public:
  void clear_remove_authorizations();
  ::viam::app::v1::Authorization* mutable_remove_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_remove_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_remove_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_remove_authorizations();
  public:
  const ::viam::app::v1::Authorization& remove_authorizations(int index) const;
  ::viam::app::v1::Authorization* add_remove_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      remove_authorizations() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > add_authorizations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > remove_authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationInviteAuthorizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse) */ {
 public:
  inline UpdateOrganizationInviteAuthorizationsResponse() : UpdateOrganizationInviteAuthorizationsResponse(nullptr) {}
  ~UpdateOrganizationInviteAuthorizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationInviteAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationInviteAuthorizationsResponse(const UpdateOrganizationInviteAuthorizationsResponse& from);
  UpdateOrganizationInviteAuthorizationsResponse(UpdateOrganizationInviteAuthorizationsResponse&& from) noexcept
    : UpdateOrganizationInviteAuthorizationsResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationInviteAuthorizationsResponse& operator=(const UpdateOrganizationInviteAuthorizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationInviteAuthorizationsResponse& operator=(UpdateOrganizationInviteAuthorizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationInviteAuthorizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationInviteAuthorizationsResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationInviteAuthorizationsResponse*>(
               &_UpdateOrganizationInviteAuthorizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdateOrganizationInviteAuthorizationsResponse& a, UpdateOrganizationInviteAuthorizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationInviteAuthorizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationInviteAuthorizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationInviteAuthorizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationInviteAuthorizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationInviteAuthorizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationInviteAuthorizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationInviteAuthorizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse";
  }
  protected:
  explicit UpdateOrganizationInviteAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteFieldNumber = 1,
  };
  // .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
  bool has_invite() const;
  private:
  bool _internal_has_invite() const;
  public:
  void clear_invite();
  const ::viam::app::v1::OrganizationInvite& invite() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OrganizationInvite* release_invite();
  ::viam::app::v1::OrganizationInvite* mutable_invite();
  void set_allocated_invite(::viam::app::v1::OrganizationInvite* invite);
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invite() const;
  ::viam::app::v1::OrganizationInvite* _internal_mutable_invite();
  public:
  void unsafe_arena_set_allocated_invite(
      ::viam::app::v1::OrganizationInvite* invite);
  ::viam::app::v1::OrganizationInvite* unsafe_arena_release_invite();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::OrganizationInvite* invite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationInviteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationInviteRequest) */ {
 public:
  inline DeleteOrganizationInviteRequest() : DeleteOrganizationInviteRequest(nullptr) {}
  ~DeleteOrganizationInviteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationInviteRequest(const DeleteOrganizationInviteRequest& from);
  DeleteOrganizationInviteRequest(DeleteOrganizationInviteRequest&& from) noexcept
    : DeleteOrganizationInviteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationInviteRequest& operator=(const DeleteOrganizationInviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationInviteRequest& operator=(DeleteOrganizationInviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationInviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationInviteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationInviteRequest*>(
               &_DeleteOrganizationInviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DeleteOrganizationInviteRequest& a, DeleteOrganizationInviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationInviteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationInviteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationInviteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationInviteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOrganizationInviteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteOrganizationInviteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOrganizationInviteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationInviteRequest";
  }
  protected:
  explicit DeleteOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationInviteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationInviteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationInviteResponse) */ {
 public:
  inline DeleteOrganizationInviteResponse() : DeleteOrganizationInviteResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationInviteResponse(const DeleteOrganizationInviteResponse& from);
  DeleteOrganizationInviteResponse(DeleteOrganizationInviteResponse&& from) noexcept
    : DeleteOrganizationInviteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationInviteResponse& operator=(const DeleteOrganizationInviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationInviteResponse& operator=(DeleteOrganizationInviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationInviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationInviteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationInviteResponse*>(
               &_DeleteOrganizationInviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DeleteOrganizationInviteResponse& a, DeleteOrganizationInviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationInviteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationInviteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationInviteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationInviteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteOrganizationInviteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteOrganizationInviteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationInviteResponse";
  }
  protected:
  explicit DeleteOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationInviteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ResendOrganizationInviteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ResendOrganizationInviteRequest) */ {
 public:
  inline ResendOrganizationInviteRequest() : ResendOrganizationInviteRequest(nullptr) {}
  ~ResendOrganizationInviteRequest() override;
  explicit PROTOBUF_CONSTEXPR ResendOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResendOrganizationInviteRequest(const ResendOrganizationInviteRequest& from);
  ResendOrganizationInviteRequest(ResendOrganizationInviteRequest&& from) noexcept
    : ResendOrganizationInviteRequest() {
    *this = ::std::move(from);
  }

  inline ResendOrganizationInviteRequest& operator=(const ResendOrganizationInviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResendOrganizationInviteRequest& operator=(ResendOrganizationInviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResendOrganizationInviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResendOrganizationInviteRequest* internal_default_instance() {
    return reinterpret_cast<const ResendOrganizationInviteRequest*>(
               &_ResendOrganizationInviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ResendOrganizationInviteRequest& a, ResendOrganizationInviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResendOrganizationInviteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResendOrganizationInviteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResendOrganizationInviteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResendOrganizationInviteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResendOrganizationInviteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResendOrganizationInviteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResendOrganizationInviteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ResendOrganizationInviteRequest";
  }
  protected:
  explicit ResendOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kSendEmailInviteFieldNumber = 3,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // optional bool send_email_invite = 3 [json_name = "sendEmailInvite"];
  bool has_send_email_invite() const;
  private:
  bool _internal_has_send_email_invite() const;
  public:
  void clear_send_email_invite();
  bool send_email_invite() const;
  void set_send_email_invite(bool value);
  private:
  bool _internal_send_email_invite() const;
  void _internal_set_send_email_invite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ResendOrganizationInviteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  bool send_email_invite_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ResendOrganizationInviteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ResendOrganizationInviteResponse) */ {
 public:
  inline ResendOrganizationInviteResponse() : ResendOrganizationInviteResponse(nullptr) {}
  ~ResendOrganizationInviteResponse() override;
  explicit PROTOBUF_CONSTEXPR ResendOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResendOrganizationInviteResponse(const ResendOrganizationInviteResponse& from);
  ResendOrganizationInviteResponse(ResendOrganizationInviteResponse&& from) noexcept
    : ResendOrganizationInviteResponse() {
    *this = ::std::move(from);
  }

  inline ResendOrganizationInviteResponse& operator=(const ResendOrganizationInviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResendOrganizationInviteResponse& operator=(ResendOrganizationInviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResendOrganizationInviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResendOrganizationInviteResponse* internal_default_instance() {
    return reinterpret_cast<const ResendOrganizationInviteResponse*>(
               &_ResendOrganizationInviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ResendOrganizationInviteResponse& a, ResendOrganizationInviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResendOrganizationInviteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResendOrganizationInviteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResendOrganizationInviteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResendOrganizationInviteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResendOrganizationInviteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResendOrganizationInviteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResendOrganizationInviteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ResendOrganizationInviteResponse";
  }
  protected:
  explicit ResendOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteFieldNumber = 1,
  };
  // .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
  bool has_invite() const;
  private:
  bool _internal_has_invite() const;
  public:
  void clear_invite();
  const ::viam::app::v1::OrganizationInvite& invite() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OrganizationInvite* release_invite();
  ::viam::app::v1::OrganizationInvite* mutable_invite();
  void set_allocated_invite(::viam::app::v1::OrganizationInvite* invite);
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invite() const;
  ::viam::app::v1::OrganizationInvite* _internal_mutable_invite();
  public:
  void unsafe_arena_set_allocated_invite(
      ::viam::app::v1::OrganizationInvite* invite);
  ::viam::app::v1::OrganizationInvite* unsafe_arena_release_invite();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ResendOrganizationInviteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::OrganizationInvite* invite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationMemberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationMemberRequest) */ {
 public:
  inline DeleteOrganizationMemberRequest() : DeleteOrganizationMemberRequest(nullptr) {}
  ~DeleteOrganizationMemberRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationMemberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationMemberRequest(const DeleteOrganizationMemberRequest& from);
  DeleteOrganizationMemberRequest(DeleteOrganizationMemberRequest&& from) noexcept
    : DeleteOrganizationMemberRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationMemberRequest& operator=(const DeleteOrganizationMemberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationMemberRequest& operator=(DeleteOrganizationMemberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationMemberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationMemberRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationMemberRequest*>(
               &_DeleteOrganizationMemberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DeleteOrganizationMemberRequest& a, DeleteOrganizationMemberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationMemberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationMemberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationMemberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationMemberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOrganizationMemberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteOrganizationMemberRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOrganizationMemberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationMemberRequest";
  }
  protected:
  explicit DeleteOrganizationMemberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string user_id = 2 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationMemberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationMemberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationMemberResponse) */ {
 public:
  inline DeleteOrganizationMemberResponse() : DeleteOrganizationMemberResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationMemberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationMemberResponse(const DeleteOrganizationMemberResponse& from);
  DeleteOrganizationMemberResponse(DeleteOrganizationMemberResponse&& from) noexcept
    : DeleteOrganizationMemberResponse() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationMemberResponse& operator=(const DeleteOrganizationMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationMemberResponse& operator=(DeleteOrganizationMemberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationMemberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationMemberResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationMemberResponse*>(
               &_DeleteOrganizationMemberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DeleteOrganizationMemberResponse& a, DeleteOrganizationMemberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationMemberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationMemberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationMemberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationMemberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteOrganizationMemberResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteOrganizationMemberResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationMemberResponse";
  }
  protected:
  explicit DeleteOrganizationMemberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationMemberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class BillingAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.BillingAddress) */ {
 public:
  inline BillingAddress() : BillingAddress(nullptr) {}
  ~BillingAddress() override;
  explicit PROTOBUF_CONSTEXPR BillingAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BillingAddress(const BillingAddress& from);
  BillingAddress(BillingAddress&& from) noexcept
    : BillingAddress() {
    *this = ::std::move(from);
  }

  inline BillingAddress& operator=(const BillingAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline BillingAddress& operator=(BillingAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BillingAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const BillingAddress* internal_default_instance() {
    return reinterpret_cast<const BillingAddress*>(
               &_BillingAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(BillingAddress& a, BillingAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(BillingAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BillingAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BillingAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BillingAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BillingAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BillingAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BillingAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.BillingAddress";
  }
  protected:
  explicit BillingAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressLine1FieldNumber = 1,
    kAddressLine2FieldNumber = 2,
    kCityFieldNumber = 3,
    kStateFieldNumber = 4,
    kZipcodeFieldNumber = 5,
    kCountryFieldNumber = 6,
  };
  // string address_line_1 = 1 [json_name = "addressLine1"];
  void clear_address_line_1();
  const std::string& address_line_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address_line_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address_line_1();
  PROTOBUF_NODISCARD std::string* release_address_line_1();
  void set_allocated_address_line_1(std::string* address_line_1);
  private:
  const std::string& _internal_address_line_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address_line_1(const std::string& value);
  std::string* _internal_mutable_address_line_1();
  public:

  // optional string address_line_2 = 2 [json_name = "addressLine2"];
  bool has_address_line_2() const;
  private:
  bool _internal_has_address_line_2() const;
  public:
  void clear_address_line_2();
  const std::string& address_line_2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address_line_2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address_line_2();
  PROTOBUF_NODISCARD std::string* release_address_line_2();
  void set_allocated_address_line_2(std::string* address_line_2);
  private:
  const std::string& _internal_address_line_2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address_line_2(const std::string& value);
  std::string* _internal_mutable_address_line_2();
  public:

  // string city = 3 [json_name = "city"];
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // string state = 4 [json_name = "state"];
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // string zipcode = 5 [json_name = "zipcode"];
  void clear_zipcode();
  const std::string& zipcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zipcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zipcode();
  PROTOBUF_NODISCARD std::string* release_zipcode();
  void set_allocated_zipcode(std::string* zipcode);
  private:
  const std::string& _internal_zipcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zipcode(const std::string& value);
  std::string* _internal_mutable_zipcode();
  public:

  // string country = 6 [json_name = "country"];
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.BillingAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_line_1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_line_2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zipcode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class EnableBillingServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.EnableBillingServiceRequest) */ {
 public:
  inline EnableBillingServiceRequest() : EnableBillingServiceRequest(nullptr) {}
  ~EnableBillingServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR EnableBillingServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableBillingServiceRequest(const EnableBillingServiceRequest& from);
  EnableBillingServiceRequest(EnableBillingServiceRequest&& from) noexcept
    : EnableBillingServiceRequest() {
    *this = ::std::move(from);
  }

  inline EnableBillingServiceRequest& operator=(const EnableBillingServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableBillingServiceRequest& operator=(EnableBillingServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableBillingServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableBillingServiceRequest* internal_default_instance() {
    return reinterpret_cast<const EnableBillingServiceRequest*>(
               &_EnableBillingServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(EnableBillingServiceRequest& a, EnableBillingServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableBillingServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableBillingServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableBillingServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableBillingServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableBillingServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnableBillingServiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableBillingServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.EnableBillingServiceRequest";
  }
  protected:
  explicit EnableBillingServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kBillingAddressFieldNumber = 2,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // .viam.app.v1.BillingAddress billing_address = 2 [json_name = "billingAddress"];
  bool has_billing_address() const;
  private:
  bool _internal_has_billing_address() const;
  public:
  void clear_billing_address();
  const ::viam::app::v1::BillingAddress& billing_address() const;
  PROTOBUF_NODISCARD ::viam::app::v1::BillingAddress* release_billing_address();
  ::viam::app::v1::BillingAddress* mutable_billing_address();
  void set_allocated_billing_address(::viam::app::v1::BillingAddress* billing_address);
  private:
  const ::viam::app::v1::BillingAddress& _internal_billing_address() const;
  ::viam::app::v1::BillingAddress* _internal_mutable_billing_address();
  public:
  void unsafe_arena_set_allocated_billing_address(
      ::viam::app::v1::BillingAddress* billing_address);
  ::viam::app::v1::BillingAddress* unsafe_arena_release_billing_address();

  // @@protoc_insertion_point(class_scope:viam.app.v1.EnableBillingServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::viam::app::v1::BillingAddress* billing_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class EnableBillingServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.EnableBillingServiceResponse) */ {
 public:
  inline EnableBillingServiceResponse() : EnableBillingServiceResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EnableBillingServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableBillingServiceResponse(const EnableBillingServiceResponse& from);
  EnableBillingServiceResponse(EnableBillingServiceResponse&& from) noexcept
    : EnableBillingServiceResponse() {
    *this = ::std::move(from);
  }

  inline EnableBillingServiceResponse& operator=(const EnableBillingServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableBillingServiceResponse& operator=(EnableBillingServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableBillingServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableBillingServiceResponse* internal_default_instance() {
    return reinterpret_cast<const EnableBillingServiceResponse*>(
               &_EnableBillingServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(EnableBillingServiceResponse& a, EnableBillingServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableBillingServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableBillingServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableBillingServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableBillingServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EnableBillingServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EnableBillingServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.EnableBillingServiceResponse";
  }
  protected:
  explicit EnableBillingServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.EnableBillingServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateBillingServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateBillingServiceRequest) */ {
 public:
  inline UpdateBillingServiceRequest() : UpdateBillingServiceRequest(nullptr) {}
  ~UpdateBillingServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateBillingServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateBillingServiceRequest(const UpdateBillingServiceRequest& from);
  UpdateBillingServiceRequest(UpdateBillingServiceRequest&& from) noexcept
    : UpdateBillingServiceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateBillingServiceRequest& operator=(const UpdateBillingServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBillingServiceRequest& operator=(UpdateBillingServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBillingServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateBillingServiceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateBillingServiceRequest*>(
               &_UpdateBillingServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(UpdateBillingServiceRequest& a, UpdateBillingServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBillingServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBillingServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBillingServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateBillingServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateBillingServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateBillingServiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBillingServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateBillingServiceRequest";
  }
  protected:
  explicit UpdateBillingServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kBillingAddressFieldNumber = 2,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // .viam.app.v1.BillingAddress billing_address = 2 [json_name = "billingAddress"];
  bool has_billing_address() const;
  private:
  bool _internal_has_billing_address() const;
  public:
  void clear_billing_address();
  const ::viam::app::v1::BillingAddress& billing_address() const;
  PROTOBUF_NODISCARD ::viam::app::v1::BillingAddress* release_billing_address();
  ::viam::app::v1::BillingAddress* mutable_billing_address();
  void set_allocated_billing_address(::viam::app::v1::BillingAddress* billing_address);
  private:
  const ::viam::app::v1::BillingAddress& _internal_billing_address() const;
  ::viam::app::v1::BillingAddress* _internal_mutable_billing_address();
  public:
  void unsafe_arena_set_allocated_billing_address(
      ::viam::app::v1::BillingAddress* billing_address);
  ::viam::app::v1::BillingAddress* unsafe_arena_release_billing_address();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateBillingServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::viam::app::v1::BillingAddress* billing_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateBillingServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateBillingServiceResponse) */ {
 public:
  inline UpdateBillingServiceResponse() : UpdateBillingServiceResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateBillingServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateBillingServiceResponse(const UpdateBillingServiceResponse& from);
  UpdateBillingServiceResponse(UpdateBillingServiceResponse&& from) noexcept
    : UpdateBillingServiceResponse() {
    *this = ::std::move(from);
  }

  inline UpdateBillingServiceResponse& operator=(const UpdateBillingServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBillingServiceResponse& operator=(UpdateBillingServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBillingServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateBillingServiceResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateBillingServiceResponse*>(
               &_UpdateBillingServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(UpdateBillingServiceResponse& a, UpdateBillingServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBillingServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBillingServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBillingServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateBillingServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateBillingServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateBillingServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateBillingServiceResponse";
  }
  protected:
  explicit UpdateBillingServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateBillingServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetBillingServiceConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetBillingServiceConfigRequest) */ {
 public:
  inline GetBillingServiceConfigRequest() : GetBillingServiceConfigRequest(nullptr) {}
  ~GetBillingServiceConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR GetBillingServiceConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBillingServiceConfigRequest(const GetBillingServiceConfigRequest& from);
  GetBillingServiceConfigRequest(GetBillingServiceConfigRequest&& from) noexcept
    : GetBillingServiceConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetBillingServiceConfigRequest& operator=(const GetBillingServiceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBillingServiceConfigRequest& operator=(GetBillingServiceConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBillingServiceConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBillingServiceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetBillingServiceConfigRequest*>(
               &_GetBillingServiceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetBillingServiceConfigRequest& a, GetBillingServiceConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBillingServiceConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBillingServiceConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBillingServiceConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBillingServiceConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBillingServiceConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBillingServiceConfigRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBillingServiceConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetBillingServiceConfigRequest";
  }
  protected:
  explicit GetBillingServiceConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetBillingServiceConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetBillingServiceConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetBillingServiceConfigResponse) */ {
 public:
  inline GetBillingServiceConfigResponse() : GetBillingServiceConfigResponse(nullptr) {}
  ~GetBillingServiceConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR GetBillingServiceConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBillingServiceConfigResponse(const GetBillingServiceConfigResponse& from);
  GetBillingServiceConfigResponse(GetBillingServiceConfigResponse&& from) noexcept
    : GetBillingServiceConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetBillingServiceConfigResponse& operator=(const GetBillingServiceConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBillingServiceConfigResponse& operator=(GetBillingServiceConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBillingServiceConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBillingServiceConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetBillingServiceConfigResponse*>(
               &_GetBillingServiceConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(GetBillingServiceConfigResponse& a, GetBillingServiceConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBillingServiceConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBillingServiceConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBillingServiceConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBillingServiceConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBillingServiceConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBillingServiceConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBillingServiceConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetBillingServiceConfigResponse";
  }
  protected:
  explicit GetBillingServiceConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportEmailFieldNumber = 2,
    kLogoUrlFieldNumber = 3,
    kBillingDashboardUrlFieldNumber = 4,
    kBillingAddressFieldNumber = 1,
  };
  // string support_email = 2 [json_name = "supportEmail"];
  void clear_support_email();
  const std::string& support_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_support_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_support_email();
  PROTOBUF_NODISCARD std::string* release_support_email();
  void set_allocated_support_email(std::string* support_email);
  private:
  const std::string& _internal_support_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_support_email(const std::string& value);
  std::string* _internal_mutable_support_email();
  public:

  // string logo_url = 3 [json_name = "logoUrl"];
  void clear_logo_url();
  const std::string& logo_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo_url();
  PROTOBUF_NODISCARD std::string* release_logo_url();
  void set_allocated_logo_url(std::string* logo_url);
  private:
  const std::string& _internal_logo_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo_url(const std::string& value);
  std::string* _internal_mutable_logo_url();
  public:

  // string billing_dashboard_url = 4 [json_name = "billingDashboardUrl"];
  void clear_billing_dashboard_url();
  const std::string& billing_dashboard_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_billing_dashboard_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_billing_dashboard_url();
  PROTOBUF_NODISCARD std::string* release_billing_dashboard_url();
  void set_allocated_billing_dashboard_url(std::string* billing_dashboard_url);
  private:
  const std::string& _internal_billing_dashboard_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_billing_dashboard_url(const std::string& value);
  std::string* _internal_mutable_billing_dashboard_url();
  public:

  // .viam.app.v1.BillingAddress billing_address = 1 [json_name = "billingAddress"];
  bool has_billing_address() const;
  private:
  bool _internal_has_billing_address() const;
  public:
  void clear_billing_address();
  const ::viam::app::v1::BillingAddress& billing_address() const;
  PROTOBUF_NODISCARD ::viam::app::v1::BillingAddress* release_billing_address();
  ::viam::app::v1::BillingAddress* mutable_billing_address();
  void set_allocated_billing_address(::viam::app::v1::BillingAddress* billing_address);
  private:
  const ::viam::app::v1::BillingAddress& _internal_billing_address() const;
  ::viam::app::v1::BillingAddress* _internal_mutable_billing_address();
  public:
  void unsafe_arena_set_allocated_billing_address(
      ::viam::app::v1::BillingAddress* billing_address);
  ::viam::app::v1::BillingAddress* unsafe_arena_release_billing_address();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetBillingServiceConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr support_email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr billing_dashboard_url_;
  ::viam::app::v1::BillingAddress* billing_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DisableBillingServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DisableBillingServiceRequest) */ {
 public:
  inline DisableBillingServiceRequest() : DisableBillingServiceRequest(nullptr) {}
  ~DisableBillingServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR DisableBillingServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableBillingServiceRequest(const DisableBillingServiceRequest& from);
  DisableBillingServiceRequest(DisableBillingServiceRequest&& from) noexcept
    : DisableBillingServiceRequest() {
    *this = ::std::move(from);
  }

  inline DisableBillingServiceRequest& operator=(const DisableBillingServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableBillingServiceRequest& operator=(DisableBillingServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableBillingServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableBillingServiceRequest* internal_default_instance() {
    return reinterpret_cast<const DisableBillingServiceRequest*>(
               &_DisableBillingServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(DisableBillingServiceRequest& a, DisableBillingServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableBillingServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableBillingServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableBillingServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableBillingServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisableBillingServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DisableBillingServiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableBillingServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DisableBillingServiceRequest";
  }
  protected:
  explicit DisableBillingServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DisableBillingServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DisableBillingServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DisableBillingServiceResponse) */ {
 public:
  inline DisableBillingServiceResponse() : DisableBillingServiceResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DisableBillingServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableBillingServiceResponse(const DisableBillingServiceResponse& from);
  DisableBillingServiceResponse(DisableBillingServiceResponse&& from) noexcept
    : DisableBillingServiceResponse() {
    *this = ::std::move(from);
  }

  inline DisableBillingServiceResponse& operator=(const DisableBillingServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableBillingServiceResponse& operator=(DisableBillingServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableBillingServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableBillingServiceResponse* internal_default_instance() {
    return reinterpret_cast<const DisableBillingServiceResponse*>(
               &_DisableBillingServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DisableBillingServiceResponse& a, DisableBillingServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableBillingServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableBillingServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableBillingServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableBillingServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DisableBillingServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DisableBillingServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DisableBillingServiceResponse";
  }
  protected:
  explicit DisableBillingServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DisableBillingServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationSetSupportEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationSetSupportEmailRequest) */ {
 public:
  inline OrganizationSetSupportEmailRequest() : OrganizationSetSupportEmailRequest(nullptr) {}
  ~OrganizationSetSupportEmailRequest() override;
  explicit PROTOBUF_CONSTEXPR OrganizationSetSupportEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationSetSupportEmailRequest(const OrganizationSetSupportEmailRequest& from);
  OrganizationSetSupportEmailRequest(OrganizationSetSupportEmailRequest&& from) noexcept
    : OrganizationSetSupportEmailRequest() {
    *this = ::std::move(from);
  }

  inline OrganizationSetSupportEmailRequest& operator=(const OrganizationSetSupportEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationSetSupportEmailRequest& operator=(OrganizationSetSupportEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationSetSupportEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationSetSupportEmailRequest* internal_default_instance() {
    return reinterpret_cast<const OrganizationSetSupportEmailRequest*>(
               &_OrganizationSetSupportEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(OrganizationSetSupportEmailRequest& a, OrganizationSetSupportEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationSetSupportEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationSetSupportEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationSetSupportEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationSetSupportEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationSetSupportEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationSetSupportEmailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationSetSupportEmailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationSetSupportEmailRequest";
  }
  protected:
  explicit OrganizationSetSupportEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kEmailFieldNumber = 2,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationSetSupportEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationSetSupportEmailResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationSetSupportEmailResponse) */ {
 public:
  inline OrganizationSetSupportEmailResponse() : OrganizationSetSupportEmailResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OrganizationSetSupportEmailResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationSetSupportEmailResponse(const OrganizationSetSupportEmailResponse& from);
  OrganizationSetSupportEmailResponse(OrganizationSetSupportEmailResponse&& from) noexcept
    : OrganizationSetSupportEmailResponse() {
    *this = ::std::move(from);
  }

  inline OrganizationSetSupportEmailResponse& operator=(const OrganizationSetSupportEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationSetSupportEmailResponse& operator=(OrganizationSetSupportEmailResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationSetSupportEmailResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationSetSupportEmailResponse* internal_default_instance() {
    return reinterpret_cast<const OrganizationSetSupportEmailResponse*>(
               &_OrganizationSetSupportEmailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(OrganizationSetSupportEmailResponse& a, OrganizationSetSupportEmailResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationSetSupportEmailResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationSetSupportEmailResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationSetSupportEmailResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationSetSupportEmailResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OrganizationSetSupportEmailResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OrganizationSetSupportEmailResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationSetSupportEmailResponse";
  }
  protected:
  explicit OrganizationSetSupportEmailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationSetSupportEmailResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationGetSupportEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationGetSupportEmailRequest) */ {
 public:
  inline OrganizationGetSupportEmailRequest() : OrganizationGetSupportEmailRequest(nullptr) {}
  ~OrganizationGetSupportEmailRequest() override;
  explicit PROTOBUF_CONSTEXPR OrganizationGetSupportEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationGetSupportEmailRequest(const OrganizationGetSupportEmailRequest& from);
  OrganizationGetSupportEmailRequest(OrganizationGetSupportEmailRequest&& from) noexcept
    : OrganizationGetSupportEmailRequest() {
    *this = ::std::move(from);
  }

  inline OrganizationGetSupportEmailRequest& operator=(const OrganizationGetSupportEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationGetSupportEmailRequest& operator=(OrganizationGetSupportEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationGetSupportEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationGetSupportEmailRequest* internal_default_instance() {
    return reinterpret_cast<const OrganizationGetSupportEmailRequest*>(
               &_OrganizationGetSupportEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(OrganizationGetSupportEmailRequest& a, OrganizationGetSupportEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationGetSupportEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationGetSupportEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationGetSupportEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationGetSupportEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationGetSupportEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationGetSupportEmailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationGetSupportEmailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationGetSupportEmailRequest";
  }
  protected:
  explicit OrganizationGetSupportEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationGetSupportEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationGetSupportEmailResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationGetSupportEmailResponse) */ {
 public:
  inline OrganizationGetSupportEmailResponse() : OrganizationGetSupportEmailResponse(nullptr) {}
  ~OrganizationGetSupportEmailResponse() override;
  explicit PROTOBUF_CONSTEXPR OrganizationGetSupportEmailResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationGetSupportEmailResponse(const OrganizationGetSupportEmailResponse& from);
  OrganizationGetSupportEmailResponse(OrganizationGetSupportEmailResponse&& from) noexcept
    : OrganizationGetSupportEmailResponse() {
    *this = ::std::move(from);
  }

  inline OrganizationGetSupportEmailResponse& operator=(const OrganizationGetSupportEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationGetSupportEmailResponse& operator=(OrganizationGetSupportEmailResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationGetSupportEmailResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationGetSupportEmailResponse* internal_default_instance() {
    return reinterpret_cast<const OrganizationGetSupportEmailResponse*>(
               &_OrganizationGetSupportEmailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(OrganizationGetSupportEmailResponse& a, OrganizationGetSupportEmailResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationGetSupportEmailResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationGetSupportEmailResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationGetSupportEmailResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationGetSupportEmailResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationGetSupportEmailResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationGetSupportEmailResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationGetSupportEmailResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationGetSupportEmailResponse";
  }
  protected:
  explicit OrganizationGetSupportEmailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationGetSupportEmailResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationIdentity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationIdentity) */ {
 public:
  inline OrganizationIdentity() : OrganizationIdentity(nullptr) {}
  ~OrganizationIdentity() override;
  explicit PROTOBUF_CONSTEXPR OrganizationIdentity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationIdentity(const OrganizationIdentity& from);
  OrganizationIdentity(OrganizationIdentity&& from) noexcept
    : OrganizationIdentity() {
    *this = ::std::move(from);
  }

  inline OrganizationIdentity& operator=(const OrganizationIdentity& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationIdentity& operator=(OrganizationIdentity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationIdentity& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationIdentity* internal_default_instance() {
    return reinterpret_cast<const OrganizationIdentity*>(
               &_OrganizationIdentity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(OrganizationIdentity& a, OrganizationIdentity& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationIdentity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationIdentity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationIdentity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationIdentity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationIdentity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationIdentity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationIdentity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationIdentity";
  }
  protected:
  explicit OrganizationIdentity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationIdentity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationOrganization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationOrganization) */ {
 public:
  inline LocationOrganization() : LocationOrganization(nullptr) {}
  ~LocationOrganization() override;
  explicit PROTOBUF_CONSTEXPR LocationOrganization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationOrganization(const LocationOrganization& from);
  LocationOrganization(LocationOrganization&& from) noexcept
    : LocationOrganization() {
    *this = ::std::move(from);
  }

  inline LocationOrganization& operator=(const LocationOrganization& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationOrganization& operator=(LocationOrganization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationOrganization& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationOrganization* internal_default_instance() {
    return reinterpret_cast<const LocationOrganization*>(
               &_LocationOrganization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(LocationOrganization& a, LocationOrganization& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationOrganization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationOrganization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationOrganization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationOrganization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationOrganization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationOrganization& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationOrganization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationOrganization";
  }
  protected:
  explicit LocationOrganization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kPrimaryFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // bool primary = 2 [json_name = "primary"];
  void clear_primary();
  bool primary() const;
  void set_primary(bool value);
  private:
  bool _internal_primary() const;
  void _internal_set_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationOrganization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  bool primary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuth) */ {
 public:
  inline LocationAuth() : LocationAuth(nullptr) {}
  ~LocationAuth() override;
  explicit PROTOBUF_CONSTEXPR LocationAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuth(const LocationAuth& from);
  LocationAuth(LocationAuth&& from) noexcept
    : LocationAuth() {
    *this = ::std::move(from);
  }

  inline LocationAuth& operator=(const LocationAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuth& operator=(LocationAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuth* internal_default_instance() {
    return reinterpret_cast<const LocationAuth*>(
               &_LocationAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(LocationAuth& a, LocationAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuth";
  }
  protected:
  explicit LocationAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kSecretFieldNumber = 1,
    kLocationIdFieldNumber = 2,
  };
  // repeated .viam.app.v1.SharedSecret secrets = 3 [json_name = "secrets"];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  ::viam::app::v1::SharedSecret* mutable_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
      mutable_secrets();
  private:
  const ::viam::app::v1::SharedSecret& _internal_secrets(int index) const;
  ::viam::app::v1::SharedSecret* _internal_add_secrets();
  public:
  const ::viam::app::v1::SharedSecret& secrets(int index) const;
  ::viam::app::v1::SharedSecret* add_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
      secrets() const;

  // string secret = 1 [json_name = "secret", deprecated = true];
  PROTOBUF_DEPRECATED void clear_secret();
  PROTOBUF_DEPRECATED const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_secret(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_secret();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_secret();
  PROTOBUF_DEPRECATED void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string location_id = 2 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class StorageConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.StorageConfig) */ {
 public:
  inline StorageConfig() : StorageConfig(nullptr) {}
  ~StorageConfig() override;
  explicit PROTOBUF_CONSTEXPR StorageConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageConfig(const StorageConfig& from);
  StorageConfig(StorageConfig&& from) noexcept
    : StorageConfig() {
    *this = ::std::move(from);
  }

  inline StorageConfig& operator=(const StorageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageConfig& operator=(StorageConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageConfig* internal_default_instance() {
    return reinterpret_cast<const StorageConfig*>(
               &_StorageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(StorageConfig& a, StorageConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StorageConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.StorageConfig";
  }
  protected:
  explicit StorageConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
  };
  // string region = 1 [json_name = "region"];
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.StorageConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Location& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationsFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kParentLocationIdFieldNumber = 4,
    kCreatedOnFieldNumber = 3,
    kAuthFieldNumber = 5,
    kConfigFieldNumber = 8,
    kPrimaryOrgIdentityFieldNumber = 9,
    kRobotCountFieldNumber = 7,
  };
  // repeated .viam.app.v1.LocationOrganization organizations = 6 [json_name = "organizations"];
  int organizations_size() const;
  private:
  int _internal_organizations_size() const;
  public:
  void clear_organizations();
  ::viam::app::v1::LocationOrganization* mutable_organizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >*
      mutable_organizations();
  private:
  const ::viam::app::v1::LocationOrganization& _internal_organizations(int index) const;
  ::viam::app::v1::LocationOrganization* _internal_add_organizations();
  public:
  const ::viam::app::v1::LocationOrganization& organizations(int index) const;
  ::viam::app::v1::LocationOrganization* add_organizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >&
      organizations() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string parent_location_id = 4 [json_name = "parentLocationId"];
  void clear_parent_location_id();
  const std::string& parent_location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_location_id();
  PROTOBUF_NODISCARD std::string* release_parent_location_id();
  void set_allocated_parent_location_id(std::string* parent_location_id);
  private:
  const std::string& _internal_parent_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_location_id(const std::string& value);
  std::string* _internal_mutable_parent_location_id();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .viam.app.v1.LocationAuth auth = 5 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // .viam.app.v1.StorageConfig config = 8 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::viam::app::v1::StorageConfig& config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::StorageConfig* release_config();
  ::viam::app::v1::StorageConfig* mutable_config();
  void set_allocated_config(::viam::app::v1::StorageConfig* config);
  private:
  const ::viam::app::v1::StorageConfig& _internal_config() const;
  ::viam::app::v1::StorageConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::viam::app::v1::StorageConfig* config);
  ::viam::app::v1::StorageConfig* unsafe_arena_release_config();

  // optional .viam.app.v1.OrganizationIdentity primary_org_identity = 9 [json_name = "primaryOrgIdentity"];
  bool has_primary_org_identity() const;
  private:
  bool _internal_has_primary_org_identity() const;
  public:
  void clear_primary_org_identity();
  const ::viam::app::v1::OrganizationIdentity& primary_org_identity() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OrganizationIdentity* release_primary_org_identity();
  ::viam::app::v1::OrganizationIdentity* mutable_primary_org_identity();
  void set_allocated_primary_org_identity(::viam::app::v1::OrganizationIdentity* primary_org_identity);
  private:
  const ::viam::app::v1::OrganizationIdentity& _internal_primary_org_identity() const;
  ::viam::app::v1::OrganizationIdentity* _internal_mutable_primary_org_identity();
  public:
  void unsafe_arena_set_allocated_primary_org_identity(
      ::viam::app::v1::OrganizationIdentity* primary_org_identity);
  ::viam::app::v1::OrganizationIdentity* unsafe_arena_release_primary_org_identity();

  // int32 robot_count = 7 [json_name = "robotCount"];
  void clear_robot_count();
  int32_t robot_count() const;
  void set_robot_count(int32_t value);
  private:
  int32_t _internal_robot_count() const;
  void _internal_set_robot_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization > organizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_location_id_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  ::viam::app::v1::LocationAuth* auth_;
  ::viam::app::v1::StorageConfig* config_;
  ::viam::app::v1::OrganizationIdentity* primary_org_identity_;
  int32_t robot_count_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class SharedSecret final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SharedSecret) */ {
 public:
  inline SharedSecret() : SharedSecret(nullptr) {}
  ~SharedSecret() override;
  explicit PROTOBUF_CONSTEXPR SharedSecret(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharedSecret(const SharedSecret& from);
  SharedSecret(SharedSecret&& from) noexcept
    : SharedSecret() {
    *this = ::std::move(from);
  }

  inline SharedSecret& operator=(const SharedSecret& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedSecret& operator=(SharedSecret&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SharedSecret& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedSecret* internal_default_instance() {
    return reinterpret_cast<const SharedSecret*>(
               &_SharedSecret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(SharedSecret& a, SharedSecret& b) {
    a.Swap(&b);
  }
  inline void Swap(SharedSecret* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedSecret* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedSecret* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharedSecret>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SharedSecret& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SharedSecret& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SharedSecret* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SharedSecret";
  }
  protected:
  explicit SharedSecret(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SharedSecret_State State;
  static constexpr State STATE_UNSPECIFIED =
    SharedSecret_State_STATE_UNSPECIFIED;
  static constexpr State STATE_ENABLED =
    SharedSecret_State_STATE_ENABLED;
  static constexpr State STATE_DISABLED =
    SharedSecret_State_STATE_DISABLED;
  static inline bool State_IsValid(int value) {
    return SharedSecret_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SharedSecret_State_State_MIN;
  static constexpr State State_MAX =
    SharedSecret_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SharedSecret_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SharedSecret_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SharedSecret_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SharedSecret_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSecretFieldNumber = 2,
    kCreatedOnFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"id\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string secret = 2 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\""];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .viam.app.v1.SharedSecret.State state = 4 [json_name = "state", (.tagger.v1.tags) = "bson:\"state\""];
  void clear_state();
  ::viam::app::v1::SharedSecret_State state() const;
  void set_state(::viam::app::v1::SharedSecret_State value);
  private:
  ::viam::app::v1::SharedSecret_State _internal_state() const;
  void _internal_set_state(::viam::app::v1::SharedSecret_State value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.SharedSecret)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationRequest) */ {
 public:
  inline CreateLocationRequest() : CreateLocationRequest(nullptr) {}
  ~CreateLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationRequest(const CreateLocationRequest& from);
  CreateLocationRequest(CreateLocationRequest&& from) noexcept
    : CreateLocationRequest() {
    *this = ::std::move(from);
  }

  inline CreateLocationRequest& operator=(const CreateLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationRequest& operator=(CreateLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateLocationRequest*>(
               &_CreateLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CreateLocationRequest& a, CreateLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationRequest";
  }
  protected:
  explicit CreateLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kParentLocationIdFieldNumber = 3,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string parent_location_id = 3 [json_name = "parentLocationId"];
  bool has_parent_location_id() const;
  private:
  bool _internal_has_parent_location_id() const;
  public:
  void clear_parent_location_id();
  const std::string& parent_location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_location_id();
  PROTOBUF_NODISCARD std::string* release_parent_location_id();
  void set_allocated_parent_location_id(std::string* parent_location_id);
  private:
  const std::string& _internal_parent_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_location_id(const std::string& value);
  std::string* _internal_mutable_parent_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_location_id_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationResponse) */ {
 public:
  inline CreateLocationResponse() : CreateLocationResponse(nullptr) {}
  ~CreateLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationResponse(const CreateLocationResponse& from);
  CreateLocationResponse(CreateLocationResponse&& from) noexcept
    : CreateLocationResponse() {
    *this = ::std::move(from);
  }

  inline CreateLocationResponse& operator=(const CreateLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationResponse& operator=(CreateLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateLocationResponse*>(
               &_CreateLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CreateLocationResponse& a, CreateLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationResponse";
  }
  protected:
  explicit CreateLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // .viam.app.v1.Location location = 1 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::viam::app::v1::Location& location() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Location* release_location();
  ::viam::app::v1::Location* mutable_location();
  void set_allocated_location(::viam::app::v1::Location* location);
  private:
  const ::viam::app::v1::Location& _internal_location() const;
  ::viam::app::v1::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::viam::app::v1::Location* location);
  ::viam::app::v1::Location* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Location* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetLocationRequest) */ {
 public:
  inline GetLocationRequest() : GetLocationRequest(nullptr) {}
  ~GetLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocationRequest(const GetLocationRequest& from);
  GetLocationRequest(GetLocationRequest&& from) noexcept
    : GetLocationRequest() {
    *this = ::std::move(from);
  }

  inline GetLocationRequest& operator=(const GetLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocationRequest& operator=(GetLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocationRequest* internal_default_instance() {
    return reinterpret_cast<const GetLocationRequest*>(
               &_GetLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(GetLocationRequest& a, GetLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetLocationRequest";
  }
  protected:
  explicit GetLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetLocationResponse) */ {
 public:
  inline GetLocationResponse() : GetLocationResponse(nullptr) {}
  ~GetLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocationResponse(const GetLocationResponse& from);
  GetLocationResponse(GetLocationResponse&& from) noexcept
    : GetLocationResponse() {
    *this = ::std::move(from);
  }

  inline GetLocationResponse& operator=(const GetLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocationResponse& operator=(GetLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocationResponse* internal_default_instance() {
    return reinterpret_cast<const GetLocationResponse*>(
               &_GetLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(GetLocationResponse& a, GetLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetLocationResponse";
  }
  protected:
  explicit GetLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // .viam.app.v1.Location location = 1 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::viam::app::v1::Location& location() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Location* release_location();
  ::viam::app::v1::Location* mutable_location();
  void set_allocated_location(::viam::app::v1::Location* location);
  private:
  const ::viam::app::v1::Location& _internal_location() const;
  ::viam::app::v1::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::viam::app::v1::Location* location);
  ::viam::app::v1::Location* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Location* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateLocationRequest) */ {
 public:
  inline UpdateLocationRequest() : UpdateLocationRequest(nullptr) {}
  ~UpdateLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocationRequest(const UpdateLocationRequest& from);
  UpdateLocationRequest(UpdateLocationRequest&& from) noexcept
    : UpdateLocationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateLocationRequest& operator=(const UpdateLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocationRequest& operator=(UpdateLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateLocationRequest*>(
               &_UpdateLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(UpdateLocationRequest& a, UpdateLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateLocationRequest";
  }
  protected:
  explicit UpdateLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kParentLocationIdFieldNumber = 3,
    kRegionFieldNumber = 4,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string parent_location_id = 3 [json_name = "parentLocationId"];
  bool has_parent_location_id() const;
  private:
  bool _internal_has_parent_location_id() const;
  public:
  void clear_parent_location_id();
  const std::string& parent_location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_location_id();
  PROTOBUF_NODISCARD std::string* release_parent_location_id();
  void set_allocated_parent_location_id(std::string* parent_location_id);
  private:
  const std::string& _internal_parent_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_location_id(const std::string& value);
  std::string* _internal_mutable_parent_location_id();
  public:

  // optional string region = 4 [json_name = "region"];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateLocationResponse) */ {
 public:
  inline UpdateLocationResponse() : UpdateLocationResponse(nullptr) {}
  ~UpdateLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocationResponse(const UpdateLocationResponse& from);
  UpdateLocationResponse(UpdateLocationResponse&& from) noexcept
    : UpdateLocationResponse() {
    *this = ::std::move(from);
  }

  inline UpdateLocationResponse& operator=(const UpdateLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocationResponse& operator=(UpdateLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocationResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateLocationResponse*>(
               &_UpdateLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(UpdateLocationResponse& a, UpdateLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateLocationResponse";
  }
  protected:
  explicit UpdateLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // .viam.app.v1.Location location = 1 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::viam::app::v1::Location& location() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Location* release_location();
  ::viam::app::v1::Location* mutable_location();
  void set_allocated_location(::viam::app::v1::Location* location);
  private:
  const ::viam::app::v1::Location& _internal_location() const;
  ::viam::app::v1::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::viam::app::v1::Location* location);
  ::viam::app::v1::Location* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Location* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationRequest) */ {
 public:
  inline DeleteLocationRequest() : DeleteLocationRequest(nullptr) {}
  ~DeleteLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationRequest(const DeleteLocationRequest& from);
  DeleteLocationRequest(DeleteLocationRequest&& from) noexcept
    : DeleteLocationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteLocationRequest& operator=(const DeleteLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationRequest& operator=(DeleteLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationRequest*>(
               &_DeleteLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(DeleteLocationRequest& a, DeleteLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationRequest";
  }
  protected:
  explicit DeleteLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationResponse) */ {
 public:
  inline DeleteLocationResponse() : DeleteLocationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationResponse(const DeleteLocationResponse& from);
  DeleteLocationResponse(DeleteLocationResponse&& from) noexcept
    : DeleteLocationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteLocationResponse& operator=(const DeleteLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationResponse& operator=(DeleteLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationResponse*>(
               &_DeleteLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(DeleteLocationResponse& a, DeleteLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationResponse";
  }
  protected:
  explicit DeleteLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetLocationMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetLocationMetadataRequest) */ {
 public:
  inline GetLocationMetadataRequest() : GetLocationMetadataRequest(nullptr) {}
  ~GetLocationMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR GetLocationMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocationMetadataRequest(const GetLocationMetadataRequest& from);
  GetLocationMetadataRequest(GetLocationMetadataRequest&& from) noexcept
    : GetLocationMetadataRequest() {
    *this = ::std::move(from);
  }

  inline GetLocationMetadataRequest& operator=(const GetLocationMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocationMetadataRequest& operator=(GetLocationMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocationMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocationMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const GetLocationMetadataRequest*>(
               &_GetLocationMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(GetLocationMetadataRequest& a, GetLocationMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocationMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocationMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocationMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocationMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocationMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLocationMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocationMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetLocationMetadataRequest";
  }
  protected:
  explicit GetLocationMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetLocationMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetLocationMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetLocationMetadataResponse) */ {
 public:
  inline GetLocationMetadataResponse() : GetLocationMetadataResponse(nullptr) {}
  ~GetLocationMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR GetLocationMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocationMetadataResponse(const GetLocationMetadataResponse& from);
  GetLocationMetadataResponse(GetLocationMetadataResponse&& from) noexcept
    : GetLocationMetadataResponse() {
    *this = ::std::move(from);
  }

  inline GetLocationMetadataResponse& operator=(const GetLocationMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocationMetadataResponse& operator=(GetLocationMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocationMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocationMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const GetLocationMetadataResponse*>(
               &_GetLocationMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(GetLocationMetadataResponse& a, GetLocationMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocationMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocationMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocationMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocationMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocationMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLocationMetadataResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocationMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetLocationMetadataResponse";
  }
  protected:
  explicit GetLocationMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .google.protobuf.Struct data = 1 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetLocationMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocationMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateLocationMetadataRequest) */ {
 public:
  inline UpdateLocationMetadataRequest() : UpdateLocationMetadataRequest(nullptr) {}
  ~UpdateLocationMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocationMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocationMetadataRequest(const UpdateLocationMetadataRequest& from);
  UpdateLocationMetadataRequest(UpdateLocationMetadataRequest&& from) noexcept
    : UpdateLocationMetadataRequest() {
    *this = ::std::move(from);
  }

  inline UpdateLocationMetadataRequest& operator=(const UpdateLocationMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocationMetadataRequest& operator=(UpdateLocationMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocationMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocationMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateLocationMetadataRequest*>(
               &_UpdateLocationMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(UpdateLocationMetadataRequest& a, UpdateLocationMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocationMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocationMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocationMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocationMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocationMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateLocationMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocationMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateLocationMetadataRequest";
  }
  protected:
  explicit UpdateLocationMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // .google.protobuf.Struct data = 2 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateLocationMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocationMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateLocationMetadataResponse) */ {
 public:
  inline UpdateLocationMetadataResponse() : UpdateLocationMetadataResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateLocationMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocationMetadataResponse(const UpdateLocationMetadataResponse& from);
  UpdateLocationMetadataResponse(UpdateLocationMetadataResponse&& from) noexcept
    : UpdateLocationMetadataResponse() {
    *this = ::std::move(from);
  }

  inline UpdateLocationMetadataResponse& operator=(const UpdateLocationMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocationMetadataResponse& operator=(UpdateLocationMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocationMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocationMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateLocationMetadataResponse*>(
               &_UpdateLocationMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(UpdateLocationMetadataResponse& a, UpdateLocationMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocationMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocationMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocationMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocationMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateLocationMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateLocationMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateLocationMetadataResponse";
  }
  protected:
  explicit UpdateLocationMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateLocationMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationsWithAccessToLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationsWithAccessToLocationRequest) */ {
 public:
  inline GetOrganizationsWithAccessToLocationRequest() : GetOrganizationsWithAccessToLocationRequest(nullptr) {}
  ~GetOrganizationsWithAccessToLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationsWithAccessToLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationsWithAccessToLocationRequest(const GetOrganizationsWithAccessToLocationRequest& from);
  GetOrganizationsWithAccessToLocationRequest(GetOrganizationsWithAccessToLocationRequest&& from) noexcept
    : GetOrganizationsWithAccessToLocationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationsWithAccessToLocationRequest& operator=(const GetOrganizationsWithAccessToLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationsWithAccessToLocationRequest& operator=(GetOrganizationsWithAccessToLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationsWithAccessToLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationsWithAccessToLocationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationsWithAccessToLocationRequest*>(
               &_GetOrganizationsWithAccessToLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(GetOrganizationsWithAccessToLocationRequest& a, GetOrganizationsWithAccessToLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationsWithAccessToLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationsWithAccessToLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationsWithAccessToLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationsWithAccessToLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationsWithAccessToLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationsWithAccessToLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationsWithAccessToLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationsWithAccessToLocationRequest";
  }
  protected:
  explicit GetOrganizationsWithAccessToLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationsWithAccessToLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationsWithAccessToLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationsWithAccessToLocationResponse) */ {
 public:
  inline GetOrganizationsWithAccessToLocationResponse() : GetOrganizationsWithAccessToLocationResponse(nullptr) {}
  ~GetOrganizationsWithAccessToLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationsWithAccessToLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationsWithAccessToLocationResponse(const GetOrganizationsWithAccessToLocationResponse& from);
  GetOrganizationsWithAccessToLocationResponse(GetOrganizationsWithAccessToLocationResponse&& from) noexcept
    : GetOrganizationsWithAccessToLocationResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationsWithAccessToLocationResponse& operator=(const GetOrganizationsWithAccessToLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationsWithAccessToLocationResponse& operator=(GetOrganizationsWithAccessToLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationsWithAccessToLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationsWithAccessToLocationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationsWithAccessToLocationResponse*>(
               &_GetOrganizationsWithAccessToLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(GetOrganizationsWithAccessToLocationResponse& a, GetOrganizationsWithAccessToLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationsWithAccessToLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationsWithAccessToLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationsWithAccessToLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationsWithAccessToLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationsWithAccessToLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationsWithAccessToLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationsWithAccessToLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationsWithAccessToLocationResponse";
  }
  protected:
  explicit GetOrganizationsWithAccessToLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdentitiesFieldNumber = 1,
  };
  // repeated .viam.app.v1.OrganizationIdentity organization_identities = 1 [json_name = "organizationIdentities"];
  int organization_identities_size() const;
  private:
  int _internal_organization_identities_size() const;
  public:
  void clear_organization_identities();
  ::viam::app::v1::OrganizationIdentity* mutable_organization_identities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >*
      mutable_organization_identities();
  private:
  const ::viam::app::v1::OrganizationIdentity& _internal_organization_identities(int index) const;
  ::viam::app::v1::OrganizationIdentity* _internal_add_organization_identities();
  public:
  const ::viam::app::v1::OrganizationIdentity& organization_identities(int index) const;
  ::viam::app::v1::OrganizationIdentity* add_organization_identities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >&
      organization_identities() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationsWithAccessToLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity > organization_identities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListLocationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListLocationsRequest) */ {
 public:
  inline ListLocationsRequest() : ListLocationsRequest(nullptr) {}
  ~ListLocationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListLocationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocationsRequest(const ListLocationsRequest& from);
  ListLocationsRequest(ListLocationsRequest&& from) noexcept
    : ListLocationsRequest() {
    *this = ::std::move(from);
  }

  inline ListLocationsRequest& operator=(const ListLocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocationsRequest& operator=(ListLocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListLocationsRequest*>(
               &_ListLocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ListLocationsRequest& a, ListLocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListLocationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListLocationsRequest";
  }
  protected:
  explicit ListLocationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListLocationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ShareLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ShareLocationRequest) */ {
 public:
  inline ShareLocationRequest() : ShareLocationRequest(nullptr) {}
  ~ShareLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR ShareLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareLocationRequest(const ShareLocationRequest& from);
  ShareLocationRequest(ShareLocationRequest&& from) noexcept
    : ShareLocationRequest() {
    *this = ::std::move(from);
  }

  inline ShareLocationRequest& operator=(const ShareLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareLocationRequest& operator=(ShareLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareLocationRequest* internal_default_instance() {
    return reinterpret_cast<const ShareLocationRequest*>(
               &_ShareLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ShareLocationRequest& a, ShareLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShareLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ShareLocationRequest";
  }
  protected:
  explicit ShareLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ShareLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ShareLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.ShareLocationResponse) */ {
 public:
  inline ShareLocationResponse() : ShareLocationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShareLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareLocationResponse(const ShareLocationResponse& from);
  ShareLocationResponse(ShareLocationResponse&& from) noexcept
    : ShareLocationResponse() {
    *this = ::std::move(from);
  }

  inline ShareLocationResponse& operator=(const ShareLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareLocationResponse& operator=(ShareLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareLocationResponse* internal_default_instance() {
    return reinterpret_cast<const ShareLocationResponse*>(
               &_ShareLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ShareLocationResponse& a, ShareLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ShareLocationResponse";
  }
  protected:
  explicit ShareLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.ShareLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UnshareLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UnshareLocationRequest) */ {
 public:
  inline UnshareLocationRequest() : UnshareLocationRequest(nullptr) {}
  ~UnshareLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR UnshareLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnshareLocationRequest(const UnshareLocationRequest& from);
  UnshareLocationRequest(UnshareLocationRequest&& from) noexcept
    : UnshareLocationRequest() {
    *this = ::std::move(from);
  }

  inline UnshareLocationRequest& operator=(const UnshareLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnshareLocationRequest& operator=(UnshareLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnshareLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnshareLocationRequest* internal_default_instance() {
    return reinterpret_cast<const UnshareLocationRequest*>(
               &_UnshareLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(UnshareLocationRequest& a, UnshareLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnshareLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnshareLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnshareLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnshareLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnshareLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnshareLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnshareLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UnshareLocationRequest";
  }
  protected:
  explicit UnshareLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UnshareLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UnshareLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UnshareLocationResponse) */ {
 public:
  inline UnshareLocationResponse() : UnshareLocationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UnshareLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnshareLocationResponse(const UnshareLocationResponse& from);
  UnshareLocationResponse(UnshareLocationResponse&& from) noexcept
    : UnshareLocationResponse() {
    *this = ::std::move(from);
  }

  inline UnshareLocationResponse& operator=(const UnshareLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnshareLocationResponse& operator=(UnshareLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnshareLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnshareLocationResponse* internal_default_instance() {
    return reinterpret_cast<const UnshareLocationResponse*>(
               &_UnshareLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(UnshareLocationResponse& a, UnshareLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnshareLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnshareLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnshareLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnshareLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UnshareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UnshareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UnshareLocationResponse";
  }
  protected:
  explicit UnshareLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UnshareLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListLocationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListLocationsResponse) */ {
 public:
  inline ListLocationsResponse() : ListLocationsResponse(nullptr) {}
  ~ListLocationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListLocationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocationsResponse(const ListLocationsResponse& from);
  ListLocationsResponse(ListLocationsResponse&& from) noexcept
    : ListLocationsResponse() {
    *this = ::std::move(from);
  }

  inline ListLocationsResponse& operator=(const ListLocationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocationsResponse& operator=(ListLocationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListLocationsResponse*>(
               &_ListLocationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ListLocationsResponse& a, ListLocationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListLocationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListLocationsResponse";
  }
  protected:
  explicit ListLocationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Location locations = 1 [json_name = "locations"];
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  ::viam::app::v1::Location* mutable_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >*
      mutable_locations();
  private:
  const ::viam::app::v1::Location& _internal_locations(int index) const;
  ::viam::app::v1::Location* _internal_add_locations();
  public:
  const ::viam::app::v1::Location& locations(int index) const;
  ::viam::app::v1::Location* add_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >&
      locations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListLocationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location > locations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationSecretRequest) */ {
 public:
  inline CreateLocationSecretRequest() : CreateLocationSecretRequest(nullptr) {}
  ~CreateLocationSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationSecretRequest(const CreateLocationSecretRequest& from);
  CreateLocationSecretRequest(CreateLocationSecretRequest&& from) noexcept
    : CreateLocationSecretRequest() {
    *this = ::std::move(from);
  }

  inline CreateLocationSecretRequest& operator=(const CreateLocationSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationSecretRequest& operator=(CreateLocationSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationSecretRequest* internal_default_instance() {
    return reinterpret_cast<const CreateLocationSecretRequest*>(
               &_CreateLocationSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(CreateLocationSecretRequest& a, CreateLocationSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationSecretRequest";
  }
  protected:
  explicit CreateLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationSecretResponse) */ {
 public:
  inline CreateLocationSecretResponse() : CreateLocationSecretResponse(nullptr) {}
  ~CreateLocationSecretResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationSecretResponse(const CreateLocationSecretResponse& from);
  CreateLocationSecretResponse(CreateLocationSecretResponse&& from) noexcept
    : CreateLocationSecretResponse() {
    *this = ::std::move(from);
  }

  inline CreateLocationSecretResponse& operator=(const CreateLocationSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationSecretResponse& operator=(CreateLocationSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationSecretResponse* internal_default_instance() {
    return reinterpret_cast<const CreateLocationSecretResponse*>(
               &_CreateLocationSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(CreateLocationSecretResponse& a, CreateLocationSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationSecretResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationSecretResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationSecretResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationSecretResponse";
  }
  protected:
  explicit CreateLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
  };
  // .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::LocationAuth* auth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationSecretRequest) */ {
 public:
  inline DeleteLocationSecretRequest() : DeleteLocationSecretRequest(nullptr) {}
  ~DeleteLocationSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationSecretRequest(const DeleteLocationSecretRequest& from);
  DeleteLocationSecretRequest(DeleteLocationSecretRequest&& from) noexcept
    : DeleteLocationSecretRequest() {
    *this = ::std::move(from);
  }

  inline DeleteLocationSecretRequest& operator=(const DeleteLocationSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationSecretRequest& operator=(DeleteLocationSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationSecretRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationSecretRequest*>(
               &_DeleteLocationSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(DeleteLocationSecretRequest& a, DeleteLocationSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteLocationSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteLocationSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteLocationSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationSecretRequest";
  }
  protected:
  explicit DeleteLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kSecretIdFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string secret_id = 2 [json_name = "secretId"];
  void clear_secret_id();
  const std::string& secret_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* secret_id);
  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(const std::string& value);
  std::string* _internal_mutable_secret_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationSecretResponse) */ {
 public:
  inline DeleteLocationSecretResponse() : DeleteLocationSecretResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationSecretResponse(const DeleteLocationSecretResponse& from);
  DeleteLocationSecretResponse(DeleteLocationSecretResponse&& from) noexcept
    : DeleteLocationSecretResponse() {
    *this = ::std::move(from);
  }

  inline DeleteLocationSecretResponse& operator=(const DeleteLocationSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationSecretResponse& operator=(DeleteLocationSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationSecretResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationSecretResponse*>(
               &_DeleteLocationSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(DeleteLocationSecretResponse& a, DeleteLocationSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteLocationSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteLocationSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationSecretResponse";
  }
  protected:
  explicit DeleteLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuthRequest) */ {
 public:
  inline LocationAuthRequest() : LocationAuthRequest(nullptr) {}
  ~LocationAuthRequest() override;
  explicit PROTOBUF_CONSTEXPR LocationAuthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuthRequest(const LocationAuthRequest& from);
  LocationAuthRequest(LocationAuthRequest&& from) noexcept
    : LocationAuthRequest() {
    *this = ::std::move(from);
  }

  inline LocationAuthRequest& operator=(const LocationAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuthRequest& operator=(LocationAuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuthRequest* internal_default_instance() {
    return reinterpret_cast<const LocationAuthRequest*>(
               &_LocationAuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(LocationAuthRequest& a, LocationAuthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuthRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationAuthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuthRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuthRequest";
  }
  protected:
  explicit LocationAuthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuthResponse) */ {
 public:
  inline LocationAuthResponse() : LocationAuthResponse(nullptr) {}
  ~LocationAuthResponse() override;
  explicit PROTOBUF_CONSTEXPR LocationAuthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuthResponse(const LocationAuthResponse& from);
  LocationAuthResponse(LocationAuthResponse&& from) noexcept
    : LocationAuthResponse() {
    *this = ::std::move(from);
  }

  inline LocationAuthResponse& operator=(const LocationAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuthResponse& operator=(LocationAuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuthResponse* internal_default_instance() {
    return reinterpret_cast<const LocationAuthResponse*>(
               &_LocationAuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(LocationAuthResponse& a, LocationAuthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationAuthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuthResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuthResponse";
  }
  protected:
  explicit LocationAuthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
  };
  // .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::LocationAuth* auth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotRequest) */ {
 public:
  inline GetRobotRequest() : GetRobotRequest(nullptr) {}
  ~GetRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotRequest(const GetRobotRequest& from);
  GetRobotRequest(GetRobotRequest&& from) noexcept
    : GetRobotRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotRequest& operator=(const GetRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotRequest& operator=(GetRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotRequest*>(
               &_GetRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(GetRobotRequest& a, GetRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotRequest";
  }
  protected:
  explicit GetRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRoverRentalRobotsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRoverRentalRobotsRequest) */ {
 public:
  inline GetRoverRentalRobotsRequest() : GetRoverRentalRobotsRequest(nullptr) {}
  ~GetRoverRentalRobotsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRoverRentalRobotsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoverRentalRobotsRequest(const GetRoverRentalRobotsRequest& from);
  GetRoverRentalRobotsRequest(GetRoverRentalRobotsRequest&& from) noexcept
    : GetRoverRentalRobotsRequest() {
    *this = ::std::move(from);
  }

  inline GetRoverRentalRobotsRequest& operator=(const GetRoverRentalRobotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoverRentalRobotsRequest& operator=(GetRoverRentalRobotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoverRentalRobotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoverRentalRobotsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRoverRentalRobotsRequest*>(
               &_GetRoverRentalRobotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(GetRoverRentalRobotsRequest& a, GetRoverRentalRobotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoverRentalRobotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoverRentalRobotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoverRentalRobotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoverRentalRobotsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoverRentalRobotsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRoverRentalRobotsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoverRentalRobotsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRoverRentalRobotsRequest";
  }
  protected:
  explicit GetRoverRentalRobotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRoverRentalRobotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RoverRentalRobot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RoverRentalRobot) */ {
 public:
  inline RoverRentalRobot() : RoverRentalRobot(nullptr) {}
  ~RoverRentalRobot() override;
  explicit PROTOBUF_CONSTEXPR RoverRentalRobot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoverRentalRobot(const RoverRentalRobot& from);
  RoverRentalRobot(RoverRentalRobot&& from) noexcept
    : RoverRentalRobot() {
    *this = ::std::move(from);
  }

  inline RoverRentalRobot& operator=(const RoverRentalRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoverRentalRobot& operator=(RoverRentalRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoverRentalRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoverRentalRobot* internal_default_instance() {
    return reinterpret_cast<const RoverRentalRobot*>(
               &_RoverRentalRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(RoverRentalRobot& a, RoverRentalRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(RoverRentalRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoverRentalRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoverRentalRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoverRentalRobot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoverRentalRobot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoverRentalRobot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoverRentalRobot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RoverRentalRobot";
  }
  protected:
  explicit RoverRentalRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
    kLocationIdFieldNumber = 2,
    kRobotNameFieldNumber = 3,
    kRobotMainPartIdFieldNumber = 4,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string location_id = 2 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string robot_name = 3 [json_name = "robotName"];
  void clear_robot_name();
  const std::string& robot_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_name();
  PROTOBUF_NODISCARD std::string* release_robot_name();
  void set_allocated_robot_name(std::string* robot_name);
  private:
  const std::string& _internal_robot_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_name(const std::string& value);
  std::string* _internal_mutable_robot_name();
  public:

  // string robot_main_part_id = 4 [json_name = "robotMainPartId"];
  void clear_robot_main_part_id();
  const std::string& robot_main_part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_main_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_main_part_id();
  PROTOBUF_NODISCARD std::string* release_robot_main_part_id();
  void set_allocated_robot_main_part_id(std::string* robot_main_part_id);
  private:
  const std::string& _internal_robot_main_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_main_part_id(const std::string& value);
  std::string* _internal_mutable_robot_main_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RoverRentalRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_main_part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRoverRentalRobotsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRoverRentalRobotsResponse) */ {
 public:
  inline GetRoverRentalRobotsResponse() : GetRoverRentalRobotsResponse(nullptr) {}
  ~GetRoverRentalRobotsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRoverRentalRobotsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoverRentalRobotsResponse(const GetRoverRentalRobotsResponse& from);
  GetRoverRentalRobotsResponse(GetRoverRentalRobotsResponse&& from) noexcept
    : GetRoverRentalRobotsResponse() {
    *this = ::std::move(from);
  }

  inline GetRoverRentalRobotsResponse& operator=(const GetRoverRentalRobotsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoverRentalRobotsResponse& operator=(GetRoverRentalRobotsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoverRentalRobotsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoverRentalRobotsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRoverRentalRobotsResponse*>(
               &_GetRoverRentalRobotsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(GetRoverRentalRobotsResponse& a, GetRoverRentalRobotsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoverRentalRobotsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoverRentalRobotsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoverRentalRobotsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoverRentalRobotsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoverRentalRobotsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRoverRentalRobotsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoverRentalRobotsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRoverRentalRobotsResponse";
  }
  protected:
  explicit GetRoverRentalRobotsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
  };
  // repeated .viam.app.v1.RoverRentalRobot robots = 1 [json_name = "robots"];
  int robots_size() const;
  private:
  int _internal_robots_size() const;
  public:
  void clear_robots();
  ::viam::app::v1::RoverRentalRobot* mutable_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >*
      mutable_robots();
  private:
  const ::viam::app::v1::RoverRentalRobot& _internal_robots(int index) const;
  ::viam::app::v1::RoverRentalRobot* _internal_add_robots();
  public:
  const ::viam::app::v1::RoverRentalRobot& robots(int index) const;
  ::viam::app::v1::RoverRentalRobot* add_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >&
      robots() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRoverRentalRobotsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot > robots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotResponse) */ {
 public:
  inline GetRobotResponse() : GetRobotResponse(nullptr) {}
  ~GetRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotResponse(const GetRobotResponse& from);
  GetRobotResponse(GetRobotResponse&& from) noexcept
    : GetRobotResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotResponse& operator=(const GetRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotResponse& operator=(GetRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotResponse*>(
               &_GetRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(GetRobotResponse& a, GetRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotResponse";
  }
  protected:
  explicit GetRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // .viam.app.v1.Robot robot = 1 [json_name = "robot"];
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::viam::app::v1::Robot& robot() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Robot* release_robot();
  ::viam::app::v1::Robot* mutable_robot();
  void set_allocated_robot(::viam::app::v1::Robot* robot);
  private:
  const ::viam::app::v1::Robot& _internal_robot() const;
  ::viam::app::v1::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::viam::app::v1::Robot* robot);
  ::viam::app::v1::Robot* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Robot* robot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartsRequest) */ {
 public:
  inline GetRobotPartsRequest() : GetRobotPartsRequest(nullptr) {}
  ~GetRobotPartsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartsRequest(const GetRobotPartsRequest& from);
  GetRobotPartsRequest(GetRobotPartsRequest&& from) noexcept
    : GetRobotPartsRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartsRequest& operator=(const GetRobotPartsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartsRequest& operator=(GetRobotPartsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartsRequest*>(
               &_GetRobotPartsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(GetRobotPartsRequest& a, GetRobotPartsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartsRequest";
  }
  protected:
  explicit GetRobotPartsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartsResponse) */ {
 public:
  inline GetRobotPartsResponse() : GetRobotPartsResponse(nullptr) {}
  ~GetRobotPartsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartsResponse(const GetRobotPartsResponse& from);
  GetRobotPartsResponse(GetRobotPartsResponse&& from) noexcept
    : GetRobotPartsResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartsResponse& operator=(const GetRobotPartsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartsResponse& operator=(GetRobotPartsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartsResponse*>(
               &_GetRobotPartsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(GetRobotPartsResponse& a, GetRobotPartsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartsResponse";
  }
  protected:
  explicit GetRobotPartsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 1,
  };
  // repeated .viam.app.v1.RobotPart parts = 1 [json_name = "parts"];
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::viam::app::v1::RobotPart* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >*
      mutable_parts();
  private:
  const ::viam::app::v1::RobotPart& _internal_parts(int index) const;
  ::viam::app::v1::RobotPart* _internal_add_parts();
  public:
  const ::viam::app::v1::RobotPart& parts(int index) const;
  ::viam::app::v1::RobotPart* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >&
      parts() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart > parts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartRequest) */ {
 public:
  inline GetRobotPartRequest() : GetRobotPartRequest(nullptr) {}
  ~GetRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartRequest(const GetRobotPartRequest& from);
  GetRobotPartRequest(GetRobotPartRequest&& from) noexcept
    : GetRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartRequest& operator=(const GetRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartRequest& operator=(GetRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartRequest*>(
               &_GetRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(GetRobotPartRequest& a, GetRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartRequest";
  }
  protected:
  explicit GetRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartResponse) */ {
 public:
  inline GetRobotPartResponse() : GetRobotPartResponse(nullptr) {}
  ~GetRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartResponse(const GetRobotPartResponse& from);
  GetRobotPartResponse(GetRobotPartResponse&& from) noexcept
    : GetRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartResponse& operator=(const GetRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartResponse& operator=(GetRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartResponse*>(
               &_GetRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(GetRobotPartResponse& a, GetRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartResponse";
  }
  protected:
  explicit GetRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigJsonFieldNumber = 2,
    kPartFieldNumber = 1,
  };
  // string config_json = 2 [json_name = "configJson"];
  void clear_config_json();
  const std::string& config_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_json();
  PROTOBUF_NODISCARD std::string* release_config_json();
  void set_allocated_config_json(std::string* config_json);
  private:
  const std::string& _internal_config_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_json(const std::string& value);
  std::string* _internal_mutable_config_json();
  public:

  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_json_;
  ::viam::app::v1::RobotPart* part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartByNameAndLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartByNameAndLocationRequest) */ {
 public:
  inline GetRobotPartByNameAndLocationRequest() : GetRobotPartByNameAndLocationRequest(nullptr) {}
  ~GetRobotPartByNameAndLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartByNameAndLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartByNameAndLocationRequest(const GetRobotPartByNameAndLocationRequest& from);
  GetRobotPartByNameAndLocationRequest(GetRobotPartByNameAndLocationRequest&& from) noexcept
    : GetRobotPartByNameAndLocationRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartByNameAndLocationRequest& operator=(const GetRobotPartByNameAndLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartByNameAndLocationRequest& operator=(GetRobotPartByNameAndLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartByNameAndLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartByNameAndLocationRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartByNameAndLocationRequest*>(
               &_GetRobotPartByNameAndLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(GetRobotPartByNameAndLocationRequest& a, GetRobotPartByNameAndLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartByNameAndLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartByNameAndLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartByNameAndLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartByNameAndLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartByNameAndLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartByNameAndLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartByNameAndLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartByNameAndLocationRequest";
  }
  protected:
  explicit GetRobotPartByNameAndLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationIdFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location_id = 2 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartByNameAndLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartByNameAndLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartByNameAndLocationResponse) */ {
 public:
  inline GetRobotPartByNameAndLocationResponse() : GetRobotPartByNameAndLocationResponse(nullptr) {}
  ~GetRobotPartByNameAndLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartByNameAndLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartByNameAndLocationResponse(const GetRobotPartByNameAndLocationResponse& from);
  GetRobotPartByNameAndLocationResponse(GetRobotPartByNameAndLocationResponse&& from) noexcept
    : GetRobotPartByNameAndLocationResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartByNameAndLocationResponse& operator=(const GetRobotPartByNameAndLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartByNameAndLocationResponse& operator=(GetRobotPartByNameAndLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartByNameAndLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartByNameAndLocationResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartByNameAndLocationResponse*>(
               &_GetRobotPartByNameAndLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(GetRobotPartByNameAndLocationResponse& a, GetRobotPartByNameAndLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartByNameAndLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartByNameAndLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartByNameAndLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartByNameAndLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartByNameAndLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartByNameAndLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartByNameAndLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartByNameAndLocationResponse";
  }
  protected:
  explicit GetRobotPartByNameAndLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartByNameAndLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RobotPart* part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartLogsRequest) */ {
 public:
  inline GetRobotPartLogsRequest() : GetRobotPartLogsRequest(nullptr) {}
  ~GetRobotPartLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartLogsRequest(const GetRobotPartLogsRequest& from);
  GetRobotPartLogsRequest(GetRobotPartLogsRequest&& from) noexcept
    : GetRobotPartLogsRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartLogsRequest& operator=(const GetRobotPartLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartLogsRequest& operator=(GetRobotPartLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartLogsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartLogsRequest*>(
               &_GetRobotPartLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(GetRobotPartLogsRequest& a, GetRobotPartLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartLogsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartLogsRequest";
  }
  protected:
  explicit GetRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelsFieldNumber = 5,
    kIdFieldNumber = 1,
    kFilterFieldNumber = 3,
    kPageTokenFieldNumber = 4,
    kSourceFieldNumber = 9,
    kStartFieldNumber = 6,
    kEndFieldNumber = 7,
    kLimitFieldNumber = 8,
    kErrorsOnlyFieldNumber = 2,
    kUserFacingOnlyFieldNumber = 10,
  };
  // repeated string levels = 5 [json_name = "levels"];
  int levels_size() const;
  private:
  int _internal_levels_size() const;
  public:
  void clear_levels();
  const std::string& levels(int index) const;
  std::string* mutable_levels(int index);
  void set_levels(int index, const std::string& value);
  void set_levels(int index, std::string&& value);
  void set_levels(int index, const char* value);
  void set_levels(int index, const char* value, size_t size);
  std::string* add_levels();
  void add_levels(const std::string& value);
  void add_levels(std::string&& value);
  void add_levels(const char* value);
  void add_levels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& levels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_levels();
  private:
  const std::string& _internal_levels(int index) const;
  std::string* _internal_add_levels();
  public:

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string filter = 3 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // optional string page_token = 4 [json_name = "pageToken"];
  bool has_page_token() const;
  private:
  bool _internal_has_page_token() const;
  public:
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // optional string source = 9 [json_name = "source"];
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // optional .google.protobuf.Timestamp start = 6 [json_name = "start"];
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start();
  void set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start();

  // optional .google.protobuf.Timestamp end = 7 [json_name = "end"];
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end();
  void set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end();

  // optional int64 limit = 8 [json_name = "limit"];
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // bool errors_only = 2 [json_name = "errorsOnly", deprecated = true];
  PROTOBUF_DEPRECATED void clear_errors_only();
  PROTOBUF_DEPRECATED bool errors_only() const;
  PROTOBUF_DEPRECATED void set_errors_only(bool value);
  private:
  bool _internal_errors_only() const;
  void _internal_set_errors_only(bool value);
  public:

  // optional bool user_facing_only = 10 [json_name = "userFacingOnly"];
  bool has_user_facing_only() const;
  private:
  bool _internal_has_user_facing_only() const;
  public:
  void clear_user_facing_only();
  bool user_facing_only() const;
  void set_user_facing_only(bool value);
  private:
  bool _internal_user_facing_only() const;
  void _internal_set_user_facing_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> levels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* start_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* end_;
  int64_t limit_;
  bool errors_only_;
  bool user_facing_only_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartLogsResponse) */ {
 public:
  inline GetRobotPartLogsResponse() : GetRobotPartLogsResponse(nullptr) {}
  ~GetRobotPartLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartLogsResponse(const GetRobotPartLogsResponse& from);
  GetRobotPartLogsResponse(GetRobotPartLogsResponse&& from) noexcept
    : GetRobotPartLogsResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartLogsResponse& operator=(const GetRobotPartLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartLogsResponse& operator=(GetRobotPartLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartLogsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartLogsResponse*>(
               &_GetRobotPartLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(GetRobotPartLogsResponse& a, GetRobotPartLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartLogsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartLogsResponse";
  }
  protected:
  explicit GetRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::common::v1::LogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
      mutable_logs();
  private:
  const ::viam::common::v1::LogEntry& _internal_logs(int index) const;
  ::viam::common::v1::LogEntry* _internal_add_logs();
  public:
  const ::viam::common::v1::LogEntry& logs(int index) const;
  ::viam::common::v1::LogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
      logs() const;

  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry > logs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TailRobotPartLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TailRobotPartLogsRequest) */ {
 public:
  inline TailRobotPartLogsRequest() : TailRobotPartLogsRequest(nullptr) {}
  ~TailRobotPartLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR TailRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailRobotPartLogsRequest(const TailRobotPartLogsRequest& from);
  TailRobotPartLogsRequest(TailRobotPartLogsRequest&& from) noexcept
    : TailRobotPartLogsRequest() {
    *this = ::std::move(from);
  }

  inline TailRobotPartLogsRequest& operator=(const TailRobotPartLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailRobotPartLogsRequest& operator=(TailRobotPartLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailRobotPartLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailRobotPartLogsRequest* internal_default_instance() {
    return reinterpret_cast<const TailRobotPartLogsRequest*>(
               &_TailRobotPartLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(TailRobotPartLogsRequest& a, TailRobotPartLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TailRobotPartLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailRobotPartLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailRobotPartLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailRobotPartLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailRobotPartLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TailRobotPartLogsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailRobotPartLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TailRobotPartLogsRequest";
  }
  protected:
  explicit TailRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kFilterFieldNumber = 3,
    kErrorsOnlyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string filter = 3 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // bool errors_only = 2 [json_name = "errorsOnly"];
  void clear_errors_only();
  bool errors_only() const;
  void set_errors_only(bool value);
  private:
  bool _internal_errors_only() const;
  void _internal_set_errors_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.TailRobotPartLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  bool errors_only_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TailRobotPartLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TailRobotPartLogsResponse) */ {
 public:
  inline TailRobotPartLogsResponse() : TailRobotPartLogsResponse(nullptr) {}
  ~TailRobotPartLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR TailRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailRobotPartLogsResponse(const TailRobotPartLogsResponse& from);
  TailRobotPartLogsResponse(TailRobotPartLogsResponse&& from) noexcept
    : TailRobotPartLogsResponse() {
    *this = ::std::move(from);
  }

  inline TailRobotPartLogsResponse& operator=(const TailRobotPartLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailRobotPartLogsResponse& operator=(TailRobotPartLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailRobotPartLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailRobotPartLogsResponse* internal_default_instance() {
    return reinterpret_cast<const TailRobotPartLogsResponse*>(
               &_TailRobotPartLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(TailRobotPartLogsResponse& a, TailRobotPartLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TailRobotPartLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailRobotPartLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailRobotPartLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailRobotPartLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailRobotPartLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TailRobotPartLogsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailRobotPartLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TailRobotPartLogsResponse";
  }
  protected:
  explicit TailRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
  };
  // repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::common::v1::LogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
      mutable_logs();
  private:
  const ::viam::common::v1::LogEntry& _internal_logs(int index) const;
  ::viam::common::v1::LogEntry* _internal_add_logs();
  public:
  const ::viam::common::v1::LogEntry& logs(int index) const;
  ::viam::common::v1::LogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
      logs() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.TailRobotPartLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry > logs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartHistoryRequest) */ {
 public:
  inline GetRobotPartHistoryRequest() : GetRobotPartHistoryRequest(nullptr) {}
  ~GetRobotPartHistoryRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartHistoryRequest(const GetRobotPartHistoryRequest& from);
  GetRobotPartHistoryRequest(GetRobotPartHistoryRequest&& from) noexcept
    : GetRobotPartHistoryRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartHistoryRequest& operator=(const GetRobotPartHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartHistoryRequest& operator=(GetRobotPartHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartHistoryRequest*>(
               &_GetRobotPartHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(GetRobotPartHistoryRequest& a, GetRobotPartHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartHistoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartHistoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartHistoryRequest";
  }
  protected:
  explicit GetRobotPartHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartHistoryResponse) */ {
 public:
  inline GetRobotPartHistoryResponse() : GetRobotPartHistoryResponse(nullptr) {}
  ~GetRobotPartHistoryResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartHistoryResponse(const GetRobotPartHistoryResponse& from);
  GetRobotPartHistoryResponse(GetRobotPartHistoryResponse&& from) noexcept
    : GetRobotPartHistoryResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartHistoryResponse& operator=(const GetRobotPartHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartHistoryResponse& operator=(GetRobotPartHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartHistoryResponse*>(
               &_GetRobotPartHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(GetRobotPartHistoryResponse& a, GetRobotPartHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartHistoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartHistoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartHistoryResponse";
  }
  protected:
  explicit GetRobotPartHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
  };
  // repeated .viam.app.v1.RobotPartHistoryEntry history = 1 [json_name = "history"];
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::viam::app::v1::RobotPartHistoryEntry* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >*
      mutable_history();
  private:
  const ::viam::app::v1::RobotPartHistoryEntry& _internal_history(int index) const;
  ::viam::app::v1::RobotPartHistoryEntry* _internal_add_history();
  public:
  const ::viam::app::v1::RobotPartHistoryEntry& history(int index) const;
  ::viam::app::v1::RobotPartHistoryEntry* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >&
      history() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry > history_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartRequest) */ {
 public:
  inline UpdateRobotPartRequest() : UpdateRobotPartRequest(nullptr) {}
  ~UpdateRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartRequest(const UpdateRobotPartRequest& from);
  UpdateRobotPartRequest(UpdateRobotPartRequest&& from) noexcept
    : UpdateRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartRequest& operator=(const UpdateRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartRequest& operator=(UpdateRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartRequest*>(
               &_UpdateRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(UpdateRobotPartRequest& a, UpdateRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartRequest";
  }
  protected:
  explicit UpdateRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kRobotConfigFieldNumber = 3,
    kLastKnownUpdateFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct robot_config = 3 [json_name = "robotConfig"];
  bool has_robot_config() const;
  private:
  bool _internal_has_robot_config() const;
  public:
  void clear_robot_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& robot_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_robot_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_robot_config();
  void set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_robot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_robot_config();
  public:
  void unsafe_arena_set_allocated_robot_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_robot_config();

  // optional .google.protobuf.Timestamp last_known_update = 4 [json_name = "lastKnownUpdate"];
  bool has_last_known_update() const;
  private:
  bool _internal_has_last_known_update() const;
  public:
  void clear_last_known_update();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_known_update() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_known_update();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_known_update();
  void set_allocated_last_known_update(::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_known_update() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_known_update();
  public:
  void unsafe_arena_set_allocated_last_known_update(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_known_update();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* robot_config_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartResponse) */ {
 public:
  inline UpdateRobotPartResponse() : UpdateRobotPartResponse(nullptr) {}
  ~UpdateRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartResponse(const UpdateRobotPartResponse& from);
  UpdateRobotPartResponse(UpdateRobotPartResponse&& from) noexcept
    : UpdateRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartResponse& operator=(const UpdateRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartResponse& operator=(UpdateRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartResponse*>(
               &_UpdateRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(UpdateRobotPartResponse& a, UpdateRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotPartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartResponse";
  }
  protected:
  explicit UpdateRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RobotPart* part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotPartRequest) */ {
 public:
  inline NewRobotPartRequest() : NewRobotPartRequest(nullptr) {}
  ~NewRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR NewRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotPartRequest(const NewRobotPartRequest& from);
  NewRobotPartRequest(NewRobotPartRequest&& from) noexcept
    : NewRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline NewRobotPartRequest& operator=(const NewRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotPartRequest& operator=(NewRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const NewRobotPartRequest*>(
               &_NewRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(NewRobotPartRequest& a, NewRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotPartRequest";
  }
  protected:
  explicit NewRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
    kPartNameFieldNumber = 2,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string part_name = 2 [json_name = "partName"];
  void clear_part_name();
  const std::string& part_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_name();
  PROTOBUF_NODISCARD std::string* release_part_name();
  void set_allocated_part_name(std::string* part_name);
  private:
  const std::string& _internal_part_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_name(const std::string& value);
  std::string* _internal_mutable_part_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotPartResponse) */ {
 public:
  inline NewRobotPartResponse() : NewRobotPartResponse(nullptr) {}
  ~NewRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR NewRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotPartResponse(const NewRobotPartResponse& from);
  NewRobotPartResponse(NewRobotPartResponse&& from) noexcept
    : NewRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline NewRobotPartResponse& operator=(const NewRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotPartResponse& operator=(NewRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const NewRobotPartResponse*>(
               &_NewRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(NewRobotPartResponse& a, NewRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotPartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotPartResponse";
  }
  protected:
  explicit NewRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartRequest) */ {
 public:
  inline DeleteRobotPartRequest() : DeleteRobotPartRequest(nullptr) {}
  ~DeleteRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartRequest(const DeleteRobotPartRequest& from);
  DeleteRobotPartRequest(DeleteRobotPartRequest&& from) noexcept
    : DeleteRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartRequest& operator=(const DeleteRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartRequest& operator=(DeleteRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartRequest*>(
               &_DeleteRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(DeleteRobotPartRequest& a, DeleteRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartRequest";
  }
  protected:
  explicit DeleteRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartMetadataRequest) */ {
 public:
  inline GetRobotPartMetadataRequest() : GetRobotPartMetadataRequest(nullptr) {}
  ~GetRobotPartMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartMetadataRequest(const GetRobotPartMetadataRequest& from);
  GetRobotPartMetadataRequest(GetRobotPartMetadataRequest&& from) noexcept
    : GetRobotPartMetadataRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartMetadataRequest& operator=(const GetRobotPartMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartMetadataRequest& operator=(GetRobotPartMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartMetadataRequest*>(
               &_GetRobotPartMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(GetRobotPartMetadataRequest& a, GetRobotPartMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartMetadataRequest";
  }
  protected:
  explicit GetRobotPartMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartMetadataResponse) */ {
 public:
  inline GetRobotPartMetadataResponse() : GetRobotPartMetadataResponse(nullptr) {}
  ~GetRobotPartMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartMetadataResponse(const GetRobotPartMetadataResponse& from);
  GetRobotPartMetadataResponse(GetRobotPartMetadataResponse&& from) noexcept
    : GetRobotPartMetadataResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartMetadataResponse& operator=(const GetRobotPartMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartMetadataResponse& operator=(GetRobotPartMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartMetadataResponse*>(
               &_GetRobotPartMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(GetRobotPartMetadataResponse& a, GetRobotPartMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartMetadataResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartMetadataResponse";
  }
  protected:
  explicit GetRobotPartMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .google.protobuf.Struct data = 1 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartMetadataRequest) */ {
 public:
  inline UpdateRobotPartMetadataRequest() : UpdateRobotPartMetadataRequest(nullptr) {}
  ~UpdateRobotPartMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartMetadataRequest(const UpdateRobotPartMetadataRequest& from);
  UpdateRobotPartMetadataRequest(UpdateRobotPartMetadataRequest&& from) noexcept
    : UpdateRobotPartMetadataRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartMetadataRequest& operator=(const UpdateRobotPartMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartMetadataRequest& operator=(UpdateRobotPartMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartMetadataRequest*>(
               &_UpdateRobotPartMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(UpdateRobotPartMetadataRequest& a, UpdateRobotPartMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotPartMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotPartMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotPartMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartMetadataRequest";
  }
  protected:
  explicit UpdateRobotPartMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Struct data = 2 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartMetadataResponse) */ {
 public:
  inline UpdateRobotPartMetadataResponse() : UpdateRobotPartMetadataResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartMetadataResponse(const UpdateRobotPartMetadataResponse& from);
  UpdateRobotPartMetadataResponse(UpdateRobotPartMetadataResponse&& from) noexcept
    : UpdateRobotPartMetadataResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartMetadataResponse& operator=(const UpdateRobotPartMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartMetadataResponse& operator=(UpdateRobotPartMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartMetadataResponse*>(
               &_UpdateRobotPartMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(UpdateRobotPartMetadataResponse& a, UpdateRobotPartMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRobotPartMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRobotPartMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartMetadataResponse";
  }
  protected:
  explicit UpdateRobotPartMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotAPIKeysRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotAPIKeysRequest) */ {
 public:
  inline GetRobotAPIKeysRequest() : GetRobotAPIKeysRequest(nullptr) {}
  ~GetRobotAPIKeysRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotAPIKeysRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotAPIKeysRequest(const GetRobotAPIKeysRequest& from);
  GetRobotAPIKeysRequest(GetRobotAPIKeysRequest&& from) noexcept
    : GetRobotAPIKeysRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotAPIKeysRequest& operator=(const GetRobotAPIKeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotAPIKeysRequest& operator=(GetRobotAPIKeysRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotAPIKeysRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotAPIKeysRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotAPIKeysRequest*>(
               &_GetRobotAPIKeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(GetRobotAPIKeysRequest& a, GetRobotAPIKeysRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotAPIKeysRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotAPIKeysRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotAPIKeysRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotAPIKeysRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotAPIKeysRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotAPIKeysRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotAPIKeysRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotAPIKeysRequest";
  }
  protected:
  explicit GetRobotAPIKeysRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotAPIKeysRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class APIKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.APIKey) */ {
 public:
  inline APIKey() : APIKey(nullptr) {}
  ~APIKey() override;
  explicit PROTOBUF_CONSTEXPR APIKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIKey(const APIKey& from);
  APIKey(APIKey&& from) noexcept
    : APIKey() {
    *this = ::std::move(from);
  }

  inline APIKey& operator=(const APIKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIKey& operator=(APIKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIKey* internal_default_instance() {
    return reinterpret_cast<const APIKey*>(
               &_APIKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(APIKey& a, APIKey& b) {
    a.Swap(&b);
  }
  inline void Swap(APIKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const APIKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.APIKey";
  }
  protected:
  explicit APIKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kNameFieldNumber = 3,
    kCreatedOnFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string key = 2 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_on = 4 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.APIKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotAPIKeysResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotAPIKeysResponse) */ {
 public:
  inline GetRobotAPIKeysResponse() : GetRobotAPIKeysResponse(nullptr) {}
  ~GetRobotAPIKeysResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotAPIKeysResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotAPIKeysResponse(const GetRobotAPIKeysResponse& from);
  GetRobotAPIKeysResponse(GetRobotAPIKeysResponse&& from) noexcept
    : GetRobotAPIKeysResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotAPIKeysResponse& operator=(const GetRobotAPIKeysResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotAPIKeysResponse& operator=(GetRobotAPIKeysResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotAPIKeysResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotAPIKeysResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotAPIKeysResponse*>(
               &_GetRobotAPIKeysResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(GetRobotAPIKeysResponse& a, GetRobotAPIKeysResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotAPIKeysResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotAPIKeysResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotAPIKeysResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotAPIKeysResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotAPIKeysResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotAPIKeysResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotAPIKeysResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotAPIKeysResponse";
  }
  protected:
  explicit GetRobotAPIKeysResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeysFieldNumber = 1,
  };
  // repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
  int api_keys_size() const;
  private:
  int _internal_api_keys_size() const;
  public:
  void clear_api_keys();
  ::viam::app::v1::APIKeyWithAuthorizations* mutable_api_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
      mutable_api_keys();
  private:
  const ::viam::app::v1::APIKeyWithAuthorizations& _internal_api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* _internal_add_api_keys();
  public:
  const ::viam::app::v1::APIKeyWithAuthorizations& api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* add_api_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
      api_keys() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotAPIKeysResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations > api_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartResponse) */ {
 public:
  inline DeleteRobotPartResponse() : DeleteRobotPartResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartResponse(const DeleteRobotPartResponse& from);
  DeleteRobotPartResponse(DeleteRobotPartResponse&& from) noexcept
    : DeleteRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartResponse& operator=(const DeleteRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartResponse& operator=(DeleteRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartResponse*>(
               &_DeleteRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(DeleteRobotPartResponse& a, DeleteRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotPartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotPartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartResponse";
  }
  protected:
  explicit DeleteRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Fragment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Fragment) */ {
 public:
  inline Fragment() : Fragment(nullptr) {}
  ~Fragment() override;
  explicit PROTOBUF_CONSTEXPR Fragment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fragment(const Fragment& from);
  Fragment(Fragment&& from) noexcept
    : Fragment() {
    *this = ::std::move(from);
  }

  inline Fragment& operator=(const Fragment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fragment& operator=(Fragment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fragment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fragment* internal_default_instance() {
    return reinterpret_cast<const Fragment*>(
               &_Fragment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(Fragment& a, Fragment& b) {
    a.Swap(&b);
  }
  inline void Swap(Fragment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fragment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fragment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fragment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fragment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Fragment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fragment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Fragment";
  }
  protected:
  explicit Fragment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kOrganizationOwnerFieldNumber = 4,
    kOrganizationNameFieldNumber = 7,
    kRevisionFieldNumber = 14,
    kFragmentFieldNumber = 3,
    kCreatedOnFieldNumber = 6,
    kLastUpdatedFieldNumber = 13,
    kPublicFieldNumber = 5,
    kOnlyUsedByOwnerFieldNumber = 11,
    kRobotPartCountFieldNumber = 9,
    kOrganizationCountFieldNumber = 10,
    kVisibilityFieldNumber = 12,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string organization_owner = 4 [json_name = "organizationOwner", (.tagger.v1.tags) = "bson:\"organization_owner\" json:\"owner\""];
  void clear_organization_owner();
  const std::string& organization_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_owner();
  PROTOBUF_NODISCARD std::string* release_organization_owner();
  void set_allocated_organization_owner(std::string* organization_owner);
  private:
  const std::string& _internal_organization_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_owner(const std::string& value);
  std::string* _internal_mutable_organization_owner();
  public:

  // string organization_name = 7 [json_name = "organizationName"];
  void clear_organization_name();
  const std::string& organization_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_name();
  PROTOBUF_NODISCARD std::string* release_organization_name();
  void set_allocated_organization_name(std::string* organization_name);
  private:
  const std::string& _internal_organization_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_name(const std::string& value);
  std::string* _internal_mutable_organization_name();
  public:

  // string revision = 14 [json_name = "revision"];
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // .google.protobuf.Struct fragment = 3 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::PROTOBUF_NAMESPACE_ID::Struct& fragment() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_fragment();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_fragment();
  void set_allocated_fragment(::PROTOBUF_NAMESPACE_ID::Struct* fragment);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_fragment() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::PROTOBUF_NAMESPACE_ID::Struct* fragment);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_fragment();

  // .google.protobuf.Timestamp created_on = 6 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .google.protobuf.Timestamp last_updated = 13 [json_name = "lastUpdated", (.tagger.v1.tags) = "bson:\"last_updated_at\""];
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // bool public = 5 [json_name = "public", (.tagger.v1.tags) = "bson:\"public\" json:\"public\""];
  void clear_public_();
  bool public_() const;
  void set_public_(bool value);
  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);
  public:

  // bool only_used_by_owner = 11 [json_name = "onlyUsedByOwner"];
  void clear_only_used_by_owner();
  bool only_used_by_owner() const;
  void set_only_used_by_owner(bool value);
  private:
  bool _internal_only_used_by_owner() const;
  void _internal_set_only_used_by_owner(bool value);
  public:

  // int32 robot_part_count = 9 [json_name = "robotPartCount"];
  void clear_robot_part_count();
  int32_t robot_part_count() const;
  void set_robot_part_count(int32_t value);
  private:
  int32_t _internal_robot_part_count() const;
  void _internal_set_robot_part_count(int32_t value);
  public:

  // int32 organization_count = 10 [json_name = "organizationCount"];
  void clear_organization_count();
  int32_t organization_count() const;
  void set_organization_count(int32_t value);
  private:
  int32_t _internal_organization_count() const;
  void _internal_set_organization_count(int32_t value);
  public:

  // .viam.app.v1.FragmentVisibility visibility = 12 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::FragmentVisibility visibility() const;
  void set_visibility(::viam::app::v1::FragmentVisibility value);
  private:
  ::viam::app::v1::FragmentVisibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::FragmentVisibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Fragment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::Struct* fragment_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
  bool public__;
  bool only_used_by_owner_;
  int32_t robot_part_count_;
  int32_t organization_count_;
  int visibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentHistoryEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentHistoryEntry) */ {
 public:
  inline FragmentHistoryEntry() : FragmentHistoryEntry(nullptr) {}
  ~FragmentHistoryEntry() override;
  explicit PROTOBUF_CONSTEXPR FragmentHistoryEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentHistoryEntry(const FragmentHistoryEntry& from);
  FragmentHistoryEntry(FragmentHistoryEntry&& from) noexcept
    : FragmentHistoryEntry() {
    *this = ::std::move(from);
  }

  inline FragmentHistoryEntry& operator=(const FragmentHistoryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentHistoryEntry& operator=(FragmentHistoryEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentHistoryEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentHistoryEntry* internal_default_instance() {
    return reinterpret_cast<const FragmentHistoryEntry*>(
               &_FragmentHistoryEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(FragmentHistoryEntry& a, FragmentHistoryEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentHistoryEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentHistoryEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentHistoryEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentHistoryEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentHistoryEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentHistoryEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentHistoryEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentHistoryEntry";
  }
  protected:
  explicit FragmentHistoryEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 1,
    kRevisionFieldNumber = 5,
    kEditedOnFieldNumber = 2,
    kOldFieldNumber = 3,
    kEditedByFieldNumber = 4,
    kConfigFieldNumber = 6,
  };
  // string fragment = 1 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
  void clear_fragment();
  const std::string& fragment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment();
  PROTOBUF_NODISCARD std::string* release_fragment();
  void set_allocated_fragment(std::string* fragment);
  private:
  const std::string& _internal_fragment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment(const std::string& value);
  std::string* _internal_mutable_fragment();
  public:

  // string revision = 5 [json_name = "revision", (.tagger.v1.tags) = "bson:\"revision\" json:\"revision\""];
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // .google.protobuf.Timestamp edited_on = 2 [json_name = "editedOn", (.tagger.v1.tags) = "bson:\"edited_on\" json:\"edited_on\""];
  bool has_edited_on() const;
  private:
  bool _internal_has_edited_on() const;
  public:
  void clear_edited_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& edited_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_edited_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_edited_on();
  void set_allocated_edited_on(::PROTOBUF_NAMESPACE_ID::Timestamp* edited_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_edited_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_edited_on();
  public:
  void unsafe_arena_set_allocated_edited_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* edited_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_edited_on();

  // .viam.app.v1.Fragment old = 3 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
  bool has_old() const;
  private:
  bool _internal_has_old() const;
  public:
  void clear_old();
  const ::viam::app::v1::Fragment& old() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Fragment* release_old();
  ::viam::app::v1::Fragment* mutable_old();
  void set_allocated_old(::viam::app::v1::Fragment* old);
  private:
  const ::viam::app::v1::Fragment& _internal_old() const;
  ::viam::app::v1::Fragment* _internal_mutable_old();
  public:
  void unsafe_arena_set_allocated_old(
      ::viam::app::v1::Fragment* old);
  ::viam::app::v1::Fragment* unsafe_arena_release_old();

  // .viam.app.v1.AuthenticatorInfo edited_by = 4 [json_name = "editedBy", (.tagger.v1.tags) = "bson:\"edited_by\" json:\"edited_by\""];
  bool has_edited_by() const;
  private:
  bool _internal_has_edited_by() const;
  public:
  void clear_edited_by();
  const ::viam::app::v1::AuthenticatorInfo& edited_by() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AuthenticatorInfo* release_edited_by();
  ::viam::app::v1::AuthenticatorInfo* mutable_edited_by();
  void set_allocated_edited_by(::viam::app::v1::AuthenticatorInfo* edited_by);
  private:
  const ::viam::app::v1::AuthenticatorInfo& _internal_edited_by() const;
  ::viam::app::v1::AuthenticatorInfo* _internal_mutable_edited_by();
  public:
  void unsafe_arena_set_allocated_edited_by(
      ::viam::app::v1::AuthenticatorInfo* edited_by);
  ::viam::app::v1::AuthenticatorInfo* unsafe_arena_release_edited_by();

  // .google.protobuf.Struct config = 6 [json_name = "config", (.tagger.v1.tags) = "bson:\"config\" json:\"config\""];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_config();
  void set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentHistoryEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* edited_on_;
  ::viam::app::v1::Fragment* old_;
  ::viam::app::v1::AuthenticatorInfo* edited_by_;
  ::PROTOBUF_NAMESPACE_ID::Struct* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentRevision final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentRevision) */ {
 public:
  inline FragmentRevision() : FragmentRevision(nullptr) {}
  ~FragmentRevision() override;
  explicit PROTOBUF_CONSTEXPR FragmentRevision(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentRevision(const FragmentRevision& from);
  FragmentRevision(FragmentRevision&& from) noexcept
    : FragmentRevision() {
    *this = ::std::move(from);
  }

  inline FragmentRevision& operator=(const FragmentRevision& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentRevision& operator=(FragmentRevision&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentRevision& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentRevision* internal_default_instance() {
    return reinterpret_cast<const FragmentRevision*>(
               &_FragmentRevision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(FragmentRevision& a, FragmentRevision& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentRevision* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentRevision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentRevision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentRevision>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentRevision& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentRevision& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentRevision* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentRevision";
  }
  protected:
  explicit FragmentRevision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRevisionFieldNumber = 1,
    kCreatedAtFieldNumber = 2,
  };
  // string revision = 1 [json_name = "revision"];
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // .google.protobuf.Timestamp created_at = 2 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentRevision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentTag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentTag) */ {
 public:
  inline FragmentTag() : FragmentTag(nullptr) {}
  ~FragmentTag() override;
  explicit PROTOBUF_CONSTEXPR FragmentTag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentTag(const FragmentTag& from);
  FragmentTag(FragmentTag&& from) noexcept
    : FragmentTag() {
    *this = ::std::move(from);
  }

  inline FragmentTag& operator=(const FragmentTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentTag& operator=(FragmentTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentTag* internal_default_instance() {
    return reinterpret_cast<const FragmentTag*>(
               &_FragmentTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(FragmentTag& a, FragmentTag& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentTag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentTag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentTag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentTag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentTag";
  }
  protected:
  explicit FragmentTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kRevisionFieldNumber = 2,
  };
  // string tag = 1 [json_name = "tag"];
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string revision = 2 [json_name = "revision"];
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentError) */ {
 public:
  inline FragmentError() : FragmentError(nullptr) {}
  ~FragmentError() override;
  explicit PROTOBUF_CONSTEXPR FragmentError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentError(const FragmentError& from);
  FragmentError(FragmentError&& from) noexcept
    : FragmentError() {
    *this = ::std::move(from);
  }

  inline FragmentError& operator=(const FragmentError& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentError& operator=(FragmentError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentError& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentError* internal_default_instance() {
    return reinterpret_cast<const FragmentError*>(
               &_FragmentError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(FragmentError& a, FragmentError& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentError";
  }
  protected:
  explicit FragmentError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdFieldNumber = 2,
    kDetailFieldNumber = 3,
    kErrorTypeFieldNumber = 1,
  };
  // string fragment_id = 2 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // string detail = 3 [json_name = "detail"];
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // .viam.app.v1.FragmentErrorType error_type = 1 [json_name = "errorType"];
  void clear_error_type();
  ::viam::app::v1::FragmentErrorType error_type() const;
  void set_error_type(::viam::app::v1::FragmentErrorType value);
  private:
  ::viam::app::v1::FragmentErrorType _internal_error_type() const;
  void _internal_set_error_type(::viam::app::v1::FragmentErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  int error_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentUsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentUsage) */ {
 public:
  inline FragmentUsage() : FragmentUsage(nullptr) {}
  ~FragmentUsage() override;
  explicit PROTOBUF_CONSTEXPR FragmentUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentUsage(const FragmentUsage& from);
  FragmentUsage(FragmentUsage&& from) noexcept
    : FragmentUsage() {
    *this = ::std::move(from);
  }

  inline FragmentUsage& operator=(const FragmentUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentUsage& operator=(FragmentUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentUsage* internal_default_instance() {
    return reinterpret_cast<const FragmentUsage*>(
               &_FragmentUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(FragmentUsage& a, FragmentUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentUsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentUsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentUsage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentUsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentUsage";
  }
  protected:
  explicit FragmentUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdFieldNumber = 1,
    kVersionFieldNumber = 5,
    kOrganizationsFieldNumber = 2,
    kMachinesFieldNumber = 3,
    kMachinesInCurrentOrgFieldNumber = 4,
  };
  // string fragment_id = 1 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // optional string version = 5 [json_name = "version"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // int32 organizations = 2 [json_name = "organizations"];
  void clear_organizations();
  int32_t organizations() const;
  void set_organizations(int32_t value);
  private:
  int32_t _internal_organizations() const;
  void _internal_set_organizations(int32_t value);
  public:

  // int32 machines = 3 [json_name = "machines"];
  void clear_machines();
  int32_t machines() const;
  void set_machines(int32_t value);
  private:
  int32_t _internal_machines() const;
  void _internal_set_machines(int32_t value);
  public:

  // int32 machines_in_current_org = 4 [json_name = "machinesInCurrentOrg"];
  void clear_machines_in_current_org();
  int32_t machines_in_current_org() const;
  void set_machines_in_current_org(int32_t value);
  private:
  int32_t _internal_machines_in_current_org() const;
  void _internal_set_machines_in_current_org(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  int32_t organizations_;
  int32_t machines_;
  int32_t machines_in_current_org_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentImport_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FragmentImport_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FragmentImport_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  FragmentImport_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FragmentImport_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FragmentImport_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FragmentImport_VariablesEntry_DoNotUse& other);
  static const FragmentImport_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FragmentImport_VariablesEntry_DoNotUse*>(&_FragmentImport_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.FragmentImport.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.FragmentImport.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};

// -------------------------------------------------------------------

class FragmentImport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentImport) */ {
 public:
  inline FragmentImport() : FragmentImport(nullptr) {}
  ~FragmentImport() override;
  explicit PROTOBUF_CONSTEXPR FragmentImport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentImport(const FragmentImport& from);
  FragmentImport(FragmentImport&& from) noexcept
    : FragmentImport() {
    *this = ::std::move(from);
  }

  inline FragmentImport& operator=(const FragmentImport& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentImport& operator=(FragmentImport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentImport& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentImport* internal_default_instance() {
    return reinterpret_cast<const FragmentImport*>(
               &_FragmentImport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(FragmentImport& a, FragmentImport& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentImport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentImport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentImport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentImport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentImport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentImport& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentImport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentImport";
  }
  protected:
  explicit FragmentImport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 4,
    kFragmentIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPrefixFieldNumber = 3,
  };
  // map<string, string> variables = 4 [json_name = "variables"];
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string fragment_id = 1 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // string version = 2 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string prefix = 3 [json_name = "prefix"];
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentImport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      FragmentImport_VariablesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ResolvedFragment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ResolvedFragment) */ {
 public:
  inline ResolvedFragment() : ResolvedFragment(nullptr) {}
  ~ResolvedFragment() override;
  explicit PROTOBUF_CONSTEXPR ResolvedFragment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedFragment(const ResolvedFragment& from);
  ResolvedFragment(ResolvedFragment&& from) noexcept
    : ResolvedFragment() {
    *this = ::std::move(from);
  }

  inline ResolvedFragment& operator=(const ResolvedFragment& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedFragment& operator=(ResolvedFragment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedFragment& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedFragment* internal_default_instance() {
    return reinterpret_cast<const ResolvedFragment*>(
               &_ResolvedFragment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(ResolvedFragment& a, ResolvedFragment& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedFragment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedFragment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedFragment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedFragment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResolvedFragment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResolvedFragment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedFragment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ResolvedFragment";
  }
  protected:
  explicit ResolvedFragment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdFieldNumber = 1,
    kRevisionFieldNumber = 4,
    kResolvedConfigFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string fragment_id = 1 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // string revision = 4 [json_name = "revision"];
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // .google.protobuf.Struct resolved_config = 2 [json_name = "resolvedConfig"];
  bool has_resolved_config() const;
  private:
  bool _internal_has_resolved_config() const;
  public:
  void clear_resolved_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& resolved_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_resolved_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_resolved_config();
  void set_allocated_resolved_config(::PROTOBUF_NAMESPACE_ID::Struct* resolved_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_resolved_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_resolved_config();
  public:
  void unsafe_arena_set_allocated_resolved_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* resolved_config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_resolved_config();

  // .viam.app.v1.FragmentError error = 3 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::viam::app::v1::FragmentError& error() const;
  PROTOBUF_NODISCARD ::viam::app::v1::FragmentError* release_error();
  ::viam::app::v1::FragmentError* mutable_error();
  void set_allocated_error(::viam::app::v1::FragmentError* error);
  private:
  const ::viam::app::v1::FragmentError& _internal_error() const;
  ::viam::app::v1::FragmentError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::viam::app::v1::FragmentError* error);
  ::viam::app::v1::FragmentError* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ResolvedFragment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::Struct* resolved_config_;
  ::viam::app::v1::FragmentError* error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListFragmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListFragmentsRequest) */ {
 public:
  inline ListFragmentsRequest() : ListFragmentsRequest(nullptr) {}
  ~ListFragmentsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListFragmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFragmentsRequest(const ListFragmentsRequest& from);
  ListFragmentsRequest(ListFragmentsRequest&& from) noexcept
    : ListFragmentsRequest() {
    *this = ::std::move(from);
  }

  inline ListFragmentsRequest& operator=(const ListFragmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFragmentsRequest& operator=(ListFragmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFragmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFragmentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListFragmentsRequest*>(
               &_ListFragmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(ListFragmentsRequest& a, ListFragmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFragmentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFragmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFragmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFragmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFragmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListFragmentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFragmentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListFragmentsRequest";
  }
  protected:
  explicit ListFragmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentVisibilityFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
    kShowPublicFieldNumber = 2,
  };
  // repeated .viam.app.v1.FragmentVisibility fragment_visibility = 3 [json_name = "fragmentVisibility"];
  int fragment_visibility_size() const;
  private:
  int _internal_fragment_visibility_size() const;
  public:
  void clear_fragment_visibility();
  private:
  ::viam::app::v1::FragmentVisibility _internal_fragment_visibility(int index) const;
  void _internal_add_fragment_visibility(::viam::app::v1::FragmentVisibility value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_fragment_visibility();
  public:
  ::viam::app::v1::FragmentVisibility fragment_visibility(int index) const;
  void set_fragment_visibility(int index, ::viam::app::v1::FragmentVisibility value);
  void add_fragment_visibility(::viam::app::v1::FragmentVisibility value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& fragment_visibility() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_fragment_visibility();

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // bool show_public = 2 [json_name = "showPublic"];
  void clear_show_public();
  bool show_public() const;
  void set_show_public(bool value);
  private:
  bool _internal_show_public() const;
  void _internal_set_show_public(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListFragmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> fragment_visibility_;
  mutable std::atomic<int> _fragment_visibility_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  bool show_public_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListFragmentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListFragmentsResponse) */ {
 public:
  inline ListFragmentsResponse() : ListFragmentsResponse(nullptr) {}
  ~ListFragmentsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListFragmentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFragmentsResponse(const ListFragmentsResponse& from);
  ListFragmentsResponse(ListFragmentsResponse&& from) noexcept
    : ListFragmentsResponse() {
    *this = ::std::move(from);
  }

  inline ListFragmentsResponse& operator=(const ListFragmentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFragmentsResponse& operator=(ListFragmentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFragmentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFragmentsResponse* internal_default_instance() {
    return reinterpret_cast<const ListFragmentsResponse*>(
               &_ListFragmentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(ListFragmentsResponse& a, ListFragmentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFragmentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFragmentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFragmentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFragmentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFragmentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListFragmentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFragmentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListFragmentsResponse";
  }
  protected:
  explicit ListFragmentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 1,
    kFragmentUsagesFieldNumber = 2,
  };
  // repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;
  public:
  void clear_fragments();
  ::viam::app::v1::Fragment* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
      mutable_fragments();
  private:
  const ::viam::app::v1::Fragment& _internal_fragments(int index) const;
  ::viam::app::v1::Fragment* _internal_add_fragments();
  public:
  const ::viam::app::v1::Fragment& fragments(int index) const;
  ::viam::app::v1::Fragment* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
      fragments() const;

  // repeated .viam.app.v1.FragmentUsage fragment_usages = 2 [json_name = "fragmentUsages"];
  int fragment_usages_size() const;
  private:
  int _internal_fragment_usages_size() const;
  public:
  void clear_fragment_usages();
  ::viam::app::v1::FragmentUsage* mutable_fragment_usages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >*
      mutable_fragment_usages();
  private:
  const ::viam::app::v1::FragmentUsage& _internal_fragment_usages(int index) const;
  ::viam::app::v1::FragmentUsage* _internal_add_fragment_usages();
  public:
  const ::viam::app::v1::FragmentUsage& fragment_usages(int index) const;
  ::viam::app::v1::FragmentUsage* add_fragment_usages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >&
      fragment_usages() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListFragmentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment > fragments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage > fragment_usages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentRequest) */ {
 public:
  inline GetFragmentRequest() : GetFragmentRequest(nullptr) {}
  ~GetFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentRequest(const GetFragmentRequest& from);
  GetFragmentRequest(GetFragmentRequest&& from) noexcept
    : GetFragmentRequest() {
    *this = ::std::move(from);
  }

  inline GetFragmentRequest& operator=(const GetFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentRequest& operator=(GetFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const GetFragmentRequest*>(
               &_GetFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(GetFragmentRequest& a, GetFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentRequest";
  }
  protected:
  explicit GetFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCurrentOrganizationIdFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string current_organization_id = 2 [json_name = "currentOrganizationId"];
  void clear_current_organization_id();
  const std::string& current_organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_organization_id();
  PROTOBUF_NODISCARD std::string* release_current_organization_id();
  void set_allocated_current_organization_id(std::string* current_organization_id);
  private:
  const std::string& _internal_current_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_organization_id(const std::string& value);
  std::string* _internal_mutable_current_organization_id();
  public:

  // optional string version = 3 [json_name = "version"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentResponse) */ {
 public:
  inline GetFragmentResponse() : GetFragmentResponse(nullptr) {}
  ~GetFragmentResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentResponse(const GetFragmentResponse& from);
  GetFragmentResponse(GetFragmentResponse&& from) noexcept
    : GetFragmentResponse() {
    *this = ::std::move(from);
  }

  inline GetFragmentResponse& operator=(const GetFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentResponse& operator=(GetFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const GetFragmentResponse*>(
               &_GetFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(GetFragmentResponse& a, GetFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentResponse";
  }
  protected:
  explicit GetFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRevisionsFieldNumber = 3,
    kTagsFieldNumber = 4,
    kFragmentFieldNumber = 1,
    kFragmentUsageFieldNumber = 2,
  };
  // repeated .viam.app.v1.FragmentRevision revisions = 3 [json_name = "revisions"];
  int revisions_size() const;
  private:
  int _internal_revisions_size() const;
  public:
  void clear_revisions();
  ::viam::app::v1::FragmentRevision* mutable_revisions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentRevision >*
      mutable_revisions();
  private:
  const ::viam::app::v1::FragmentRevision& _internal_revisions(int index) const;
  ::viam::app::v1::FragmentRevision* _internal_add_revisions();
  public:
  const ::viam::app::v1::FragmentRevision& revisions(int index) const;
  ::viam::app::v1::FragmentRevision* add_revisions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentRevision >&
      revisions() const;

  // repeated .viam.app.v1.FragmentTag tags = 4 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::viam::app::v1::FragmentTag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >*
      mutable_tags();
  private:
  const ::viam::app::v1::FragmentTag& _internal_tags(int index) const;
  ::viam::app::v1::FragmentTag* _internal_add_tags();
  public:
  const ::viam::app::v1::FragmentTag& tags(int index) const;
  ::viam::app::v1::FragmentTag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >&
      tags() const;

  // .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::viam::app::v1::Fragment& fragment() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Fragment* release_fragment();
  ::viam::app::v1::Fragment* mutable_fragment();
  void set_allocated_fragment(::viam::app::v1::Fragment* fragment);
  private:
  const ::viam::app::v1::Fragment& _internal_fragment() const;
  ::viam::app::v1::Fragment* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::viam::app::v1::Fragment* fragment);
  ::viam::app::v1::Fragment* unsafe_arena_release_fragment();

  // .viam.app.v1.FragmentUsage fragment_usage = 2 [json_name = "fragmentUsage"];
  bool has_fragment_usage() const;
  private:
  bool _internal_has_fragment_usage() const;
  public:
  void clear_fragment_usage();
  const ::viam::app::v1::FragmentUsage& fragment_usage() const;
  PROTOBUF_NODISCARD ::viam::app::v1::FragmentUsage* release_fragment_usage();
  ::viam::app::v1::FragmentUsage* mutable_fragment_usage();
  void set_allocated_fragment_usage(::viam::app::v1::FragmentUsage* fragment_usage);
  private:
  const ::viam::app::v1::FragmentUsage& _internal_fragment_usage() const;
  ::viam::app::v1::FragmentUsage* _internal_mutable_fragment_usage();
  public:
  void unsafe_arena_set_allocated_fragment_usage(
      ::viam::app::v1::FragmentUsage* fragment_usage);
  ::viam::app::v1::FragmentUsage* unsafe_arena_release_fragment_usage();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentRevision > revisions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag > tags_;
  ::viam::app::v1::Fragment* fragment_;
  ::viam::app::v1::FragmentUsage* fragment_usage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateFragmentRequest) */ {
 public:
  inline CreateFragmentRequest() : CreateFragmentRequest(nullptr) {}
  ~CreateFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFragmentRequest(const CreateFragmentRequest& from);
  CreateFragmentRequest(CreateFragmentRequest&& from) noexcept
    : CreateFragmentRequest() {
    *this = ::std::move(from);
  }

  inline CreateFragmentRequest& operator=(const CreateFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFragmentRequest& operator=(CreateFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const CreateFragmentRequest*>(
               &_CreateFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(CreateFragmentRequest& a, CreateFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateFragmentRequest";
  }
  protected:
  explicit CreateFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kOrganizationIdFieldNumber = 3,
    kConfigFieldNumber = 2,
    kVisibilityFieldNumber = 4,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string organization_id = 3 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // .google.protobuf.Struct config = 2 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_config();
  void set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_config();

  // optional .viam.app.v1.FragmentVisibility visibility = 4 [json_name = "visibility"];
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  ::viam::app::v1::FragmentVisibility visibility() const;
  void set_visibility(::viam::app::v1::FragmentVisibility value);
  private:
  ::viam::app::v1::FragmentVisibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::FragmentVisibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* config_;
  int visibility_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateFragmentResponse) */ {
 public:
  inline CreateFragmentResponse() : CreateFragmentResponse(nullptr) {}
  ~CreateFragmentResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFragmentResponse(const CreateFragmentResponse& from);
  CreateFragmentResponse(CreateFragmentResponse&& from) noexcept
    : CreateFragmentResponse() {
    *this = ::std::move(from);
  }

  inline CreateFragmentResponse& operator=(const CreateFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFragmentResponse& operator=(CreateFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const CreateFragmentResponse*>(
               &_CreateFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(CreateFragmentResponse& a, CreateFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFragmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateFragmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFragmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateFragmentResponse";
  }
  protected:
  explicit CreateFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 1,
  };
  // .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::viam::app::v1::Fragment& fragment() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Fragment* release_fragment();
  ::viam::app::v1::Fragment* mutable_fragment();
  void set_allocated_fragment(::viam::app::v1::Fragment* fragment);
  private:
  const ::viam::app::v1::Fragment& _internal_fragment() const;
  ::viam::app::v1::Fragment* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::viam::app::v1::Fragment* fragment);
  ::viam::app::v1::Fragment* unsafe_arena_release_fragment();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Fragment* fragment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateFragmentRequest) */ {
 public:
  inline UpdateFragmentRequest() : UpdateFragmentRequest(nullptr) {}
  ~UpdateFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFragmentRequest(const UpdateFragmentRequest& from);
  UpdateFragmentRequest(UpdateFragmentRequest&& from) noexcept
    : UpdateFragmentRequest() {
    *this = ::std::move(from);
  }

  inline UpdateFragmentRequest& operator=(const UpdateFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFragmentRequest& operator=(UpdateFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateFragmentRequest*>(
               &_UpdateFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(UpdateFragmentRequest& a, UpdateFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateFragmentRequest";
  }
  protected:
  explicit UpdateFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kConfigFieldNumber = 3,
    kLastKnownUpdateFieldNumber = 6,
    kPublicFieldNumber = 4,
    kVisibilityFieldNumber = 5,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct config = 3 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_config();
  void set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_config();

  // optional .google.protobuf.Timestamp last_known_update = 6 [json_name = "lastKnownUpdate"];
  bool has_last_known_update() const;
  private:
  bool _internal_has_last_known_update() const;
  public:
  void clear_last_known_update();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_known_update() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_known_update();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_known_update();
  void set_allocated_last_known_update(::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_known_update() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_known_update();
  public:
  void unsafe_arena_set_allocated_last_known_update(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_known_update();

  // optional bool public = 4 [json_name = "public"];
  bool has_public_() const;
  private:
  bool _internal_has_public_() const;
  public:
  void clear_public_();
  bool public_() const;
  void set_public_(bool value);
  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);
  public:

  // optional .viam.app.v1.FragmentVisibility visibility = 5 [json_name = "visibility"];
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  ::viam::app::v1::FragmentVisibility visibility() const;
  void set_visibility(::viam::app::v1::FragmentVisibility value);
  private:
  ::viam::app::v1::FragmentVisibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::FragmentVisibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* config_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update_;
  bool public__;
  int visibility_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateFragmentResponse) */ {
 public:
  inline UpdateFragmentResponse() : UpdateFragmentResponse(nullptr) {}
  ~UpdateFragmentResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFragmentResponse(const UpdateFragmentResponse& from);
  UpdateFragmentResponse(UpdateFragmentResponse&& from) noexcept
    : UpdateFragmentResponse() {
    *this = ::std::move(from);
  }

  inline UpdateFragmentResponse& operator=(const UpdateFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFragmentResponse& operator=(UpdateFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateFragmentResponse*>(
               &_UpdateFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(UpdateFragmentResponse& a, UpdateFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateFragmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateFragmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFragmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateFragmentResponse";
  }
  protected:
  explicit UpdateFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 1,
  };
  // .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::viam::app::v1::Fragment& fragment() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Fragment* release_fragment();
  ::viam::app::v1::Fragment* mutable_fragment();
  void set_allocated_fragment(::viam::app::v1::Fragment* fragment);
  private:
  const ::viam::app::v1::Fragment& _internal_fragment() const;
  ::viam::app::v1::Fragment* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::viam::app::v1::Fragment* fragment);
  ::viam::app::v1::Fragment* unsafe_arena_release_fragment();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Fragment* fragment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteFragmentRequest) */ {
 public:
  inline DeleteFragmentRequest() : DeleteFragmentRequest(nullptr) {}
  ~DeleteFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFragmentRequest(const DeleteFragmentRequest& from);
  DeleteFragmentRequest(DeleteFragmentRequest&& from) noexcept
    : DeleteFragmentRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFragmentRequest& operator=(const DeleteFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFragmentRequest& operator=(DeleteFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFragmentRequest*>(
               &_DeleteFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(DeleteFragmentRequest& a, DeleteFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteFragmentRequest";
  }
  protected:
  explicit DeleteFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteFragmentResponse) */ {
 public:
  inline DeleteFragmentResponse() : DeleteFragmentResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFragmentResponse(const DeleteFragmentResponse& from);
  DeleteFragmentResponse(DeleteFragmentResponse&& from) noexcept
    : DeleteFragmentResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFragmentResponse& operator=(const DeleteFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFragmentResponse& operator=(DeleteFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFragmentResponse*>(
               &_DeleteFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(DeleteFragmentResponse& a, DeleteFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteFragmentResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteFragmentResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteFragmentResponse";
  }
  protected:
  explicit DeleteFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentHistoryRequest) */ {
 public:
  inline GetFragmentHistoryRequest() : GetFragmentHistoryRequest(nullptr) {}
  ~GetFragmentHistoryRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentHistoryRequest(const GetFragmentHistoryRequest& from);
  GetFragmentHistoryRequest(GetFragmentHistoryRequest&& from) noexcept
    : GetFragmentHistoryRequest() {
    *this = ::std::move(from);
  }

  inline GetFragmentHistoryRequest& operator=(const GetFragmentHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentHistoryRequest& operator=(GetFragmentHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const GetFragmentHistoryRequest*>(
               &_GetFragmentHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(GetFragmentHistoryRequest& a, GetFragmentHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentHistoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentHistoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentHistoryRequest";
  }
  protected:
  explicit GetFragmentHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPageTokenFieldNumber = 2,
    kPageLimitFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string page_token = 2 [json_name = "pageToken"];
  bool has_page_token() const;
  private:
  bool _internal_has_page_token() const;
  public:
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // optional int64 page_limit = 3 [json_name = "pageLimit"];
  bool has_page_limit() const;
  private:
  bool _internal_has_page_limit() const;
  public:
  void clear_page_limit();
  int64_t page_limit() const;
  void set_page_limit(int64_t value);
  private:
  int64_t _internal_page_limit() const;
  void _internal_set_page_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int64_t page_limit_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentHistoryResponse) */ {
 public:
  inline GetFragmentHistoryResponse() : GetFragmentHistoryResponse(nullptr) {}
  ~GetFragmentHistoryResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentHistoryResponse(const GetFragmentHistoryResponse& from);
  GetFragmentHistoryResponse(GetFragmentHistoryResponse&& from) noexcept
    : GetFragmentHistoryResponse() {
    *this = ::std::move(from);
  }

  inline GetFragmentHistoryResponse& operator=(const GetFragmentHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentHistoryResponse& operator=(GetFragmentHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const GetFragmentHistoryResponse*>(
               &_GetFragmentHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(GetFragmentHistoryResponse& a, GetFragmentHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentHistoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentHistoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentHistoryResponse";
  }
  protected:
  explicit GetFragmentHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .viam.app.v1.FragmentHistoryEntry history = 1 [json_name = "history"];
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::viam::app::v1::FragmentHistoryEntry* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentHistoryEntry >*
      mutable_history();
  private:
  const ::viam::app::v1::FragmentHistoryEntry& _internal_history(int index) const;
  ::viam::app::v1::FragmentHistoryEntry* _internal_add_history();
  public:
  const ::viam::app::v1::FragmentHistoryEntry& history(int index) const;
  ::viam::app::v1::FragmentHistoryEntry* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentHistoryEntry >&
      history() const;

  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentHistoryEntry > history_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentUsageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentUsageRequest) */ {
 public:
  inline GetFragmentUsageRequest() : GetFragmentUsageRequest(nullptr) {}
  ~GetFragmentUsageRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentUsageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentUsageRequest(const GetFragmentUsageRequest& from);
  GetFragmentUsageRequest(GetFragmentUsageRequest&& from) noexcept
    : GetFragmentUsageRequest() {
    *this = ::std::move(from);
  }

  inline GetFragmentUsageRequest& operator=(const GetFragmentUsageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentUsageRequest& operator=(GetFragmentUsageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentUsageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentUsageRequest* internal_default_instance() {
    return reinterpret_cast<const GetFragmentUsageRequest*>(
               &_GetFragmentUsageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(GetFragmentUsageRequest& a, GetFragmentUsageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentUsageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentUsageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentUsageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentUsageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentUsageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentUsageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentUsageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentUsageRequest";
  }
  protected:
  explicit GetFragmentUsageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdFieldNumber = 1,
  };
  // string fragment_id = 1 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentUsageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentUsageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentUsageResponse) */ {
 public:
  inline GetFragmentUsageResponse() : GetFragmentUsageResponse(nullptr) {}
  ~GetFragmentUsageResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentUsageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentUsageResponse(const GetFragmentUsageResponse& from);
  GetFragmentUsageResponse(GetFragmentUsageResponse&& from) noexcept
    : GetFragmentUsageResponse() {
    *this = ::std::move(from);
  }

  inline GetFragmentUsageResponse& operator=(const GetFragmentUsageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentUsageResponse& operator=(GetFragmentUsageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentUsageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentUsageResponse* internal_default_instance() {
    return reinterpret_cast<const GetFragmentUsageResponse*>(
               &_GetFragmentUsageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(GetFragmentUsageResponse& a, GetFragmentUsageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentUsageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentUsageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentUsageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentUsageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentUsageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentUsageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentUsageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentUsageResponse";
  }
  protected:
  explicit GetFragmentUsageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionUsagesFieldNumber = 1,
  };
  // repeated .viam.app.v1.FragmentUsage version_usages = 1 [json_name = "versionUsages"];
  int version_usages_size() const;
  private:
  int _internal_version_usages_size() const;
  public:
  void clear_version_usages();
  ::viam::app::v1::FragmentUsage* mutable_version_usages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >*
      mutable_version_usages();
  private:
  const ::viam::app::v1::FragmentUsage& _internal_version_usages(int index) const;
  ::viam::app::v1::FragmentUsage* _internal_add_version_usages();
  public:
  const ::viam::app::v1::FragmentUsage& version_usages(int index) const;
  ::viam::app::v1::FragmentUsage* add_version_usages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >&
      version_usages() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentUsageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage > version_usages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class SetFragmentTagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SetFragmentTagRequest) */ {
 public:
  inline SetFragmentTagRequest() : SetFragmentTagRequest(nullptr) {}
  ~SetFragmentTagRequest() override;
  explicit PROTOBUF_CONSTEXPR SetFragmentTagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFragmentTagRequest(const SetFragmentTagRequest& from);
  SetFragmentTagRequest(SetFragmentTagRequest&& from) noexcept
    : SetFragmentTagRequest() {
    *this = ::std::move(from);
  }

  inline SetFragmentTagRequest& operator=(const SetFragmentTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFragmentTagRequest& operator=(SetFragmentTagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFragmentTagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFragmentTagRequest* internal_default_instance() {
    return reinterpret_cast<const SetFragmentTagRequest*>(
               &_SetFragmentTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(SetFragmentTagRequest& a, SetFragmentTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFragmentTagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFragmentTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFragmentTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFragmentTagRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFragmentTagRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetFragmentTagRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFragmentTagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SetFragmentTagRequest";
  }
  protected:
  explicit SetFragmentTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdFieldNumber = 1,
    kTagFieldNumber = 2,
    kRevisionFieldNumber = 3,
  };
  // string fragment_id = 1 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // string tag = 2 [json_name = "tag"];
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string revision = 3 [json_name = "revision"];
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.SetFragmentTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class SetFragmentTagResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SetFragmentTagResponse) */ {
 public:
  inline SetFragmentTagResponse() : SetFragmentTagResponse(nullptr) {}
  ~SetFragmentTagResponse() override;
  explicit PROTOBUF_CONSTEXPR SetFragmentTagResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFragmentTagResponse(const SetFragmentTagResponse& from);
  SetFragmentTagResponse(SetFragmentTagResponse&& from) noexcept
    : SetFragmentTagResponse() {
    *this = ::std::move(from);
  }

  inline SetFragmentTagResponse& operator=(const SetFragmentTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFragmentTagResponse& operator=(SetFragmentTagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFragmentTagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFragmentTagResponse* internal_default_instance() {
    return reinterpret_cast<const SetFragmentTagResponse*>(
               &_SetFragmentTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(SetFragmentTagResponse& a, SetFragmentTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFragmentTagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFragmentTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFragmentTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFragmentTagResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFragmentTagResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetFragmentTagResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFragmentTagResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SetFragmentTagResponse";
  }
  protected:
  explicit SetFragmentTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
  };
  // repeated .viam.app.v1.FragmentTag tags = 1 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::viam::app::v1::FragmentTag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >*
      mutable_tags();
  private:
  const ::viam::app::v1::FragmentTag& _internal_tags(int index) const;
  ::viam::app::v1::FragmentTag* _internal_add_tags();
  public:
  const ::viam::app::v1::FragmentTag& tags(int index) const;
  ::viam::app::v1::FragmentTag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >&
      tags() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.SetFragmentTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag > tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteFragmentTagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteFragmentTagRequest) */ {
 public:
  inline DeleteFragmentTagRequest() : DeleteFragmentTagRequest(nullptr) {}
  ~DeleteFragmentTagRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFragmentTagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFragmentTagRequest(const DeleteFragmentTagRequest& from);
  DeleteFragmentTagRequest(DeleteFragmentTagRequest&& from) noexcept
    : DeleteFragmentTagRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFragmentTagRequest& operator=(const DeleteFragmentTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFragmentTagRequest& operator=(DeleteFragmentTagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFragmentTagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFragmentTagRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFragmentTagRequest*>(
               &_DeleteFragmentTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(DeleteFragmentTagRequest& a, DeleteFragmentTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFragmentTagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFragmentTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFragmentTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFragmentTagRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFragmentTagRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFragmentTagRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFragmentTagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteFragmentTagRequest";
  }
  protected:
  explicit DeleteFragmentTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdFieldNumber = 1,
    kTagFieldNumber = 2,
  };
  // string fragment_id = 1 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // string tag = 2 [json_name = "tag"];
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteFragmentTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteFragmentTagResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteFragmentTagResponse) */ {
 public:
  inline DeleteFragmentTagResponse() : DeleteFragmentTagResponse(nullptr) {}
  ~DeleteFragmentTagResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteFragmentTagResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFragmentTagResponse(const DeleteFragmentTagResponse& from);
  DeleteFragmentTagResponse(DeleteFragmentTagResponse&& from) noexcept
    : DeleteFragmentTagResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFragmentTagResponse& operator=(const DeleteFragmentTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFragmentTagResponse& operator=(DeleteFragmentTagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFragmentTagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFragmentTagResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFragmentTagResponse*>(
               &_DeleteFragmentTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(DeleteFragmentTagResponse& a, DeleteFragmentTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFragmentTagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFragmentTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFragmentTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFragmentTagResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFragmentTagResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFragmentTagResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFragmentTagResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteFragmentTagResponse";
  }
  protected:
  explicit DeleteFragmentTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
  };
  // repeated .viam.app.v1.FragmentTag tags = 1 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::viam::app::v1::FragmentTag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >*
      mutable_tags();
  private:
  const ::viam::app::v1::FragmentTag& _internal_tags(int index) const;
  ::viam::app::v1::FragmentTag* _internal_add_tags();
  public:
  const ::viam::app::v1::FragmentTag& tags(int index) const;
  ::viam::app::v1::FragmentTag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >&
      tags() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteFragmentTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag > tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsRequest) */ {
 public:
  inline ListRobotsRequest() : ListRobotsRequest(nullptr) {}
  ~ListRobotsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsRequest(const ListRobotsRequest& from);
  ListRobotsRequest(ListRobotsRequest&& from) noexcept
    : ListRobotsRequest() {
    *this = ::std::move(from);
  }

  inline ListRobotsRequest& operator=(const ListRobotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsRequest& operator=(ListRobotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRobotsRequest*>(
               &_ListRobotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(ListRobotsRequest& a, ListRobotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsRequest";
  }
  protected:
  explicit ListRobotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsForLocationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsForLocationsRequest) */ {
 public:
  inline ListRobotsForLocationsRequest() : ListRobotsForLocationsRequest(nullptr) {}
  ~ListRobotsForLocationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsForLocationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsForLocationsRequest(const ListRobotsForLocationsRequest& from);
  ListRobotsForLocationsRequest(ListRobotsForLocationsRequest&& from) noexcept
    : ListRobotsForLocationsRequest() {
    *this = ::std::move(from);
  }

  inline ListRobotsForLocationsRequest& operator=(const ListRobotsForLocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsForLocationsRequest& operator=(ListRobotsForLocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsForLocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsForLocationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRobotsForLocationsRequest*>(
               &_ListRobotsForLocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(ListRobotsForLocationsRequest& a, ListRobotsForLocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsForLocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsForLocationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsForLocationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsForLocationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsForLocationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsForLocationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsForLocationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsForLocationsRequest";
  }
  protected:
  explicit ListRobotsForLocationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdsFieldNumber = 1,
  };
  // repeated string location_ids = 1 [json_name = "locationIds"];
  int location_ids_size() const;
  private:
  int _internal_location_ids_size() const;
  public:
  void clear_location_ids();
  const std::string& location_ids(int index) const;
  std::string* mutable_location_ids(int index);
  void set_location_ids(int index, const std::string& value);
  void set_location_ids(int index, std::string&& value);
  void set_location_ids(int index, const char* value);
  void set_location_ids(int index, const char* value, size_t size);
  std::string* add_location_ids();
  void add_location_ids(const std::string& value);
  void add_location_ids(std::string&& value);
  void add_location_ids(const char* value);
  void add_location_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& location_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_location_ids();
  private:
  const std::string& _internal_location_ids(int index) const;
  std::string* _internal_add_location_ids();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsForLocationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> location_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsForOrgRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsForOrgRequest) */ {
 public:
  inline ListRobotsForOrgRequest() : ListRobotsForOrgRequest(nullptr) {}
  ~ListRobotsForOrgRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsForOrgRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsForOrgRequest(const ListRobotsForOrgRequest& from);
  ListRobotsForOrgRequest(ListRobotsForOrgRequest&& from) noexcept
    : ListRobotsForOrgRequest() {
    *this = ::std::move(from);
  }

  inline ListRobotsForOrgRequest& operator=(const ListRobotsForOrgRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsForOrgRequest& operator=(ListRobotsForOrgRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsForOrgRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsForOrgRequest* internal_default_instance() {
    return reinterpret_cast<const ListRobotsForOrgRequest*>(
               &_ListRobotsForOrgRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(ListRobotsForOrgRequest& a, ListRobotsForOrgRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsForOrgRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsForOrgRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsForOrgRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsForOrgRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsForOrgRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsForOrgRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsForOrgRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsForOrgRequest";
  }
  protected:
  explicit ListRobotsForOrgRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsForOrgRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AdditionalFragment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AdditionalFragment) */ {
 public:
  inline AdditionalFragment() : AdditionalFragment(nullptr) {}
  ~AdditionalFragment() override;
  explicit PROTOBUF_CONSTEXPR AdditionalFragment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdditionalFragment(const AdditionalFragment& from);
  AdditionalFragment(AdditionalFragment&& from) noexcept
    : AdditionalFragment() {
    *this = ::std::move(from);
  }

  inline AdditionalFragment& operator=(const AdditionalFragment& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalFragment& operator=(AdditionalFragment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdditionalFragment& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdditionalFragment* internal_default_instance() {
    return reinterpret_cast<const AdditionalFragment*>(
               &_AdditionalFragment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(AdditionalFragment& a, AdditionalFragment& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalFragment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalFragment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdditionalFragment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdditionalFragment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdditionalFragment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdditionalFragment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalFragment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AdditionalFragment";
  }
  protected:
  explicit AdditionalFragment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string fragment_id = 1 [json_name = "fragmentId"];
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // optional string version = 2 [json_name = "version"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AdditionalFragment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListNestedFragmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListNestedFragmentsRequest) */ {
 public:
  inline ListNestedFragmentsRequest() : ListNestedFragmentsRequest(nullptr) {}
  ~ListNestedFragmentsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListNestedFragmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNestedFragmentsRequest(const ListNestedFragmentsRequest& from);
  ListNestedFragmentsRequest(ListNestedFragmentsRequest&& from) noexcept
    : ListNestedFragmentsRequest() {
    *this = ::std::move(from);
  }

  inline ListNestedFragmentsRequest& operator=(const ListNestedFragmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNestedFragmentsRequest& operator=(ListNestedFragmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNestedFragmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNestedFragmentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListNestedFragmentsRequest*>(
               &_ListNestedFragmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(ListNestedFragmentsRequest& a, ListNestedFragmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNestedFragmentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNestedFragmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNestedFragmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNestedFragmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNestedFragmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNestedFragmentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNestedFragmentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListNestedFragmentsRequest";
  }
  protected:
  explicit ListNestedFragmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalFragmentsFieldNumber = 2,
    kFragmentIdFieldNumber = 1,
  };
  // repeated .viam.app.v1.AdditionalFragment additional_fragments = 2 [json_name = "additionalFragments"];
  int additional_fragments_size() const;
  private:
  int _internal_additional_fragments_size() const;
  public:
  void clear_additional_fragments();
  ::viam::app::v1::AdditionalFragment* mutable_additional_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >*
      mutable_additional_fragments();
  private:
  const ::viam::app::v1::AdditionalFragment& _internal_additional_fragments(int index) const;
  ::viam::app::v1::AdditionalFragment* _internal_add_additional_fragments();
  public:
  const ::viam::app::v1::AdditionalFragment& additional_fragments(int index) const;
  ::viam::app::v1::AdditionalFragment* add_additional_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >&
      additional_fragments() const;

  // optional string fragment_id = 1 [json_name = "fragmentId"];
  bool has_fragment_id() const;
  private:
  bool _internal_has_fragment_id() const;
  public:
  void clear_fragment_id();
  const std::string& fragment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_id();
  PROTOBUF_NODISCARD std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListNestedFragmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment > additional_fragments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListNestedFragmentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListNestedFragmentsResponse) */ {
 public:
  inline ListNestedFragmentsResponse() : ListNestedFragmentsResponse(nullptr) {}
  ~ListNestedFragmentsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListNestedFragmentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNestedFragmentsResponse(const ListNestedFragmentsResponse& from);
  ListNestedFragmentsResponse(ListNestedFragmentsResponse&& from) noexcept
    : ListNestedFragmentsResponse() {
    *this = ::std::move(from);
  }

  inline ListNestedFragmentsResponse& operator=(const ListNestedFragmentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNestedFragmentsResponse& operator=(ListNestedFragmentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNestedFragmentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNestedFragmentsResponse* internal_default_instance() {
    return reinterpret_cast<const ListNestedFragmentsResponse*>(
               &_ListNestedFragmentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(ListNestedFragmentsResponse& a, ListNestedFragmentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNestedFragmentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNestedFragmentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNestedFragmentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNestedFragmentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNestedFragmentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNestedFragmentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNestedFragmentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListNestedFragmentsResponse";
  }
  protected:
  explicit ListNestedFragmentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 1,
    kResolvedFragmentsFieldNumber = 2,
  };
  // repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;
  public:
  void clear_fragments();
  ::viam::app::v1::Fragment* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
      mutable_fragments();
  private:
  const ::viam::app::v1::Fragment& _internal_fragments(int index) const;
  ::viam::app::v1::Fragment* _internal_add_fragments();
  public:
  const ::viam::app::v1::Fragment& fragments(int index) const;
  ::viam::app::v1::Fragment* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
      fragments() const;

  // repeated .viam.app.v1.ResolvedFragment resolved_fragments = 2 [json_name = "resolvedFragments"];
  int resolved_fragments_size() const;
  private:
  int _internal_resolved_fragments_size() const;
  public:
  void clear_resolved_fragments();
  ::viam::app::v1::ResolvedFragment* mutable_resolved_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >*
      mutable_resolved_fragments();
  private:
  const ::viam::app::v1::ResolvedFragment& _internal_resolved_fragments(int index) const;
  ::viam::app::v1::ResolvedFragment* _internal_add_resolved_fragments();
  public:
  const ::viam::app::v1::ResolvedFragment& resolved_fragments(int index) const;
  ::viam::app::v1::ResolvedFragment* add_resolved_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >&
      resolved_fragments() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListNestedFragmentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment > fragments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment > resolved_fragments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListMachineFragmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListMachineFragmentsRequest) */ {
 public:
  inline ListMachineFragmentsRequest() : ListMachineFragmentsRequest(nullptr) {}
  ~ListMachineFragmentsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListMachineFragmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMachineFragmentsRequest(const ListMachineFragmentsRequest& from);
  ListMachineFragmentsRequest(ListMachineFragmentsRequest&& from) noexcept
    : ListMachineFragmentsRequest() {
    *this = ::std::move(from);
  }

  inline ListMachineFragmentsRequest& operator=(const ListMachineFragmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMachineFragmentsRequest& operator=(ListMachineFragmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMachineFragmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMachineFragmentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListMachineFragmentsRequest*>(
               &_ListMachineFragmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(ListMachineFragmentsRequest& a, ListMachineFragmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMachineFragmentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMachineFragmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMachineFragmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMachineFragmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMachineFragmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListMachineFragmentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMachineFragmentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListMachineFragmentsRequest";
  }
  protected:
  explicit ListMachineFragmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalFragmentIdsFieldNumber = 2,
    kAdditionalFragmentsFieldNumber = 3,
    kMachineIdFieldNumber = 1,
  };
  // repeated string additional_fragment_ids = 2 [json_name = "additionalFragmentIds"];
  int additional_fragment_ids_size() const;
  private:
  int _internal_additional_fragment_ids_size() const;
  public:
  void clear_additional_fragment_ids();
  const std::string& additional_fragment_ids(int index) const;
  std::string* mutable_additional_fragment_ids(int index);
  void set_additional_fragment_ids(int index, const std::string& value);
  void set_additional_fragment_ids(int index, std::string&& value);
  void set_additional_fragment_ids(int index, const char* value);
  void set_additional_fragment_ids(int index, const char* value, size_t size);
  std::string* add_additional_fragment_ids();
  void add_additional_fragment_ids(const std::string& value);
  void add_additional_fragment_ids(std::string&& value);
  void add_additional_fragment_ids(const char* value);
  void add_additional_fragment_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& additional_fragment_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_additional_fragment_ids();
  private:
  const std::string& _internal_additional_fragment_ids(int index) const;
  std::string* _internal_add_additional_fragment_ids();
  public:

  // repeated .viam.app.v1.AdditionalFragment additional_fragments = 3 [json_name = "additionalFragments"];
  int additional_fragments_size() const;
  private:
  int _internal_additional_fragments_size() const;
  public:
  void clear_additional_fragments();
  ::viam::app::v1::AdditionalFragment* mutable_additional_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >*
      mutable_additional_fragments();
  private:
  const ::viam::app::v1::AdditionalFragment& _internal_additional_fragments(int index) const;
  ::viam::app::v1::AdditionalFragment* _internal_add_additional_fragments();
  public:
  const ::viam::app::v1::AdditionalFragment& additional_fragments(int index) const;
  ::viam::app::v1::AdditionalFragment* add_additional_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >&
      additional_fragments() const;

  // string machine_id = 1 [json_name = "machineId"];
  void clear_machine_id();
  const std::string& machine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_id();
  PROTOBUF_NODISCARD std::string* release_machine_id();
  void set_allocated_machine_id(std::string* machine_id);
  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(const std::string& value);
  std::string* _internal_mutable_machine_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListMachineFragmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> additional_fragment_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment > additional_fragments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListMachineFragmentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListMachineFragmentsResponse) */ {
 public:
  inline ListMachineFragmentsResponse() : ListMachineFragmentsResponse(nullptr) {}
  ~ListMachineFragmentsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListMachineFragmentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMachineFragmentsResponse(const ListMachineFragmentsResponse& from);
  ListMachineFragmentsResponse(ListMachineFragmentsResponse&& from) noexcept
    : ListMachineFragmentsResponse() {
    *this = ::std::move(from);
  }

  inline ListMachineFragmentsResponse& operator=(const ListMachineFragmentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMachineFragmentsResponse& operator=(ListMachineFragmentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMachineFragmentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMachineFragmentsResponse* internal_default_instance() {
    return reinterpret_cast<const ListMachineFragmentsResponse*>(
               &_ListMachineFragmentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(ListMachineFragmentsResponse& a, ListMachineFragmentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMachineFragmentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMachineFragmentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMachineFragmentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMachineFragmentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMachineFragmentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListMachineFragmentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMachineFragmentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListMachineFragmentsResponse";
  }
  protected:
  explicit ListMachineFragmentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 1,
    kResolvedFragmentsFieldNumber = 2,
  };
  // repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;
  public:
  void clear_fragments();
  ::viam::app::v1::Fragment* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
      mutable_fragments();
  private:
  const ::viam::app::v1::Fragment& _internal_fragments(int index) const;
  ::viam::app::v1::Fragment* _internal_add_fragments();
  public:
  const ::viam::app::v1::Fragment& fragments(int index) const;
  ::viam::app::v1::Fragment* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
      fragments() const;

  // repeated .viam.app.v1.ResolvedFragment resolved_fragments = 2 [json_name = "resolvedFragments"];
  int resolved_fragments_size() const;
  private:
  int _internal_resolved_fragments_size() const;
  public:
  void clear_resolved_fragments();
  ::viam::app::v1::ResolvedFragment* mutable_resolved_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >*
      mutable_resolved_fragments();
  private:
  const ::viam::app::v1::ResolvedFragment& _internal_resolved_fragments(int index) const;
  ::viam::app::v1::ResolvedFragment* _internal_add_resolved_fragments();
  public:
  const ::viam::app::v1::ResolvedFragment& resolved_fragments(int index) const;
  ::viam::app::v1::ResolvedFragment* add_resolved_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >&
      resolved_fragments() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListMachineFragmentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment > fragments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment > resolved_fragments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListMachineSummariesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListMachineSummariesRequest) */ {
 public:
  inline ListMachineSummariesRequest() : ListMachineSummariesRequest(nullptr) {}
  ~ListMachineSummariesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListMachineSummariesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMachineSummariesRequest(const ListMachineSummariesRequest& from);
  ListMachineSummariesRequest(ListMachineSummariesRequest&& from) noexcept
    : ListMachineSummariesRequest() {
    *this = ::std::move(from);
  }

  inline ListMachineSummariesRequest& operator=(const ListMachineSummariesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMachineSummariesRequest& operator=(ListMachineSummariesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMachineSummariesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMachineSummariesRequest* internal_default_instance() {
    return reinterpret_cast<const ListMachineSummariesRequest*>(
               &_ListMachineSummariesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(ListMachineSummariesRequest& a, ListMachineSummariesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMachineSummariesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMachineSummariesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMachineSummariesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMachineSummariesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMachineSummariesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListMachineSummariesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMachineSummariesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListMachineSummariesRequest";
  }
  protected:
  explicit ListMachineSummariesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdsFieldNumber = 2,
    kLocationIdsFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
    kLimitFieldNumber = 4,
  };
  // repeated string fragment_ids = 2 [json_name = "fragmentIds"];
  int fragment_ids_size() const;
  private:
  int _internal_fragment_ids_size() const;
  public:
  void clear_fragment_ids();
  const std::string& fragment_ids(int index) const;
  std::string* mutable_fragment_ids(int index);
  void set_fragment_ids(int index, const std::string& value);
  void set_fragment_ids(int index, std::string&& value);
  void set_fragment_ids(int index, const char* value);
  void set_fragment_ids(int index, const char* value, size_t size);
  std::string* add_fragment_ids();
  void add_fragment_ids(const std::string& value);
  void add_fragment_ids(std::string&& value);
  void add_fragment_ids(const char* value);
  void add_fragment_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fragment_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fragment_ids();
  private:
  const std::string& _internal_fragment_ids(int index) const;
  std::string* _internal_add_fragment_ids();
  public:

  // repeated string location_ids = 3 [json_name = "locationIds"];
  int location_ids_size() const;
  private:
  int _internal_location_ids_size() const;
  public:
  void clear_location_ids();
  const std::string& location_ids(int index) const;
  std::string* mutable_location_ids(int index);
  void set_location_ids(int index, const std::string& value);
  void set_location_ids(int index, std::string&& value);
  void set_location_ids(int index, const char* value);
  void set_location_ids(int index, const char* value, size_t size);
  std::string* add_location_ids();
  void add_location_ids(const std::string& value);
  void add_location_ids(std::string&& value);
  void add_location_ids(const char* value);
  void add_location_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& location_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_location_ids();
  private:
  const std::string& _internal_location_ids(int index) const;
  std::string* _internal_add_location_ids();
  public:

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // optional int32 limit = 4 [json_name = "limit"];
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListMachineSummariesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fragment_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> location_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  int32_t limit_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListMachineSummariesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListMachineSummariesResponse) */ {
 public:
  inline ListMachineSummariesResponse() : ListMachineSummariesResponse(nullptr) {}
  ~ListMachineSummariesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListMachineSummariesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMachineSummariesResponse(const ListMachineSummariesResponse& from);
  ListMachineSummariesResponse(ListMachineSummariesResponse&& from) noexcept
    : ListMachineSummariesResponse() {
    *this = ::std::move(from);
  }

  inline ListMachineSummariesResponse& operator=(const ListMachineSummariesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMachineSummariesResponse& operator=(ListMachineSummariesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMachineSummariesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMachineSummariesResponse* internal_default_instance() {
    return reinterpret_cast<const ListMachineSummariesResponse*>(
               &_ListMachineSummariesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(ListMachineSummariesResponse& a, ListMachineSummariesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMachineSummariesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMachineSummariesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMachineSummariesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMachineSummariesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMachineSummariesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListMachineSummariesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMachineSummariesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListMachineSummariesResponse";
  }
  protected:
  explicit ListMachineSummariesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationSummariesFieldNumber = 1,
  };
  // repeated .viam.app.v1.LocationSummary location_summaries = 1 [json_name = "locationSummaries"];
  int location_summaries_size() const;
  private:
  int _internal_location_summaries_size() const;
  public:
  void clear_location_summaries();
  ::viam::app::v1::LocationSummary* mutable_location_summaries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSummary >*
      mutable_location_summaries();
  private:
  const ::viam::app::v1::LocationSummary& _internal_location_summaries(int index) const;
  ::viam::app::v1::LocationSummary* _internal_add_location_summaries();
  public:
  const ::viam::app::v1::LocationSummary& location_summaries(int index) const;
  ::viam::app::v1::LocationSummary* add_location_summaries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSummary >&
      location_summaries() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListMachineSummariesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSummary > location_summaries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationSummary) */ {
 public:
  inline LocationSummary() : LocationSummary(nullptr) {}
  ~LocationSummary() override;
  explicit PROTOBUF_CONSTEXPR LocationSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationSummary(const LocationSummary& from);
  LocationSummary(LocationSummary&& from) noexcept
    : LocationSummary() {
    *this = ::std::move(from);
  }

  inline LocationSummary& operator=(const LocationSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationSummary& operator=(LocationSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationSummary* internal_default_instance() {
    return reinterpret_cast<const LocationSummary*>(
               &_LocationSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(LocationSummary& a, LocationSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationSummary";
  }
  protected:
  explicit LocationSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineSummariesFieldNumber = 3,
    kLocationIdFieldNumber = 1,
    kLocationNameFieldNumber = 2,
  };
  // repeated .viam.app.v1.MachineSummary machine_summaries = 3 [json_name = "machineSummaries"];
  int machine_summaries_size() const;
  private:
  int _internal_machine_summaries_size() const;
  public:
  void clear_machine_summaries();
  ::viam::app::v1::MachineSummary* mutable_machine_summaries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MachineSummary >*
      mutable_machine_summaries();
  private:
  const ::viam::app::v1::MachineSummary& _internal_machine_summaries(int index) const;
  ::viam::app::v1::MachineSummary* _internal_add_machine_summaries();
  public:
  const ::viam::app::v1::MachineSummary& machine_summaries(int index) const;
  ::viam::app::v1::MachineSummary* add_machine_summaries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MachineSummary >&
      machine_summaries() const;

  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string location_name = 2 [json_name = "locationName"];
  void clear_location_name();
  const std::string& location_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_name();
  PROTOBUF_NODISCARD std::string* release_location_name();
  void set_allocated_location_name(std::string* location_name);
  private:
  const std::string& _internal_location_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_name(const std::string& value);
  std::string* _internal_mutable_location_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MachineSummary > machine_summaries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MachineSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MachineSummary) */ {
 public:
  inline MachineSummary() : MachineSummary(nullptr) {}
  ~MachineSummary() override;
  explicit PROTOBUF_CONSTEXPR MachineSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MachineSummary(const MachineSummary& from);
  MachineSummary(MachineSummary&& from) noexcept
    : MachineSummary() {
    *this = ::std::move(from);
  }

  inline MachineSummary& operator=(const MachineSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline MachineSummary& operator=(MachineSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MachineSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const MachineSummary* internal_default_instance() {
    return reinterpret_cast<const MachineSummary*>(
               &_MachineSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(MachineSummary& a, MachineSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(MachineSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MachineSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MachineSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MachineSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MachineSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MachineSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MachineSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MachineSummary";
  }
  protected:
  explicit MachineSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartSummariesFieldNumber = 3,
    kMachineIdFieldNumber = 1,
    kMachineNameFieldNumber = 2,
  };
  // repeated .viam.app.v1.PartSummary part_summaries = 3 [json_name = "partSummaries"];
  int part_summaries_size() const;
  private:
  int _internal_part_summaries_size() const;
  public:
  void clear_part_summaries();
  ::viam::app::v1::PartSummary* mutable_part_summaries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PartSummary >*
      mutable_part_summaries();
  private:
  const ::viam::app::v1::PartSummary& _internal_part_summaries(int index) const;
  ::viam::app::v1::PartSummary* _internal_add_part_summaries();
  public:
  const ::viam::app::v1::PartSummary& part_summaries(int index) const;
  ::viam::app::v1::PartSummary* add_part_summaries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PartSummary >&
      part_summaries() const;

  // string machine_id = 1 [json_name = "machineId"];
  void clear_machine_id();
  const std::string& machine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_id();
  PROTOBUF_NODISCARD std::string* release_machine_id();
  void set_allocated_machine_id(std::string* machine_id);
  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(const std::string& value);
  std::string* _internal_mutable_machine_id();
  public:

  // string machine_name = 2 [json_name = "machineName"];
  void clear_machine_name();
  const std::string& machine_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_name();
  PROTOBUF_NODISCARD std::string* release_machine_name();
  void set_allocated_machine_name(std::string* machine_name);
  private:
  const std::string& _internal_machine_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_name(const std::string& value);
  std::string* _internal_mutable_machine_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MachineSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PartSummary > part_summaries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FragmentSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FragmentSummary) */ {
 public:
  inline FragmentSummary() : FragmentSummary(nullptr) {}
  ~FragmentSummary() override;
  explicit PROTOBUF_CONSTEXPR FragmentSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentSummary(const FragmentSummary& from);
  FragmentSummary(FragmentSummary&& from) noexcept
    : FragmentSummary() {
    *this = ::std::move(from);
  }

  inline FragmentSummary& operator=(const FragmentSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentSummary& operator=(FragmentSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentSummary* internal_default_instance() {
    return reinterpret_cast<const FragmentSummary*>(
               &_FragmentSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(FragmentSummary& a, FragmentSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FragmentSummary";
  }
  protected:
  explicit FragmentSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.FragmentSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ViamServerVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ViamServerVersion) */ {
 public:
  inline ViamServerVersion() : ViamServerVersion(nullptr) {}
  ~ViamServerVersion() override;
  explicit PROTOBUF_CONSTEXPR ViamServerVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViamServerVersion(const ViamServerVersion& from);
  ViamServerVersion(ViamServerVersion&& from) noexcept
    : ViamServerVersion() {
    *this = ::std::move(from);
  }

  inline ViamServerVersion& operator=(const ViamServerVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViamServerVersion& operator=(ViamServerVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViamServerVersion& default_instance() {
    return *internal_default_instance();
  }
  enum VersionCase {
    kMajor = 1,
    kMinor = 2,
    VERSION_NOT_SET = 0,
  };

  static inline const ViamServerVersion* internal_default_instance() {
    return reinterpret_cast<const ViamServerVersion*>(
               &_ViamServerVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(ViamServerVersion& a, ViamServerVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ViamServerVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViamServerVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViamServerVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViamServerVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViamServerVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ViamServerVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViamServerVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ViamServerVersion";
  }
  protected:
  explicit ViamServerVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
  };
  // string major = 1 [json_name = "major"];
  bool has_major() const;
  private:
  bool _internal_has_major() const;
  public:
  void clear_major();
  const std::string& major() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_major(ArgT0&& arg0, ArgT... args);
  std::string* mutable_major();
  PROTOBUF_NODISCARD std::string* release_major();
  void set_allocated_major(std::string* major);
  private:
  const std::string& _internal_major() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_major(const std::string& value);
  std::string* _internal_mutable_major();
  public:

  // string minor = 2 [json_name = "minor"];
  bool has_minor() const;
  private:
  bool _internal_has_minor() const;
  public:
  void clear_minor();
  const std::string& minor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minor();
  PROTOBUF_NODISCARD std::string* release_minor();
  void set_allocated_minor(std::string* minor);
  private:
  const std::string& _internal_minor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minor(const std::string& value);
  std::string* _internal_mutable_minor();
  public:

  void clear_version();
  VersionCase version_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.ViamServerVersion)
 private:
  class _Internal;
  void set_has_major();
  void set_has_minor();

  inline bool has_version() const;
  inline void clear_has_version();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union VersionUnion {
    constexpr VersionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr major_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minor_;
  } version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ViamAgentVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ViamAgentVersion) */ {
 public:
  inline ViamAgentVersion() : ViamAgentVersion(nullptr) {}
  ~ViamAgentVersion() override;
  explicit PROTOBUF_CONSTEXPR ViamAgentVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViamAgentVersion(const ViamAgentVersion& from);
  ViamAgentVersion(ViamAgentVersion&& from) noexcept
    : ViamAgentVersion() {
    *this = ::std::move(from);
  }

  inline ViamAgentVersion& operator=(const ViamAgentVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViamAgentVersion& operator=(ViamAgentVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViamAgentVersion& default_instance() {
    return *internal_default_instance();
  }
  enum VersionCase {
    kMajor = 1,
    kMinor = 2,
    VERSION_NOT_SET = 0,
  };

  static inline const ViamAgentVersion* internal_default_instance() {
    return reinterpret_cast<const ViamAgentVersion*>(
               &_ViamAgentVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(ViamAgentVersion& a, ViamAgentVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ViamAgentVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViamAgentVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViamAgentVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViamAgentVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViamAgentVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ViamAgentVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViamAgentVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ViamAgentVersion";
  }
  protected:
  explicit ViamAgentVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
  };
  // string major = 1 [json_name = "major"];
  bool has_major() const;
  private:
  bool _internal_has_major() const;
  public:
  void clear_major();
  const std::string& major() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_major(ArgT0&& arg0, ArgT... args);
  std::string* mutable_major();
  PROTOBUF_NODISCARD std::string* release_major();
  void set_allocated_major(std::string* major);
  private:
  const std::string& _internal_major() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_major(const std::string& value);
  std::string* _internal_mutable_major();
  public:

  // string minor = 2 [json_name = "minor"];
  bool has_minor() const;
  private:
  bool _internal_has_minor() const;
  public:
  void clear_minor();
  const std::string& minor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minor();
  PROTOBUF_NODISCARD std::string* release_minor();
  void set_allocated_minor(std::string* minor);
  private:
  const std::string& _internal_minor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minor(const std::string& value);
  std::string* _internal_mutable_minor();
  public:

  void clear_version();
  VersionCase version_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.ViamAgentVersion)
 private:
  class _Internal;
  void set_has_major();
  void set_has_minor();

  inline bool has_version() const;
  inline void clear_has_version();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union VersionUnion {
    constexpr VersionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr major_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minor_;
  } version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class PartSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.PartSummary) */ {
 public:
  inline PartSummary() : PartSummary(nullptr) {}
  ~PartSummary() override;
  explicit PROTOBUF_CONSTEXPR PartSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartSummary(const PartSummary& from);
  PartSummary(PartSummary&& from) noexcept
    : PartSummary() {
    *this = ::std::move(from);
  }

  inline PartSummary& operator=(const PartSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartSummary& operator=(PartSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartSummary* internal_default_instance() {
    return reinterpret_cast<const PartSummary*>(
               &_PartSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(PartSummary& a, PartSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(PartSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.PartSummary";
  }
  protected:
  explicit PartSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 9,
    kPartIdFieldNumber = 1,
    kPartNameFieldNumber = 2,
    kOsFieldNumber = 6,
    kPlatformFieldNumber = 7,
    kPublicIpAddressFieldNumber = 8,
    kDnsNameFieldNumber = 10,
    kLastOnlineFieldNumber = 3,
    kViamServerVersionFieldNumber = 4,
    kViamAgentVersionFieldNumber = 5,
    kLastAccessFieldNumber = 14,
    kIsMainPartFieldNumber = 11,
    kOnlineStateFieldNumber = 12,
    kSecondsSinceOnlineFieldNumber = 13,
  };
  // repeated .viam.app.v1.FragmentSummary fragments = 9 [json_name = "fragments"];
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;
  public:
  void clear_fragments();
  ::viam::app::v1::FragmentSummary* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentSummary >*
      mutable_fragments();
  private:
  const ::viam::app::v1::FragmentSummary& _internal_fragments(int index) const;
  ::viam::app::v1::FragmentSummary* _internal_add_fragments();
  public:
  const ::viam::app::v1::FragmentSummary& fragments(int index) const;
  ::viam::app::v1::FragmentSummary* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentSummary >&
      fragments() const;

  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string part_name = 2 [json_name = "partName"];
  void clear_part_name();
  const std::string& part_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_name();
  PROTOBUF_NODISCARD std::string* release_part_name();
  void set_allocated_part_name(std::string* part_name);
  private:
  const std::string& _internal_part_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_name(const std::string& value);
  std::string* _internal_mutable_part_name();
  public:

  // optional string os = 6 [json_name = "os"];
  bool has_os() const;
  private:
  bool _internal_has_os() const;
  public:
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // optional string platform = 7 [json_name = "platform"];
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional string public_ip_address = 8 [json_name = "publicIpAddress"];
  bool has_public_ip_address() const;
  private:
  bool _internal_has_public_ip_address() const;
  public:
  void clear_public_ip_address();
  const std::string& public_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_ip_address();
  PROTOBUF_NODISCARD std::string* release_public_ip_address();
  void set_allocated_public_ip_address(std::string* public_ip_address);
  private:
  const std::string& _internal_public_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_ip_address(const std::string& value);
  std::string* _internal_mutable_public_ip_address();
  public:

  // optional string dns_name = 10 [json_name = "dnsName"];
  bool has_dns_name() const;
  private:
  bool _internal_has_dns_name() const;
  public:
  void clear_dns_name();
  const std::string& dns_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dns_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dns_name();
  PROTOBUF_NODISCARD std::string* release_dns_name();
  void set_allocated_dns_name(std::string* dns_name);
  private:
  const std::string& _internal_dns_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns_name(const std::string& value);
  std::string* _internal_mutable_dns_name();
  public:

  // optional .google.protobuf.Timestamp last_online = 3 [json_name = "lastOnline"];
  bool has_last_online() const;
  private:
  bool _internal_has_last_online() const;
  public:
  void clear_last_online();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_online() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_online();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_online();
  void set_allocated_last_online(::PROTOBUF_NAMESPACE_ID::Timestamp* last_online);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_online() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_online();
  public:
  void unsafe_arena_set_allocated_last_online(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_online);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_online();

  // optional .viam.app.v1.ViamServerVersion viam_server_version = 4 [json_name = "viamServerVersion"];
  bool has_viam_server_version() const;
  private:
  bool _internal_has_viam_server_version() const;
  public:
  void clear_viam_server_version();
  const ::viam::app::v1::ViamServerVersion& viam_server_version() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ViamServerVersion* release_viam_server_version();
  ::viam::app::v1::ViamServerVersion* mutable_viam_server_version();
  void set_allocated_viam_server_version(::viam::app::v1::ViamServerVersion* viam_server_version);
  private:
  const ::viam::app::v1::ViamServerVersion& _internal_viam_server_version() const;
  ::viam::app::v1::ViamServerVersion* _internal_mutable_viam_server_version();
  public:
  void unsafe_arena_set_allocated_viam_server_version(
      ::viam::app::v1::ViamServerVersion* viam_server_version);
  ::viam::app::v1::ViamServerVersion* unsafe_arena_release_viam_server_version();

  // optional .viam.app.v1.ViamAgentVersion viam_agent_version = 5 [json_name = "viamAgentVersion"];
  bool has_viam_agent_version() const;
  private:
  bool _internal_has_viam_agent_version() const;
  public:
  void clear_viam_agent_version();
  const ::viam::app::v1::ViamAgentVersion& viam_agent_version() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ViamAgentVersion* release_viam_agent_version();
  ::viam::app::v1::ViamAgentVersion* mutable_viam_agent_version();
  void set_allocated_viam_agent_version(::viam::app::v1::ViamAgentVersion* viam_agent_version);
  private:
  const ::viam::app::v1::ViamAgentVersion& _internal_viam_agent_version() const;
  ::viam::app::v1::ViamAgentVersion* _internal_mutable_viam_agent_version();
  public:
  void unsafe_arena_set_allocated_viam_agent_version(
      ::viam::app::v1::ViamAgentVersion* viam_agent_version);
  ::viam::app::v1::ViamAgentVersion* unsafe_arena_release_viam_agent_version();

  // optional .google.protobuf.Timestamp last_access = 14 [json_name = "lastAccess"];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // bool is_main_part = 11 [json_name = "isMainPart"];
  void clear_is_main_part();
  bool is_main_part() const;
  void set_is_main_part(bool value);
  private:
  bool _internal_is_main_part() const;
  void _internal_set_is_main_part(bool value);
  public:

  // .viam.app.v1.OnlineState online_state = 12 [json_name = "onlineState"];
  void clear_online_state();
  ::viam::app::v1::OnlineState online_state() const;
  void set_online_state(::viam::app::v1::OnlineState value);
  private:
  ::viam::app::v1::OnlineState _internal_online_state() const;
  void _internal_set_online_state(::viam::app::v1::OnlineState value);
  public:

  // int64 seconds_since_online = 13 [json_name = "secondsSinceOnline"];
  void clear_seconds_since_online();
  int64_t seconds_since_online() const;
  void set_seconds_since_online(int64_t value);
  private:
  int64_t _internal_seconds_since_online() const;
  void _internal_set_seconds_since_online(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.PartSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentSummary > fragments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dns_name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_online_;
  ::viam::app::v1::ViamServerVersion* viam_server_version_;
  ::viam::app::v1::ViamAgentVersion* viam_agent_version_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
  bool is_main_part_;
  int online_state_;
  int64_t seconds_since_online_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsResponse) */ {
 public:
  inline ListRobotsResponse() : ListRobotsResponse(nullptr) {}
  ~ListRobotsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsResponse(const ListRobotsResponse& from);
  ListRobotsResponse(ListRobotsResponse&& from) noexcept
    : ListRobotsResponse() {
    *this = ::std::move(from);
  }

  inline ListRobotsResponse& operator=(const ListRobotsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsResponse& operator=(ListRobotsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRobotsResponse*>(
               &_ListRobotsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    156;

  friend void swap(ListRobotsResponse& a, ListRobotsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsResponse";
  }
  protected:
  explicit ListRobotsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
  int robots_size() const;
  private:
  int _internal_robots_size() const;
  public:
  void clear_robots();
  ::viam::app::v1::Robot* mutable_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
      mutable_robots();
  private:
  const ::viam::app::v1::Robot& _internal_robots(int index) const;
  ::viam::app::v1::Robot* _internal_add_robots();
  public:
  const ::viam::app::v1::Robot& robots(int index) const;
  ::viam::app::v1::Robot* add_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
      robots() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot > robots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsForLocationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsForLocationsResponse) */ {
 public:
  inline ListRobotsForLocationsResponse() : ListRobotsForLocationsResponse(nullptr) {}
  ~ListRobotsForLocationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsForLocationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsForLocationsResponse(const ListRobotsForLocationsResponse& from);
  ListRobotsForLocationsResponse(ListRobotsForLocationsResponse&& from) noexcept
    : ListRobotsForLocationsResponse() {
    *this = ::std::move(from);
  }

  inline ListRobotsForLocationsResponse& operator=(const ListRobotsForLocationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsForLocationsResponse& operator=(ListRobotsForLocationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsForLocationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsForLocationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRobotsForLocationsResponse*>(
               &_ListRobotsForLocationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    157;

  friend void swap(ListRobotsForLocationsResponse& a, ListRobotsForLocationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsForLocationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsForLocationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsForLocationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsForLocationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsForLocationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsForLocationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsForLocationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsForLocationsResponse";
  }
  protected:
  explicit ListRobotsForLocationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
  int robots_size() const;
  private:
  int _internal_robots_size() const;
  public:
  void clear_robots();
  ::viam::app::v1::Robot* mutable_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
      mutable_robots();
  private:
  const ::viam::app::v1::Robot& _internal_robots(int index) const;
  ::viam::app::v1::Robot* _internal_add_robots();
  public:
  const ::viam::app::v1::Robot& robots(int index) const;
  ::viam::app::v1::Robot* add_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
      robots() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsForLocationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot > robots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsForOrgResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsForOrgResponse) */ {
 public:
  inline ListRobotsForOrgResponse() : ListRobotsForOrgResponse(nullptr) {}
  ~ListRobotsForOrgResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsForOrgResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsForOrgResponse(const ListRobotsForOrgResponse& from);
  ListRobotsForOrgResponse(ListRobotsForOrgResponse&& from) noexcept
    : ListRobotsForOrgResponse() {
    *this = ::std::move(from);
  }

  inline ListRobotsForOrgResponse& operator=(const ListRobotsForOrgResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsForOrgResponse& operator=(ListRobotsForOrgResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsForOrgResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsForOrgResponse* internal_default_instance() {
    return reinterpret_cast<const ListRobotsForOrgResponse*>(
               &_ListRobotsForOrgResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    158;

  friend void swap(ListRobotsForOrgResponse& a, ListRobotsForOrgResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsForOrgResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsForOrgResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsForOrgResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsForOrgResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsForOrgResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsForOrgResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsForOrgResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsForOrgResponse";
  }
  protected:
  explicit ListRobotsForOrgResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
  int robots_size() const;
  private:
  int _internal_robots_size() const;
  public:
  void clear_robots();
  ::viam::app::v1::Robot* mutable_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
      mutable_robots();
  private:
  const ::viam::app::v1::Robot& _internal_robots(int index) const;
  ::viam::app::v1::Robot* _internal_add_robots();
  public:
  const ::viam::app::v1::Robot& robots(int index) const;
  ::viam::app::v1::Robot* add_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
      robots() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsForOrgResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot > robots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotRequest) */ {
 public:
  inline NewRobotRequest() : NewRobotRequest(nullptr) {}
  ~NewRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR NewRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotRequest(const NewRobotRequest& from);
  NewRobotRequest(NewRobotRequest&& from) noexcept
    : NewRobotRequest() {
    *this = ::std::move(from);
  }

  inline NewRobotRequest& operator=(const NewRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotRequest& operator=(NewRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotRequest* internal_default_instance() {
    return reinterpret_cast<const NewRobotRequest*>(
               &_NewRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    159;

  friend void swap(NewRobotRequest& a, NewRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotRequest";
  }
  protected:
  explicit NewRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 2 [json_name = "location"];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotResponse) */ {
 public:
  inline NewRobotResponse() : NewRobotResponse(nullptr) {}
  ~NewRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR NewRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotResponse(const NewRobotResponse& from);
  NewRobotResponse(NewRobotResponse&& from) noexcept
    : NewRobotResponse() {
    *this = ::std::move(from);
  }

  inline NewRobotResponse& operator=(const NewRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotResponse& operator=(NewRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotResponse* internal_default_instance() {
    return reinterpret_cast<const NewRobotResponse*>(
               &_NewRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    160;

  friend void swap(NewRobotResponse& a, NewRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotResponse";
  }
  protected:
  explicit NewRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotRequest) */ {
 public:
  inline UpdateRobotRequest() : UpdateRobotRequest(nullptr) {}
  ~UpdateRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotRequest(const UpdateRobotRequest& from);
  UpdateRobotRequest(UpdateRobotRequest&& from) noexcept
    : UpdateRobotRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotRequest& operator=(const UpdateRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotRequest& operator=(UpdateRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotRequest*>(
               &_UpdateRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    161;

  friend void swap(UpdateRobotRequest& a, UpdateRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotRequest";
  }
  protected:
  explicit UpdateRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLocationFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 3 [json_name = "location"];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotResponse) */ {
 public:
  inline UpdateRobotResponse() : UpdateRobotResponse(nullptr) {}
  ~UpdateRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotResponse(const UpdateRobotResponse& from);
  UpdateRobotResponse(UpdateRobotResponse&& from) noexcept
    : UpdateRobotResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotResponse& operator=(const UpdateRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotResponse& operator=(UpdateRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotResponse*>(
               &_UpdateRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    162;

  friend void swap(UpdateRobotResponse& a, UpdateRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotResponse";
  }
  protected:
  explicit UpdateRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // .viam.app.v1.Robot robot = 1 [json_name = "robot"];
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::viam::app::v1::Robot& robot() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Robot* release_robot();
  ::viam::app::v1::Robot* mutable_robot();
  void set_allocated_robot(::viam::app::v1::Robot* robot);
  private:
  const ::viam::app::v1::Robot& _internal_robot() const;
  ::viam::app::v1::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::viam::app::v1::Robot* robot);
  ::viam::app::v1::Robot* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Robot* robot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotRequest) */ {
 public:
  inline DeleteRobotRequest() : DeleteRobotRequest(nullptr) {}
  ~DeleteRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotRequest(const DeleteRobotRequest& from);
  DeleteRobotRequest(DeleteRobotRequest&& from) noexcept
    : DeleteRobotRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotRequest& operator=(const DeleteRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotRequest& operator=(DeleteRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotRequest*>(
               &_DeleteRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    163;

  friend void swap(DeleteRobotRequest& a, DeleteRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotRequest";
  }
  protected:
  explicit DeleteRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotResponse) */ {
 public:
  inline DeleteRobotResponse() : DeleteRobotResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotResponse(const DeleteRobotResponse& from);
  DeleteRobotResponse(DeleteRobotResponse&& from) noexcept
    : DeleteRobotResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotResponse& operator=(const DeleteRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotResponse& operator=(DeleteRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotResponse*>(
               &_DeleteRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    164;

  friend void swap(DeleteRobotResponse& a, DeleteRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotResponse";
  }
  protected:
  explicit DeleteRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotMetadataRequest) */ {
 public:
  inline GetRobotMetadataRequest() : GetRobotMetadataRequest(nullptr) {}
  ~GetRobotMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotMetadataRequest(const GetRobotMetadataRequest& from);
  GetRobotMetadataRequest(GetRobotMetadataRequest&& from) noexcept
    : GetRobotMetadataRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotMetadataRequest& operator=(const GetRobotMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotMetadataRequest& operator=(GetRobotMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotMetadataRequest*>(
               &_GetRobotMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    165;

  friend void swap(GetRobotMetadataRequest& a, GetRobotMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotMetadataRequest";
  }
  protected:
  explicit GetRobotMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotMetadataResponse) */ {
 public:
  inline GetRobotMetadataResponse() : GetRobotMetadataResponse(nullptr) {}
  ~GetRobotMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotMetadataResponse(const GetRobotMetadataResponse& from);
  GetRobotMetadataResponse(GetRobotMetadataResponse&& from) noexcept
    : GetRobotMetadataResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotMetadataResponse& operator=(const GetRobotMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotMetadataResponse& operator=(GetRobotMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotMetadataResponse*>(
               &_GetRobotMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    166;

  friend void swap(GetRobotMetadataResponse& a, GetRobotMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotMetadataResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotMetadataResponse";
  }
  protected:
  explicit GetRobotMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .google.protobuf.Struct data = 1 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotMetadataRequest) */ {
 public:
  inline UpdateRobotMetadataRequest() : UpdateRobotMetadataRequest(nullptr) {}
  ~UpdateRobotMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotMetadataRequest(const UpdateRobotMetadataRequest& from);
  UpdateRobotMetadataRequest(UpdateRobotMetadataRequest&& from) noexcept
    : UpdateRobotMetadataRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotMetadataRequest& operator=(const UpdateRobotMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotMetadataRequest& operator=(UpdateRobotMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotMetadataRequest*>(
               &_UpdateRobotMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    167;

  friend void swap(UpdateRobotMetadataRequest& a, UpdateRobotMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotMetadataRequest";
  }
  protected:
  explicit UpdateRobotMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Struct data = 2 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotMetadataResponse) */ {
 public:
  inline UpdateRobotMetadataResponse() : UpdateRobotMetadataResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateRobotMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotMetadataResponse(const UpdateRobotMetadataResponse& from);
  UpdateRobotMetadataResponse(UpdateRobotMetadataResponse&& from) noexcept
    : UpdateRobotMetadataResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotMetadataResponse& operator=(const UpdateRobotMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotMetadataResponse& operator=(UpdateRobotMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotMetadataResponse*>(
               &_UpdateRobotMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    168;

  friend void swap(UpdateRobotMetadataResponse& a, UpdateRobotMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRobotMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRobotMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotMetadataResponse";
  }
  protected:
  explicit UpdateRobotMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartAsMainRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartAsMainRequest) */ {
 public:
  inline MarkPartAsMainRequest() : MarkPartAsMainRequest(nullptr) {}
  ~MarkPartAsMainRequest() override;
  explicit PROTOBUF_CONSTEXPR MarkPartAsMainRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartAsMainRequest(const MarkPartAsMainRequest& from);
  MarkPartAsMainRequest(MarkPartAsMainRequest&& from) noexcept
    : MarkPartAsMainRequest() {
    *this = ::std::move(from);
  }

  inline MarkPartAsMainRequest& operator=(const MarkPartAsMainRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartAsMainRequest& operator=(MarkPartAsMainRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartAsMainRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartAsMainRequest* internal_default_instance() {
    return reinterpret_cast<const MarkPartAsMainRequest*>(
               &_MarkPartAsMainRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    169;

  friend void swap(MarkPartAsMainRequest& a, MarkPartAsMainRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartAsMainRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartAsMainRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartAsMainRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartAsMainRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkPartAsMainRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarkPartAsMainRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkPartAsMainRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartAsMainRequest";
  }
  protected:
  explicit MarkPartAsMainRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartAsMainRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartAsMainResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartAsMainResponse) */ {
 public:
  inline MarkPartAsMainResponse() : MarkPartAsMainResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MarkPartAsMainResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartAsMainResponse(const MarkPartAsMainResponse& from);
  MarkPartAsMainResponse(MarkPartAsMainResponse&& from) noexcept
    : MarkPartAsMainResponse() {
    *this = ::std::move(from);
  }

  inline MarkPartAsMainResponse& operator=(const MarkPartAsMainResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartAsMainResponse& operator=(MarkPartAsMainResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartAsMainResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartAsMainResponse* internal_default_instance() {
    return reinterpret_cast<const MarkPartAsMainResponse*>(
               &_MarkPartAsMainResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    170;

  friend void swap(MarkPartAsMainResponse& a, MarkPartAsMainResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartAsMainResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartAsMainResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartAsMainResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartAsMainResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MarkPartAsMainResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MarkPartAsMainResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartAsMainResponse";
  }
  protected:
  explicit MarkPartAsMainResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartAsMainResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartForRestartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartForRestartRequest) */ {
 public:
  inline MarkPartForRestartRequest() : MarkPartForRestartRequest(nullptr) {}
  ~MarkPartForRestartRequest() override;
  explicit PROTOBUF_CONSTEXPR MarkPartForRestartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartForRestartRequest(const MarkPartForRestartRequest& from);
  MarkPartForRestartRequest(MarkPartForRestartRequest&& from) noexcept
    : MarkPartForRestartRequest() {
    *this = ::std::move(from);
  }

  inline MarkPartForRestartRequest& operator=(const MarkPartForRestartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartForRestartRequest& operator=(MarkPartForRestartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartForRestartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartForRestartRequest* internal_default_instance() {
    return reinterpret_cast<const MarkPartForRestartRequest*>(
               &_MarkPartForRestartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    171;

  friend void swap(MarkPartForRestartRequest& a, MarkPartForRestartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartForRestartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartForRestartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartForRestartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartForRestartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkPartForRestartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarkPartForRestartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkPartForRestartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartForRestartRequest";
  }
  protected:
  explicit MarkPartForRestartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartForRestartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartForRestartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartForRestartResponse) */ {
 public:
  inline MarkPartForRestartResponse() : MarkPartForRestartResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MarkPartForRestartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartForRestartResponse(const MarkPartForRestartResponse& from);
  MarkPartForRestartResponse(MarkPartForRestartResponse&& from) noexcept
    : MarkPartForRestartResponse() {
    *this = ::std::move(from);
  }

  inline MarkPartForRestartResponse& operator=(const MarkPartForRestartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartForRestartResponse& operator=(MarkPartForRestartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartForRestartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartForRestartResponse* internal_default_instance() {
    return reinterpret_cast<const MarkPartForRestartResponse*>(
               &_MarkPartForRestartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    172;

  friend void swap(MarkPartForRestartResponse& a, MarkPartForRestartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartForRestartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartForRestartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartForRestartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartForRestartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MarkPartForRestartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MarkPartForRestartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartForRestartResponse";
  }
  protected:
  explicit MarkPartForRestartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartForRestartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRobotPartSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRobotPartSecretRequest) */ {
 public:
  inline CreateRobotPartSecretRequest() : CreateRobotPartSecretRequest(nullptr) {}
  ~CreateRobotPartSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRobotPartSecretRequest(const CreateRobotPartSecretRequest& from);
  CreateRobotPartSecretRequest(CreateRobotPartSecretRequest&& from) noexcept
    : CreateRobotPartSecretRequest() {
    *this = ::std::move(from);
  }

  inline CreateRobotPartSecretRequest& operator=(const CreateRobotPartSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRobotPartSecretRequest& operator=(CreateRobotPartSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRobotPartSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRobotPartSecretRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRobotPartSecretRequest*>(
               &_CreateRobotPartSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    173;

  friend void swap(CreateRobotPartSecretRequest& a, CreateRobotPartSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRobotPartSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRobotPartSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRobotPartSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRobotPartSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRobotPartSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRobotPartSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRobotPartSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRobotPartSecretRequest";
  }
  protected:
  explicit CreateRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRobotPartSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRobotPartSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRobotPartSecretResponse) */ {
 public:
  inline CreateRobotPartSecretResponse() : CreateRobotPartSecretResponse(nullptr) {}
  ~CreateRobotPartSecretResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRobotPartSecretResponse(const CreateRobotPartSecretResponse& from);
  CreateRobotPartSecretResponse(CreateRobotPartSecretResponse&& from) noexcept
    : CreateRobotPartSecretResponse() {
    *this = ::std::move(from);
  }

  inline CreateRobotPartSecretResponse& operator=(const CreateRobotPartSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRobotPartSecretResponse& operator=(CreateRobotPartSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRobotPartSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRobotPartSecretResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRobotPartSecretResponse*>(
               &_CreateRobotPartSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    174;

  friend void swap(CreateRobotPartSecretResponse& a, CreateRobotPartSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRobotPartSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRobotPartSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRobotPartSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRobotPartSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRobotPartSecretResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRobotPartSecretResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRobotPartSecretResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRobotPartSecretResponse";
  }
  protected:
  explicit CreateRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRobotPartSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RobotPart* part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartSecretRequest) */ {
 public:
  inline DeleteRobotPartSecretRequest() : DeleteRobotPartSecretRequest(nullptr) {}
  ~DeleteRobotPartSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartSecretRequest(const DeleteRobotPartSecretRequest& from);
  DeleteRobotPartSecretRequest(DeleteRobotPartSecretRequest&& from) noexcept
    : DeleteRobotPartSecretRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartSecretRequest& operator=(const DeleteRobotPartSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartSecretRequest& operator=(DeleteRobotPartSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartSecretRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartSecretRequest*>(
               &_DeleteRobotPartSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    175;

  friend void swap(DeleteRobotPartSecretRequest& a, DeleteRobotPartSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotPartSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRobotPartSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotPartSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartSecretRequest";
  }
  protected:
  explicit DeleteRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
    kSecretIdFieldNumber = 2,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string secret_id = 2 [json_name = "secretId"];
  void clear_secret_id();
  const std::string& secret_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* secret_id);
  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(const std::string& value);
  std::string* _internal_mutable_secret_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartSecretResponse) */ {
 public:
  inline DeleteRobotPartSecretResponse() : DeleteRobotPartSecretResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartSecretResponse(const DeleteRobotPartSecretResponse& from);
  DeleteRobotPartSecretResponse(DeleteRobotPartSecretResponse&& from) noexcept
    : DeleteRobotPartSecretResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartSecretResponse& operator=(const DeleteRobotPartSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartSecretResponse& operator=(DeleteRobotPartSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartSecretResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartSecretResponse*>(
               &_DeleteRobotPartSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    176;

  friend void swap(DeleteRobotPartSecretResponse& a, DeleteRobotPartSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotPartSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotPartSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartSecretResponse";
  }
  protected:
  explicit DeleteRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Authorization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Authorization) */ {
 public:
  inline Authorization() : Authorization(nullptr) {}
  ~Authorization() override;
  explicit PROTOBUF_CONSTEXPR Authorization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Authorization(const Authorization& from);
  Authorization(Authorization&& from) noexcept
    : Authorization() {
    *this = ::std::move(from);
  }

  inline Authorization& operator=(const Authorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Authorization& operator=(Authorization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Authorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const Authorization* internal_default_instance() {
    return reinterpret_cast<const Authorization*>(
               &_Authorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    177;

  friend void swap(Authorization& a, Authorization& b) {
    a.Swap(&b);
  }
  inline void Swap(Authorization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Authorization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Authorization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Authorization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Authorization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Authorization& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authorization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Authorization";
  }
  protected:
  explicit Authorization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationTypeFieldNumber = 1,
    kAuthorizationIdFieldNumber = 2,
    kResourceTypeFieldNumber = 3,
    kResourceIdFieldNumber = 4,
    kIdentityIdFieldNumber = 5,
    kOrganizationIdFieldNumber = 6,
    kIdentityTypeFieldNumber = 7,
  };
  // string authorization_type = 1 [json_name = "authorizationType"];
  void clear_authorization_type();
  const std::string& authorization_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_type();
  PROTOBUF_NODISCARD std::string* release_authorization_type();
  void set_allocated_authorization_type(std::string* authorization_type);
  private:
  const std::string& _internal_authorization_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_type(const std::string& value);
  std::string* _internal_mutable_authorization_type();
  public:

  // string authorization_id = 2 [json_name = "authorizationId"];
  void clear_authorization_id();
  const std::string& authorization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_id();
  PROTOBUF_NODISCARD std::string* release_authorization_id();
  void set_allocated_authorization_id(std::string* authorization_id);
  private:
  const std::string& _internal_authorization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_id(const std::string& value);
  std::string* _internal_mutable_authorization_id();
  public:

  // string resource_type = 3 [json_name = "resourceType"];
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string resource_id = 4 [json_name = "resourceId"];
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string identity_id = 5 [json_name = "identityId"];
  void clear_identity_id();
  const std::string& identity_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity_id();
  PROTOBUF_NODISCARD std::string* release_identity_id();
  void set_allocated_identity_id(std::string* identity_id);
  private:
  const std::string& _internal_identity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_id(const std::string& value);
  std::string* _internal_mutable_identity_id();
  public:

  // string organization_id = 6 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string identity_type = 7 [json_name = "identityType"];
  void clear_identity_type();
  const std::string& identity_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity_type();
  PROTOBUF_NODISCARD std::string* release_identity_type();
  void set_allocated_identity_type(std::string* identity_type);
  private:
  const std::string& _internal_identity_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_type(const std::string& value);
  std::string* _internal_mutable_identity_type();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Authorization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AddRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AddRoleRequest) */ {
 public:
  inline AddRoleRequest() : AddRoleRequest(nullptr) {}
  ~AddRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR AddRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRoleRequest(const AddRoleRequest& from);
  AddRoleRequest(AddRoleRequest&& from) noexcept
    : AddRoleRequest() {
    *this = ::std::move(from);
  }

  inline AddRoleRequest& operator=(const AddRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRoleRequest& operator=(AddRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRoleRequest* internal_default_instance() {
    return reinterpret_cast<const AddRoleRequest*>(
               &_AddRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    178;

  friend void swap(AddRoleRequest& a, AddRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddRoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AddRoleRequest";
  }
  protected:
  explicit AddRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationFieldNumber = 1,
  };
  // .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
  bool has_authorization() const;
  private:
  bool _internal_has_authorization() const;
  public:
  void clear_authorization();
  const ::viam::app::v1::Authorization& authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_authorization();
  ::viam::app::v1::Authorization* mutable_authorization();
  void set_allocated_authorization(::viam::app::v1::Authorization* authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_authorization();
  public:
  void unsafe_arena_set_allocated_authorization(
      ::viam::app::v1::Authorization* authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_authorization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.AddRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Authorization* authorization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AddRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.AddRoleResponse) */ {
 public:
  inline AddRoleResponse() : AddRoleResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRoleResponse(const AddRoleResponse& from);
  AddRoleResponse(AddRoleResponse&& from) noexcept
    : AddRoleResponse() {
    *this = ::std::move(from);
  }

  inline AddRoleResponse& operator=(const AddRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRoleResponse& operator=(AddRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRoleResponse* internal_default_instance() {
    return reinterpret_cast<const AddRoleResponse*>(
               &_AddRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    179;

  friend void swap(AddRoleResponse& a, AddRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AddRoleResponse";
  }
  protected:
  explicit AddRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.AddRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RemoveRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoveRoleRequest) */ {
 public:
  inline RemoveRoleRequest() : RemoveRoleRequest(nullptr) {}
  ~RemoveRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRoleRequest(const RemoveRoleRequest& from);
  RemoveRoleRequest(RemoveRoleRequest&& from) noexcept
    : RemoveRoleRequest() {
    *this = ::std::move(from);
  }

  inline RemoveRoleRequest& operator=(const RemoveRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRoleRequest& operator=(RemoveRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRoleRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveRoleRequest*>(
               &_RemoveRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    180;

  friend void swap(RemoveRoleRequest& a, RemoveRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveRoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RemoveRoleRequest";
  }
  protected:
  explicit RemoveRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationFieldNumber = 1,
  };
  // .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
  bool has_authorization() const;
  private:
  bool _internal_has_authorization() const;
  public:
  void clear_authorization();
  const ::viam::app::v1::Authorization& authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_authorization();
  ::viam::app::v1::Authorization* mutable_authorization();
  void set_allocated_authorization(::viam::app::v1::Authorization* authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_authorization();
  public:
  void unsafe_arena_set_allocated_authorization(
      ::viam::app::v1::Authorization* authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_authorization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoveRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Authorization* authorization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RemoveRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoveRoleResponse) */ {
 public:
  inline RemoveRoleResponse() : RemoveRoleResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RemoveRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRoleResponse(const RemoveRoleResponse& from);
  RemoveRoleResponse(RemoveRoleResponse&& from) noexcept
    : RemoveRoleResponse() {
    *this = ::std::move(from);
  }

  inline RemoveRoleResponse& operator=(const RemoveRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRoleResponse& operator=(RemoveRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRoleResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveRoleResponse*>(
               &_RemoveRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    181;

  friend void swap(RemoveRoleResponse& a, RemoveRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RemoveRoleResponse";
  }
  protected:
  explicit RemoveRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoveRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ChangeRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ChangeRoleRequest) */ {
 public:
  inline ChangeRoleRequest() : ChangeRoleRequest(nullptr) {}
  ~ChangeRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR ChangeRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeRoleRequest(const ChangeRoleRequest& from);
  ChangeRoleRequest(ChangeRoleRequest&& from) noexcept
    : ChangeRoleRequest() {
    *this = ::std::move(from);
  }

  inline ChangeRoleRequest& operator=(const ChangeRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeRoleRequest& operator=(ChangeRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeRoleRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeRoleRequest*>(
               &_ChangeRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    182;

  friend void swap(ChangeRoleRequest& a, ChangeRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeRoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ChangeRoleRequest";
  }
  protected:
  explicit ChangeRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldAuthorizationFieldNumber = 1,
    kNewAuthorizationFieldNumber = 2,
  };
  // .viam.app.v1.Authorization old_authorization = 1 [json_name = "oldAuthorization"];
  bool has_old_authorization() const;
  private:
  bool _internal_has_old_authorization() const;
  public:
  void clear_old_authorization();
  const ::viam::app::v1::Authorization& old_authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_old_authorization();
  ::viam::app::v1::Authorization* mutable_old_authorization();
  void set_allocated_old_authorization(::viam::app::v1::Authorization* old_authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_old_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_old_authorization();
  public:
  void unsafe_arena_set_allocated_old_authorization(
      ::viam::app::v1::Authorization* old_authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_old_authorization();

  // .viam.app.v1.Authorization new_authorization = 2 [json_name = "newAuthorization"];
  bool has_new_authorization() const;
  private:
  bool _internal_has_new_authorization() const;
  public:
  void clear_new_authorization();
  const ::viam::app::v1::Authorization& new_authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_new_authorization();
  ::viam::app::v1::Authorization* mutable_new_authorization();
  void set_allocated_new_authorization(::viam::app::v1::Authorization* new_authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_new_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_new_authorization();
  public:
  void unsafe_arena_set_allocated_new_authorization(
      ::viam::app::v1::Authorization* new_authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_new_authorization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ChangeRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Authorization* old_authorization_;
  ::viam::app::v1::Authorization* new_authorization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ChangeRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.ChangeRoleResponse) */ {
 public:
  inline ChangeRoleResponse() : ChangeRoleResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ChangeRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeRoleResponse(const ChangeRoleResponse& from);
  ChangeRoleResponse(ChangeRoleResponse&& from) noexcept
    : ChangeRoleResponse() {
    *this = ::std::move(from);
  }

  inline ChangeRoleResponse& operator=(const ChangeRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeRoleResponse& operator=(ChangeRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeRoleResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeRoleResponse*>(
               &_ChangeRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    183;

  friend void swap(ChangeRoleResponse& a, ChangeRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeRoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChangeRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChangeRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ChangeRoleResponse";
  }
  protected:
  explicit ChangeRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.ChangeRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListAuthorizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListAuthorizationsRequest) */ {
 public:
  inline ListAuthorizationsRequest() : ListAuthorizationsRequest(nullptr) {}
  ~ListAuthorizationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAuthorizationsRequest(const ListAuthorizationsRequest& from);
  ListAuthorizationsRequest(ListAuthorizationsRequest&& from) noexcept
    : ListAuthorizationsRequest() {
    *this = ::std::move(from);
  }

  inline ListAuthorizationsRequest& operator=(const ListAuthorizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAuthorizationsRequest& operator=(ListAuthorizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAuthorizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAuthorizationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAuthorizationsRequest*>(
               &_ListAuthorizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    184;

  friend void swap(ListAuthorizationsRequest& a, ListAuthorizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAuthorizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAuthorizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAuthorizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAuthorizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAuthorizationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAuthorizationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAuthorizationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListAuthorizationsRequest";
  }
  protected:
  explicit ListAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceIdsFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // repeated string resource_ids = 2 [json_name = "resourceIds"];
  int resource_ids_size() const;
  private:
  int _internal_resource_ids_size() const;
  public:
  void clear_resource_ids();
  const std::string& resource_ids(int index) const;
  std::string* mutable_resource_ids(int index);
  void set_resource_ids(int index, const std::string& value);
  void set_resource_ids(int index, std::string&& value);
  void set_resource_ids(int index, const char* value);
  void set_resource_ids(int index, const char* value, size_t size);
  std::string* add_resource_ids();
  void add_resource_ids(const std::string& value);
  void add_resource_ids(std::string&& value);
  void add_resource_ids(const char* value);
  void add_resource_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& resource_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_resource_ids();
  private:
  const std::string& _internal_resource_ids(int index) const;
  std::string* _internal_add_resource_ids();
  public:

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListAuthorizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> resource_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListAuthorizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListAuthorizationsResponse) */ {
 public:
  inline ListAuthorizationsResponse() : ListAuthorizationsResponse(nullptr) {}
  ~ListAuthorizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAuthorizationsResponse(const ListAuthorizationsResponse& from);
  ListAuthorizationsResponse(ListAuthorizationsResponse&& from) noexcept
    : ListAuthorizationsResponse() {
    *this = ::std::move(from);
  }

  inline ListAuthorizationsResponse& operator=(const ListAuthorizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAuthorizationsResponse& operator=(ListAuthorizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAuthorizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAuthorizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAuthorizationsResponse*>(
               &_ListAuthorizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    185;

  friend void swap(ListAuthorizationsResponse& a, ListAuthorizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAuthorizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAuthorizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAuthorizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAuthorizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAuthorizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAuthorizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAuthorizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListAuthorizationsResponse";
  }
  protected:
  explicit ListAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListAuthorizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CheckPermissionsRequest) */ {
 public:
  inline CheckPermissionsRequest() : CheckPermissionsRequest(nullptr) {}
  ~CheckPermissionsRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckPermissionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckPermissionsRequest(const CheckPermissionsRequest& from);
  CheckPermissionsRequest(CheckPermissionsRequest&& from) noexcept
    : CheckPermissionsRequest() {
    *this = ::std::move(from);
  }

  inline CheckPermissionsRequest& operator=(const CheckPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionsRequest& operator=(CheckPermissionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermissionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionsRequest*>(
               &_CheckPermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    186;

  friend void swap(CheckPermissionsRequest& a, CheckPermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermissionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermissionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckPermissionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckPermissionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CheckPermissionsRequest";
  }
  protected:
  explicit CheckPermissionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .viam.app.v1.AuthorizedPermissions permissions = 1 [json_name = "permissions"];
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::viam::app::v1::AuthorizedPermissions* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
      mutable_permissions();
  private:
  const ::viam::app::v1::AuthorizedPermissions& _internal_permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* _internal_add_permissions();
  public:
  const ::viam::app::v1::AuthorizedPermissions& permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
      permissions() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.CheckPermissionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions > permissions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AuthorizedPermissions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthorizedPermissions) */ {
 public:
  inline AuthorizedPermissions() : AuthorizedPermissions(nullptr) {}
  ~AuthorizedPermissions() override;
  explicit PROTOBUF_CONSTEXPR AuthorizedPermissions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizedPermissions(const AuthorizedPermissions& from);
  AuthorizedPermissions(AuthorizedPermissions&& from) noexcept
    : AuthorizedPermissions() {
    *this = ::std::move(from);
  }

  inline AuthorizedPermissions& operator=(const AuthorizedPermissions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizedPermissions& operator=(AuthorizedPermissions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizedPermissions& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizedPermissions* internal_default_instance() {
    return reinterpret_cast<const AuthorizedPermissions*>(
               &_AuthorizedPermissions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    187;

  friend void swap(AuthorizedPermissions& a, AuthorizedPermissions& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizedPermissions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizedPermissions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizedPermissions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizedPermissions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizedPermissions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthorizedPermissions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizedPermissions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AuthorizedPermissions";
  }
  protected:
  explicit AuthorizedPermissions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 3,
    kResourceTypeFieldNumber = 1,
    kResourceIdFieldNumber = 2,
  };
  // repeated string permissions = 3 [json_name = "permissions"];
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  const std::string& permissions(int index) const;
  std::string* mutable_permissions(int index);
  void set_permissions(int index, const std::string& value);
  void set_permissions(int index, std::string&& value);
  void set_permissions(int index, const char* value);
  void set_permissions(int index, const char* value, size_t size);
  std::string* add_permissions();
  void add_permissions(const std::string& value);
  void add_permissions(std::string&& value);
  void add_permissions(const char* value);
  void add_permissions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_permissions();
  private:
  const std::string& _internal_permissions(int index) const;
  std::string* _internal_add_permissions();
  public:

  // string resource_type = 1 [json_name = "resourceType"];
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string resource_id = 2 [json_name = "resourceId"];
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthorizedPermissions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CheckPermissionsResponse) */ {
 public:
  inline CheckPermissionsResponse() : CheckPermissionsResponse(nullptr) {}
  ~CheckPermissionsResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckPermissionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckPermissionsResponse(const CheckPermissionsResponse& from);
  CheckPermissionsResponse(CheckPermissionsResponse&& from) noexcept
    : CheckPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline CheckPermissionsResponse& operator=(const CheckPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionsResponse& operator=(CheckPermissionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionsResponse*>(
               &_CheckPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    188;

  friend void swap(CheckPermissionsResponse& a, CheckPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermissionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermissionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckPermissionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckPermissionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CheckPermissionsResponse";
  }
  protected:
  explicit CheckPermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizedPermissionsFieldNumber = 1,
  };
  // repeated .viam.app.v1.AuthorizedPermissions authorized_permissions = 1 [json_name = "authorizedPermissions"];
  int authorized_permissions_size() const;
  private:
  int _internal_authorized_permissions_size() const;
  public:
  void clear_authorized_permissions();
  ::viam::app::v1::AuthorizedPermissions* mutable_authorized_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
      mutable_authorized_permissions();
  private:
  const ::viam::app::v1::AuthorizedPermissions& _internal_authorized_permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* _internal_add_authorized_permissions();
  public:
  const ::viam::app::v1::AuthorizedPermissions& authorized_permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* add_authorized_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
      authorized_permissions() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.CheckPermissionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions > authorized_permissions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ModuleVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleVersion) */ {
 public:
  inline ModuleVersion() : ModuleVersion(nullptr) {}
  ~ModuleVersion() override;
  explicit PROTOBUF_CONSTEXPR ModuleVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleVersion(const ModuleVersion& from);
  ModuleVersion(ModuleVersion&& from) noexcept
    : ModuleVersion() {
    *this = ::std::move(from);
  }

  inline ModuleVersion& operator=(const ModuleVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleVersion& operator=(ModuleVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleVersion* internal_default_instance() {
    return reinterpret_cast<const ModuleVersion*>(
               &_ModuleVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    189;

  friend void swap(ModuleVersion& a, ModuleVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ModuleVersion";
  }
  protected:
  explicit ModuleVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 2,
    kModelsFieldNumber = 3,
    kAppsFieldNumber = 7,
    kVersionFieldNumber = 1,
    kEntrypointFieldNumber = 4,
    kFirstRunFieldNumber = 5,
    kMarkdownDescriptionFieldNumber = 6,
  };
  // repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::viam::app::v1::Uploads* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
      mutable_files();
  private:
  const ::viam::app::v1::Uploads& _internal_files(int index) const;
  ::viam::app::v1::Uploads* _internal_add_files();
  public:
  const ::viam::app::v1::Uploads& files(int index) const;
  ::viam::app::v1::Uploads* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
      files() const;

  // repeated .viam.app.v1.Model models = 3 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // repeated .viam.app.v1.App apps = 7 [json_name = "apps"];
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::viam::app::v1::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
      mutable_apps();
  private:
  const ::viam::app::v1::App& _internal_apps(int index) const;
  ::viam::app::v1::App* _internal_add_apps();
  public:
  const ::viam::app::v1::App& apps(int index) const;
  ::viam::app::v1::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
      apps() const;

  // string version = 1 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string entrypoint = 4 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // optional string first_run = 5 [json_name = "firstRun"];
  bool has_first_run() const;
  private:
  bool _internal_has_first_run() const;
  public:
  void clear_first_run();
  const std::string& first_run() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_run(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_run();
  PROTOBUF_NODISCARD std::string* release_first_run();
  void set_allocated_first_run(std::string* first_run);
  private:
  const std::string& _internal_first_run() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_run(const std::string& value);
  std::string* _internal_mutable_first_run();
  public:

  // optional string markdown_description = 6 [json_name = "markdownDescription"];
  bool has_markdown_description() const;
  private:
  bool _internal_has_markdown_description() const;
  public:
  void clear_markdown_description();
  const std::string& markdown_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_markdown_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_markdown_description();
  PROTOBUF_NODISCARD std::string* release_markdown_description();
  void set_allocated_markdown_description(std::string* markdown_description);
  private:
  const std::string& _internal_markdown_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_markdown_description(const std::string& value);
  std::string* _internal_mutable_markdown_description();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App > apps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_run_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr markdown_description_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ModuleMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleMetadata) */ {
 public:
  inline ModuleMetadata() : ModuleMetadata(nullptr) {}
  ~ModuleMetadata() override;
  explicit PROTOBUF_CONSTEXPR ModuleMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleMetadata(const ModuleMetadata& from);
  ModuleMetadata(ModuleMetadata&& from) noexcept
    : ModuleMetadata() {
    *this = ::std::move(from);
  }

  inline ModuleMetadata& operator=(const ModuleMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleMetadata& operator=(ModuleMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleMetadata* internal_default_instance() {
    return reinterpret_cast<const ModuleMetadata*>(
               &_ModuleMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    190;

  friend void swap(ModuleMetadata& a, ModuleMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ModuleMetadata";
  }
  protected:
  explicit ModuleMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
    kVersionsFieldNumber = 2,
    kAppsFieldNumber = 6,
    kEntrypointFieldNumber = 3,
    kFirstRunFieldNumber = 4,
    kMarkdownDescriptionFieldNumber = 5,
    kSourceTypeFieldNumber = 7,
    kLanguageFieldNumber = 8,
  };
  // repeated .viam.app.v1.Model models = 1 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // repeated .viam.app.v1.ModuleVersion versions = 2 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  ::viam::app::v1::ModuleVersion* mutable_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >*
      mutable_versions();
  private:
  const ::viam::app::v1::ModuleVersion& _internal_versions(int index) const;
  ::viam::app::v1::ModuleVersion* _internal_add_versions();
  public:
  const ::viam::app::v1::ModuleVersion& versions(int index) const;
  ::viam::app::v1::ModuleVersion* add_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >&
      versions() const;

  // repeated .viam.app.v1.App apps = 6 [json_name = "apps"];
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::viam::app::v1::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
      mutable_apps();
  private:
  const ::viam::app::v1::App& _internal_apps(int index) const;
  ::viam::app::v1::App* _internal_add_apps();
  public:
  const ::viam::app::v1::App& apps(int index) const;
  ::viam::app::v1::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
      apps() const;

  // string entrypoint = 3 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // optional string first_run = 4 [json_name = "firstRun"];
  bool has_first_run() const;
  private:
  bool _internal_has_first_run() const;
  public:
  void clear_first_run();
  const std::string& first_run() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_run(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_run();
  PROTOBUF_NODISCARD std::string* release_first_run();
  void set_allocated_first_run(std::string* first_run);
  private:
  const std::string& _internal_first_run() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_run(const std::string& value);
  std::string* _internal_mutable_first_run();
  public:

  // optional string markdown_description = 5 [json_name = "markdownDescription"];
  bool has_markdown_description() const;
  private:
  bool _internal_has_markdown_description() const;
  public:
  void clear_markdown_description();
  const std::string& markdown_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_markdown_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_markdown_description();
  PROTOBUF_NODISCARD std::string* release_markdown_description();
  void set_allocated_markdown_description(std::string* markdown_description);
  private:
  const std::string& _internal_markdown_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_markdown_description(const std::string& value);
  std::string* _internal_mutable_markdown_description();
  public:

  // optional .viam.app.v1.ModuleSourceType source_type = 7 [json_name = "sourceType"];
  bool has_source_type() const;
  private:
  bool _internal_has_source_type() const;
  public:
  void clear_source_type();
  ::viam::app::v1::ModuleSourceType source_type() const;
  void set_source_type(::viam::app::v1::ModuleSourceType value);
  private:
  ::viam::app::v1::ModuleSourceType _internal_source_type() const;
  void _internal_set_source_type(::viam::app::v1::ModuleSourceType value);
  public:

  // optional .viam.app.v1.ModuleLanguage language = 8 [json_name = "language"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  ::viam::app::v1::ModuleLanguage language() const;
  void set_language(::viam::app::v1::ModuleLanguage value);
  private:
  ::viam::app::v1::ModuleLanguage _internal_language() const;
  void _internal_set_language(::viam::app::v1::ModuleLanguage value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion > versions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App > apps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_run_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr markdown_description_;
  int source_type_;
  int language_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MLModelMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MLModelMetadata) */ {
 public:
  inline MLModelMetadata() : MLModelMetadata(nullptr) {}
  ~MLModelMetadata() override;
  explicit PROTOBUF_CONSTEXPR MLModelMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLModelMetadata(const MLModelMetadata& from);
  MLModelMetadata(MLModelMetadata&& from) noexcept
    : MLModelMetadata() {
    *this = ::std::move(from);
  }

  inline MLModelMetadata& operator=(const MLModelMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLModelMetadata& operator=(MLModelMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLModelMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLModelMetadata* internal_default_instance() {
    return reinterpret_cast<const MLModelMetadata*>(
               &_MLModelMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    191;

  friend void swap(MLModelMetadata& a, MLModelMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MLModelMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLModelMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLModelMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLModelMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLModelMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MLModelMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLModelMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MLModelMetadata";
  }
  protected:
  explicit MLModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 1,
    kModelTypeFieldNumber = 2,
    kModelFrameworkFieldNumber = 3,
  };
  // repeated string versions = 1 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // .viam.app.mltraining.v1.ModelType model_type = 2 [json_name = "modelType"];
  void clear_model_type();
  ::viam::app::mltraining::v1::ModelType model_type() const;
  void set_model_type(::viam::app::mltraining::v1::ModelType value);
  private:
  ::viam::app::mltraining::v1::ModelType _internal_model_type() const;
  void _internal_set_model_type(::viam::app::mltraining::v1::ModelType value);
  public:

  // .viam.app.mltraining.v1.ModelFramework model_framework = 3 [json_name = "modelFramework"];
  void clear_model_framework();
  ::viam::app::mltraining::v1::ModelFramework model_framework() const;
  void set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  private:
  ::viam::app::mltraining::v1::ModelFramework _internal_model_framework() const;
  void _internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MLModelMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
  int model_type_;
  int model_framework_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MLTrainingVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MLTrainingVersion) */ {
 public:
  inline MLTrainingVersion() : MLTrainingVersion(nullptr) {}
  ~MLTrainingVersion() override;
  explicit PROTOBUF_CONSTEXPR MLTrainingVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLTrainingVersion(const MLTrainingVersion& from);
  MLTrainingVersion(MLTrainingVersion&& from) noexcept
    : MLTrainingVersion() {
    *this = ::std::move(from);
  }

  inline MLTrainingVersion& operator=(const MLTrainingVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLTrainingVersion& operator=(MLTrainingVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLTrainingVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLTrainingVersion* internal_default_instance() {
    return reinterpret_cast<const MLTrainingVersion*>(
               &_MLTrainingVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    192;

  friend void swap(MLTrainingVersion& a, MLTrainingVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(MLTrainingVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLTrainingVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLTrainingVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLTrainingVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLTrainingVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MLTrainingVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLTrainingVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MLTrainingVersion";
  }
  protected:
  explicit MLTrainingVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kCreatedOnFieldNumber = 2,
  };
  // string version = 1 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .google.protobuf.Timestamp created_on = 2 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.MLTrainingVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MLTrainingMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MLTrainingMetadata) */ {
 public:
  inline MLTrainingMetadata() : MLTrainingMetadata(nullptr) {}
  ~MLTrainingMetadata() override;
  explicit PROTOBUF_CONSTEXPR MLTrainingMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLTrainingMetadata(const MLTrainingMetadata& from);
  MLTrainingMetadata(MLTrainingMetadata&& from) noexcept
    : MLTrainingMetadata() {
    *this = ::std::move(from);
  }

  inline MLTrainingMetadata& operator=(const MLTrainingMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLTrainingMetadata& operator=(MLTrainingMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLTrainingMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLTrainingMetadata* internal_default_instance() {
    return reinterpret_cast<const MLTrainingMetadata*>(
               &_MLTrainingMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    193;

  friend void swap(MLTrainingMetadata& a, MLTrainingMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MLTrainingMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLTrainingMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLTrainingMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLTrainingMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLTrainingMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MLTrainingMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLTrainingMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MLTrainingMetadata";
  }
  protected:
  explicit MLTrainingMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 5,
    kModelTypeFieldNumber = 2,
    kModelFrameworkFieldNumber = 3,
    kDraftFieldNumber = 4,
  };
  // repeated .viam.app.v1.MLTrainingVersion versions = 5 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  ::viam::app::v1::MLTrainingVersion* mutable_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MLTrainingVersion >*
      mutable_versions();
  private:
  const ::viam::app::v1::MLTrainingVersion& _internal_versions(int index) const;
  ::viam::app::v1::MLTrainingVersion* _internal_add_versions();
  public:
  const ::viam::app::v1::MLTrainingVersion& versions(int index) const;
  ::viam::app::v1::MLTrainingVersion* add_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MLTrainingVersion >&
      versions() const;

  // .viam.app.mltraining.v1.ModelType model_type = 2 [json_name = "modelType"];
  void clear_model_type();
  ::viam::app::mltraining::v1::ModelType model_type() const;
  void set_model_type(::viam::app::mltraining::v1::ModelType value);
  private:
  ::viam::app::mltraining::v1::ModelType _internal_model_type() const;
  void _internal_set_model_type(::viam::app::mltraining::v1::ModelType value);
  public:

  // .viam.app.mltraining.v1.ModelFramework model_framework = 3 [json_name = "modelFramework"];
  void clear_model_framework();
  ::viam::app::mltraining::v1::ModelFramework model_framework() const;
  void set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  private:
  ::viam::app::mltraining::v1::ModelFramework _internal_model_framework() const;
  void _internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  public:

  // bool draft = 4 [json_name = "draft"];
  void clear_draft();
  bool draft() const;
  void set_draft(bool value);
  private:
  bool _internal_draft() const;
  void _internal_set_draft(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MLTrainingMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MLTrainingVersion > versions_;
  int model_type_;
  int model_framework_;
  bool draft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RegistryItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RegistryItem) */ {
 public:
  inline RegistryItem() : RegistryItem(nullptr) {}
  ~RegistryItem() override;
  explicit PROTOBUF_CONSTEXPR RegistryItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryItem(const RegistryItem& from);
  RegistryItem(RegistryItem&& from) noexcept
    : RegistryItem() {
    *this = ::std::move(from);
  }

  inline RegistryItem& operator=(const RegistryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryItem& operator=(RegistryItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryItem& default_instance() {
    return *internal_default_instance();
  }
  enum MetadataCase {
    kModuleMetadata = 11,
    kMlModelMetadata = 12,
    kMlTrainingMetadata = 18,
    METADATA_NOT_SET = 0,
  };

  static inline const RegistryItem* internal_default_instance() {
    return reinterpret_cast<const RegistryItem*>(
               &_RegistryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    194;

  friend void swap(RegistryItem& a, RegistryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegistryItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RegistryItem";
  }
  protected:
  explicit RegistryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
    kPublicNamespaceFieldNumber = 3,
    kNameFieldNumber = 4,
    kUrlFieldNumber = 7,
    kDescriptionFieldNumber = 8,
    kCreatedAtFieldNumber = 15,
    kUpdatedAtFieldNumber = 16,
    kTypeFieldNumber = 5,
    kVisibilityFieldNumber = 6,
    kTotalRobotUsageFieldNumber = 9,
    kTotalOrganizationUsageFieldNumber = 10,
    kTotalExternalRobotUsageFieldNumber = 13,
    kTotalExternalOrganizationUsageFieldNumber = 14,
    kModuleMetadataFieldNumber = 11,
    kMlModelMetadataFieldNumber = 12,
    kMlTrainingMetadataFieldNumber = 18,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string public_namespace = 3 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // string name = 4 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 7 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 8 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Timestamp created_at = 15 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 16 [json_name = "updatedAt"];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .viam.app.packages.v1.PackageType type = 5 [json_name = "type"];
  void clear_type();
  ::viam::app::packages::v1::PackageType type() const;
  void set_type(::viam::app::packages::v1::PackageType value);
  private:
  ::viam::app::packages::v1::PackageType _internal_type() const;
  void _internal_set_type(::viam::app::packages::v1::PackageType value);
  public:

  // .viam.app.v1.Visibility visibility = 6 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // int64 total_robot_usage = 9 [json_name = "totalRobotUsage"];
  void clear_total_robot_usage();
  int64_t total_robot_usage() const;
  void set_total_robot_usage(int64_t value);
  private:
  int64_t _internal_total_robot_usage() const;
  void _internal_set_total_robot_usage(int64_t value);
  public:

  // int64 total_organization_usage = 10 [json_name = "totalOrganizationUsage"];
  void clear_total_organization_usage();
  int64_t total_organization_usage() const;
  void set_total_organization_usage(int64_t value);
  private:
  int64_t _internal_total_organization_usage() const;
  void _internal_set_total_organization_usage(int64_t value);
  public:

  // int64 total_external_robot_usage = 13 [json_name = "totalExternalRobotUsage"];
  void clear_total_external_robot_usage();
  int64_t total_external_robot_usage() const;
  void set_total_external_robot_usage(int64_t value);
  private:
  int64_t _internal_total_external_robot_usage() const;
  void _internal_set_total_external_robot_usage(int64_t value);
  public:

  // int64 total_external_organization_usage = 14 [json_name = "totalExternalOrganizationUsage"];
  void clear_total_external_organization_usage();
  int64_t total_external_organization_usage() const;
  void set_total_external_organization_usage(int64_t value);
  private:
  int64_t _internal_total_external_organization_usage() const;
  void _internal_set_total_external_organization_usage(int64_t value);
  public:

  // .viam.app.v1.ModuleMetadata module_metadata = 11 [json_name = "moduleMetadata"];
  bool has_module_metadata() const;
  private:
  bool _internal_has_module_metadata() const;
  public:
  void clear_module_metadata();
  const ::viam::app::v1::ModuleMetadata& module_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ModuleMetadata* release_module_metadata();
  ::viam::app::v1::ModuleMetadata* mutable_module_metadata();
  void set_allocated_module_metadata(::viam::app::v1::ModuleMetadata* module_metadata);
  private:
  const ::viam::app::v1::ModuleMetadata& _internal_module_metadata() const;
  ::viam::app::v1::ModuleMetadata* _internal_mutable_module_metadata();
  public:
  void unsafe_arena_set_allocated_module_metadata(
      ::viam::app::v1::ModuleMetadata* module_metadata);
  ::viam::app::v1::ModuleMetadata* unsafe_arena_release_module_metadata();

  // .viam.app.v1.MLModelMetadata ml_model_metadata = 12 [json_name = "mlModelMetadata"];
  bool has_ml_model_metadata() const;
  private:
  bool _internal_has_ml_model_metadata() const;
  public:
  void clear_ml_model_metadata();
  const ::viam::app::v1::MLModelMetadata& ml_model_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::MLModelMetadata* release_ml_model_metadata();
  ::viam::app::v1::MLModelMetadata* mutable_ml_model_metadata();
  void set_allocated_ml_model_metadata(::viam::app::v1::MLModelMetadata* ml_model_metadata);
  private:
  const ::viam::app::v1::MLModelMetadata& _internal_ml_model_metadata() const;
  ::viam::app::v1::MLModelMetadata* _internal_mutable_ml_model_metadata();
  public:
  void unsafe_arena_set_allocated_ml_model_metadata(
      ::viam::app::v1::MLModelMetadata* ml_model_metadata);
  ::viam::app::v1::MLModelMetadata* unsafe_arena_release_ml_model_metadata();

  // .viam.app.v1.MLTrainingMetadata ml_training_metadata = 18 [json_name = "mlTrainingMetadata"];
  bool has_ml_training_metadata() const;
  private:
  bool _internal_has_ml_training_metadata() const;
  public:
  void clear_ml_training_metadata();
  const ::viam::app::v1::MLTrainingMetadata& ml_training_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::MLTrainingMetadata* release_ml_training_metadata();
  ::viam::app::v1::MLTrainingMetadata* mutable_ml_training_metadata();
  void set_allocated_ml_training_metadata(::viam::app::v1::MLTrainingMetadata* ml_training_metadata);
  private:
  const ::viam::app::v1::MLTrainingMetadata& _internal_ml_training_metadata() const;
  ::viam::app::v1::MLTrainingMetadata* _internal_mutable_ml_training_metadata();
  public:
  void unsafe_arena_set_allocated_ml_training_metadata(
      ::viam::app::v1::MLTrainingMetadata* ml_training_metadata);
  ::viam::app::v1::MLTrainingMetadata* unsafe_arena_release_ml_training_metadata();

  void clear_metadata();
  MetadataCase metadata_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.RegistryItem)
 private:
  class _Internal;
  void set_has_module_metadata();
  void set_has_ml_model_metadata();
  void set_has_ml_training_metadata();

  inline bool has_metadata() const;
  inline void clear_has_metadata();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  int type_;
  int visibility_;
  int64_t total_robot_usage_;
  int64_t total_organization_usage_;
  int64_t total_external_robot_usage_;
  int64_t total_external_organization_usage_;
  union MetadataUnion {
    constexpr MetadataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::viam::app::v1::ModuleMetadata* module_metadata_;
    ::viam::app::v1::MLModelMetadata* ml_model_metadata_;
    ::viam::app::v1::MLTrainingMetadata* ml_training_metadata_;
  } metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRegistryItemRequest) */ {
 public:
  inline GetRegistryItemRequest() : GetRegistryItemRequest(nullptr) {}
  ~GetRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegistryItemRequest(const GetRegistryItemRequest& from);
  GetRegistryItemRequest(GetRegistryItemRequest&& from) noexcept
    : GetRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline GetRegistryItemRequest& operator=(const GetRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegistryItemRequest& operator=(GetRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegistryItemRequest*>(
               &_GetRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    195;

  friend void swap(GetRegistryItemRequest& a, GetRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRegistryItemRequest";
  }
  protected:
  explicit GetRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kIncludeMarkdownDocumentationFieldNumber = 2,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // optional bool include_markdown_documentation = 2 [json_name = "includeMarkdownDocumentation"];
  bool has_include_markdown_documentation() const;
  private:
  bool _internal_has_include_markdown_documentation() const;
  public:
  void clear_include_markdown_documentation();
  bool include_markdown_documentation() const;
  void set_include_markdown_documentation(bool value);
  private:
  bool _internal_include_markdown_documentation() const;
  void _internal_set_include_markdown_documentation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  bool include_markdown_documentation_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRegistryItemResponse) */ {
 public:
  inline GetRegistryItemResponse() : GetRegistryItemResponse(nullptr) {}
  ~GetRegistryItemResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegistryItemResponse(const GetRegistryItemResponse& from);
  GetRegistryItemResponse(GetRegistryItemResponse&& from) noexcept
    : GetRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline GetRegistryItemResponse& operator=(const GetRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegistryItemResponse& operator=(GetRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const GetRegistryItemResponse*>(
               &_GetRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    196;

  friend void swap(GetRegistryItemResponse& a, GetRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegistryItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRegistryItemResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegistryItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRegistryItemResponse";
  }
  protected:
  explicit GetRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .viam.app.v1.RegistryItem item = 1 [json_name = "item"];
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::viam::app::v1::RegistryItem& item() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RegistryItem* release_item();
  ::viam::app::v1::RegistryItem* mutable_item();
  void set_allocated_item(::viam::app::v1::RegistryItem* item);
  private:
  const ::viam::app::v1::RegistryItem& _internal_item() const;
  ::viam::app::v1::RegistryItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::viam::app::v1::RegistryItem* item);
  ::viam::app::v1::RegistryItem* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RegistryItem* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRegistryItemRequest) */ {
 public:
  inline CreateRegistryItemRequest() : CreateRegistryItemRequest(nullptr) {}
  ~CreateRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRegistryItemRequest(const CreateRegistryItemRequest& from);
  CreateRegistryItemRequest(CreateRegistryItemRequest&& from) noexcept
    : CreateRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline CreateRegistryItemRequest& operator=(const CreateRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRegistryItemRequest& operator=(CreateRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRegistryItemRequest*>(
               &_CreateRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    197;

  friend void swap(CreateRegistryItemRequest& a, CreateRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRegistryItemRequest";
  }
  protected:
  explicit CreateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .viam.app.packages.v1.PackageType type = 3 [json_name = "type"];
  void clear_type();
  ::viam::app::packages::v1::PackageType type() const;
  void set_type(::viam::app::packages::v1::PackageType value);
  private:
  ::viam::app::packages::v1::PackageType _internal_type() const;
  void _internal_set_type(::viam::app::packages::v1::PackageType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRegistryItemResponse) */ {
 public:
  inline CreateRegistryItemResponse() : CreateRegistryItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRegistryItemResponse(const CreateRegistryItemResponse& from);
  CreateRegistryItemResponse(CreateRegistryItemResponse&& from) noexcept
    : CreateRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline CreateRegistryItemResponse& operator=(const CreateRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRegistryItemResponse& operator=(CreateRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRegistryItemResponse*>(
               &_CreateRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    198;

  friend void swap(CreateRegistryItemResponse& a, CreateRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRegistryItemResponse";
  }
  protected:
  explicit CreateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRegistryItemRequest) */ {
 public:
  inline UpdateRegistryItemRequest() : UpdateRegistryItemRequest(nullptr) {}
  ~UpdateRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRegistryItemRequest(const UpdateRegistryItemRequest& from);
  UpdateRegistryItemRequest(UpdateRegistryItemRequest&& from) noexcept
    : UpdateRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRegistryItemRequest& operator=(const UpdateRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRegistryItemRequest& operator=(UpdateRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  enum MetadataCase {
    kUpdateModuleMetadata = 6,
    kUpdateMlModelMetadata = 7,
    kUpdateMlTrainingMetadata = 8,
    METADATA_NOT_SET = 0,
  };

  static inline const UpdateRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRegistryItemRequest*>(
               &_UpdateRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    199;

  friend void swap(UpdateRegistryItemRequest& a, UpdateRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRegistryItemRequest";
  }
  protected:
  explicit UpdateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kDescriptionFieldNumber = 3,
    kUrlFieldNumber = 5,
    kMarkdownDescriptionFieldNumber = 9,
    kTypeFieldNumber = 2,
    kVisibilityFieldNumber = 4,
    kUpdateModuleMetadataFieldNumber = 6,
    kUpdateMlModelMetadataFieldNumber = 7,
    kUpdateMlTrainingMetadataFieldNumber = 8,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string description = 3 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string url = 5 [json_name = "url"];
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string markdown_description = 9 [json_name = "markdownDescription"];
  bool has_markdown_description() const;
  private:
  bool _internal_has_markdown_description() const;
  public:
  void clear_markdown_description();
  const std::string& markdown_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_markdown_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_markdown_description();
  PROTOBUF_NODISCARD std::string* release_markdown_description();
  void set_allocated_markdown_description(std::string* markdown_description);
  private:
  const std::string& _internal_markdown_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_markdown_description(const std::string& value);
  std::string* _internal_mutable_markdown_description();
  public:

  // .viam.app.packages.v1.PackageType type = 2 [json_name = "type"];
  void clear_type();
  ::viam::app::packages::v1::PackageType type() const;
  void set_type(::viam::app::packages::v1::PackageType value);
  private:
  ::viam::app::packages::v1::PackageType _internal_type() const;
  void _internal_set_type(::viam::app::packages::v1::PackageType value);
  public:

  // .viam.app.v1.Visibility visibility = 4 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // .viam.app.v1.UpdateModuleMetadata update_module_metadata = 6 [json_name = "updateModuleMetadata"];
  bool has_update_module_metadata() const;
  private:
  bool _internal_has_update_module_metadata() const;
  public:
  void clear_update_module_metadata();
  const ::viam::app::v1::UpdateModuleMetadata& update_module_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::UpdateModuleMetadata* release_update_module_metadata();
  ::viam::app::v1::UpdateModuleMetadata* mutable_update_module_metadata();
  void set_allocated_update_module_metadata(::viam::app::v1::UpdateModuleMetadata* update_module_metadata);
  private:
  const ::viam::app::v1::UpdateModuleMetadata& _internal_update_module_metadata() const;
  ::viam::app::v1::UpdateModuleMetadata* _internal_mutable_update_module_metadata();
  public:
  void unsafe_arena_set_allocated_update_module_metadata(
      ::viam::app::v1::UpdateModuleMetadata* update_module_metadata);
  ::viam::app::v1::UpdateModuleMetadata* unsafe_arena_release_update_module_metadata();

  // .viam.app.v1.UpdateMLModelMetadata update_ml_model_metadata = 7 [json_name = "updateMlModelMetadata"];
  bool has_update_ml_model_metadata() const;
  private:
  bool _internal_has_update_ml_model_metadata() const;
  public:
  void clear_update_ml_model_metadata();
  const ::viam::app::v1::UpdateMLModelMetadata& update_ml_model_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::UpdateMLModelMetadata* release_update_ml_model_metadata();
  ::viam::app::v1::UpdateMLModelMetadata* mutable_update_ml_model_metadata();
  void set_allocated_update_ml_model_metadata(::viam::app::v1::UpdateMLModelMetadata* update_ml_model_metadata);
  private:
  const ::viam::app::v1::UpdateMLModelMetadata& _internal_update_ml_model_metadata() const;
  ::viam::app::v1::UpdateMLModelMetadata* _internal_mutable_update_ml_model_metadata();
  public:
  void unsafe_arena_set_allocated_update_ml_model_metadata(
      ::viam::app::v1::UpdateMLModelMetadata* update_ml_model_metadata);
  ::viam::app::v1::UpdateMLModelMetadata* unsafe_arena_release_update_ml_model_metadata();

  // .viam.app.v1.UpdateMLTrainingMetadata update_ml_training_metadata = 8 [json_name = "updateMlTrainingMetadata"];
  bool has_update_ml_training_metadata() const;
  private:
  bool _internal_has_update_ml_training_metadata() const;
  public:
  void clear_update_ml_training_metadata();
  const ::viam::app::v1::UpdateMLTrainingMetadata& update_ml_training_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::UpdateMLTrainingMetadata* release_update_ml_training_metadata();
  ::viam::app::v1::UpdateMLTrainingMetadata* mutable_update_ml_training_metadata();
  void set_allocated_update_ml_training_metadata(::viam::app::v1::UpdateMLTrainingMetadata* update_ml_training_metadata);
  private:
  const ::viam::app::v1::UpdateMLTrainingMetadata& _internal_update_ml_training_metadata() const;
  ::viam::app::v1::UpdateMLTrainingMetadata* _internal_mutable_update_ml_training_metadata();
  public:
  void unsafe_arena_set_allocated_update_ml_training_metadata(
      ::viam::app::v1::UpdateMLTrainingMetadata* update_ml_training_metadata);
  ::viam::app::v1::UpdateMLTrainingMetadata* unsafe_arena_release_update_ml_training_metadata();

  void clear_metadata();
  MetadataCase metadata_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRegistryItemRequest)
 private:
  class _Internal;
  void set_has_update_module_metadata();
  void set_has_update_ml_model_metadata();
  void set_has_update_ml_training_metadata();

  inline bool has_metadata() const;
  inline void clear_has_metadata();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr markdown_description_;
  int type_;
  int visibility_;
  union MetadataUnion {
    constexpr MetadataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::viam::app::v1::UpdateModuleMetadata* update_module_metadata_;
    ::viam::app::v1::UpdateMLModelMetadata* update_ml_model_metadata_;
    ::viam::app::v1::UpdateMLTrainingMetadata* update_ml_training_metadata_;
  } metadata_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRegistryItemResponse) */ {
 public:
  inline UpdateRegistryItemResponse() : UpdateRegistryItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRegistryItemResponse(const UpdateRegistryItemResponse& from);
  UpdateRegistryItemResponse(UpdateRegistryItemResponse&& from) noexcept
    : UpdateRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRegistryItemResponse& operator=(const UpdateRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRegistryItemResponse& operator=(UpdateRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRegistryItemResponse*>(
               &_UpdateRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    200;

  friend void swap(UpdateRegistryItemResponse& a, UpdateRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRegistryItemResponse";
  }
  protected:
  explicit UpdateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRegistryItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRegistryItemsRequest) */ {
 public:
  inline ListRegistryItemsRequest() : ListRegistryItemsRequest(nullptr) {}
  ~ListRegistryItemsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRegistryItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRegistryItemsRequest(const ListRegistryItemsRequest& from);
  ListRegistryItemsRequest(ListRegistryItemsRequest&& from) noexcept
    : ListRegistryItemsRequest() {
    *this = ::std::move(from);
  }

  inline ListRegistryItemsRequest& operator=(const ListRegistryItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRegistryItemsRequest& operator=(ListRegistryItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRegistryItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRegistryItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRegistryItemsRequest*>(
               &_ListRegistryItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    201;

  friend void swap(ListRegistryItemsRequest& a, ListRegistryItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRegistryItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRegistryItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRegistryItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRegistryItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRegistryItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRegistryItemsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRegistryItemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRegistryItemsRequest";
  }
  protected:
  explicit ListRegistryItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 2,
    kVisibilitiesFieldNumber = 3,
    kPlatformsFieldNumber = 4,
    kStatusesFieldNumber = 5,
    kPublicNamespacesFieldNumber = 8,
    kModuleSourceTypesFieldNumber = 10,
    kModuleLanguagesFieldNumber = 11,
    kOrganizationIdFieldNumber = 1,
    kSearchTermFieldNumber = 6,
    kPageTokenFieldNumber = 7,
    kIncludeMarkdownDocumentationFieldNumber = 9,
  };
  // repeated .viam.app.packages.v1.PackageType types = 2 [json_name = "types"];
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  ::viam::app::packages::v1::PackageType _internal_types(int index) const;
  void _internal_add_types(::viam::app::packages::v1::PackageType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_types();
  public:
  ::viam::app::packages::v1::PackageType types(int index) const;
  void set_types(int index, ::viam::app::packages::v1::PackageType value);
  void add_types(::viam::app::packages::v1::PackageType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_types();

  // repeated .viam.app.v1.Visibility visibilities = 3 [json_name = "visibilities"];
  int visibilities_size() const;
  private:
  int _internal_visibilities_size() const;
  public:
  void clear_visibilities();
  private:
  ::viam::app::v1::Visibility _internal_visibilities(int index) const;
  void _internal_add_visibilities(::viam::app::v1::Visibility value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_visibilities();
  public:
  ::viam::app::v1::Visibility visibilities(int index) const;
  void set_visibilities(int index, ::viam::app::v1::Visibility value);
  void add_visibilities(::viam::app::v1::Visibility value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& visibilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_visibilities();

  // repeated string platforms = 4 [json_name = "platforms"];
  int platforms_size() const;
  private:
  int _internal_platforms_size() const;
  public:
  void clear_platforms();
  const std::string& platforms(int index) const;
  std::string* mutable_platforms(int index);
  void set_platforms(int index, const std::string& value);
  void set_platforms(int index, std::string&& value);
  void set_platforms(int index, const char* value);
  void set_platforms(int index, const char* value, size_t size);
  std::string* add_platforms();
  void add_platforms(const std::string& value);
  void add_platforms(std::string&& value);
  void add_platforms(const char* value);
  void add_platforms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& platforms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_platforms();
  private:
  const std::string& _internal_platforms(int index) const;
  std::string* _internal_add_platforms();
  public:

  // repeated .viam.app.v1.RegistryItemStatus statuses = 5 [json_name = "statuses"];
  int statuses_size() const;
  private:
  int _internal_statuses_size() const;
  public:
  void clear_statuses();
  private:
  ::viam::app::v1::RegistryItemStatus _internal_statuses(int index) const;
  void _internal_add_statuses(::viam::app::v1::RegistryItemStatus value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_statuses();
  public:
  ::viam::app::v1::RegistryItemStatus statuses(int index) const;
  void set_statuses(int index, ::viam::app::v1::RegistryItemStatus value);
  void add_statuses(::viam::app::v1::RegistryItemStatus value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& statuses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_statuses();

  // repeated string public_namespaces = 8 [json_name = "publicNamespaces"];
  int public_namespaces_size() const;
  private:
  int _internal_public_namespaces_size() const;
  public:
  void clear_public_namespaces();
  const std::string& public_namespaces(int index) const;
  std::string* mutable_public_namespaces(int index);
  void set_public_namespaces(int index, const std::string& value);
  void set_public_namespaces(int index, std::string&& value);
  void set_public_namespaces(int index, const char* value);
  void set_public_namespaces(int index, const char* value, size_t size);
  std::string* add_public_namespaces();
  void add_public_namespaces(const std::string& value);
  void add_public_namespaces(std::string&& value);
  void add_public_namespaces(const char* value);
  void add_public_namespaces(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& public_namespaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_public_namespaces();
  private:
  const std::string& _internal_public_namespaces(int index) const;
  std::string* _internal_add_public_namespaces();
  public:

  // repeated .viam.app.v1.ModuleSourceType module_source_types = 10 [json_name = "moduleSourceTypes"];
  int module_source_types_size() const;
  private:
  int _internal_module_source_types_size() const;
  public:
  void clear_module_source_types();
  private:
  ::viam::app::v1::ModuleSourceType _internal_module_source_types(int index) const;
  void _internal_add_module_source_types(::viam::app::v1::ModuleSourceType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_module_source_types();
  public:
  ::viam::app::v1::ModuleSourceType module_source_types(int index) const;
  void set_module_source_types(int index, ::viam::app::v1::ModuleSourceType value);
  void add_module_source_types(::viam::app::v1::ModuleSourceType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& module_source_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_module_source_types();

  // repeated .viam.app.v1.ModuleLanguage module_languages = 11 [json_name = "moduleLanguages"];
  int module_languages_size() const;
  private:
  int _internal_module_languages_size() const;
  public:
  void clear_module_languages();
  private:
  ::viam::app::v1::ModuleLanguage _internal_module_languages(int index) const;
  void _internal_add_module_languages(::viam::app::v1::ModuleLanguage value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_module_languages();
  public:
  ::viam::app::v1::ModuleLanguage module_languages(int index) const;
  void set_module_languages(int index, ::viam::app::v1::ModuleLanguage value);
  void add_module_languages(::viam::app::v1::ModuleLanguage value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& module_languages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_module_languages();

  // optional string organization_id = 1 [json_name = "organizationId"];
  bool has_organization_id() const;
  private:
  bool _internal_has_organization_id() const;
  public:
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // optional string search_term = 6 [json_name = "searchTerm"];
  bool has_search_term() const;
  private:
  bool _internal_has_search_term() const;
  public:
  void clear_search_term();
  const std::string& search_term() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_term(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_term();
  PROTOBUF_NODISCARD std::string* release_search_term();
  void set_allocated_search_term(std::string* search_term);
  private:
  const std::string& _internal_search_term() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_term(const std::string& value);
  std::string* _internal_mutable_search_term();
  public:

  // optional string page_token = 7 [json_name = "pageToken"];
  bool has_page_token() const;
  private:
  bool _internal_has_page_token() const;
  public:
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // optional bool include_markdown_documentation = 9 [json_name = "includeMarkdownDocumentation"];
  bool has_include_markdown_documentation() const;
  private:
  bool _internal_has_include_markdown_documentation() const;
  public:
  void clear_include_markdown_documentation();
  bool include_markdown_documentation() const;
  void set_include_markdown_documentation(bool value);
  private:
  bool _internal_include_markdown_documentation() const;
  void _internal_set_include_markdown_documentation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRegistryItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> types_;
  mutable std::atomic<int> _types_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> visibilities_;
  mutable std::atomic<int> _visibilities_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> platforms_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> statuses_;
  mutable std::atomic<int> _statuses_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> public_namespaces_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> module_source_types_;
  mutable std::atomic<int> _module_source_types_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> module_languages_;
  mutable std::atomic<int> _module_languages_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_term_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  bool include_markdown_documentation_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRegistryItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRegistryItemsResponse) */ {
 public:
  inline ListRegistryItemsResponse() : ListRegistryItemsResponse(nullptr) {}
  ~ListRegistryItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRegistryItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRegistryItemsResponse(const ListRegistryItemsResponse& from);
  ListRegistryItemsResponse(ListRegistryItemsResponse&& from) noexcept
    : ListRegistryItemsResponse() {
    *this = ::std::move(from);
  }

  inline ListRegistryItemsResponse& operator=(const ListRegistryItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRegistryItemsResponse& operator=(ListRegistryItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRegistryItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRegistryItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRegistryItemsResponse*>(
               &_ListRegistryItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    202;

  friend void swap(ListRegistryItemsResponse& a, ListRegistryItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRegistryItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRegistryItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRegistryItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRegistryItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRegistryItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRegistryItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRegistryItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRegistryItemsResponse";
  }
  protected:
  explicit ListRegistryItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .viam.app.v1.RegistryItem items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::viam::app::v1::RegistryItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >*
      mutable_items();
  private:
  const ::viam::app::v1::RegistryItem& _internal_items(int index) const;
  ::viam::app::v1::RegistryItem* _internal_add_items();
  public:
  const ::viam::app::v1::RegistryItem& items(int index) const;
  ::viam::app::v1::RegistryItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRegistryItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRegistryItemRequest) */ {
 public:
  inline DeleteRegistryItemRequest() : DeleteRegistryItemRequest(nullptr) {}
  ~DeleteRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRegistryItemRequest(const DeleteRegistryItemRequest& from);
  DeleteRegistryItemRequest(DeleteRegistryItemRequest&& from) noexcept
    : DeleteRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRegistryItemRequest& operator=(const DeleteRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRegistryItemRequest& operator=(DeleteRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRegistryItemRequest*>(
               &_DeleteRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    203;

  friend void swap(DeleteRegistryItemRequest& a, DeleteRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRegistryItemRequest";
  }
  protected:
  explicit DeleteRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRegistryItemResponse) */ {
 public:
  inline DeleteRegistryItemResponse() : DeleteRegistryItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRegistryItemResponse(const DeleteRegistryItemResponse& from);
  DeleteRegistryItemResponse(DeleteRegistryItemResponse&& from) noexcept
    : DeleteRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRegistryItemResponse& operator=(const DeleteRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRegistryItemResponse& operator=(DeleteRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRegistryItemResponse*>(
               &_DeleteRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    204;

  friend void swap(DeleteRegistryItemResponse& a, DeleteRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRegistryItemResponse";
  }
  protected:
  explicit DeleteRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RenameRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RenameRegistryItemRequest) */ {
 public:
  inline RenameRegistryItemRequest() : RenameRegistryItemRequest(nullptr) {}
  ~RenameRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR RenameRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameRegistryItemRequest(const RenameRegistryItemRequest& from);
  RenameRegistryItemRequest(RenameRegistryItemRequest&& from) noexcept
    : RenameRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline RenameRegistryItemRequest& operator=(const RenameRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameRegistryItemRequest& operator=(RenameRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const RenameRegistryItemRequest*>(
               &_RenameRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    205;

  friend void swap(RenameRegistryItemRequest& a, RenameRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RenameRegistryItemRequest";
  }
  protected:
  explicit RenameRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kNewNameFieldNumber = 2,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string new_name = 2 [json_name = "newName"];
  void clear_new_name();
  const std::string& new_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_name();
  PROTOBUF_NODISCARD std::string* release_new_name();
  void set_allocated_new_name(std::string* new_name);
  private:
  const std::string& _internal_new_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_name(const std::string& value);
  std::string* _internal_mutable_new_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RenameRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RenameRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RenameRegistryItemResponse) */ {
 public:
  inline RenameRegistryItemResponse() : RenameRegistryItemResponse(nullptr) {}
  ~RenameRegistryItemResponse() override;
  explicit PROTOBUF_CONSTEXPR RenameRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameRegistryItemResponse(const RenameRegistryItemResponse& from);
  RenameRegistryItemResponse(RenameRegistryItemResponse&& from) noexcept
    : RenameRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline RenameRegistryItemResponse& operator=(const RenameRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameRegistryItemResponse& operator=(RenameRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const RenameRegistryItemResponse*>(
               &_RenameRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    206;

  friend void swap(RenameRegistryItemResponse& a, RenameRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameRegistryItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameRegistryItemResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameRegistryItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RenameRegistryItemResponse";
  }
  protected:
  explicit RenameRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .viam.app.v1.RegistryItem item = 1 [json_name = "item"];
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::viam::app::v1::RegistryItem& item() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RegistryItem* release_item();
  ::viam::app::v1::RegistryItem* mutable_item();
  void set_allocated_item(::viam::app::v1::RegistryItem* item);
  private:
  const ::viam::app::v1::RegistryItem& _internal_item() const;
  ::viam::app::v1::RegistryItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::viam::app::v1::RegistryItem* item);
  ::viam::app::v1::RegistryItem* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:viam.app.v1.RenameRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RegistryItem* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TransferRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TransferRegistryItemRequest) */ {
 public:
  inline TransferRegistryItemRequest() : TransferRegistryItemRequest(nullptr) {}
  ~TransferRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR TransferRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferRegistryItemRequest(const TransferRegistryItemRequest& from);
  TransferRegistryItemRequest(TransferRegistryItemRequest&& from) noexcept
    : TransferRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline TransferRegistryItemRequest& operator=(const TransferRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferRegistryItemRequest& operator=(TransferRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const TransferRegistryItemRequest*>(
               &_TransferRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    207;

  friend void swap(TransferRegistryItemRequest& a, TransferRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TransferRegistryItemRequest";
  }
  protected:
  explicit TransferRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kNewPublicNamespaceFieldNumber = 2,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string new_public_namespace = 2 [json_name = "newPublicNamespace"];
  void clear_new_public_namespace();
  const std::string& new_public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_public_namespace();
  PROTOBUF_NODISCARD std::string* release_new_public_namespace();
  void set_allocated_new_public_namespace(std::string* new_public_namespace);
  private:
  const std::string& _internal_new_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_public_namespace(const std::string& value);
  std::string* _internal_mutable_new_public_namespace();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.TransferRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_public_namespace_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TransferRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.TransferRegistryItemResponse) */ {
 public:
  inline TransferRegistryItemResponse() : TransferRegistryItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TransferRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferRegistryItemResponse(const TransferRegistryItemResponse& from);
  TransferRegistryItemResponse(TransferRegistryItemResponse&& from) noexcept
    : TransferRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline TransferRegistryItemResponse& operator=(const TransferRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferRegistryItemResponse& operator=(TransferRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const TransferRegistryItemResponse*>(
               &_TransferRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    208;

  friend void swap(TransferRegistryItemResponse& a, TransferRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TransferRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TransferRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TransferRegistryItemResponse";
  }
  protected:
  explicit TransferRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.TransferRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateModuleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateModuleRequest) */ {
 public:
  inline CreateModuleRequest() : CreateModuleRequest(nullptr) {}
  ~CreateModuleRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateModuleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateModuleRequest(const CreateModuleRequest& from);
  CreateModuleRequest(CreateModuleRequest&& from) noexcept
    : CreateModuleRequest() {
    *this = ::std::move(from);
  }

  inline CreateModuleRequest& operator=(const CreateModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModuleRequest& operator=(CreateModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateModuleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateModuleRequest*>(
               &_CreateModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    209;

  friend void swap(CreateModuleRequest& a, CreateModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModuleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateModuleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateModuleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateModuleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateModuleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateModuleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateModuleRequest";
  }
  protected:
  explicit CreateModuleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateModuleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateModuleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateModuleResponse) */ {
 public:
  inline CreateModuleResponse() : CreateModuleResponse(nullptr) {}
  ~CreateModuleResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateModuleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateModuleResponse(const CreateModuleResponse& from);
  CreateModuleResponse(CreateModuleResponse&& from) noexcept
    : CreateModuleResponse() {
    *this = ::std::move(from);
  }

  inline CreateModuleResponse& operator=(const CreateModuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModuleResponse& operator=(CreateModuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateModuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateModuleResponse* internal_default_instance() {
    return reinterpret_cast<const CreateModuleResponse*>(
               &_CreateModuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    210;

  friend void swap(CreateModuleResponse& a, CreateModuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModuleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateModuleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateModuleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateModuleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateModuleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateModuleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateModuleResponse";
  }
  protected:
  explicit CreateModuleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleIdFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string url = 2 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateModuleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateModuleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateModuleRequest) */ {
 public:
  inline UpdateModuleRequest() : UpdateModuleRequest(nullptr) {}
  ~UpdateModuleRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateModuleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateModuleRequest(const UpdateModuleRequest& from);
  UpdateModuleRequest(UpdateModuleRequest&& from) noexcept
    : UpdateModuleRequest() {
    *this = ::std::move(from);
  }

  inline UpdateModuleRequest& operator=(const UpdateModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateModuleRequest& operator=(UpdateModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateModuleRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateModuleRequest*>(
               &_UpdateModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    211;

  friend void swap(UpdateModuleRequest& a, UpdateModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateModuleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateModuleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateModuleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateModuleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateModuleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateModuleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateModuleRequest";
  }
  protected:
  explicit UpdateModuleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 5,
    kAppsFieldNumber = 8,
    kModuleIdFieldNumber = 1,
    kUrlFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kEntrypointFieldNumber = 6,
    kFirstRunFieldNumber = 7,
    kMarkdownDescriptionFieldNumber = 9,
    kVisibilityFieldNumber = 2,
  };
  // repeated .viam.app.v1.Model models = 5 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // repeated .viam.app.v1.App apps = 8 [json_name = "apps"];
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::viam::app::v1::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
      mutable_apps();
  private:
  const ::viam::app::v1::App& _internal_apps(int index) const;
  ::viam::app::v1::App* _internal_add_apps();
  public:
  const ::viam::app::v1::App& apps(int index) const;
  ::viam::app::v1::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
      apps() const;

  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string url = 3 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 4 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string entrypoint = 6 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // optional string first_run = 7 [json_name = "firstRun"];
  bool has_first_run() const;
  private:
  bool _internal_has_first_run() const;
  public:
  void clear_first_run();
  const std::string& first_run() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_run(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_run();
  PROTOBUF_NODISCARD std::string* release_first_run();
  void set_allocated_first_run(std::string* first_run);
  private:
  const std::string& _internal_first_run() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_run(const std::string& value);
  std::string* _internal_mutable_first_run();
  public:

  // optional string markdown_description = 9 [json_name = "markdownDescription"];
  bool has_markdown_description() const;
  private:
  bool _internal_has_markdown_description() const;
  public:
  void clear_markdown_description();
  const std::string& markdown_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_markdown_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_markdown_description();
  PROTOBUF_NODISCARD std::string* release_markdown_description();
  void set_allocated_markdown_description(std::string* markdown_description);
  private:
  const std::string& _internal_markdown_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_markdown_description(const std::string& value);
  std::string* _internal_mutable_markdown_description();
  public:

  // .viam.app.v1.Visibility visibility = 2 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateModuleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App > apps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_run_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr markdown_description_;
  int visibility_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class App final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() override;
  explicit PROTOBUF_CONSTEXPR App(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  App(const App& from);
  App(App&& from) noexcept
    : App() {
    *this = ::std::move(from);
  }

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
               &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    212;

  friend void swap(App& a, App& b) {
    a.Swap(&b);
  }
  inline void Swap(App* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<App>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const App& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const App& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(App* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.App";
  }
  protected:
  explicit App(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentIdsFieldNumber = 4,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kEntrypointFieldNumber = 3,
    kLogoPathFieldNumber = 5,
    kCustomizationsFieldNumber = 6,
  };
  // repeated string fragment_ids = 4 [json_name = "fragmentIds"];
  int fragment_ids_size() const;
  private:
  int _internal_fragment_ids_size() const;
  public:
  void clear_fragment_ids();
  const std::string& fragment_ids(int index) const;
  std::string* mutable_fragment_ids(int index);
  void set_fragment_ids(int index, const std::string& value);
  void set_fragment_ids(int index, std::string&& value);
  void set_fragment_ids(int index, const char* value);
  void set_fragment_ids(int index, const char* value, size_t size);
  std::string* add_fragment_ids();
  void add_fragment_ids(const std::string& value);
  void add_fragment_ids(std::string&& value);
  void add_fragment_ids(const char* value);
  void add_fragment_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fragment_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fragment_ids();
  private:
  const std::string& _internal_fragment_ids(int index) const;
  std::string* _internal_add_fragment_ids();
  public:

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string entrypoint = 3 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // optional string logo_path = 5 [json_name = "logoPath"];
  bool has_logo_path() const;
  private:
  bool _internal_has_logo_path() const;
  public:
  void clear_logo_path();
  const std::string& logo_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo_path();
  PROTOBUF_NODISCARD std::string* release_logo_path();
  void set_allocated_logo_path(std::string* logo_path);
  private:
  const std::string& _internal_logo_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo_path(const std::string& value);
  std::string* _internal_mutable_logo_path();
  public:

  // .viam.app.v1.AppCustomizations customizations = 6 [json_name = "customizations"];
  bool has_customizations() const;
  private:
  bool _internal_has_customizations() const;
  public:
  void clear_customizations();
  const ::viam::app::v1::AppCustomizations& customizations() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AppCustomizations* release_customizations();
  ::viam::app::v1::AppCustomizations* mutable_customizations();
  void set_allocated_customizations(::viam::app::v1::AppCustomizations* customizations);
  private:
  const ::viam::app::v1::AppCustomizations& _internal_customizations() const;
  ::viam::app::v1::AppCustomizations* _internal_mutable_customizations();
  public:
  void unsafe_arena_set_allocated_customizations(
      ::viam::app::v1::AppCustomizations* customizations);
  ::viam::app::v1::AppCustomizations* unsafe_arena_release_customizations();

  // @@protoc_insertion_point(class_scope:viam.app.v1.App)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fragment_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_path_;
  ::viam::app::v1::AppCustomizations* customizations_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateModuleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateModuleResponse) */ {
 public:
  inline UpdateModuleResponse() : UpdateModuleResponse(nullptr) {}
  ~UpdateModuleResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateModuleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateModuleResponse(const UpdateModuleResponse& from);
  UpdateModuleResponse(UpdateModuleResponse&& from) noexcept
    : UpdateModuleResponse() {
    *this = ::std::move(from);
  }

  inline UpdateModuleResponse& operator=(const UpdateModuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateModuleResponse& operator=(UpdateModuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateModuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateModuleResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateModuleResponse*>(
               &_UpdateModuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    213;

  friend void swap(UpdateModuleResponse& a, UpdateModuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateModuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateModuleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateModuleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateModuleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateModuleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateModuleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateModuleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateModuleResponse";
  }
  protected:
  explicit UpdateModuleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateModuleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateModuleMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateModuleMetadata) */ {
 public:
  inline UpdateModuleMetadata() : UpdateModuleMetadata(nullptr) {}
  ~UpdateModuleMetadata() override;
  explicit PROTOBUF_CONSTEXPR UpdateModuleMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateModuleMetadata(const UpdateModuleMetadata& from);
  UpdateModuleMetadata(UpdateModuleMetadata&& from) noexcept
    : UpdateModuleMetadata() {
    *this = ::std::move(from);
  }

  inline UpdateModuleMetadata& operator=(const UpdateModuleMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateModuleMetadata& operator=(UpdateModuleMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateModuleMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateModuleMetadata* internal_default_instance() {
    return reinterpret_cast<const UpdateModuleMetadata*>(
               &_UpdateModuleMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    214;

  friend void swap(UpdateModuleMetadata& a, UpdateModuleMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateModuleMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateModuleMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateModuleMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateModuleMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateModuleMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateModuleMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateModuleMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateModuleMetadata";
  }
  protected:
  explicit UpdateModuleMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
    kAppsFieldNumber = 3,
    kEntrypointFieldNumber = 2,
    kSourceTypeFieldNumber = 4,
    kLanguageFieldNumber = 5,
  };
  // repeated .viam.app.v1.Model models = 1 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // repeated .viam.app.v1.App apps = 3 [json_name = "apps"];
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::viam::app::v1::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
      mutable_apps();
  private:
  const ::viam::app::v1::App& _internal_apps(int index) const;
  ::viam::app::v1::App* _internal_add_apps();
  public:
  const ::viam::app::v1::App& apps(int index) const;
  ::viam::app::v1::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
      apps() const;

  // string entrypoint = 2 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // optional .viam.app.v1.ModuleSourceType source_type = 4 [json_name = "sourceType"];
  bool has_source_type() const;
  private:
  bool _internal_has_source_type() const;
  public:
  void clear_source_type();
  ::viam::app::v1::ModuleSourceType source_type() const;
  void set_source_type(::viam::app::v1::ModuleSourceType value);
  private:
  ::viam::app::v1::ModuleSourceType _internal_source_type() const;
  void _internal_set_source_type(::viam::app::v1::ModuleSourceType value);
  public:

  // optional .viam.app.v1.ModuleLanguage language = 5 [json_name = "language"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  ::viam::app::v1::ModuleLanguage language() const;
  void set_language(::viam::app::v1::ModuleLanguage value);
  private:
  ::viam::app::v1::ModuleLanguage _internal_language() const;
  void _internal_set_language(::viam::app::v1::ModuleLanguage value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateModuleMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App > apps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  int source_type_;
  int language_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateMLModelMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateMLModelMetadata) */ {
 public:
  inline UpdateMLModelMetadata() : UpdateMLModelMetadata(nullptr) {}
  ~UpdateMLModelMetadata() override;
  explicit PROTOBUF_CONSTEXPR UpdateMLModelMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMLModelMetadata(const UpdateMLModelMetadata& from);
  UpdateMLModelMetadata(UpdateMLModelMetadata&& from) noexcept
    : UpdateMLModelMetadata() {
    *this = ::std::move(from);
  }

  inline UpdateMLModelMetadata& operator=(const UpdateMLModelMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMLModelMetadata& operator=(UpdateMLModelMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMLModelMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMLModelMetadata* internal_default_instance() {
    return reinterpret_cast<const UpdateMLModelMetadata*>(
               &_UpdateMLModelMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    215;

  friend void swap(UpdateMLModelMetadata& a, UpdateMLModelMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMLModelMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMLModelMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateMLModelMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateMLModelMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMLModelMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateMLModelMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMLModelMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateMLModelMetadata";
  }
  protected:
  explicit UpdateMLModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelTypeFieldNumber = 1,
    kModelFrameworkFieldNumber = 2,
  };
  // .viam.app.mltraining.v1.ModelType model_type = 1 [json_name = "modelType"];
  void clear_model_type();
  ::viam::app::mltraining::v1::ModelType model_type() const;
  void set_model_type(::viam::app::mltraining::v1::ModelType value);
  private:
  ::viam::app::mltraining::v1::ModelType _internal_model_type() const;
  void _internal_set_model_type(::viam::app::mltraining::v1::ModelType value);
  public:

  // .viam.app.mltraining.v1.ModelFramework model_framework = 2 [json_name = "modelFramework"];
  void clear_model_framework();
  ::viam::app::mltraining::v1::ModelFramework model_framework() const;
  void set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  private:
  ::viam::app::mltraining::v1::ModelFramework _internal_model_framework() const;
  void _internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateMLModelMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int model_type_;
  int model_framework_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateMLTrainingMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateMLTrainingMetadata) */ {
 public:
  inline UpdateMLTrainingMetadata() : UpdateMLTrainingMetadata(nullptr) {}
  ~UpdateMLTrainingMetadata() override;
  explicit PROTOBUF_CONSTEXPR UpdateMLTrainingMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMLTrainingMetadata(const UpdateMLTrainingMetadata& from);
  UpdateMLTrainingMetadata(UpdateMLTrainingMetadata&& from) noexcept
    : UpdateMLTrainingMetadata() {
    *this = ::std::move(from);
  }

  inline UpdateMLTrainingMetadata& operator=(const UpdateMLTrainingMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMLTrainingMetadata& operator=(UpdateMLTrainingMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMLTrainingMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMLTrainingMetadata* internal_default_instance() {
    return reinterpret_cast<const UpdateMLTrainingMetadata*>(
               &_UpdateMLTrainingMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    216;

  friend void swap(UpdateMLTrainingMetadata& a, UpdateMLTrainingMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMLTrainingMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMLTrainingMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateMLTrainingMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateMLTrainingMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMLTrainingMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateMLTrainingMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMLTrainingMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateMLTrainingMetadata";
  }
  protected:
  explicit UpdateMLTrainingMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelTypeFieldNumber = 1,
    kModelFrameworkFieldNumber = 2,
    kDraftFieldNumber = 3,
  };
  // .viam.app.mltraining.v1.ModelType model_type = 1 [json_name = "modelType"];
  void clear_model_type();
  ::viam::app::mltraining::v1::ModelType model_type() const;
  void set_model_type(::viam::app::mltraining::v1::ModelType value);
  private:
  ::viam::app::mltraining::v1::ModelType _internal_model_type() const;
  void _internal_set_model_type(::viam::app::mltraining::v1::ModelType value);
  public:

  // .viam.app.mltraining.v1.ModelFramework model_framework = 2 [json_name = "modelFramework"];
  void clear_model_framework();
  ::viam::app::mltraining::v1::ModelFramework model_framework() const;
  void set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  private:
  ::viam::app::mltraining::v1::ModelFramework _internal_model_framework() const;
  void _internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  public:

  // bool draft = 3 [json_name = "draft"];
  void clear_draft();
  bool draft() const;
  void set_draft(bool value);
  private:
  bool _internal_draft() const;
  void _internal_set_draft(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateMLTrainingMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int model_type_;
  int model_framework_;
  bool draft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    217;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Model& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedHardwareFieldNumber = 5,
    kApiFieldNumber = 1,
    kModelFieldNumber = 2,
    kMarkdownDocumentationFieldNumber = 3,
    kDescriptionFieldNumber = 4,
  };
  // repeated string supported_hardware = 5 [json_name = "supportedHardware"];
  int supported_hardware_size() const;
  private:
  int _internal_supported_hardware_size() const;
  public:
  void clear_supported_hardware();
  const std::string& supported_hardware(int index) const;
  std::string* mutable_supported_hardware(int index);
  void set_supported_hardware(int index, const std::string& value);
  void set_supported_hardware(int index, std::string&& value);
  void set_supported_hardware(int index, const char* value);
  void set_supported_hardware(int index, const char* value, size_t size);
  std::string* add_supported_hardware();
  void add_supported_hardware(const std::string& value);
  void add_supported_hardware(std::string&& value);
  void add_supported_hardware(const char* value);
  void add_supported_hardware(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_hardware() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_hardware();
  private:
  const std::string& _internal_supported_hardware(int index) const;
  std::string* _internal_add_supported_hardware();
  public:

  // string api = 1 [json_name = "api"];
  void clear_api();
  const std::string& api() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api();
  PROTOBUF_NODISCARD std::string* release_api();
  void set_allocated_api(std::string* api);
  private:
  const std::string& _internal_api() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api(const std::string& value);
  std::string* _internal_mutable_api();
  public:

  // string model = 2 [json_name = "model"];
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional string markdown_documentation = 3 [json_name = "markdownDocumentation"];
  bool has_markdown_documentation() const;
  private:
  bool _internal_has_markdown_documentation() const;
  public:
  void clear_markdown_documentation();
  const std::string& markdown_documentation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_markdown_documentation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_markdown_documentation();
  PROTOBUF_NODISCARD std::string* release_markdown_documentation();
  void set_allocated_markdown_documentation(std::string* markdown_documentation);
  private:
  const std::string& _internal_markdown_documentation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_markdown_documentation(const std::string& value);
  std::string* _internal_mutable_markdown_documentation();
  public:

  // optional string description = 4 [json_name = "description"];
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_hardware_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr markdown_documentation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ModuleFileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleFileInfo) */ {
 public:
  inline ModuleFileInfo() : ModuleFileInfo(nullptr) {}
  ~ModuleFileInfo() override;
  explicit PROTOBUF_CONSTEXPR ModuleFileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleFileInfo(const ModuleFileInfo& from);
  ModuleFileInfo(ModuleFileInfo&& from) noexcept
    : ModuleFileInfo() {
    *this = ::std::move(from);
  }

  inline ModuleFileInfo& operator=(const ModuleFileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleFileInfo& operator=(ModuleFileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleFileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleFileInfo* internal_default_instance() {
    return reinterpret_cast<const ModuleFileInfo*>(
               &_ModuleFileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    218;

  friend void swap(ModuleFileInfo& a, ModuleFileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleFileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleFileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleFileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleFileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleFileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleFileInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleFileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ModuleFileInfo";
  }
  protected:
  explicit ModuleFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformTagsFieldNumber = 5,
    kModuleIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPlatformFieldNumber = 3,
  };
  // repeated string platform_tags = 5 [json_name = "platformTags"];
  int platform_tags_size() const;
  private:
  int _internal_platform_tags_size() const;
  public:
  void clear_platform_tags();
  const std::string& platform_tags(int index) const;
  std::string* mutable_platform_tags(int index);
  void set_platform_tags(int index, const std::string& value);
  void set_platform_tags(int index, std::string&& value);
  void set_platform_tags(int index, const char* value);
  void set_platform_tags(int index, const char* value, size_t size);
  std::string* add_platform_tags();
  void add_platform_tags(const std::string& value);
  void add_platform_tags(std::string&& value);
  void add_platform_tags(const char* value);
  void add_platform_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& platform_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_platform_tags();
  private:
  const std::string& _internal_platform_tags(int index) const;
  std::string* _internal_add_platform_tags();
  public:

  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string version = 2 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string platform = 3 [json_name = "platform"];
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleFileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> platform_tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UploadModuleFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UploadModuleFileRequest) */ {
 public:
  inline UploadModuleFileRequest() : UploadModuleFileRequest(nullptr) {}
  ~UploadModuleFileRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadModuleFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadModuleFileRequest(const UploadModuleFileRequest& from);
  UploadModuleFileRequest(UploadModuleFileRequest&& from) noexcept
    : UploadModuleFileRequest() {
    *this = ::std::move(from);
  }

  inline UploadModuleFileRequest& operator=(const UploadModuleFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadModuleFileRequest& operator=(UploadModuleFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadModuleFileRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ModuleFileCase {
    kModuleFileInfo = 1,
    kFile = 2,
    MODULE_FILE_NOT_SET = 0,
  };

  static inline const UploadModuleFileRequest* internal_default_instance() {
    return reinterpret_cast<const UploadModuleFileRequest*>(
               &_UploadModuleFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    219;

  friend void swap(UploadModuleFileRequest& a, UploadModuleFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadModuleFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadModuleFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadModuleFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadModuleFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadModuleFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadModuleFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadModuleFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UploadModuleFileRequest";
  }
  protected:
  explicit UploadModuleFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFileInfoFieldNumber = 1,
    kFileFieldNumber = 2,
  };
  // .viam.app.v1.ModuleFileInfo module_file_info = 1 [json_name = "moduleFileInfo"];
  bool has_module_file_info() const;
  private:
  bool _internal_has_module_file_info() const;
  public:
  void clear_module_file_info();
  const ::viam::app::v1::ModuleFileInfo& module_file_info() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ModuleFileInfo* release_module_file_info();
  ::viam::app::v1::ModuleFileInfo* mutable_module_file_info();
  void set_allocated_module_file_info(::viam::app::v1::ModuleFileInfo* module_file_info);
  private:
  const ::viam::app::v1::ModuleFileInfo& _internal_module_file_info() const;
  ::viam::app::v1::ModuleFileInfo* _internal_mutable_module_file_info();
  public:
  void unsafe_arena_set_allocated_module_file_info(
      ::viam::app::v1::ModuleFileInfo* module_file_info);
  ::viam::app::v1::ModuleFileInfo* unsafe_arena_release_module_file_info();

  // bytes file = 2 [json_name = "file"];
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_NODISCARD std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  void clear_module_file();
  ModuleFileCase module_file_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.UploadModuleFileRequest)
 private:
  class _Internal;
  void set_has_module_file_info();
  void set_has_file();

  inline bool has_module_file() const;
  inline void clear_has_module_file();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ModuleFileUnion {
    constexpr ModuleFileUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::viam::app::v1::ModuleFileInfo* module_file_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  } module_file_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UploadModuleFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UploadModuleFileResponse) */ {
 public:
  inline UploadModuleFileResponse() : UploadModuleFileResponse(nullptr) {}
  ~UploadModuleFileResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadModuleFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadModuleFileResponse(const UploadModuleFileResponse& from);
  UploadModuleFileResponse(UploadModuleFileResponse&& from) noexcept
    : UploadModuleFileResponse() {
    *this = ::std::move(from);
  }

  inline UploadModuleFileResponse& operator=(const UploadModuleFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadModuleFileResponse& operator=(UploadModuleFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadModuleFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadModuleFileResponse* internal_default_instance() {
    return reinterpret_cast<const UploadModuleFileResponse*>(
               &_UploadModuleFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    220;

  friend void swap(UploadModuleFileResponse& a, UploadModuleFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadModuleFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadModuleFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadModuleFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadModuleFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadModuleFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadModuleFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadModuleFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UploadModuleFileResponse";
  }
  protected:
  explicit UploadModuleFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UploadModuleFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetModuleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetModuleRequest) */ {
 public:
  inline GetModuleRequest() : GetModuleRequest(nullptr) {}
  ~GetModuleRequest() override;
  explicit PROTOBUF_CONSTEXPR GetModuleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModuleRequest(const GetModuleRequest& from);
  GetModuleRequest(GetModuleRequest&& from) noexcept
    : GetModuleRequest() {
    *this = ::std::move(from);
  }

  inline GetModuleRequest& operator=(const GetModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleRequest& operator=(GetModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleRequest* internal_default_instance() {
    return reinterpret_cast<const GetModuleRequest*>(
               &_GetModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    221;

  friend void swap(GetModuleRequest& a, GetModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModuleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModuleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModuleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetModuleRequest";
  }
  protected:
  explicit GetModuleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleIdFieldNumber = 1,
    kIncludeMarkdownDocumentationFieldNumber = 2,
  };
  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // optional bool include_markdown_documentation = 2 [json_name = "includeMarkdownDocumentation"];
  bool has_include_markdown_documentation() const;
  private:
  bool _internal_has_include_markdown_documentation() const;
  public:
  void clear_include_markdown_documentation();
  bool include_markdown_documentation() const;
  void set_include_markdown_documentation(bool value);
  private:
  bool _internal_include_markdown_documentation() const;
  void _internal_set_include_markdown_documentation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetModuleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  bool include_markdown_documentation_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetModuleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetModuleResponse) */ {
 public:
  inline GetModuleResponse() : GetModuleResponse(nullptr) {}
  ~GetModuleResponse() override;
  explicit PROTOBUF_CONSTEXPR GetModuleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModuleResponse(const GetModuleResponse& from);
  GetModuleResponse(GetModuleResponse&& from) noexcept
    : GetModuleResponse() {
    *this = ::std::move(from);
  }

  inline GetModuleResponse& operator=(const GetModuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleResponse& operator=(GetModuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleResponse* internal_default_instance() {
    return reinterpret_cast<const GetModuleResponse*>(
               &_GetModuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    222;

  friend void swap(GetModuleResponse& a, GetModuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModuleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModuleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModuleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetModuleResponse";
  }
  protected:
  explicit GetModuleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFieldNumber = 1,
  };
  // .viam.app.v1.Module module = 1 [json_name = "module"];
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::viam::app::v1::Module& module() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Module* release_module();
  ::viam::app::v1::Module* mutable_module();
  void set_allocated_module(::viam::app::v1::Module* module);
  private:
  const ::viam::app::v1::Module& _internal_module() const;
  ::viam::app::v1::Module* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::viam::app::v1::Module* module);
  ::viam::app::v1::Module* unsafe_arena_release_module();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetModuleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Module* module_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Module final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Module) */ {
 public:
  inline Module() : Module(nullptr) {}
  ~Module() override;
  explicit PROTOBUF_CONSTEXPR Module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Module(const Module& from);
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Module& operator=(Module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Module& default_instance() {
    return *internal_default_instance();
  }
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    223;

  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }
  inline void Swap(Module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Module>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Module& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Module& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Module* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Module";
  }
  protected:
  explicit Module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 4,
    kModelsFieldNumber = 7,
    kAppsFieldNumber = 15,
    kModuleIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kUrlFieldNumber = 5,
    kDescriptionFieldNumber = 6,
    kOrganizationIdFieldNumber = 10,
    kEntrypointFieldNumber = 11,
    kPublicNamespaceFieldNumber = 12,
    kFirstRunFieldNumber = 13,
    kMarkdownDescriptionFieldNumber = 14,
    kTotalRobotUsageFieldNumber = 8,
    kTotalOrganizationUsageFieldNumber = 9,
    kVisibilityFieldNumber = 3,
  };
  // repeated .viam.app.v1.VersionHistory versions = 4 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  ::viam::app::v1::VersionHistory* mutable_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >*
      mutable_versions();
  private:
  const ::viam::app::v1::VersionHistory& _internal_versions(int index) const;
  ::viam::app::v1::VersionHistory* _internal_add_versions();
  public:
  const ::viam::app::v1::VersionHistory& versions(int index) const;
  ::viam::app::v1::VersionHistory* add_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >&
      versions() const;

  // repeated .viam.app.v1.Model models = 7 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // repeated .viam.app.v1.App apps = 15 [json_name = "apps"];
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::viam::app::v1::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
      mutable_apps();
  private:
  const ::viam::app::v1::App& _internal_apps(int index) const;
  ::viam::app::v1::App* _internal_add_apps();
  public:
  const ::viam::app::v1::App& apps(int index) const;
  ::viam::app::v1::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
      apps() const;

  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 5 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 6 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string organization_id = 10 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string entrypoint = 11 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // string public_namespace = 12 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // optional string first_run = 13 [json_name = "firstRun"];
  bool has_first_run() const;
  private:
  bool _internal_has_first_run() const;
  public:
  void clear_first_run();
  const std::string& first_run() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_run(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_run();
  PROTOBUF_NODISCARD std::string* release_first_run();
  void set_allocated_first_run(std::string* first_run);
  private:
  const std::string& _internal_first_run() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_run(const std::string& value);
  std::string* _internal_mutable_first_run();
  public:

  // optional string markdown_description = 14 [json_name = "markdownDescription"];
  bool has_markdown_description() const;
  private:
  bool _internal_has_markdown_description() const;
  public:
  void clear_markdown_description();
  const std::string& markdown_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_markdown_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_markdown_description();
  PROTOBUF_NODISCARD std::string* release_markdown_description();
  void set_allocated_markdown_description(std::string* markdown_description);
  private:
  const std::string& _internal_markdown_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_markdown_description(const std::string& value);
  std::string* _internal_mutable_markdown_description();
  public:

  // int64 total_robot_usage = 8 [json_name = "totalRobotUsage"];
  void clear_total_robot_usage();
  int64_t total_robot_usage() const;
  void set_total_robot_usage(int64_t value);
  private:
  int64_t _internal_total_robot_usage() const;
  void _internal_set_total_robot_usage(int64_t value);
  public:

  // int64 total_organization_usage = 9 [json_name = "totalOrganizationUsage"];
  void clear_total_organization_usage();
  int64_t total_organization_usage() const;
  void set_total_organization_usage(int64_t value);
  private:
  int64_t _internal_total_organization_usage() const;
  void _internal_set_total_organization_usage(int64_t value);
  public:

  // .viam.app.v1.Visibility visibility = 3 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory > versions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App > apps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_run_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr markdown_description_;
  int64_t total_robot_usage_;
  int64_t total_organization_usage_;
  int visibility_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class VersionHistory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.VersionHistory) */ {
 public:
  inline VersionHistory() : VersionHistory(nullptr) {}
  ~VersionHistory() override;
  explicit PROTOBUF_CONSTEXPR VersionHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionHistory(const VersionHistory& from);
  VersionHistory(VersionHistory&& from) noexcept
    : VersionHistory() {
    *this = ::std::move(from);
  }

  inline VersionHistory& operator=(const VersionHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionHistory& operator=(VersionHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionHistory* internal_default_instance() {
    return reinterpret_cast<const VersionHistory*>(
               &_VersionHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    224;

  friend void swap(VersionHistory& a, VersionHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionHistory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionHistory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionHistory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VersionHistory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionHistory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.VersionHistory";
  }
  protected:
  explicit VersionHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 2,
    kModelsFieldNumber = 3,
    kAppsFieldNumber = 7,
    kVersionFieldNumber = 1,
    kEntrypointFieldNumber = 4,
    kFirstRunFieldNumber = 5,
    kMarkdownDescriptionFieldNumber = 6,
  };
  // repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::viam::app::v1::Uploads* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
      mutable_files();
  private:
  const ::viam::app::v1::Uploads& _internal_files(int index) const;
  ::viam::app::v1::Uploads* _internal_add_files();
  public:
  const ::viam::app::v1::Uploads& files(int index) const;
  ::viam::app::v1::Uploads* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
      files() const;

  // repeated .viam.app.v1.Model models = 3 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // repeated .viam.app.v1.App apps = 7 [json_name = "apps"];
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::viam::app::v1::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
      mutable_apps();
  private:
  const ::viam::app::v1::App& _internal_apps(int index) const;
  ::viam::app::v1::App* _internal_add_apps();
  public:
  const ::viam::app::v1::App& apps(int index) const;
  ::viam::app::v1::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
      apps() const;

  // string version = 1 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string entrypoint = 4 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // optional string first_run = 5 [json_name = "firstRun"];
  bool has_first_run() const;
  private:
  bool _internal_has_first_run() const;
  public:
  void clear_first_run();
  const std::string& first_run() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_run(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_run();
  PROTOBUF_NODISCARD std::string* release_first_run();
  void set_allocated_first_run(std::string* first_run);
  private:
  const std::string& _internal_first_run() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_run(const std::string& value);
  std::string* _internal_mutable_first_run();
  public:

  // optional string markdown_description = 6 [json_name = "markdownDescription"];
  bool has_markdown_description() const;
  private:
  bool _internal_has_markdown_description() const;
  public:
  void clear_markdown_description();
  const std::string& markdown_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_markdown_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_markdown_description();
  PROTOBUF_NODISCARD std::string* release_markdown_description();
  void set_allocated_markdown_description(std::string* markdown_description);
  private:
  const std::string& _internal_markdown_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_markdown_description(const std::string& value);
  std::string* _internal_mutable_markdown_description();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.VersionHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App > apps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_run_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr markdown_description_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Uploads final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Uploads) */ {
 public:
  inline Uploads() : Uploads(nullptr) {}
  ~Uploads() override;
  explicit PROTOBUF_CONSTEXPR Uploads(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uploads(const Uploads& from);
  Uploads(Uploads&& from) noexcept
    : Uploads() {
    *this = ::std::move(from);
  }

  inline Uploads& operator=(const Uploads& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uploads& operator=(Uploads&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uploads& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uploads* internal_default_instance() {
    return reinterpret_cast<const Uploads*>(
               &_Uploads_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    225;

  friend void swap(Uploads& a, Uploads& b) {
    a.Swap(&b);
  }
  inline void Swap(Uploads* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uploads* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uploads* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uploads>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uploads& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Uploads& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uploads* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Uploads";
  }
  protected:
  explicit Uploads(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformFieldNumber = 1,
    kUploadedAtFieldNumber = 2,
  };
  // string platform = 1 [json_name = "platform"];
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // .google.protobuf.Timestamp uploaded_at = 2 [json_name = "uploadedAt"];
  bool has_uploaded_at() const;
  private:
  bool _internal_has_uploaded_at() const;
  public:
  void clear_uploaded_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& uploaded_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_uploaded_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_uploaded_at();
  void set_allocated_uploaded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_uploaded_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_uploaded_at();
  public:
  void unsafe_arena_set_allocated_uploaded_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_uploaded_at();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Uploads)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListModulesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListModulesRequest) */ {
 public:
  inline ListModulesRequest() : ListModulesRequest(nullptr) {}
  ~ListModulesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListModulesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListModulesRequest(const ListModulesRequest& from);
  ListModulesRequest(ListModulesRequest&& from) noexcept
    : ListModulesRequest() {
    *this = ::std::move(from);
  }

  inline ListModulesRequest& operator=(const ListModulesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModulesRequest& operator=(ListModulesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModulesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModulesRequest* internal_default_instance() {
    return reinterpret_cast<const ListModulesRequest*>(
               &_ListModulesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    226;

  friend void swap(ListModulesRequest& a, ListModulesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModulesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModulesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModulesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModulesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListModulesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListModulesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListModulesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListModulesRequest";
  }
  protected:
  explicit ListModulesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kIncludeMarkdownDocumentationFieldNumber = 2,
  };
  // optional string organization_id = 1 [json_name = "organizationId"];
  bool has_organization_id() const;
  private:
  bool _internal_has_organization_id() const;
  public:
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // optional bool include_markdown_documentation = 2 [json_name = "includeMarkdownDocumentation"];
  bool has_include_markdown_documentation() const;
  private:
  bool _internal_has_include_markdown_documentation() const;
  public:
  void clear_include_markdown_documentation();
  bool include_markdown_documentation() const;
  void set_include_markdown_documentation(bool value);
  private:
  bool _internal_include_markdown_documentation() const;
  void _internal_set_include_markdown_documentation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListModulesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  bool include_markdown_documentation_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListModulesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListModulesResponse) */ {
 public:
  inline ListModulesResponse() : ListModulesResponse(nullptr) {}
  ~ListModulesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListModulesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListModulesResponse(const ListModulesResponse& from);
  ListModulesResponse(ListModulesResponse&& from) noexcept
    : ListModulesResponse() {
    *this = ::std::move(from);
  }

  inline ListModulesResponse& operator=(const ListModulesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModulesResponse& operator=(ListModulesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModulesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModulesResponse* internal_default_instance() {
    return reinterpret_cast<const ListModulesResponse*>(
               &_ListModulesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    227;

  friend void swap(ListModulesResponse& a, ListModulesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModulesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModulesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModulesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModulesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListModulesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListModulesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListModulesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListModulesResponse";
  }
  protected:
  explicit ListModulesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 1,
  };
  // repeated .viam.app.v1.Module modules = 1 [json_name = "modules"];
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  ::viam::app::v1::Module* mutable_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >*
      mutable_modules();
  private:
  const ::viam::app::v1::Module& _internal_modules(int index) const;
  ::viam::app::v1::Module* _internal_add_modules();
  public:
  const ::viam::app::v1::Module& modules(int index) const;
  ::viam::app::v1::Module* add_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >&
      modules() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListModulesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module > modules_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDByEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetUserIDByEmailRequest) */ {
 public:
  inline GetUserIDByEmailRequest() : GetUserIDByEmailRequest(nullptr) {}
  ~GetUserIDByEmailRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserIDByEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDByEmailRequest(const GetUserIDByEmailRequest& from);
  GetUserIDByEmailRequest(GetUserIDByEmailRequest&& from) noexcept
    : GetUserIDByEmailRequest() {
    *this = ::std::move(from);
  }

  inline GetUserIDByEmailRequest& operator=(const GetUserIDByEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDByEmailRequest& operator=(GetUserIDByEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDByEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDByEmailRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserIDByEmailRequest*>(
               &_GetUserIDByEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    228;

  friend void swap(GetUserIDByEmailRequest& a, GetUserIDByEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDByEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDByEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDByEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDByEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDByEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserIDByEmailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDByEmailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetUserIDByEmailRequest";
  }
  protected:
  explicit GetUserIDByEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetUserIDByEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDByEmailResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetUserIDByEmailResponse) */ {
 public:
  inline GetUserIDByEmailResponse() : GetUserIDByEmailResponse(nullptr) {}
  ~GetUserIDByEmailResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserIDByEmailResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDByEmailResponse(const GetUserIDByEmailResponse& from);
  GetUserIDByEmailResponse(GetUserIDByEmailResponse&& from) noexcept
    : GetUserIDByEmailResponse() {
    *this = ::std::move(from);
  }

  inline GetUserIDByEmailResponse& operator=(const GetUserIDByEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDByEmailResponse& operator=(GetUserIDByEmailResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDByEmailResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDByEmailResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserIDByEmailResponse*>(
               &_GetUserIDByEmailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    229;

  friend void swap(GetUserIDByEmailResponse& a, GetUserIDByEmailResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDByEmailResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDByEmailResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDByEmailResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDByEmailResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDByEmailResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserIDByEmailResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDByEmailResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetUserIDByEmailResponse";
  }
  protected:
  explicit GetUserIDByEmailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetUserIDByEmailResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsByUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsByUserRequest) */ {
 public:
  inline ListOrganizationsByUserRequest() : ListOrganizationsByUserRequest(nullptr) {}
  ~ListOrganizationsByUserRequest() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationsByUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsByUserRequest(const ListOrganizationsByUserRequest& from);
  ListOrganizationsByUserRequest(ListOrganizationsByUserRequest&& from) noexcept
    : ListOrganizationsByUserRequest() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsByUserRequest& operator=(const ListOrganizationsByUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsByUserRequest& operator=(ListOrganizationsByUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsByUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsByUserRequest* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsByUserRequest*>(
               &_ListOrganizationsByUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    230;

  friend void swap(ListOrganizationsByUserRequest& a, ListOrganizationsByUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsByUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsByUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsByUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsByUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationsByUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationsByUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationsByUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsByUserRequest";
  }
  protected:
  explicit ListOrganizationsByUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsByUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrgDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrgDetails) */ {
 public:
  inline OrgDetails() : OrgDetails(nullptr) {}
  ~OrgDetails() override;
  explicit PROTOBUF_CONSTEXPR OrgDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrgDetails(const OrgDetails& from);
  OrgDetails(OrgDetails&& from) noexcept
    : OrgDetails() {
    *this = ::std::move(from);
  }

  inline OrgDetails& operator=(const OrgDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrgDetails& operator=(OrgDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrgDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrgDetails* internal_default_instance() {
    return reinterpret_cast<const OrgDetails*>(
               &_OrgDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    231;

  friend void swap(OrgDetails& a, OrgDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(OrgDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrgDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrgDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrgDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrgDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrgDetails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrgDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrgDetails";
  }
  protected:
  explicit OrgDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kOrgNameFieldNumber = 2,
    kOrgCidFieldNumber = 3,
    kPublicNamespaceFieldNumber = 4,
    kBillingTierFieldNumber = 5,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string org_name = 2 [json_name = "orgName"];
  void clear_org_name();
  const std::string& org_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_name();
  PROTOBUF_NODISCARD std::string* release_org_name();
  void set_allocated_org_name(std::string* org_name);
  private:
  const std::string& _internal_org_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_name(const std::string& value);
  std::string* _internal_mutable_org_name();
  public:

  // optional string org_cid = 3 [json_name = "orgCid"];
  bool has_org_cid() const;
  private:
  bool _internal_has_org_cid() const;
  public:
  void clear_org_cid();
  const std::string& org_cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_cid();
  PROTOBUF_NODISCARD std::string* release_org_cid();
  void set_allocated_org_cid(std::string* org_cid);
  private:
  const std::string& _internal_org_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_cid(const std::string& value);
  std::string* _internal_mutable_org_cid();
  public:

  // optional string public_namespace = 4 [json_name = "publicNamespace"];
  bool has_public_namespace() const;
  private:
  bool _internal_has_public_namespace() const;
  public:
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // optional string billing_tier = 5 [json_name = "billingTier"];
  bool has_billing_tier() const;
  private:
  bool _internal_has_billing_tier() const;
  public:
  void clear_billing_tier();
  const std::string& billing_tier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_billing_tier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_billing_tier();
  PROTOBUF_NODISCARD std::string* release_billing_tier();
  void set_allocated_billing_tier(std::string* billing_tier);
  private:
  const std::string& _internal_billing_tier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_billing_tier(const std::string& value);
  std::string* _internal_mutable_billing_tier();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrgDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr billing_tier_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsByUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsByUserResponse) */ {
 public:
  inline ListOrganizationsByUserResponse() : ListOrganizationsByUserResponse(nullptr) {}
  ~ListOrganizationsByUserResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationsByUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsByUserResponse(const ListOrganizationsByUserResponse& from);
  ListOrganizationsByUserResponse(ListOrganizationsByUserResponse&& from) noexcept
    : ListOrganizationsByUserResponse() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsByUserResponse& operator=(const ListOrganizationsByUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsByUserResponse& operator=(ListOrganizationsByUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsByUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsByUserResponse* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsByUserResponse*>(
               &_ListOrganizationsByUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    232;

  friend void swap(ListOrganizationsByUserResponse& a, ListOrganizationsByUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsByUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsByUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsByUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsByUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationsByUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationsByUserResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationsByUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsByUserResponse";
  }
  protected:
  explicit ListOrganizationsByUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgsFieldNumber = 1,
  };
  // repeated .viam.app.v1.OrgDetails orgs = 1 [json_name = "orgs"];
  int orgs_size() const;
  private:
  int _internal_orgs_size() const;
  public:
  void clear_orgs();
  ::viam::app::v1::OrgDetails* mutable_orgs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >*
      mutable_orgs();
  private:
  const ::viam::app::v1::OrgDetails& _internal_orgs(int index) const;
  ::viam::app::v1::OrgDetails* _internal_add_orgs();
  public:
  const ::viam::app::v1::OrgDetails& orgs(int index) const;
  ::viam::app::v1::OrgDetails* add_orgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >&
      orgs() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsByUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails > orgs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class SearchOrganizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SearchOrganizationsRequest) */ {
 public:
  inline SearchOrganizationsRequest() : SearchOrganizationsRequest(nullptr) {}
  ~SearchOrganizationsRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchOrganizationsRequest(const SearchOrganizationsRequest& from);
  SearchOrganizationsRequest(SearchOrganizationsRequest&& from) noexcept
    : SearchOrganizationsRequest() {
    *this = ::std::move(from);
  }

  inline SearchOrganizationsRequest& operator=(const SearchOrganizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchOrganizationsRequest& operator=(SearchOrganizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchOrganizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchOrganizationsRequest* internal_default_instance() {
    return reinterpret_cast<const SearchOrganizationsRequest*>(
               &_SearchOrganizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    233;

  friend void swap(SearchOrganizationsRequest& a, SearchOrganizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchOrganizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchOrganizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchOrganizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchOrganizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchOrganizationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchOrganizationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchOrganizationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SearchOrganizationsRequest";
  }
  protected:
  explicit SearchOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kOrgNameFieldNumber = 2,
    kCidFieldNumber = 3,
    kPublicNamespaceFieldNumber = 4,
  };
  // optional string org_id = 1 [json_name = "orgId"];
  bool has_org_id() const;
  private:
  bool _internal_has_org_id() const;
  public:
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // optional string org_name = 2 [json_name = "orgName"];
  bool has_org_name() const;
  private:
  bool _internal_has_org_name() const;
  public:
  void clear_org_name();
  const std::string& org_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_name();
  PROTOBUF_NODISCARD std::string* release_org_name();
  void set_allocated_org_name(std::string* org_name);
  private:
  const std::string& _internal_org_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_name(const std::string& value);
  std::string* _internal_mutable_org_name();
  public:

  // optional string cid = 3 [json_name = "cid"];
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // optional string public_namespace = 4 [json_name = "publicNamespace"];
  bool has_public_namespace() const;
  private:
  bool _internal_has_public_namespace() const;
  public:
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.SearchOrganizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class SearchOrganizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SearchOrganizationsResponse) */ {
 public:
  inline SearchOrganizationsResponse() : SearchOrganizationsResponse(nullptr) {}
  ~SearchOrganizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchOrganizationsResponse(const SearchOrganizationsResponse& from);
  SearchOrganizationsResponse(SearchOrganizationsResponse&& from) noexcept
    : SearchOrganizationsResponse() {
    *this = ::std::move(from);
  }

  inline SearchOrganizationsResponse& operator=(const SearchOrganizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchOrganizationsResponse& operator=(SearchOrganizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchOrganizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchOrganizationsResponse* internal_default_instance() {
    return reinterpret_cast<const SearchOrganizationsResponse*>(
               &_SearchOrganizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    234;

  friend void swap(SearchOrganizationsResponse& a, SearchOrganizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchOrganizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchOrganizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchOrganizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchOrganizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchOrganizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchOrganizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchOrganizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SearchOrganizationsResponse";
  }
  protected:
  explicit SearchOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.OrgDetails organizations = 1 [json_name = "organizations"];
  int organizations_size() const;
  private:
  int _internal_organizations_size() const;
  public:
  void clear_organizations();
  ::viam::app::v1::OrgDetails* mutable_organizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >*
      mutable_organizations();
  private:
  const ::viam::app::v1::OrgDetails& _internal_organizations(int index) const;
  ::viam::app::v1::OrgDetails* _internal_add_organizations();
  public:
  const ::viam::app::v1::OrgDetails& organizations(int index) const;
  ::viam::app::v1::OrgDetails* add_organizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >&
      organizations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.SearchOrganizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails > organizations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyRequest) */ {
 public:
  inline CreateKeyRequest() : CreateKeyRequest(nullptr) {}
  ~CreateKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyRequest(const CreateKeyRequest& from);
  CreateKeyRequest(CreateKeyRequest&& from) noexcept
    : CreateKeyRequest() {
    *this = ::std::move(from);
  }

  inline CreateKeyRequest& operator=(const CreateKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyRequest& operator=(CreateKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyRequest* internal_default_instance() {
    return reinterpret_cast<const CreateKeyRequest*>(
               &_CreateKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    235;

  friend void swap(CreateKeyRequest& a, CreateKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyRequest";
  }
  protected:
  explicit CreateKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyResponse) */ {
 public:
  inline CreateKeyResponse() : CreateKeyResponse(nullptr) {}
  ~CreateKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyResponse(const CreateKeyResponse& from);
  CreateKeyResponse(CreateKeyResponse&& from) noexcept
    : CreateKeyResponse() {
    *this = ::std::move(from);
  }

  inline CreateKeyResponse& operator=(const CreateKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyResponse& operator=(CreateKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyResponse* internal_default_instance() {
    return reinterpret_cast<const CreateKeyResponse*>(
               &_CreateKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    236;

  friend void swap(CreateKeyResponse& a, CreateKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyResponse";
  }
  protected:
  explicit CreateKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string id = 2 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteKeyRequest) */ {
 public:
  inline DeleteKeyRequest() : DeleteKeyRequest(nullptr) {}
  ~DeleteKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteKeyRequest(const DeleteKeyRequest& from);
  DeleteKeyRequest(DeleteKeyRequest&& from) noexcept
    : DeleteKeyRequest() {
    *this = ::std::move(from);
  }

  inline DeleteKeyRequest& operator=(const DeleteKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyRequest& operator=(DeleteKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyRequest*>(
               &_DeleteKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    237;

  friend void swap(DeleteKeyRequest& a, DeleteKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteKeyRequest";
  }
  protected:
  explicit DeleteKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteKeyResponse) */ {
 public:
  inline DeleteKeyResponse() : DeleteKeyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteKeyResponse(const DeleteKeyResponse& from);
  DeleteKeyResponse(DeleteKeyResponse&& from) noexcept
    : DeleteKeyResponse() {
    *this = ::std::move(from);
  }

  inline DeleteKeyResponse& operator=(const DeleteKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyResponse& operator=(DeleteKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyResponse*>(
               &_DeleteKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    238;

  friend void swap(DeleteKeyResponse& a, DeleteKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteKeyResponse";
  }
  protected:
  explicit DeleteKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RenameKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RenameKeyRequest) */ {
 public:
  inline RenameKeyRequest() : RenameKeyRequest(nullptr) {}
  ~RenameKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR RenameKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameKeyRequest(const RenameKeyRequest& from);
  RenameKeyRequest(RenameKeyRequest&& from) noexcept
    : RenameKeyRequest() {
    *this = ::std::move(from);
  }

  inline RenameKeyRequest& operator=(const RenameKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameKeyRequest& operator=(RenameKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameKeyRequest* internal_default_instance() {
    return reinterpret_cast<const RenameKeyRequest*>(
               &_RenameKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    239;

  friend void swap(RenameKeyRequest& a, RenameKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RenameKeyRequest";
  }
  protected:
  explicit RenameKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RenameKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RenameKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RenameKeyResponse) */ {
 public:
  inline RenameKeyResponse() : RenameKeyResponse(nullptr) {}
  ~RenameKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR RenameKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameKeyResponse(const RenameKeyResponse& from);
  RenameKeyResponse(RenameKeyResponse&& from) noexcept
    : RenameKeyResponse() {
    *this = ::std::move(from);
  }

  inline RenameKeyResponse& operator=(const RenameKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameKeyResponse& operator=(RenameKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameKeyResponse* internal_default_instance() {
    return reinterpret_cast<const RenameKeyResponse*>(
               &_RenameKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    240;

  friend void swap(RenameKeyResponse& a, RenameKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RenameKeyResponse";
  }
  protected:
  explicit RenameKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RenameKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AuthorizationDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthorizationDetails) */ {
 public:
  inline AuthorizationDetails() : AuthorizationDetails(nullptr) {}
  ~AuthorizationDetails() override;
  explicit PROTOBUF_CONSTEXPR AuthorizationDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizationDetails(const AuthorizationDetails& from);
  AuthorizationDetails(AuthorizationDetails&& from) noexcept
    : AuthorizationDetails() {
    *this = ::std::move(from);
  }

  inline AuthorizationDetails& operator=(const AuthorizationDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizationDetails& operator=(AuthorizationDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizationDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizationDetails* internal_default_instance() {
    return reinterpret_cast<const AuthorizationDetails*>(
               &_AuthorizationDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    241;

  friend void swap(AuthorizationDetails& a, AuthorizationDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizationDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizationDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizationDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizationDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizationDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthorizationDetails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizationDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AuthorizationDetails";
  }
  protected:
  explicit AuthorizationDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationTypeFieldNumber = 1,
    kAuthorizationIdFieldNumber = 2,
    kResourceTypeFieldNumber = 3,
    kResourceIdFieldNumber = 4,
    kOrgIdFieldNumber = 5,
  };
  // string authorization_type = 1 [json_name = "authorizationType"];
  void clear_authorization_type();
  const std::string& authorization_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_type();
  PROTOBUF_NODISCARD std::string* release_authorization_type();
  void set_allocated_authorization_type(std::string* authorization_type);
  private:
  const std::string& _internal_authorization_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_type(const std::string& value);
  std::string* _internal_mutable_authorization_type();
  public:

  // string authorization_id = 2 [json_name = "authorizationId"];
  void clear_authorization_id();
  const std::string& authorization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_id();
  PROTOBUF_NODISCARD std::string* release_authorization_id();
  void set_allocated_authorization_id(std::string* authorization_id);
  private:
  const std::string& _internal_authorization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_id(const std::string& value);
  std::string* _internal_mutable_authorization_id();
  public:

  // string resource_type = 3 [json_name = "resourceType"];
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string resource_id = 4 [json_name = "resourceId"];
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string org_id = 5 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthorizationDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class APIKeyWithAuthorizations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.APIKeyWithAuthorizations) */ {
 public:
  inline APIKeyWithAuthorizations() : APIKeyWithAuthorizations(nullptr) {}
  ~APIKeyWithAuthorizations() override;
  explicit PROTOBUF_CONSTEXPR APIKeyWithAuthorizations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIKeyWithAuthorizations(const APIKeyWithAuthorizations& from);
  APIKeyWithAuthorizations(APIKeyWithAuthorizations&& from) noexcept
    : APIKeyWithAuthorizations() {
    *this = ::std::move(from);
  }

  inline APIKeyWithAuthorizations& operator=(const APIKeyWithAuthorizations& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIKeyWithAuthorizations& operator=(APIKeyWithAuthorizations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIKeyWithAuthorizations& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIKeyWithAuthorizations* internal_default_instance() {
    return reinterpret_cast<const APIKeyWithAuthorizations*>(
               &_APIKeyWithAuthorizations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    242;

  friend void swap(APIKeyWithAuthorizations& a, APIKeyWithAuthorizations& b) {
    a.Swap(&b);
  }
  inline void Swap(APIKeyWithAuthorizations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIKeyWithAuthorizations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIKeyWithAuthorizations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIKeyWithAuthorizations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIKeyWithAuthorizations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const APIKeyWithAuthorizations& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIKeyWithAuthorizations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.APIKeyWithAuthorizations";
  }
  protected:
  explicit APIKeyWithAuthorizations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 2,
    kApiKeyFieldNumber = 1,
  };
  // repeated .viam.app.v1.AuthorizationDetails authorizations = 2 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::AuthorizationDetails* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::AuthorizationDetails& _internal_authorizations(int index) const;
  ::viam::app::v1::AuthorizationDetails* _internal_add_authorizations();
  public:
  const ::viam::app::v1::AuthorizationDetails& authorizations(int index) const;
  ::viam::app::v1::AuthorizationDetails* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >&
      authorizations() const;

  // .viam.app.v1.APIKey api_key = 1 [json_name = "apiKey"];
  bool has_api_key() const;
  private:
  bool _internal_has_api_key() const;
  public:
  void clear_api_key();
  const ::viam::app::v1::APIKey& api_key() const;
  PROTOBUF_NODISCARD ::viam::app::v1::APIKey* release_api_key();
  ::viam::app::v1::APIKey* mutable_api_key();
  void set_allocated_api_key(::viam::app::v1::APIKey* api_key);
  private:
  const ::viam::app::v1::APIKey& _internal_api_key() const;
  ::viam::app::v1::APIKey* _internal_mutable_api_key();
  public:
  void unsafe_arena_set_allocated_api_key(
      ::viam::app::v1::APIKey* api_key);
  ::viam::app::v1::APIKey* unsafe_arena_release_api_key();

  // @@protoc_insertion_point(class_scope:viam.app.v1.APIKeyWithAuthorizations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails > authorizations_;
  ::viam::app::v1::APIKey* api_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListKeysRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListKeysRequest) */ {
 public:
  inline ListKeysRequest() : ListKeysRequest(nullptr) {}
  ~ListKeysRequest() override;
  explicit PROTOBUF_CONSTEXPR ListKeysRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListKeysRequest(const ListKeysRequest& from);
  ListKeysRequest(ListKeysRequest&& from) noexcept
    : ListKeysRequest() {
    *this = ::std::move(from);
  }

  inline ListKeysRequest& operator=(const ListKeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListKeysRequest& operator=(ListKeysRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListKeysRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListKeysRequest* internal_default_instance() {
    return reinterpret_cast<const ListKeysRequest*>(
               &_ListKeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    243;

  friend void swap(ListKeysRequest& a, ListKeysRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListKeysRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListKeysRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListKeysRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListKeysRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListKeysRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListKeysRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListKeysRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListKeysRequest";
  }
  protected:
  explicit ListKeysRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListKeysRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListKeysResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListKeysResponse) */ {
 public:
  inline ListKeysResponse() : ListKeysResponse(nullptr) {}
  ~ListKeysResponse() override;
  explicit PROTOBUF_CONSTEXPR ListKeysResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListKeysResponse(const ListKeysResponse& from);
  ListKeysResponse(ListKeysResponse&& from) noexcept
    : ListKeysResponse() {
    *this = ::std::move(from);
  }

  inline ListKeysResponse& operator=(const ListKeysResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListKeysResponse& operator=(ListKeysResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListKeysResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListKeysResponse* internal_default_instance() {
    return reinterpret_cast<const ListKeysResponse*>(
               &_ListKeysResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    244;

  friend void swap(ListKeysResponse& a, ListKeysResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListKeysResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListKeysResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListKeysResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListKeysResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListKeysResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListKeysResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListKeysResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListKeysResponse";
  }
  protected:
  explicit ListKeysResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeysFieldNumber = 1,
  };
  // repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
  int api_keys_size() const;
  private:
  int _internal_api_keys_size() const;
  public:
  void clear_api_keys();
  ::viam::app::v1::APIKeyWithAuthorizations* mutable_api_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
      mutable_api_keys();
  private:
  const ::viam::app::v1::APIKeyWithAuthorizations& _internal_api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* _internal_add_api_keys();
  public:
  const ::viam::app::v1::APIKeyWithAuthorizations& api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* add_api_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
      api_keys() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListKeysResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations > api_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RotateKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RotateKeyRequest) */ {
 public:
  inline RotateKeyRequest() : RotateKeyRequest(nullptr) {}
  ~RotateKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR RotateKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotateKeyRequest(const RotateKeyRequest& from);
  RotateKeyRequest(RotateKeyRequest&& from) noexcept
    : RotateKeyRequest() {
    *this = ::std::move(from);
  }

  inline RotateKeyRequest& operator=(const RotateKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateKeyRequest& operator=(RotateKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotateKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotateKeyRequest* internal_default_instance() {
    return reinterpret_cast<const RotateKeyRequest*>(
               &_RotateKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    245;

  friend void swap(RotateKeyRequest& a, RotateKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RotateKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotateKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotateKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotateKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotateKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RotateKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RotateKeyRequest";
  }
  protected:
  explicit RotateKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RotateKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RotateKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RotateKeyResponse) */ {
 public:
  inline RotateKeyResponse() : RotateKeyResponse(nullptr) {}
  ~RotateKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR RotateKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotateKeyResponse(const RotateKeyResponse& from);
  RotateKeyResponse(RotateKeyResponse&& from) noexcept
    : RotateKeyResponse() {
    *this = ::std::move(from);
  }

  inline RotateKeyResponse& operator=(const RotateKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateKeyResponse& operator=(RotateKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotateKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotateKeyResponse* internal_default_instance() {
    return reinterpret_cast<const RotateKeyResponse*>(
               &_RotateKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    246;

  friend void swap(RotateKeyResponse& a, RotateKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RotateKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotateKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotateKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotateKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotateKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RotateKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RotateKeyResponse";
  }
  protected:
  explicit RotateKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string key = 2 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RotateKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyFromExistingKeyAuthorizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest) */ {
 public:
  inline CreateKeyFromExistingKeyAuthorizationsRequest() : CreateKeyFromExistingKeyAuthorizationsRequest(nullptr) {}
  ~CreateKeyFromExistingKeyAuthorizationsRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyFromExistingKeyAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyFromExistingKeyAuthorizationsRequest(const CreateKeyFromExistingKeyAuthorizationsRequest& from);
  CreateKeyFromExistingKeyAuthorizationsRequest(CreateKeyFromExistingKeyAuthorizationsRequest&& from) noexcept
    : CreateKeyFromExistingKeyAuthorizationsRequest() {
    *this = ::std::move(from);
  }

  inline CreateKeyFromExistingKeyAuthorizationsRequest& operator=(const CreateKeyFromExistingKeyAuthorizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyFromExistingKeyAuthorizationsRequest& operator=(CreateKeyFromExistingKeyAuthorizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyFromExistingKeyAuthorizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyFromExistingKeyAuthorizationsRequest* internal_default_instance() {
    return reinterpret_cast<const CreateKeyFromExistingKeyAuthorizationsRequest*>(
               &_CreateKeyFromExistingKeyAuthorizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    247;

  friend void swap(CreateKeyFromExistingKeyAuthorizationsRequest& a, CreateKeyFromExistingKeyAuthorizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyFromExistingKeyAuthorizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyFromExistingKeyAuthorizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyFromExistingKeyAuthorizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyFromExistingKeyAuthorizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyFromExistingKeyAuthorizationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyFromExistingKeyAuthorizationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyFromExistingKeyAuthorizationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest";
  }
  protected:
  explicit CreateKeyFromExistingKeyAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyFromExistingKeyAuthorizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse) */ {
 public:
  inline CreateKeyFromExistingKeyAuthorizationsResponse() : CreateKeyFromExistingKeyAuthorizationsResponse(nullptr) {}
  ~CreateKeyFromExistingKeyAuthorizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyFromExistingKeyAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyFromExistingKeyAuthorizationsResponse(const CreateKeyFromExistingKeyAuthorizationsResponse& from);
  CreateKeyFromExistingKeyAuthorizationsResponse(CreateKeyFromExistingKeyAuthorizationsResponse&& from) noexcept
    : CreateKeyFromExistingKeyAuthorizationsResponse() {
    *this = ::std::move(from);
  }

  inline CreateKeyFromExistingKeyAuthorizationsResponse& operator=(const CreateKeyFromExistingKeyAuthorizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyFromExistingKeyAuthorizationsResponse& operator=(CreateKeyFromExistingKeyAuthorizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyFromExistingKeyAuthorizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyFromExistingKeyAuthorizationsResponse* internal_default_instance() {
    return reinterpret_cast<const CreateKeyFromExistingKeyAuthorizationsResponse*>(
               &_CreateKeyFromExistingKeyAuthorizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    248;

  friend void swap(CreateKeyFromExistingKeyAuthorizationsResponse& a, CreateKeyFromExistingKeyAuthorizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyFromExistingKeyAuthorizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyFromExistingKeyAuthorizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyFromExistingKeyAuthorizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyFromExistingKeyAuthorizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyFromExistingKeyAuthorizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyFromExistingKeyAuthorizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyFromExistingKeyAuthorizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse";
  }
  protected:
  explicit CreateKeyFromExistingKeyAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string key = 2 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetAppContentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetAppContentRequest) */ {
 public:
  inline GetAppContentRequest() : GetAppContentRequest(nullptr) {}
  ~GetAppContentRequest() override;
  explicit PROTOBUF_CONSTEXPR GetAppContentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppContentRequest(const GetAppContentRequest& from);
  GetAppContentRequest(GetAppContentRequest&& from) noexcept
    : GetAppContentRequest() {
    *this = ::std::move(from);
  }

  inline GetAppContentRequest& operator=(const GetAppContentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppContentRequest& operator=(GetAppContentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppContentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppContentRequest* internal_default_instance() {
    return reinterpret_cast<const GetAppContentRequest*>(
               &_GetAppContentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    249;

  friend void swap(GetAppContentRequest& a, GetAppContentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppContentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppContentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppContentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppContentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppContentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAppContentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppContentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetAppContentRequest";
  }
  protected:
  explicit GetAppContentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicNamespaceFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string public_namespace = 1 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetAppContentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetAppContentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetAppContentResponse) */ {
 public:
  inline GetAppContentResponse() : GetAppContentResponse(nullptr) {}
  ~GetAppContentResponse() override;
  explicit PROTOBUF_CONSTEXPR GetAppContentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppContentResponse(const GetAppContentResponse& from);
  GetAppContentResponse(GetAppContentResponse&& from) noexcept
    : GetAppContentResponse() {
    *this = ::std::move(from);
  }

  inline GetAppContentResponse& operator=(const GetAppContentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppContentResponse& operator=(GetAppContentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppContentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppContentResponse* internal_default_instance() {
    return reinterpret_cast<const GetAppContentResponse*>(
               &_GetAppContentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    250;

  friend void swap(GetAppContentResponse& a, GetAppContentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppContentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppContentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppContentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppContentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppContentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAppContentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppContentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetAppContentResponse";
  }
  protected:
  explicit GetAppContentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobPathFieldNumber = 1,
    kEntrypointFieldNumber = 2,
    kAppTypeFieldNumber = 3,
  };
  // string blob_path = 1 [json_name = "blobPath"];
  void clear_blob_path();
  const std::string& blob_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob_path();
  PROTOBUF_NODISCARD std::string* release_blob_path();
  void set_allocated_blob_path(std::string* blob_path);
  private:
  const std::string& _internal_blob_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob_path(const std::string& value);
  std::string* _internal_mutable_blob_path();
  public:

  // string entrypoint = 2 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // .viam.app.v1.AppType app_type = 3 [json_name = "appType"];
  void clear_app_type();
  ::viam::app::v1::AppType app_type() const;
  void set_app_type(::viam::app::v1::AppType value);
  private:
  ::viam::app::v1::AppType _internal_app_type() const;
  void _internal_set_app_type(::viam::app::v1::AppType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetAppContentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  int app_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationSetLogoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationSetLogoRequest) */ {
 public:
  inline OrganizationSetLogoRequest() : OrganizationSetLogoRequest(nullptr) {}
  ~OrganizationSetLogoRequest() override;
  explicit PROTOBUF_CONSTEXPR OrganizationSetLogoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationSetLogoRequest(const OrganizationSetLogoRequest& from);
  OrganizationSetLogoRequest(OrganizationSetLogoRequest&& from) noexcept
    : OrganizationSetLogoRequest() {
    *this = ::std::move(from);
  }

  inline OrganizationSetLogoRequest& operator=(const OrganizationSetLogoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationSetLogoRequest& operator=(OrganizationSetLogoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationSetLogoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationSetLogoRequest* internal_default_instance() {
    return reinterpret_cast<const OrganizationSetLogoRequest*>(
               &_OrganizationSetLogoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    251;

  friend void swap(OrganizationSetLogoRequest& a, OrganizationSetLogoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationSetLogoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationSetLogoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationSetLogoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationSetLogoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationSetLogoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationSetLogoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationSetLogoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationSetLogoRequest";
  }
  protected:
  explicit OrganizationSetLogoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kLogoFieldNumber = 2,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // bytes logo = 2 [json_name = "logo"];
  void clear_logo();
  const std::string& logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo();
  PROTOBUF_NODISCARD std::string* release_logo();
  void set_allocated_logo(std::string* logo);
  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(const std::string& value);
  std::string* _internal_mutable_logo();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationSetLogoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationSetLogoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationSetLogoResponse) */ {
 public:
  inline OrganizationSetLogoResponse() : OrganizationSetLogoResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OrganizationSetLogoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationSetLogoResponse(const OrganizationSetLogoResponse& from);
  OrganizationSetLogoResponse(OrganizationSetLogoResponse&& from) noexcept
    : OrganizationSetLogoResponse() {
    *this = ::std::move(from);
  }

  inline OrganizationSetLogoResponse& operator=(const OrganizationSetLogoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationSetLogoResponse& operator=(OrganizationSetLogoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationSetLogoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationSetLogoResponse* internal_default_instance() {
    return reinterpret_cast<const OrganizationSetLogoResponse*>(
               &_OrganizationSetLogoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    252;

  friend void swap(OrganizationSetLogoResponse& a, OrganizationSetLogoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationSetLogoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationSetLogoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationSetLogoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationSetLogoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OrganizationSetLogoResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OrganizationSetLogoResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationSetLogoResponse";
  }
  protected:
  explicit OrganizationSetLogoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationSetLogoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationGetLogoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationGetLogoRequest) */ {
 public:
  inline OrganizationGetLogoRequest() : OrganizationGetLogoRequest(nullptr) {}
  ~OrganizationGetLogoRequest() override;
  explicit PROTOBUF_CONSTEXPR OrganizationGetLogoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationGetLogoRequest(const OrganizationGetLogoRequest& from);
  OrganizationGetLogoRequest(OrganizationGetLogoRequest&& from) noexcept
    : OrganizationGetLogoRequest() {
    *this = ::std::move(from);
  }

  inline OrganizationGetLogoRequest& operator=(const OrganizationGetLogoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationGetLogoRequest& operator=(OrganizationGetLogoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationGetLogoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationGetLogoRequest* internal_default_instance() {
    return reinterpret_cast<const OrganizationGetLogoRequest*>(
               &_OrganizationGetLogoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    253;

  friend void swap(OrganizationGetLogoRequest& a, OrganizationGetLogoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationGetLogoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationGetLogoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationGetLogoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationGetLogoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationGetLogoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationGetLogoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationGetLogoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationGetLogoRequest";
  }
  protected:
  explicit OrganizationGetLogoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationGetLogoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationGetLogoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationGetLogoResponse) */ {
 public:
  inline OrganizationGetLogoResponse() : OrganizationGetLogoResponse(nullptr) {}
  ~OrganizationGetLogoResponse() override;
  explicit PROTOBUF_CONSTEXPR OrganizationGetLogoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationGetLogoResponse(const OrganizationGetLogoResponse& from);
  OrganizationGetLogoResponse(OrganizationGetLogoResponse&& from) noexcept
    : OrganizationGetLogoResponse() {
    *this = ::std::move(from);
  }

  inline OrganizationGetLogoResponse& operator=(const OrganizationGetLogoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationGetLogoResponse& operator=(OrganizationGetLogoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationGetLogoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationGetLogoResponse* internal_default_instance() {
    return reinterpret_cast<const OrganizationGetLogoResponse*>(
               &_OrganizationGetLogoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    254;

  friend void swap(OrganizationGetLogoResponse& a, OrganizationGetLogoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationGetLogoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationGetLogoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationGetLogoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationGetLogoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationGetLogoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationGetLogoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationGetLogoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationGetLogoResponse";
  }
  protected:
  explicit OrganizationGetLogoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationGetLogoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class EnableAuthServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.EnableAuthServiceRequest) */ {
 public:
  inline EnableAuthServiceRequest() : EnableAuthServiceRequest(nullptr) {}
  ~EnableAuthServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR EnableAuthServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableAuthServiceRequest(const EnableAuthServiceRequest& from);
  EnableAuthServiceRequest(EnableAuthServiceRequest&& from) noexcept
    : EnableAuthServiceRequest() {
    *this = ::std::move(from);
  }

  inline EnableAuthServiceRequest& operator=(const EnableAuthServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableAuthServiceRequest& operator=(EnableAuthServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableAuthServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableAuthServiceRequest* internal_default_instance() {
    return reinterpret_cast<const EnableAuthServiceRequest*>(
               &_EnableAuthServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    255;

  friend void swap(EnableAuthServiceRequest& a, EnableAuthServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableAuthServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableAuthServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableAuthServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableAuthServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableAuthServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnableAuthServiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableAuthServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.EnableAuthServiceRequest";
  }
  protected:
  explicit EnableAuthServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.EnableAuthServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class EnableAuthServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.EnableAuthServiceResponse) */ {
 public:
  inline EnableAuthServiceResponse() : EnableAuthServiceResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EnableAuthServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableAuthServiceResponse(const EnableAuthServiceResponse& from);
  EnableAuthServiceResponse(EnableAuthServiceResponse&& from) noexcept
    : EnableAuthServiceResponse() {
    *this = ::std::move(from);
  }

  inline EnableAuthServiceResponse& operator=(const EnableAuthServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableAuthServiceResponse& operator=(EnableAuthServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableAuthServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableAuthServiceResponse* internal_default_instance() {
    return reinterpret_cast<const EnableAuthServiceResponse*>(
               &_EnableAuthServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    256;

  friend void swap(EnableAuthServiceResponse& a, EnableAuthServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableAuthServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableAuthServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableAuthServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableAuthServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EnableAuthServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EnableAuthServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.EnableAuthServiceResponse";
  }
  protected:
  explicit EnableAuthServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.EnableAuthServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DisableAuthServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DisableAuthServiceRequest) */ {
 public:
  inline DisableAuthServiceRequest() : DisableAuthServiceRequest(nullptr) {}
  ~DisableAuthServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR DisableAuthServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableAuthServiceRequest(const DisableAuthServiceRequest& from);
  DisableAuthServiceRequest(DisableAuthServiceRequest&& from) noexcept
    : DisableAuthServiceRequest() {
    *this = ::std::move(from);
  }

  inline DisableAuthServiceRequest& operator=(const DisableAuthServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableAuthServiceRequest& operator=(DisableAuthServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableAuthServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableAuthServiceRequest* internal_default_instance() {
    return reinterpret_cast<const DisableAuthServiceRequest*>(
               &_DisableAuthServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    257;

  friend void swap(DisableAuthServiceRequest& a, DisableAuthServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableAuthServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableAuthServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableAuthServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableAuthServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisableAuthServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DisableAuthServiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableAuthServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DisableAuthServiceRequest";
  }
  protected:
  explicit DisableAuthServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DisableAuthServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DisableAuthServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DisableAuthServiceResponse) */ {
 public:
  inline DisableAuthServiceResponse() : DisableAuthServiceResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DisableAuthServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableAuthServiceResponse(const DisableAuthServiceResponse& from);
  DisableAuthServiceResponse(DisableAuthServiceResponse&& from) noexcept
    : DisableAuthServiceResponse() {
    *this = ::std::move(from);
  }

  inline DisableAuthServiceResponse& operator=(const DisableAuthServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableAuthServiceResponse& operator=(DisableAuthServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableAuthServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableAuthServiceResponse* internal_default_instance() {
    return reinterpret_cast<const DisableAuthServiceResponse*>(
               &_DisableAuthServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    258;

  friend void swap(DisableAuthServiceResponse& a, DisableAuthServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableAuthServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableAuthServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableAuthServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableAuthServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DisableAuthServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DisableAuthServiceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DisableAuthServiceResponse";
  }
  protected:
  explicit DisableAuthServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DisableAuthServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOAuthAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOAuthAppRequest) */ {
 public:
  inline CreateOAuthAppRequest() : CreateOAuthAppRequest(nullptr) {}
  ~CreateOAuthAppRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOAuthAppRequest(const CreateOAuthAppRequest& from);
  CreateOAuthAppRequest(CreateOAuthAppRequest&& from) noexcept
    : CreateOAuthAppRequest() {
    *this = ::std::move(from);
  }

  inline CreateOAuthAppRequest& operator=(const CreateOAuthAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOAuthAppRequest& operator=(CreateOAuthAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOAuthAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOAuthAppRequest* internal_default_instance() {
    return reinterpret_cast<const CreateOAuthAppRequest*>(
               &_CreateOAuthAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    259;

  friend void swap(CreateOAuthAppRequest& a, CreateOAuthAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOAuthAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOAuthAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOAuthAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOAuthAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOAuthAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOAuthAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOAuthAppRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOAuthAppRequest";
  }
  protected:
  explicit CreateOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kClientNameFieldNumber = 2,
    kOauthConfigFieldNumber = 3,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string client_name = 2 [json_name = "clientName"];
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // .viam.app.v1.OAuthConfig oauth_config = 3 [json_name = "oauthConfig"];
  bool has_oauth_config() const;
  private:
  bool _internal_has_oauth_config() const;
  public:
  void clear_oauth_config();
  const ::viam::app::v1::OAuthConfig& oauth_config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OAuthConfig* release_oauth_config();
  ::viam::app::v1::OAuthConfig* mutable_oauth_config();
  void set_allocated_oauth_config(::viam::app::v1::OAuthConfig* oauth_config);
  private:
  const ::viam::app::v1::OAuthConfig& _internal_oauth_config() const;
  ::viam::app::v1::OAuthConfig* _internal_mutable_oauth_config();
  public:
  void unsafe_arena_set_allocated_oauth_config(
      ::viam::app::v1::OAuthConfig* oauth_config);
  ::viam::app::v1::OAuthConfig* unsafe_arena_release_oauth_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOAuthAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::viam::app::v1::OAuthConfig* oauth_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOAuthAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOAuthAppResponse) */ {
 public:
  inline CreateOAuthAppResponse() : CreateOAuthAppResponse(nullptr) {}
  ~CreateOAuthAppResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOAuthAppResponse(const CreateOAuthAppResponse& from);
  CreateOAuthAppResponse(CreateOAuthAppResponse&& from) noexcept
    : CreateOAuthAppResponse() {
    *this = ::std::move(from);
  }

  inline CreateOAuthAppResponse& operator=(const CreateOAuthAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOAuthAppResponse& operator=(CreateOAuthAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOAuthAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOAuthAppResponse* internal_default_instance() {
    return reinterpret_cast<const CreateOAuthAppResponse*>(
               &_CreateOAuthAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    260;

  friend void swap(CreateOAuthAppResponse& a, CreateOAuthAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOAuthAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOAuthAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOAuthAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOAuthAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOAuthAppResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOAuthAppResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOAuthAppResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOAuthAppResponse";
  }
  protected:
  explicit CreateOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kClientSecretFieldNumber = 2,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // string client_secret = 2 [json_name = "clientSecret"];
  void clear_client_secret();
  const std::string& client_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_secret();
  PROTOBUF_NODISCARD std::string* release_client_secret();
  void set_allocated_client_secret(std::string* client_secret);
  private:
  const std::string& _internal_client_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_secret(const std::string& value);
  std::string* _internal_mutable_client_secret();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOAuthAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_secret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ReadOAuthAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ReadOAuthAppRequest) */ {
 public:
  inline ReadOAuthAppRequest() : ReadOAuthAppRequest(nullptr) {}
  ~ReadOAuthAppRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadOAuthAppRequest(const ReadOAuthAppRequest& from);
  ReadOAuthAppRequest(ReadOAuthAppRequest&& from) noexcept
    : ReadOAuthAppRequest() {
    *this = ::std::move(from);
  }

  inline ReadOAuthAppRequest& operator=(const ReadOAuthAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOAuthAppRequest& operator=(ReadOAuthAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadOAuthAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadOAuthAppRequest* internal_default_instance() {
    return reinterpret_cast<const ReadOAuthAppRequest*>(
               &_ReadOAuthAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    261;

  friend void swap(ReadOAuthAppRequest& a, ReadOAuthAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOAuthAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadOAuthAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadOAuthAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadOAuthAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadOAuthAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadOAuthAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOAuthAppRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ReadOAuthAppRequest";
  }
  protected:
  explicit ReadOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string client_id = 2 [json_name = "clientId"];
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ReadOAuthAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ReadOAuthAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ReadOAuthAppResponse) */ {
 public:
  inline ReadOAuthAppResponse() : ReadOAuthAppResponse(nullptr) {}
  ~ReadOAuthAppResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadOAuthAppResponse(const ReadOAuthAppResponse& from);
  ReadOAuthAppResponse(ReadOAuthAppResponse&& from) noexcept
    : ReadOAuthAppResponse() {
    *this = ::std::move(from);
  }

  inline ReadOAuthAppResponse& operator=(const ReadOAuthAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOAuthAppResponse& operator=(ReadOAuthAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadOAuthAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadOAuthAppResponse* internal_default_instance() {
    return reinterpret_cast<const ReadOAuthAppResponse*>(
               &_ReadOAuthAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    262;

  friend void swap(ReadOAuthAppResponse& a, ReadOAuthAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOAuthAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadOAuthAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadOAuthAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadOAuthAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadOAuthAppResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadOAuthAppResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOAuthAppResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ReadOAuthAppResponse";
  }
  protected:
  explicit ReadOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kClientSecretFieldNumber = 2,
    kOauthConfigFieldNumber = 3,
  };
  // string client_name = 1 [json_name = "clientName"];
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // string client_secret = 2 [json_name = "clientSecret"];
  void clear_client_secret();
  const std::string& client_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_secret();
  PROTOBUF_NODISCARD std::string* release_client_secret();
  void set_allocated_client_secret(std::string* client_secret);
  private:
  const std::string& _internal_client_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_secret(const std::string& value);
  std::string* _internal_mutable_client_secret();
  public:

  // .viam.app.v1.OAuthConfig oauth_config = 3 [json_name = "oauthConfig"];
  bool has_oauth_config() const;
  private:
  bool _internal_has_oauth_config() const;
  public:
  void clear_oauth_config();
  const ::viam::app::v1::OAuthConfig& oauth_config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OAuthConfig* release_oauth_config();
  ::viam::app::v1::OAuthConfig* mutable_oauth_config();
  void set_allocated_oauth_config(::viam::app::v1::OAuthConfig* oauth_config);
  private:
  const ::viam::app::v1::OAuthConfig& _internal_oauth_config() const;
  ::viam::app::v1::OAuthConfig* _internal_mutable_oauth_config();
  public:
  void unsafe_arena_set_allocated_oauth_config(
      ::viam::app::v1::OAuthConfig* oauth_config);
  ::viam::app::v1::OAuthConfig* unsafe_arena_release_oauth_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ReadOAuthAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_secret_;
  ::viam::app::v1::OAuthConfig* oauth_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOAuthAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOAuthAppRequest) */ {
 public:
  inline UpdateOAuthAppRequest() : UpdateOAuthAppRequest(nullptr) {}
  ~UpdateOAuthAppRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOAuthAppRequest(const UpdateOAuthAppRequest& from);
  UpdateOAuthAppRequest(UpdateOAuthAppRequest&& from) noexcept
    : UpdateOAuthAppRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOAuthAppRequest& operator=(const UpdateOAuthAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOAuthAppRequest& operator=(UpdateOAuthAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOAuthAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOAuthAppRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOAuthAppRequest*>(
               &_UpdateOAuthAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    263;

  friend void swap(UpdateOAuthAppRequest& a, UpdateOAuthAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOAuthAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOAuthAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOAuthAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOAuthAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOAuthAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOAuthAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOAuthAppRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOAuthAppRequest";
  }
  protected:
  explicit UpdateOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kClientNameFieldNumber = 3,
    kOauthConfigFieldNumber = 4,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string client_id = 2 [json_name = "clientId"];
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // string client_name = 3 [json_name = "clientName"];
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // .viam.app.v1.OAuthConfig oauth_config = 4 [json_name = "oauthConfig"];
  bool has_oauth_config() const;
  private:
  bool _internal_has_oauth_config() const;
  public:
  void clear_oauth_config();
  const ::viam::app::v1::OAuthConfig& oauth_config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OAuthConfig* release_oauth_config();
  ::viam::app::v1::OAuthConfig* mutable_oauth_config();
  void set_allocated_oauth_config(::viam::app::v1::OAuthConfig* oauth_config);
  private:
  const ::viam::app::v1::OAuthConfig& _internal_oauth_config() const;
  ::viam::app::v1::OAuthConfig* _internal_mutable_oauth_config();
  public:
  void unsafe_arena_set_allocated_oauth_config(
      ::viam::app::v1::OAuthConfig* oauth_config);
  ::viam::app::v1::OAuthConfig* unsafe_arena_release_oauth_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOAuthAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::viam::app::v1::OAuthConfig* oauth_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOAuthAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOAuthAppResponse) */ {
 public:
  inline UpdateOAuthAppResponse() : UpdateOAuthAppResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOAuthAppResponse(const UpdateOAuthAppResponse& from);
  UpdateOAuthAppResponse(UpdateOAuthAppResponse&& from) noexcept
    : UpdateOAuthAppResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOAuthAppResponse& operator=(const UpdateOAuthAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOAuthAppResponse& operator=(UpdateOAuthAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOAuthAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOAuthAppResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOAuthAppResponse*>(
               &_UpdateOAuthAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    264;

  friend void swap(UpdateOAuthAppResponse& a, UpdateOAuthAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOAuthAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOAuthAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOAuthAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOAuthAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateOAuthAppResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateOAuthAppResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOAuthAppResponse";
  }
  protected:
  explicit UpdateOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOAuthAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOAuthAppRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOAuthAppRequest) */ {
 public:
  inline DeleteOAuthAppRequest() : DeleteOAuthAppRequest(nullptr) {}
  ~DeleteOAuthAppRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOAuthAppRequest(const DeleteOAuthAppRequest& from);
  DeleteOAuthAppRequest(DeleteOAuthAppRequest&& from) noexcept
    : DeleteOAuthAppRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOAuthAppRequest& operator=(const DeleteOAuthAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOAuthAppRequest& operator=(DeleteOAuthAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOAuthAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOAuthAppRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOAuthAppRequest*>(
               &_DeleteOAuthAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    265;

  friend void swap(DeleteOAuthAppRequest& a, DeleteOAuthAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOAuthAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOAuthAppRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOAuthAppRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOAuthAppRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOAuthAppRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteOAuthAppRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOAuthAppRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOAuthAppRequest";
  }
  protected:
  explicit DeleteOAuthAppRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string client_id = 2 [json_name = "clientId"];
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOAuthAppRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOAuthAppResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOAuthAppResponse) */ {
 public:
  inline DeleteOAuthAppResponse() : DeleteOAuthAppResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOAuthAppResponse(const DeleteOAuthAppResponse& from);
  DeleteOAuthAppResponse(DeleteOAuthAppResponse&& from) noexcept
    : DeleteOAuthAppResponse() {
    *this = ::std::move(from);
  }

  inline DeleteOAuthAppResponse& operator=(const DeleteOAuthAppResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOAuthAppResponse& operator=(DeleteOAuthAppResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOAuthAppResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOAuthAppResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteOAuthAppResponse*>(
               &_DeleteOAuthAppResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    266;

  friend void swap(DeleteOAuthAppResponse& a, DeleteOAuthAppResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOAuthAppResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOAuthAppResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOAuthAppResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOAuthAppResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteOAuthAppResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteOAuthAppResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOAuthAppResponse";
  }
  protected:
  explicit DeleteOAuthAppResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOAuthAppResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOAuthAppsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOAuthAppsRequest) */ {
 public:
  inline ListOAuthAppsRequest() : ListOAuthAppsRequest(nullptr) {}
  ~ListOAuthAppsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListOAuthAppsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOAuthAppsRequest(const ListOAuthAppsRequest& from);
  ListOAuthAppsRequest(ListOAuthAppsRequest&& from) noexcept
    : ListOAuthAppsRequest() {
    *this = ::std::move(from);
  }

  inline ListOAuthAppsRequest& operator=(const ListOAuthAppsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOAuthAppsRequest& operator=(ListOAuthAppsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOAuthAppsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOAuthAppsRequest* internal_default_instance() {
    return reinterpret_cast<const ListOAuthAppsRequest*>(
               &_ListOAuthAppsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    267;

  friend void swap(ListOAuthAppsRequest& a, ListOAuthAppsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOAuthAppsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOAuthAppsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOAuthAppsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOAuthAppsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOAuthAppsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOAuthAppsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOAuthAppsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOAuthAppsRequest";
  }
  protected:
  explicit ListOAuthAppsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOAuthAppsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOAuthAppsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOAuthAppsResponse) */ {
 public:
  inline ListOAuthAppsResponse() : ListOAuthAppsResponse(nullptr) {}
  ~ListOAuthAppsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOAuthAppsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOAuthAppsResponse(const ListOAuthAppsResponse& from);
  ListOAuthAppsResponse(ListOAuthAppsResponse&& from) noexcept
    : ListOAuthAppsResponse() {
    *this = ::std::move(from);
  }

  inline ListOAuthAppsResponse& operator=(const ListOAuthAppsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOAuthAppsResponse& operator=(ListOAuthAppsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOAuthAppsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOAuthAppsResponse* internal_default_instance() {
    return reinterpret_cast<const ListOAuthAppsResponse*>(
               &_ListOAuthAppsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    268;

  friend void swap(ListOAuthAppsResponse& a, ListOAuthAppsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOAuthAppsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOAuthAppsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOAuthAppsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOAuthAppsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOAuthAppsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOAuthAppsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOAuthAppsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOAuthAppsResponse";
  }
  protected:
  explicit ListOAuthAppsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdsFieldNumber = 1,
  };
  // repeated string client_ids = 1 [json_name = "clientIds"];
  int client_ids_size() const;
  private:
  int _internal_client_ids_size() const;
  public:
  void clear_client_ids();
  const std::string& client_ids(int index) const;
  std::string* mutable_client_ids(int index);
  void set_client_ids(int index, const std::string& value);
  void set_client_ids(int index, std::string&& value);
  void set_client_ids(int index, const char* value);
  void set_client_ids(int index, const char* value, size_t size);
  std::string* add_client_ids();
  void add_client_ids(const std::string& value);
  void add_client_ids(std::string&& value);
  void add_client_ids(const char* value);
  void add_client_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& client_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_client_ids();
  private:
  const std::string& _internal_client_ids(int index) const;
  std::string* _internal_add_client_ids();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOAuthAppsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> client_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OAuthConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OAuthConfig) */ {
 public:
  inline OAuthConfig() : OAuthConfig(nullptr) {}
  ~OAuthConfig() override;
  explicit PROTOBUF_CONSTEXPR OAuthConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OAuthConfig(const OAuthConfig& from);
  OAuthConfig(OAuthConfig&& from) noexcept
    : OAuthConfig() {
    *this = ::std::move(from);
  }

  inline OAuthConfig& operator=(const OAuthConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline OAuthConfig& operator=(OAuthConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OAuthConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const OAuthConfig* internal_default_instance() {
    return reinterpret_cast<const OAuthConfig*>(
               &_OAuthConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    269;

  friend void swap(OAuthConfig& a, OAuthConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(OAuthConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OAuthConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OAuthConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OAuthConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OAuthConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OAuthConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OAuthConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OAuthConfig";
  }
  protected:
  explicit OAuthConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginUrisFieldNumber = 4,
    kRedirectUrisFieldNumber = 5,
    kEnabledGrantsFieldNumber = 7,
    kLogoutUriFieldNumber = 6,
    kClientAuthenticationFieldNumber = 1,
    kPkceFieldNumber = 2,
    kUrlValidationFieldNumber = 3,
  };
  // repeated string origin_uris = 4 [json_name = "originUris"];
  int origin_uris_size() const;
  private:
  int _internal_origin_uris_size() const;
  public:
  void clear_origin_uris();
  const std::string& origin_uris(int index) const;
  std::string* mutable_origin_uris(int index);
  void set_origin_uris(int index, const std::string& value);
  void set_origin_uris(int index, std::string&& value);
  void set_origin_uris(int index, const char* value);
  void set_origin_uris(int index, const char* value, size_t size);
  std::string* add_origin_uris();
  void add_origin_uris(const std::string& value);
  void add_origin_uris(std::string&& value);
  void add_origin_uris(const char* value);
  void add_origin_uris(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& origin_uris() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_origin_uris();
  private:
  const std::string& _internal_origin_uris(int index) const;
  std::string* _internal_add_origin_uris();
  public:

  // repeated string redirect_uris = 5 [json_name = "redirectUris"];
  int redirect_uris_size() const;
  private:
  int _internal_redirect_uris_size() const;
  public:
  void clear_redirect_uris();
  const std::string& redirect_uris(int index) const;
  std::string* mutable_redirect_uris(int index);
  void set_redirect_uris(int index, const std::string& value);
  void set_redirect_uris(int index, std::string&& value);
  void set_redirect_uris(int index, const char* value);
  void set_redirect_uris(int index, const char* value, size_t size);
  std::string* add_redirect_uris();
  void add_redirect_uris(const std::string& value);
  void add_redirect_uris(std::string&& value);
  void add_redirect_uris(const char* value);
  void add_redirect_uris(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& redirect_uris() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_redirect_uris();
  private:
  const std::string& _internal_redirect_uris(int index) const;
  std::string* _internal_add_redirect_uris();
  public:

  // repeated .viam.app.v1.EnabledGrant enabled_grants = 7 [json_name = "enabledGrants"];
  int enabled_grants_size() const;
  private:
  int _internal_enabled_grants_size() const;
  public:
  void clear_enabled_grants();
  private:
  ::viam::app::v1::EnabledGrant _internal_enabled_grants(int index) const;
  void _internal_add_enabled_grants(::viam::app::v1::EnabledGrant value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_enabled_grants();
  public:
  ::viam::app::v1::EnabledGrant enabled_grants(int index) const;
  void set_enabled_grants(int index, ::viam::app::v1::EnabledGrant value);
  void add_enabled_grants(::viam::app::v1::EnabledGrant value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& enabled_grants() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_enabled_grants();

  // string logout_uri = 6 [json_name = "logoutUri"];
  void clear_logout_uri();
  const std::string& logout_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logout_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logout_uri();
  PROTOBUF_NODISCARD std::string* release_logout_uri();
  void set_allocated_logout_uri(std::string* logout_uri);
  private:
  const std::string& _internal_logout_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logout_uri(const std::string& value);
  std::string* _internal_mutable_logout_uri();
  public:

  // .viam.app.v1.ClientAuthentication client_authentication = 1 [json_name = "clientAuthentication"];
  void clear_client_authentication();
  ::viam::app::v1::ClientAuthentication client_authentication() const;
  void set_client_authentication(::viam::app::v1::ClientAuthentication value);
  private:
  ::viam::app::v1::ClientAuthentication _internal_client_authentication() const;
  void _internal_set_client_authentication(::viam::app::v1::ClientAuthentication value);
  public:

  // .viam.app.v1.PKCE pkce = 2 [json_name = "pkce"];
  void clear_pkce();
  ::viam::app::v1::PKCE pkce() const;
  void set_pkce(::viam::app::v1::PKCE value);
  private:
  ::viam::app::v1::PKCE _internal_pkce() const;
  void _internal_set_pkce(::viam::app::v1::PKCE value);
  public:

  // .viam.app.v1.URLValidation url_validation = 3 [json_name = "urlValidation"];
  void clear_url_validation();
  ::viam::app::v1::URLValidation url_validation() const;
  void set_url_validation(::viam::app::v1::URLValidation value);
  private:
  ::viam::app::v1::URLValidation _internal_url_validation() const;
  void _internal_set_url_validation(::viam::app::v1::URLValidation value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OAuthConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> origin_uris_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> redirect_uris_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> enabled_grants_;
  mutable std::atomic<int> _enabled_grants_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logout_uri_;
  int client_authentication_;
  int pkce_;
  int url_validation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetAppBrandingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetAppBrandingRequest) */ {
 public:
  inline GetAppBrandingRequest() : GetAppBrandingRequest(nullptr) {}
  ~GetAppBrandingRequest() override;
  explicit PROTOBUF_CONSTEXPR GetAppBrandingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppBrandingRequest(const GetAppBrandingRequest& from);
  GetAppBrandingRequest(GetAppBrandingRequest&& from) noexcept
    : GetAppBrandingRequest() {
    *this = ::std::move(from);
  }

  inline GetAppBrandingRequest& operator=(const GetAppBrandingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppBrandingRequest& operator=(GetAppBrandingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppBrandingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppBrandingRequest* internal_default_instance() {
    return reinterpret_cast<const GetAppBrandingRequest*>(
               &_GetAppBrandingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    270;

  friend void swap(GetAppBrandingRequest& a, GetAppBrandingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppBrandingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppBrandingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppBrandingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppBrandingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppBrandingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAppBrandingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppBrandingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetAppBrandingRequest";
  }
  protected:
  explicit GetAppBrandingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicNamespaceFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string public_namespace = 1 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetAppBrandingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TextOverrides_FieldsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TextOverrides_FieldsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TextOverrides_FieldsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TextOverrides_FieldsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TextOverrides_FieldsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TextOverrides_FieldsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TextOverrides_FieldsEntry_DoNotUse& other);
  static const TextOverrides_FieldsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TextOverrides_FieldsEntry_DoNotUse*>(&_TextOverrides_FieldsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.TextOverrides.FieldsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.TextOverrides.FieldsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};

// -------------------------------------------------------------------

class TextOverrides final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TextOverrides) */ {
 public:
  inline TextOverrides() : TextOverrides(nullptr) {}
  ~TextOverrides() override;
  explicit PROTOBUF_CONSTEXPR TextOverrides(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextOverrides(const TextOverrides& from);
  TextOverrides(TextOverrides&& from) noexcept
    : TextOverrides() {
    *this = ::std::move(from);
  }

  inline TextOverrides& operator=(const TextOverrides& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextOverrides& operator=(TextOverrides&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextOverrides& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextOverrides* internal_default_instance() {
    return reinterpret_cast<const TextOverrides*>(
               &_TextOverrides_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    272;

  friend void swap(TextOverrides& a, TextOverrides& b) {
    a.Swap(&b);
  }
  inline void Swap(TextOverrides* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextOverrides* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextOverrides* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextOverrides>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextOverrides& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextOverrides& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextOverrides* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TextOverrides";
  }
  protected:
  explicit TextOverrides(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
  };
  // map<string, string> fields = 1 [json_name = "fields"];
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_fields() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_fields();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      fields() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_fields();

  // @@protoc_insertion_point(class_scope:viam.app.v1.TextOverrides)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TextOverrides_FieldsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> fields_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse, 
    std::string, ::viam::app::v1::TextOverrides,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse, 
    std::string, ::viam::app::v1::TextOverrides,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse& other);
  static const GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse*>(&_GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.GetAppBrandingResponse.TextCustomizationsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};

// -------------------------------------------------------------------

class GetAppBrandingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetAppBrandingResponse) */ {
 public:
  inline GetAppBrandingResponse() : GetAppBrandingResponse(nullptr) {}
  ~GetAppBrandingResponse() override;
  explicit PROTOBUF_CONSTEXPR GetAppBrandingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppBrandingResponse(const GetAppBrandingResponse& from);
  GetAppBrandingResponse(GetAppBrandingResponse&& from) noexcept
    : GetAppBrandingResponse() {
    *this = ::std::move(from);
  }

  inline GetAppBrandingResponse& operator=(const GetAppBrandingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppBrandingResponse& operator=(GetAppBrandingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppBrandingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppBrandingResponse* internal_default_instance() {
    return reinterpret_cast<const GetAppBrandingResponse*>(
               &_GetAppBrandingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    274;

  friend void swap(GetAppBrandingResponse& a, GetAppBrandingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppBrandingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppBrandingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppBrandingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppBrandingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppBrandingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAppBrandingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppBrandingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetAppBrandingResponse";
  }
  protected:
  explicit GetAppBrandingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTextCustomizationsFieldNumber = 2,
    kFragmentIdsFieldNumber = 3,
    kLogoPathFieldNumber = 1,
  };
  // map<string, .viam.app.v1.TextOverrides> text_customizations = 2 [json_name = "textCustomizations"];
  int text_customizations_size() const;
  private:
  int _internal_text_customizations_size() const;
  public:
  void clear_text_customizations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >&
      _internal_text_customizations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >*
      _internal_mutable_text_customizations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >&
      text_customizations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >*
      mutable_text_customizations();

  // repeated string fragment_ids = 3 [json_name = "fragmentIds"];
  int fragment_ids_size() const;
  private:
  int _internal_fragment_ids_size() const;
  public:
  void clear_fragment_ids();
  const std::string& fragment_ids(int index) const;
  std::string* mutable_fragment_ids(int index);
  void set_fragment_ids(int index, const std::string& value);
  void set_fragment_ids(int index, std::string&& value);
  void set_fragment_ids(int index, const char* value);
  void set_fragment_ids(int index, const char* value, size_t size);
  std::string* add_fragment_ids();
  void add_fragment_ids(const std::string& value);
  void add_fragment_ids(std::string&& value);
  void add_fragment_ids(const char* value);
  void add_fragment_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fragment_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fragment_ids();
  private:
  const std::string& _internal_fragment_ids(int index) const;
  std::string* _internal_add_fragment_ids();
  public:

  // optional string logo_path = 1 [json_name = "logoPath"];
  bool has_logo_path() const;
  private:
  bool _internal_has_logo_path() const;
  public:
  void clear_logo_path();
  const std::string& logo_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo_path();
  PROTOBUF_NODISCARD std::string* release_logo_path();
  void set_allocated_logo_path(std::string* logo_path);
  private:
  const std::string& _internal_logo_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo_path(const std::string& value);
  std::string* _internal_mutable_logo_path();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetAppBrandingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetAppBrandingResponse_TextCustomizationsEntry_DoNotUse,
      std::string, ::viam::app::v1::TextOverrides,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> text_customizations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fragment_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_path_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AppCustomizations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AppCustomizations) */ {
 public:
  inline AppCustomizations() : AppCustomizations(nullptr) {}
  ~AppCustomizations() override;
  explicit PROTOBUF_CONSTEXPR AppCustomizations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppCustomizations(const AppCustomizations& from);
  AppCustomizations(AppCustomizations&& from) noexcept
    : AppCustomizations() {
    *this = ::std::move(from);
  }

  inline AppCustomizations& operator=(const AppCustomizations& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppCustomizations& operator=(AppCustomizations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppCustomizations& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppCustomizations* internal_default_instance() {
    return reinterpret_cast<const AppCustomizations*>(
               &_AppCustomizations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    275;

  friend void swap(AppCustomizations& a, AppCustomizations& b) {
    a.Swap(&b);
  }
  inline void Swap(AppCustomizations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppCustomizations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppCustomizations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppCustomizations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppCustomizations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppCustomizations& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppCustomizations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AppCustomizations";
  }
  protected:
  explicit AppCustomizations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachinePickerFieldNumber = 1,
  };
  // .viam.app.v1.MachinePickerCustomizations machine_picker = 1 [json_name = "machinePicker"];
  bool has_machine_picker() const;
  private:
  bool _internal_has_machine_picker() const;
  public:
  void clear_machine_picker();
  const ::viam::app::v1::MachinePickerCustomizations& machine_picker() const;
  PROTOBUF_NODISCARD ::viam::app::v1::MachinePickerCustomizations* release_machine_picker();
  ::viam::app::v1::MachinePickerCustomizations* mutable_machine_picker();
  void set_allocated_machine_picker(::viam::app::v1::MachinePickerCustomizations* machine_picker);
  private:
  const ::viam::app::v1::MachinePickerCustomizations& _internal_machine_picker() const;
  ::viam::app::v1::MachinePickerCustomizations* _internal_mutable_machine_picker();
  public:
  void unsafe_arena_set_allocated_machine_picker(
      ::viam::app::v1::MachinePickerCustomizations* machine_picker);
  ::viam::app::v1::MachinePickerCustomizations* unsafe_arena_release_machine_picker();

  // @@protoc_insertion_point(class_scope:viam.app.v1.AppCustomizations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::MachinePickerCustomizations* machine_picker_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MachinePickerCustomizations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MachinePickerCustomizations) */ {
 public:
  inline MachinePickerCustomizations() : MachinePickerCustomizations(nullptr) {}
  ~MachinePickerCustomizations() override;
  explicit PROTOBUF_CONSTEXPR MachinePickerCustomizations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MachinePickerCustomizations(const MachinePickerCustomizations& from);
  MachinePickerCustomizations(MachinePickerCustomizations&& from) noexcept
    : MachinePickerCustomizations() {
    *this = ::std::move(from);
  }

  inline MachinePickerCustomizations& operator=(const MachinePickerCustomizations& from) {
    CopyFrom(from);
    return *this;
  }
  inline MachinePickerCustomizations& operator=(MachinePickerCustomizations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MachinePickerCustomizations& default_instance() {
    return *internal_default_instance();
  }
  static inline const MachinePickerCustomizations* internal_default_instance() {
    return reinterpret_cast<const MachinePickerCustomizations*>(
               &_MachinePickerCustomizations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    276;

  friend void swap(MachinePickerCustomizations& a, MachinePickerCustomizations& b) {
    a.Swap(&b);
  }
  inline void Swap(MachinePickerCustomizations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MachinePickerCustomizations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MachinePickerCustomizations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MachinePickerCustomizations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MachinePickerCustomizations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MachinePickerCustomizations& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MachinePickerCustomizations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MachinePickerCustomizations";
  }
  protected:
  explicit MachinePickerCustomizations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadingFieldNumber = 1,
    kSubheadingFieldNumber = 2,
  };
  // optional string heading = 1 [json_name = "heading"];
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  const std::string& heading() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_heading(ArgT0&& arg0, ArgT... args);
  std::string* mutable_heading();
  PROTOBUF_NODISCARD std::string* release_heading();
  void set_allocated_heading(std::string* heading);
  private:
  const std::string& _internal_heading() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heading(const std::string& value);
  std::string* _internal_mutable_heading();
  public:

  // optional string subheading = 2 [json_name = "subheading"];
  bool has_subheading() const;
  private:
  bool _internal_has_subheading() const;
  public:
  void clear_subheading();
  const std::string& subheading() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subheading(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subheading();
  PROTOBUF_NODISCARD std::string* release_subheading();
  void set_allocated_subheading(std::string* subheading);
  private:
  const std::string& _internal_subheading() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subheading(const std::string& value);
  std::string* _internal_mutable_subheading();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MachinePickerCustomizations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heading_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subheading_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Robot

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void Robot::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Robot::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.id)
}
inline std::string* Robot::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.id)
  return _s;
}
inline const std::string& Robot::_internal_id() const {
  return id_.Get();
}
inline void Robot::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.id)
  return id_.Release();
}
inline void Robot::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void Robot::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Robot::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.name)
}
inline std::string* Robot::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.name)
  return _s;
}
inline const std::string& Robot::_internal_name() const {
  return name_.Get();
}
inline void Robot::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.name)
  return name_.Release();
}
inline void Robot::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.name)
}

// string location = 3 [json_name = "location", (.tagger.v1.tags) = "bson:\"location\" json:\"location\""];
inline void Robot::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& Robot::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.location)
}
inline std::string* Robot::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.location)
  return _s;
}
inline const std::string& Robot::_internal_location() const {
  return location_.Get();
}
inline void Robot::_internal_set_location(const std::string& value) {
  
  location_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_location() {
  
  return location_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.location)
  return location_.Release();
}
inline void Robot::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault()) {
    location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.location)
}

// .google.protobuf.Timestamp last_access = 4 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
inline bool Robot::_internal_has_last_access() const {
  return this != internal_default_instance() && last_access_ != nullptr;
}
inline bool Robot::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.last_access)
  return _internal_last_access();
}
inline void Robot::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  last_access_ = last_access;
  if (last_access) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Robot.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::release_last_access() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.last_access)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::_internal_mutable_last_access() {
  
  if (last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_access_ = p;
  }
  return last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.last_access)
  return _msg;
}
inline void Robot::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    
  } else {
    
  }
  last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.last_access)
}

// .google.protobuf.Timestamp created_on = 5 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool Robot::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Robot::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.created_on)
  return _internal_created_on();
}
inline void Robot::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Robot.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.created_on)
  return _msg;
}
inline void Robot::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.created_on)
}

// .viam.app.v1.OnlineState online_state = 6 [json_name = "onlineState", (.tagger.v1.tags) = "bson:\"online_state\" json:\"online_state,omitempty\""];
inline void Robot::clear_online_state() {
  online_state_ = 0;
}
inline ::viam::app::v1::OnlineState Robot::_internal_online_state() const {
  return static_cast< ::viam::app::v1::OnlineState >(online_state_);
}
inline ::viam::app::v1::OnlineState Robot::online_state() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.online_state)
  return _internal_online_state();
}
inline void Robot::_internal_set_online_state(::viam::app::v1::OnlineState value) {
  
  online_state_ = value;
}
inline void Robot::set_online_state(::viam::app::v1::OnlineState value) {
  _internal_set_online_state(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.online_state)
}

// int64 seconds_since_online = 7 [json_name = "secondsSinceOnline", (.tagger.v1.tags) = "bson:\"seconds_since_online\" json:\"seconds_since_online,omitempty\""];
inline void Robot::clear_seconds_since_online() {
  seconds_since_online_ = int64_t{0};
}
inline int64_t Robot::_internal_seconds_since_online() const {
  return seconds_since_online_;
}
inline int64_t Robot::seconds_since_online() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.seconds_since_online)
  return _internal_seconds_since_online();
}
inline void Robot::_internal_set_seconds_since_online(int64_t value) {
  
  seconds_since_online_ = value;
}
inline void Robot::set_seconds_since_online(int64_t value) {
  _internal_set_seconds_since_online(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.seconds_since_online)
}

// -------------------------------------------------------------------

// RobotPart

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void RobotPart::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RobotPart::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.id)
}
inline std::string* RobotPart::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.id)
  return _s;
}
inline const std::string& RobotPart::_internal_id() const {
  return id_.Get();
}
inline void RobotPart::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.id)
  return id_.Release();
}
inline void RobotPart::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void RobotPart::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RobotPart::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.name)
}
inline std::string* RobotPart::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.name)
  return _s;
}
inline const std::string& RobotPart::_internal_name() const {
  return name_.Get();
}
inline void RobotPart::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.name)
  return name_.Release();
}
inline void RobotPart::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.name)
}

// string dns_name = 10 [json_name = "dnsName", (.tagger.v1.tags) = "bson:\"dns_name\" json:\"dns_name\""];
inline void RobotPart::clear_dns_name() {
  dns_name_.ClearToEmpty();
}
inline const std::string& RobotPart::dns_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.dns_name)
  return _internal_dns_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_dns_name(ArgT0&& arg0, ArgT... args) {
 
 dns_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.dns_name)
}
inline std::string* RobotPart::mutable_dns_name() {
  std::string* _s = _internal_mutable_dns_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.dns_name)
  return _s;
}
inline const std::string& RobotPart::_internal_dns_name() const {
  return dns_name_.Get();
}
inline void RobotPart::_internal_set_dns_name(const std::string& value) {
  
  dns_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_dns_name() {
  
  return dns_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_dns_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.dns_name)
  return dns_name_.Release();
}
inline void RobotPart::set_allocated_dns_name(std::string* dns_name) {
  if (dns_name != nullptr) {
    
  } else {
    
  }
  dns_name_.SetAllocated(dns_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dns_name_.IsDefault()) {
    dns_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.dns_name)
}

// string secret = 3 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\" json:\"secret,omitempty\""];
inline void RobotPart::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& RobotPart::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.secret)
}
inline std::string* RobotPart::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.secret)
  return _s;
}
inline const std::string& RobotPart::_internal_secret() const {
  return secret_.Get();
}
inline void RobotPart::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.secret)
  return secret_.Release();
}
inline void RobotPart::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.secret)
}

// string robot = 4 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
inline void RobotPart::clear_robot() {
  robot_.ClearToEmpty();
}
inline const std::string& RobotPart::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.robot)
  return _internal_robot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_robot(ArgT0&& arg0, ArgT... args) {
 
 robot_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.robot)
}
inline std::string* RobotPart::mutable_robot() {
  std::string* _s = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.robot)
  return _s;
}
inline const std::string& RobotPart::_internal_robot() const {
  return robot_.Get();
}
inline void RobotPart::_internal_set_robot(const std::string& value) {
  
  robot_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_robot() {
  
  return robot_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.robot)
  return robot_.Release();
}
inline void RobotPart::set_allocated_robot(std::string* robot) {
  if (robot != nullptr) {
    
  } else {
    
  }
  robot_.SetAllocated(robot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_.IsDefault()) {
    robot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.robot)
}

// string location_id = 12 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"-\""];
inline void RobotPart::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& RobotPart::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.location_id)
}
inline std::string* RobotPart::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.location_id)
  return _s;
}
inline const std::string& RobotPart::_internal_location_id() const {
  return location_id_.Get();
}
inline void RobotPart::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.location_id)
  return location_id_.Release();
}
inline void RobotPart::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.location_id)
}

// .google.protobuf.Struct robot_config = 5 [json_name = "robotConfig", (.tagger.v1.tags) = "bson:\"config\" json:\"robot_config\""];
inline bool RobotPart::_internal_has_robot_config() const {
  return this != internal_default_instance() && robot_config_ != nullptr;
}
inline bool RobotPart::has_robot_config() const {
  return _internal_has_robot_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::_internal_robot_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = robot_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::robot_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.robot_config)
  return _internal_robot_config();
}
inline void RobotPart::unsafe_arena_set_allocated_robot_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  robot_config_ = robot_config;
  if (robot_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.robot_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::release_robot_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::unsafe_arena_release_robot_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.robot_config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::_internal_mutable_robot_config() {
  
  if (robot_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    robot_config_ = p;
  }
  return robot_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::mutable_robot_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_robot_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.robot_config)
  return _msg;
}
inline void RobotPart::set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  if (robot_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config));
    if (message_arena != submessage_arena) {
      robot_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_config, submessage_arena);
    }
    
  } else {
    
  }
  robot_config_ = robot_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.robot_config)
}

// .google.protobuf.Timestamp last_access = 6 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
inline bool RobotPart::_internal_has_last_access() const {
  return this != internal_default_instance() && last_access_ != nullptr;
}
inline bool RobotPart::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.last_access)
  return _internal_last_access();
}
inline void RobotPart::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  last_access_ = last_access;
  if (last_access) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::release_last_access() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.last_access)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::_internal_mutable_last_access() {
  
  if (last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_access_ = p;
  }
  return last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.last_access)
  return _msg;
}
inline void RobotPart::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    
  } else {
    
  }
  last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.last_access)
}

// .google.protobuf.Struct user_supplied_info = 7 [json_name = "userSuppliedInfo", (.tagger.v1.tags) = "bson:\"user_supplied_info\" json:\"user_supplied_info\""];
inline bool RobotPart::_internal_has_user_supplied_info() const {
  return this != internal_default_instance() && user_supplied_info_ != nullptr;
}
inline bool RobotPart::has_user_supplied_info() const {
  return _internal_has_user_supplied_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::_internal_user_supplied_info() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = user_supplied_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::user_supplied_info() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.user_supplied_info)
  return _internal_user_supplied_info();
}
inline void RobotPart::unsafe_arena_set_allocated_user_supplied_info(
    ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_supplied_info_);
  }
  user_supplied_info_ = user_supplied_info;
  if (user_supplied_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.user_supplied_info)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::release_user_supplied_info() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = user_supplied_info_;
  user_supplied_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::unsafe_arena_release_user_supplied_info() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.user_supplied_info)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = user_supplied_info_;
  user_supplied_info_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::_internal_mutable_user_supplied_info() {
  
  if (user_supplied_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    user_supplied_info_ = p;
  }
  return user_supplied_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::mutable_user_supplied_info() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_user_supplied_info();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.user_supplied_info)
  return _msg;
}
inline void RobotPart::set_allocated_user_supplied_info(::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_supplied_info_);
  }
  if (user_supplied_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_supplied_info));
    if (message_arena != submessage_arena) {
      user_supplied_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_supplied_info, submessage_arena);
    }
    
  } else {
    
  }
  user_supplied_info_ = user_supplied_info;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.user_supplied_info)
}

// bool main_part = 8 [json_name = "mainPart", (.tagger.v1.tags) = "bson:\"main_part\" json:\"main_part\""];
inline void RobotPart::clear_main_part() {
  main_part_ = false;
}
inline bool RobotPart::_internal_main_part() const {
  return main_part_;
}
inline bool RobotPart::main_part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.main_part)
  return _internal_main_part();
}
inline void RobotPart::_internal_set_main_part(bool value) {
  
  main_part_ = value;
}
inline void RobotPart::set_main_part(bool value) {
  _internal_set_main_part(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.main_part)
}

// string fqdn = 9 [json_name = "fqdn"];
inline void RobotPart::clear_fqdn() {
  fqdn_.ClearToEmpty();
}
inline const std::string& RobotPart::fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.fqdn)
  return _internal_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_fqdn(ArgT0&& arg0, ArgT... args) {
 
 fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.fqdn)
}
inline std::string* RobotPart::mutable_fqdn() {
  std::string* _s = _internal_mutable_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.fqdn)
  return _s;
}
inline const std::string& RobotPart::_internal_fqdn() const {
  return fqdn_.Get();
}
inline void RobotPart::_internal_set_fqdn(const std::string& value) {
  
  fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_fqdn() {
  
  return fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.fqdn)
  return fqdn_.Release();
}
inline void RobotPart::set_allocated_fqdn(std::string* fqdn) {
  if (fqdn != nullptr) {
    
  } else {
    
  }
  fqdn_.SetAllocated(fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fqdn_.IsDefault()) {
    fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.fqdn)
}

// string local_fqdn = 11 [json_name = "localFqdn"];
inline void RobotPart::clear_local_fqdn() {
  local_fqdn_.ClearToEmpty();
}
inline const std::string& RobotPart::local_fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.local_fqdn)
  return _internal_local_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_local_fqdn(ArgT0&& arg0, ArgT... args) {
 
 local_fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.local_fqdn)
}
inline std::string* RobotPart::mutable_local_fqdn() {
  std::string* _s = _internal_mutable_local_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.local_fqdn)
  return _s;
}
inline const std::string& RobotPart::_internal_local_fqdn() const {
  return local_fqdn_.Get();
}
inline void RobotPart::_internal_set_local_fqdn(const std::string& value) {
  
  local_fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_local_fqdn() {
  
  return local_fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_local_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.local_fqdn)
  return local_fqdn_.Release();
}
inline void RobotPart::set_allocated_local_fqdn(std::string* local_fqdn) {
  if (local_fqdn != nullptr) {
    
  } else {
    
  }
  local_fqdn_.SetAllocated(local_fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (local_fqdn_.IsDefault()) {
    local_fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.local_fqdn)
}

// .google.protobuf.Timestamp created_on = 13 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool RobotPart::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool RobotPart::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.created_on)
  return _internal_created_on();
}
inline void RobotPart::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.created_on)
  return _msg;
}
inline void RobotPart::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.created_on)
}

// repeated .viam.app.v1.SharedSecret secrets = 14 [json_name = "secrets", (.tagger.v1.tags) = "bson:\"secrets\""];
inline int RobotPart::_internal_secrets_size() const {
  return secrets_.size();
}
inline int RobotPart::secrets_size() const {
  return _internal_secrets_size();
}
inline void RobotPart::clear_secrets() {
  secrets_.Clear();
}
inline ::viam::app::v1::SharedSecret* RobotPart::mutable_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.secrets)
  return secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
RobotPart::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotPart.secrets)
  return &secrets_;
}
inline const ::viam::app::v1::SharedSecret& RobotPart::_internal_secrets(int index) const {
  return secrets_.Get(index);
}
inline const ::viam::app::v1::SharedSecret& RobotPart::secrets(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.secrets)
  return _internal_secrets(index);
}
inline ::viam::app::v1::SharedSecret* RobotPart::_internal_add_secrets() {
  return secrets_.Add();
}
inline ::viam::app::v1::SharedSecret* RobotPart::add_secrets() {
  ::viam::app::v1::SharedSecret* _add = _internal_add_secrets();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotPart.secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
RobotPart::secrets() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotPart.secrets)
  return secrets_;
}

// .google.protobuf.Timestamp last_updated = 15 [json_name = "lastUpdated", (.tagger.v1.tags) = "bson:\"last_updated_at\""];
inline bool RobotPart::_internal_has_last_updated() const {
  return this != internal_default_instance() && last_updated_ != nullptr;
}
inline bool RobotPart::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::last_updated() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.last_updated)
  return _internal_last_updated();
}
inline void RobotPart::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::_internal_mutable_last_updated() {
  
  if (last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_updated_ = p;
  }
  return last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.last_updated)
  return _msg;
}
inline void RobotPart::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.last_updated)
}

// .viam.app.v1.OnlineState online_state = 16 [json_name = "onlineState", (.tagger.v1.tags) = "bson:\"online_state\" json:\"online_state,omitempty\""];
inline void RobotPart::clear_online_state() {
  online_state_ = 0;
}
inline ::viam::app::v1::OnlineState RobotPart::_internal_online_state() const {
  return static_cast< ::viam::app::v1::OnlineState >(online_state_);
}
inline ::viam::app::v1::OnlineState RobotPart::online_state() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.online_state)
  return _internal_online_state();
}
inline void RobotPart::_internal_set_online_state(::viam::app::v1::OnlineState value) {
  
  online_state_ = value;
}
inline void RobotPart::set_online_state(::viam::app::v1::OnlineState value) {
  _internal_set_online_state(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.online_state)
}

// int64 seconds_since_online = 17 [json_name = "secondsSinceOnline", (.tagger.v1.tags) = "bson:\"seconds_since_online\" json:\"seconds_since_online,omitempty\""];
inline void RobotPart::clear_seconds_since_online() {
  seconds_since_online_ = int64_t{0};
}
inline int64_t RobotPart::_internal_seconds_since_online() const {
  return seconds_since_online_;
}
inline int64_t RobotPart::seconds_since_online() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.seconds_since_online)
  return _internal_seconds_since_online();
}
inline void RobotPart::_internal_set_seconds_since_online(int64_t value) {
  
  seconds_since_online_ = value;
}
inline void RobotPart::set_seconds_since_online(int64_t value) {
  _internal_set_seconds_since_online(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.seconds_since_online)
}

// -------------------------------------------------------------------

// RobotPartHistoryEntry

// string part = 1 [json_name = "part", (.tagger.v1.tags) = "bson:\"part\" json:\"part\""];
inline void RobotPartHistoryEntry::clear_part() {
  part_.ClearToEmpty();
}
inline const std::string& RobotPartHistoryEntry::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.part)
  return _internal_part();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPartHistoryEntry::set_part(ArgT0&& arg0, ArgT... args) {
 
 part_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPartHistoryEntry.part)
}
inline std::string* RobotPartHistoryEntry::mutable_part() {
  std::string* _s = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.part)
  return _s;
}
inline const std::string& RobotPartHistoryEntry::_internal_part() const {
  return part_.Get();
}
inline void RobotPartHistoryEntry::_internal_set_part(const std::string& value) {
  
  part_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::_internal_mutable_part() {
  
  return part_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.part)
  return part_.Release();
}
inline void RobotPartHistoryEntry::set_allocated_part(std::string* part) {
  if (part != nullptr) {
    
  } else {
    
  }
  part_.SetAllocated(part, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_.IsDefault()) {
    part_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.part)
}

// string robot = 2 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
inline void RobotPartHistoryEntry::clear_robot() {
  robot_.ClearToEmpty();
}
inline const std::string& RobotPartHistoryEntry::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.robot)
  return _internal_robot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPartHistoryEntry::set_robot(ArgT0&& arg0, ArgT... args) {
 
 robot_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPartHistoryEntry.robot)
}
inline std::string* RobotPartHistoryEntry::mutable_robot() {
  std::string* _s = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.robot)
  return _s;
}
inline const std::string& RobotPartHistoryEntry::_internal_robot() const {
  return robot_.Get();
}
inline void RobotPartHistoryEntry::_internal_set_robot(const std::string& value) {
  
  robot_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::_internal_mutable_robot() {
  
  return robot_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.robot)
  return robot_.Release();
}
inline void RobotPartHistoryEntry::set_allocated_robot(std::string* robot) {
  if (robot != nullptr) {
    
  } else {
    
  }
  robot_.SetAllocated(robot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_.IsDefault()) {
    robot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.robot)
}

// .google.protobuf.Timestamp when = 3 [json_name = "when", (.tagger.v1.tags) = "bson:\"when\" json:\"when\""];
inline bool RobotPartHistoryEntry::_internal_has_when() const {
  return this != internal_default_instance() && when_ != nullptr;
}
inline bool RobotPartHistoryEntry::has_when() const {
  return _internal_has_when();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPartHistoryEntry::_internal_when() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = when_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPartHistoryEntry::when() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.when)
  return _internal_when();
}
inline void RobotPartHistoryEntry::unsafe_arena_set_allocated_when(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* when) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(when_);
  }
  when_ = when;
  if (when) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPartHistoryEntry.when)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::release_when() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = when_;
  when_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::unsafe_arena_release_when() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.when)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = when_;
  when_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::_internal_mutable_when() {
  
  if (when_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    when_ = p;
  }
  return when_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::mutable_when() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_when();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.when)
  return _msg;
}
inline void RobotPartHistoryEntry::set_allocated_when(::PROTOBUF_NAMESPACE_ID::Timestamp* when) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(when_);
  }
  if (when) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(when));
    if (message_arena != submessage_arena) {
      when = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, when, submessage_arena);
    }
    
  } else {
    
  }
  when_ = when;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.when)
}

// .viam.app.v1.RobotPart old = 4 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
inline bool RobotPartHistoryEntry::_internal_has_old() const {
  return this != internal_default_instance() && old_ != nullptr;
}
inline bool RobotPartHistoryEntry::has_old() const {
  return _internal_has_old();
}
inline void RobotPartHistoryEntry::clear_old() {
  if (GetArenaForAllocation() == nullptr && old_ != nullptr) {
    delete old_;
  }
  old_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& RobotPartHistoryEntry::_internal_old() const {
  const ::viam::app::v1::RobotPart* p = old_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& RobotPartHistoryEntry::old() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.old)
  return _internal_old();
}
inline void RobotPartHistoryEntry::unsafe_arena_set_allocated_old(
    ::viam::app::v1::RobotPart* old) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_);
  }
  old_ = old;
  if (old) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPartHistoryEntry.old)
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::release_old() {
  
  ::viam::app::v1::RobotPart* temp = old_;
  old_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::unsafe_arena_release_old() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.old)
  
  ::viam::app::v1::RobotPart* temp = old_;
  old_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::_internal_mutable_old() {
  
  if (old_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    old_ = p;
  }
  return old_;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::mutable_old() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_old();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.old)
  return _msg;
}
inline void RobotPartHistoryEntry::set_allocated_old(::viam::app::v1::RobotPart* old) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete old_;
  }
  if (old) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old);
    if (message_arena != submessage_arena) {
      old = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old, submessage_arena);
    }
    
  } else {
    
  }
  old_ = old;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.old)
}

// .viam.app.v1.AuthenticatorInfo edited_by = 5 [json_name = "editedBy", (.tagger.v1.tags) = "bson:\"edited_by\" json:\"edited_by\""];
inline bool RobotPartHistoryEntry::_internal_has_edited_by() const {
  return this != internal_default_instance() && edited_by_ != nullptr;
}
inline bool RobotPartHistoryEntry::has_edited_by() const {
  return _internal_has_edited_by();
}
inline void RobotPartHistoryEntry::clear_edited_by() {
  if (GetArenaForAllocation() == nullptr && edited_by_ != nullptr) {
    delete edited_by_;
  }
  edited_by_ = nullptr;
}
inline const ::viam::app::v1::AuthenticatorInfo& RobotPartHistoryEntry::_internal_edited_by() const {
  const ::viam::app::v1::AuthenticatorInfo* p = edited_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AuthenticatorInfo&>(
      ::viam::app::v1::_AuthenticatorInfo_default_instance_);
}
inline const ::viam::app::v1::AuthenticatorInfo& RobotPartHistoryEntry::edited_by() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.edited_by)
  return _internal_edited_by();
}
inline void RobotPartHistoryEntry::unsafe_arena_set_allocated_edited_by(
    ::viam::app::v1::AuthenticatorInfo* edited_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edited_by_);
  }
  edited_by_ = edited_by;
  if (edited_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPartHistoryEntry.edited_by)
}
inline ::viam::app::v1::AuthenticatorInfo* RobotPartHistoryEntry::release_edited_by() {
  
  ::viam::app::v1::AuthenticatorInfo* temp = edited_by_;
  edited_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::AuthenticatorInfo* RobotPartHistoryEntry::unsafe_arena_release_edited_by() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.edited_by)
  
  ::viam::app::v1::AuthenticatorInfo* temp = edited_by_;
  edited_by_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AuthenticatorInfo* RobotPartHistoryEntry::_internal_mutable_edited_by() {
  
  if (edited_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AuthenticatorInfo>(GetArenaForAllocation());
    edited_by_ = p;
  }
  return edited_by_;
}
inline ::viam::app::v1::AuthenticatorInfo* RobotPartHistoryEntry::mutable_edited_by() {
  ::viam::app::v1::AuthenticatorInfo* _msg = _internal_mutable_edited_by();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.edited_by)
  return _msg;
}
inline void RobotPartHistoryEntry::set_allocated_edited_by(::viam::app::v1::AuthenticatorInfo* edited_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edited_by_;
  }
  if (edited_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edited_by);
    if (message_arena != submessage_arena) {
      edited_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edited_by, submessage_arena);
    }
    
  } else {
    
  }
  edited_by_ = edited_by;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.edited_by)
}

// -------------------------------------------------------------------

// AuthenticatorInfo

// .viam.app.v1.AuthenticationType type = 1 [json_name = "type"];
inline void AuthenticatorInfo::clear_type() {
  type_ = 0;
}
inline ::viam::app::v1::AuthenticationType AuthenticatorInfo::_internal_type() const {
  return static_cast< ::viam::app::v1::AuthenticationType >(type_);
}
inline ::viam::app::v1::AuthenticationType AuthenticatorInfo::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthenticatorInfo.type)
  return _internal_type();
}
inline void AuthenticatorInfo::_internal_set_type(::viam::app::v1::AuthenticationType value) {
  
  type_ = value;
}
inline void AuthenticatorInfo::set_type(::viam::app::v1::AuthenticationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthenticatorInfo.type)
}

// string value = 2 [json_name = "value"];
inline void AuthenticatorInfo::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& AuthenticatorInfo::value() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthenticatorInfo.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticatorInfo::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthenticatorInfo.value)
}
inline std::string* AuthenticatorInfo::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthenticatorInfo.value)
  return _s;
}
inline const std::string& AuthenticatorInfo::_internal_value() const {
  return value_.Get();
}
inline void AuthenticatorInfo::_internal_set_value(const std::string& value) {
  
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticatorInfo::_internal_mutable_value() {
  
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticatorInfo::release_value() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthenticatorInfo.value)
  return value_.Release();
}
inline void AuthenticatorInfo::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthenticatorInfo.value)
}

// bool is_deactivated = 3 [json_name = "isDeactivated"];
inline void AuthenticatorInfo::clear_is_deactivated() {
  is_deactivated_ = false;
}
inline bool AuthenticatorInfo::_internal_is_deactivated() const {
  return is_deactivated_;
}
inline bool AuthenticatorInfo::is_deactivated() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthenticatorInfo.is_deactivated)
  return _internal_is_deactivated();
}
inline void AuthenticatorInfo::_internal_set_is_deactivated(bool value) {
  
  is_deactivated_ = value;
}
inline void AuthenticatorInfo::set_is_deactivated(bool value) {
  _internal_set_is_deactivated(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthenticatorInfo.is_deactivated)
}

// -------------------------------------------------------------------

// ListOrganizationsRequest

// -------------------------------------------------------------------

// Organization

// string id = 1 [json_name = "id"];
inline void Organization::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Organization::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.id)
}
inline std::string* Organization::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.id)
  return _s;
}
inline const std::string& Organization::_internal_id() const {
  return id_.Get();
}
inline void Organization::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.id)
  return id_.Release();
}
inline void Organization::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.id)
}

// string name = 2 [json_name = "name"];
inline void Organization::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Organization::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.name)
}
inline std::string* Organization::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.name)
  return _s;
}
inline const std::string& Organization::_internal_name() const {
  return name_.Get();
}
inline void Organization::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.name)
  return name_.Release();
}
inline void Organization::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.name)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool Organization::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Organization::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Organization::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Organization::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.created_on)
  return _internal_created_on();
}
inline void Organization::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Organization.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.created_on)
  return _msg;
}
inline void Organization::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.created_on)
}

// string public_namespace = 4 [json_name = "publicNamespace"];
inline void Organization::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& Organization::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.public_namespace)
}
inline std::string* Organization::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.public_namespace)
  return _s;
}
inline const std::string& Organization::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void Organization::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.public_namespace)
  return public_namespace_.Release();
}
inline void Organization::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.public_namespace)
}

// string default_region = 5 [json_name = "defaultRegion"];
inline void Organization::clear_default_region() {
  default_region_.ClearToEmpty();
}
inline const std::string& Organization::default_region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.default_region)
  return _internal_default_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_default_region(ArgT0&& arg0, ArgT... args) {
 
 default_region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.default_region)
}
inline std::string* Organization::mutable_default_region() {
  std::string* _s = _internal_mutable_default_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.default_region)
  return _s;
}
inline const std::string& Organization::_internal_default_region() const {
  return default_region_.Get();
}
inline void Organization::_internal_set_default_region(const std::string& value) {
  
  default_region_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_default_region() {
  
  return default_region_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_default_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.default_region)
  return default_region_.Release();
}
inline void Organization::set_allocated_default_region(std::string* default_region) {
  if (default_region != nullptr) {
    
  } else {
    
  }
  default_region_.SetAllocated(default_region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_region_.IsDefault()) {
    default_region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.default_region)
}

// optional string cid = 6 [json_name = "cid"];
inline bool Organization::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Organization::has_cid() const {
  return _internal_has_cid();
}
inline void Organization::clear_cid() {
  cid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Organization::cid() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_cid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.cid)
}
inline std::string* Organization::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.cid)
  return _s;
}
inline const std::string& Organization::_internal_cid() const {
  return cid_.Get();
}
inline void Organization::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000001u;
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_cid() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Organization::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.cid)
}

// -------------------------------------------------------------------

// OrganizationMember

// string user_id = 1 [json_name = "userId"];
inline void OrganizationMember::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& OrganizationMember::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationMember::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationMember.user_id)
}
inline std::string* OrganizationMember::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.user_id)
  return _s;
}
inline const std::string& OrganizationMember::_internal_user_id() const {
  return user_id_.Get();
}
inline void OrganizationMember::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationMember::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationMember::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationMember.user_id)
  return user_id_.Release();
}
inline void OrganizationMember::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationMember.user_id)
}

// repeated string emails = 2 [json_name = "emails"];
inline int OrganizationMember::_internal_emails_size() const {
  return emails_.size();
}
inline int OrganizationMember::emails_size() const {
  return _internal_emails_size();
}
inline void OrganizationMember::clear_emails() {
  emails_.Clear();
}
inline std::string* OrganizationMember::add_emails() {
  std::string* _s = _internal_add_emails();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.OrganizationMember.emails)
  return _s;
}
inline const std::string& OrganizationMember::_internal_emails(int index) const {
  return emails_.Get(index);
}
inline const std::string& OrganizationMember::emails(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.emails)
  return _internal_emails(index);
}
inline std::string* OrganizationMember::mutable_emails(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.emails)
  return emails_.Mutable(index);
}
inline void OrganizationMember::set_emails(int index, const std::string& value) {
  emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::set_emails(int index, std::string&& value) {
  emails_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::set_emails(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::set_emails(int index, const char* value, size_t size) {
  emails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.OrganizationMember.emails)
}
inline std::string* OrganizationMember::_internal_add_emails() {
  return emails_.Add();
}
inline void OrganizationMember::add_emails(const std::string& value) {
  emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::add_emails(std::string&& value) {
  emails_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::add_emails(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::add_emails(const char* value, size_t size) {
  emails_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.OrganizationMember.emails)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrganizationMember::emails() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.OrganizationMember.emails)
  return emails_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrganizationMember::mutable_emails() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.OrganizationMember.emails)
  return &emails_;
}

// .google.protobuf.Timestamp date_added = 3 [json_name = "dateAdded"];
inline bool OrganizationMember::_internal_has_date_added() const {
  return this != internal_default_instance() && date_added_ != nullptr;
}
inline bool OrganizationMember::has_date_added() const {
  return _internal_has_date_added();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::_internal_date_added() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = date_added_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::date_added() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.date_added)
  return _internal_date_added();
}
inline void OrganizationMember::unsafe_arena_set_allocated_date_added(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_added) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_added_);
  }
  date_added_ = date_added;
  if (date_added) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.OrganizationMember.date_added)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::release_date_added() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = date_added_;
  date_added_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::unsafe_arena_release_date_added() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationMember.date_added)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = date_added_;
  date_added_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::_internal_mutable_date_added() {
  
  if (date_added_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    date_added_ = p;
  }
  return date_added_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::mutable_date_added() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_added();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.date_added)
  return _msg;
}
inline void OrganizationMember::set_allocated_date_added(::PROTOBUF_NAMESPACE_ID::Timestamp* date_added) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_added_);
  }
  if (date_added) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_added));
    if (message_arena != submessage_arena) {
      date_added = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_added, submessage_arena);
    }
    
  } else {
    
  }
  date_added_ = date_added;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationMember.date_added)
}

// optional .google.protobuf.Timestamp last_login = 4 [json_name = "lastLogin"];
inline bool OrganizationMember::_internal_has_last_login() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || last_login_ != nullptr);
  return value;
}
inline bool OrganizationMember::has_last_login() const {
  return _internal_has_last_login();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::_internal_last_login() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_login_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::last_login() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.last_login)
  return _internal_last_login();
}
inline void OrganizationMember::unsafe_arena_set_allocated_last_login(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  last_login_ = last_login;
  if (last_login) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.OrganizationMember.last_login)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::release_last_login() {
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_login_;
  last_login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::unsafe_arena_release_last_login() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationMember.last_login)
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_login_;
  last_login_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::_internal_mutable_last_login() {
  _has_bits_[0] |= 0x00000001u;
  if (last_login_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_login_ = p;
  }
  return last_login_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::mutable_last_login() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_login();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.last_login)
  return _msg;
}
inline void OrganizationMember::set_allocated_last_login(::PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  if (last_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login));
    if (message_arena != submessage_arena) {
      last_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_login, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_login_ = last_login;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationMember.last_login)
}

// optional .google.protobuf.Timestamp last_access = 5 [json_name = "lastAccess"];
inline bool OrganizationMember::_internal_has_last_access() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || last_access_ != nullptr);
  return value;
}
inline bool OrganizationMember::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.last_access)
  return _internal_last_access();
}
inline void OrganizationMember::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  last_access_ = last_access;
  if (last_access) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.OrganizationMember.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::release_last_access() {
  _has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationMember.last_access)
  _has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::_internal_mutable_last_access() {
  _has_bits_[0] |= 0x00000002u;
  if (last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_access_ = p;
  }
  return last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.last_access)
  return _msg;
}
inline void OrganizationMember::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationMember.last_access)
}

// -------------------------------------------------------------------

// ListOrganizationsResponse

// repeated .viam.app.v1.Organization organizations = 1 [json_name = "organizations"];
inline int ListOrganizationsResponse::_internal_organizations_size() const {
  return organizations_.size();
}
inline int ListOrganizationsResponse::organizations_size() const {
  return _internal_organizations_size();
}
inline void ListOrganizationsResponse::clear_organizations() {
  organizations_.Clear();
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::mutable_organizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationsResponse.organizations)
  return organizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >*
ListOrganizationsResponse::mutable_organizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationsResponse.organizations)
  return &organizations_;
}
inline const ::viam::app::v1::Organization& ListOrganizationsResponse::_internal_organizations(int index) const {
  return organizations_.Get(index);
}
inline const ::viam::app::v1::Organization& ListOrganizationsResponse::organizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationsResponse.organizations)
  return _internal_organizations(index);
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::_internal_add_organizations() {
  return organizations_.Add();
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::add_organizations() {
  ::viam::app::v1::Organization* _add = _internal_add_organizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationsResponse.organizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >&
ListOrganizationsResponse::organizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationsResponse.organizations)
  return organizations_;
}

// -------------------------------------------------------------------

// OrganizationInvite

// string organization_id = 1 [json_name = "organizationId"];
inline void OrganizationInvite::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& OrganizationInvite::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationInvite::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationInvite.organization_id)
}
inline std::string* OrganizationInvite::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.organization_id)
  return _s;
}
inline const std::string& OrganizationInvite::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void OrganizationInvite::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationInvite::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationInvite::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationInvite.organization_id)
  return organization_id_.Release();
}
inline void OrganizationInvite::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationInvite.organization_id)
}

// string email = 2 [json_name = "email"];
inline void OrganizationInvite::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& OrganizationInvite::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationInvite::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationInvite.email)
}
inline std::string* OrganizationInvite::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.email)
  return _s;
}
inline const std::string& OrganizationInvite::_internal_email() const {
  return email_.Get();
}
inline void OrganizationInvite::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationInvite::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationInvite::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationInvite.email)
  return email_.Release();
}
inline void OrganizationInvite::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationInvite.email)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool OrganizationInvite::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool OrganizationInvite::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationInvite::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationInvite::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.created_on)
  return _internal_created_on();
}
inline void OrganizationInvite::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.OrganizationInvite.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationInvite.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.created_on)
  return _msg;
}
inline void OrganizationInvite::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationInvite.created_on)
}

// repeated .viam.app.v1.Authorization authorizations = 4 [json_name = "authorizations"];
inline int OrganizationInvite::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int OrganizationInvite::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void OrganizationInvite::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* OrganizationInvite::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
OrganizationInvite::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.OrganizationInvite.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& OrganizationInvite::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& OrganizationInvite::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* OrganizationInvite::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* OrganizationInvite::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.OrganizationInvite.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
OrganizationInvite::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.OrganizationInvite.authorizations)
  return authorizations_;
}

// -------------------------------------------------------------------

// CreateOrganizationRequest

// string name = 1 [json_name = "name"];
inline void CreateOrganizationRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateOrganizationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOrganizationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationRequest.name)
}
inline std::string* CreateOrganizationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationRequest.name)
  return _s;
}
inline const std::string& CreateOrganizationRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateOrganizationRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOrganizationRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOrganizationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationRequest.name)
  return name_.Release();
}
inline void CreateOrganizationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationRequest.name)
}

// -------------------------------------------------------------------

// CreateOrganizationResponse

// .viam.app.v1.Organization organization = 1 [json_name = "organization"];
inline bool CreateOrganizationResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool CreateOrganizationResponse::has_organization() const {
  return _internal_has_organization();
}
inline void CreateOrganizationResponse::clear_organization() {
  if (GetArenaForAllocation() == nullptr && organization_ != nullptr) {
    delete organization_;
  }
  organization_ = nullptr;
}
inline const ::viam::app::v1::Organization& CreateOrganizationResponse::_internal_organization() const {
  const ::viam::app::v1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Organization&>(
      ::viam::app::v1::_Organization_default_instance_);
}
inline const ::viam::app::v1::Organization& CreateOrganizationResponse::organization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationResponse.organization)
  return _internal_organization();
}
inline void CreateOrganizationResponse::unsafe_arena_set_allocated_organization(
    ::viam::app::v1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateOrganizationResponse.organization)
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::release_organization() {
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationResponse.organization)
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::mutable_organization() {
  ::viam::app::v1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationResponse.organization)
  return _msg;
}
inline void CreateOrganizationResponse::set_allocated_organization(::viam::app::v1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationResponse.organization)
}

// -------------------------------------------------------------------

// GetOrganizationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetOrganizationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& GetOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationRequest.organization_id)
}
inline std::string* GetOrganizationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationRequest.organization_id)
  return _s;
}
inline const std::string& GetOrganizationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void GetOrganizationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationRequest.organization_id)
  return organization_id_.Release();
}
inline void GetOrganizationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// GetOrganizationResponse

// .viam.app.v1.Organization organization = 1 [json_name = "organization"];
inline bool GetOrganizationResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool GetOrganizationResponse::has_organization() const {
  return _internal_has_organization();
}
inline void GetOrganizationResponse::clear_organization() {
  if (GetArenaForAllocation() == nullptr && organization_ != nullptr) {
    delete organization_;
  }
  organization_ = nullptr;
}
inline const ::viam::app::v1::Organization& GetOrganizationResponse::_internal_organization() const {
  const ::viam::app::v1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Organization&>(
      ::viam::app::v1::_Organization_default_instance_);
}
inline const ::viam::app::v1::Organization& GetOrganizationResponse::organization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationResponse.organization)
  return _internal_organization();
}
inline void GetOrganizationResponse::unsafe_arena_set_allocated_organization(
    ::viam::app::v1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetOrganizationResponse.organization)
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::release_organization() {
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationResponse.organization)
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::mutable_organization() {
  ::viam::app::v1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationResponse.organization)
  return _msg;
}
inline void GetOrganizationResponse::set_allocated_organization(::viam::app::v1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationResponse.organization)
}

// -------------------------------------------------------------------

// GetOrganizationNamespaceAvailabilityRequest

// string public_namespace = 1 [json_name = "publicNamespace"];
inline void GetOrganizationNamespaceAvailabilityRequest::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& GetOrganizationNamespaceAvailabilityRequest::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationNamespaceAvailabilityRequest::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
  return _s;
}
inline const std::string& GetOrganizationNamespaceAvailabilityRequest::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void GetOrganizationNamespaceAvailabilityRequest::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
  return public_namespace_.Release();
}
inline void GetOrganizationNamespaceAvailabilityRequest::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void GetOrganizationNamespaceAvailabilityRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& GetOrganizationNamespaceAvailabilityRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationNamespaceAvailabilityRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.organization_id)
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.organization_id)
  return _s;
}
inline const std::string& GetOrganizationNamespaceAvailabilityRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void GetOrganizationNamespaceAvailabilityRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.organization_id)
  return organization_id_.Release();
}
inline void GetOrganizationNamespaceAvailabilityRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.organization_id)
}

// -------------------------------------------------------------------

// GetOrganizationNamespaceAvailabilityResponse

// bool available = 1 [json_name = "available"];
inline void GetOrganizationNamespaceAvailabilityResponse::clear_available() {
  available_ = false;
}
inline bool GetOrganizationNamespaceAvailabilityResponse::_internal_available() const {
  return available_;
}
inline bool GetOrganizationNamespaceAvailabilityResponse::available() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse.available)
  return _internal_available();
}
inline void GetOrganizationNamespaceAvailabilityResponse::_internal_set_available(bool value) {
  
  available_ = value;
}
inline void GetOrganizationNamespaceAvailabilityResponse::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse.available)
}

// -------------------------------------------------------------------

// FragmentImportList

// repeated .viam.app.v1.FragmentImport fragments = 1 [json_name = "fragments"];
inline int FragmentImportList::_internal_fragments_size() const {
  return fragments_.size();
}
inline int FragmentImportList::fragments_size() const {
  return _internal_fragments_size();
}
inline void FragmentImportList::clear_fragments() {
  fragments_.Clear();
}
inline ::viam::app::v1::FragmentImport* FragmentImportList::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentImportList.fragments)
  return fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentImport >*
FragmentImportList::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.FragmentImportList.fragments)
  return &fragments_;
}
inline const ::viam::app::v1::FragmentImport& FragmentImportList::_internal_fragments(int index) const {
  return fragments_.Get(index);
}
inline const ::viam::app::v1::FragmentImport& FragmentImportList::fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentImportList.fragments)
  return _internal_fragments(index);
}
inline ::viam::app::v1::FragmentImport* FragmentImportList::_internal_add_fragments() {
  return fragments_.Add();
}
inline ::viam::app::v1::FragmentImport* FragmentImportList::add_fragments() {
  ::viam::app::v1::FragmentImport* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.FragmentImportList.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentImport >&
FragmentImportList::fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.FragmentImportList.fragments)
  return fragments_;
}

// -------------------------------------------------------------------

// UpdateOrganizationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void UpdateOrganizationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.organization_id)
}
inline std::string* UpdateOrganizationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.organization_id)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.organization_id)
  return organization_id_.Release();
}
inline void UpdateOrganizationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.organization_id)
}

// optional string name = 2 [json_name = "name"];
inline bool UpdateOrganizationRequest::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_name() const {
  return _internal_has_name();
}
inline void UpdateOrganizationRequest::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateOrganizationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.name)
}
inline std::string* UpdateOrganizationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.name)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.name)
}

// optional string public_namespace = 3 [json_name = "publicNamespace"];
inline bool UpdateOrganizationRequest::_internal_has_public_namespace() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_public_namespace() const {
  return _internal_has_public_namespace();
}
inline void UpdateOrganizationRequest::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateOrganizationRequest::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.public_namespace)
}
inline std::string* UpdateOrganizationRequest::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.public_namespace)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_public_namespace(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_public_namespace() {
  _has_bits_[0] |= 0x00000002u;
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.public_namespace)
  if (!_internal_has_public_namespace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_namespace_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.public_namespace)
}

// optional string region = 4 [json_name = "region"];
inline bool UpdateOrganizationRequest::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_region() const {
  return _internal_has_region();
}
inline void UpdateOrganizationRequest::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UpdateOrganizationRequest::region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.region)
}
inline std::string* UpdateOrganizationRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.region)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_region() const {
  return region_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000004u;
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.region)
}

// optional string cid = 5 [json_name = "cid"];
inline bool UpdateOrganizationRequest::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_cid() const {
  return _internal_has_cid();
}
inline void UpdateOrganizationRequest::clear_cid() {
  cid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UpdateOrganizationRequest::cid() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.cid)
}
inline std::string* UpdateOrganizationRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.cid)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_cid() const {
  return cid_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000008u;
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_cid() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = cid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.cid)
}

// optional .viam.app.v1.FragmentImportList default_fragments = 6 [json_name = "defaultFragments"];
inline bool UpdateOrganizationRequest::_internal_has_default_fragments() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || default_fragments_ != nullptr);
  return value;
}
inline bool UpdateOrganizationRequest::has_default_fragments() const {
  return _internal_has_default_fragments();
}
inline void UpdateOrganizationRequest::clear_default_fragments() {
  if (default_fragments_ != nullptr) default_fragments_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::viam::app::v1::FragmentImportList& UpdateOrganizationRequest::_internal_default_fragments() const {
  const ::viam::app::v1::FragmentImportList* p = default_fragments_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::FragmentImportList&>(
      ::viam::app::v1::_FragmentImportList_default_instance_);
}
inline const ::viam::app::v1::FragmentImportList& UpdateOrganizationRequest::default_fragments() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.default_fragments)
  return _internal_default_fragments();
}
inline void UpdateOrganizationRequest::unsafe_arena_set_allocated_default_fragments(
    ::viam::app::v1::FragmentImportList* default_fragments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_fragments_);
  }
  default_fragments_ = default_fragments;
  if (default_fragments) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOrganizationRequest.default_fragments)
}
inline ::viam::app::v1::FragmentImportList* UpdateOrganizationRequest::release_default_fragments() {
  _has_bits_[0] &= ~0x00000010u;
  ::viam::app::v1::FragmentImportList* temp = default_fragments_;
  default_fragments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::FragmentImportList* UpdateOrganizationRequest::unsafe_arena_release_default_fragments() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.default_fragments)
  _has_bits_[0] &= ~0x00000010u;
  ::viam::app::v1::FragmentImportList* temp = default_fragments_;
  default_fragments_ = nullptr;
  return temp;
}
inline ::viam::app::v1::FragmentImportList* UpdateOrganizationRequest::_internal_mutable_default_fragments() {
  _has_bits_[0] |= 0x00000010u;
  if (default_fragments_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::FragmentImportList>(GetArenaForAllocation());
    default_fragments_ = p;
  }
  return default_fragments_;
}
inline ::viam::app::v1::FragmentImportList* UpdateOrganizationRequest::mutable_default_fragments() {
  ::viam::app::v1::FragmentImportList* _msg = _internal_mutable_default_fragments();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.default_fragments)
  return _msg;
}
inline void UpdateOrganizationRequest::set_allocated_default_fragments(::viam::app::v1::FragmentImportList* default_fragments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete default_fragments_;
  }
  if (default_fragments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_fragments);
    if (message_arena != submessage_arena) {
      default_fragments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_fragments, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  default_fragments_ = default_fragments;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.default_fragments)
}

// -------------------------------------------------------------------

// UpdateOrganizationResponse

// .viam.app.v1.Organization organization = 1 [json_name = "organization"];
inline bool UpdateOrganizationResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool UpdateOrganizationResponse::has_organization() const {
  return _internal_has_organization();
}
inline void UpdateOrganizationResponse::clear_organization() {
  if (GetArenaForAllocation() == nullptr && organization_ != nullptr) {
    delete organization_;
  }
  organization_ = nullptr;
}
inline const ::viam::app::v1::Organization& UpdateOrganizationResponse::_internal_organization() const {
  const ::viam::app::v1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Organization&>(
      ::viam::app::v1::_Organization_default_instance_);
}
inline const ::viam::app::v1::Organization& UpdateOrganizationResponse::organization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationResponse.organization)
  return _internal_organization();
}
inline void UpdateOrganizationResponse::unsafe_arena_set_allocated_organization(
    ::viam::app::v1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOrganizationResponse.organization)
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::release_organization() {
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationResponse.organization)
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::mutable_organization() {
  ::viam::app::v1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationResponse.organization)
  return _msg;
}
inline void UpdateOrganizationResponse::set_allocated_organization(::viam::app::v1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationResponse.organization)
}

// -------------------------------------------------------------------

// UpdateOrganizationNamespaceRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void UpdateOrganizationNamespaceRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationNamespaceRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationNamespaceRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationNamespaceRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationNamespaceRequest.organization_id)
}
inline std::string* UpdateOrganizationNamespaceRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationNamespaceRequest.organization_id)
  return _s;
}
inline const std::string& UpdateOrganizationNamespaceRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UpdateOrganizationNamespaceRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationNamespaceRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationNamespaceRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationNamespaceRequest.organization_id)
  return organization_id_.Release();
}
inline void UpdateOrganizationNamespaceRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationNamespaceRequest.organization_id)
}

// string new_public_namespace = 2 [json_name = "newPublicNamespace"];
inline void UpdateOrganizationNamespaceRequest::clear_new_public_namespace() {
  new_public_namespace_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationNamespaceRequest::new_public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationNamespaceRequest.new_public_namespace)
  return _internal_new_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationNamespaceRequest::set_new_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 new_public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationNamespaceRequest.new_public_namespace)
}
inline std::string* UpdateOrganizationNamespaceRequest::mutable_new_public_namespace() {
  std::string* _s = _internal_mutable_new_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationNamespaceRequest.new_public_namespace)
  return _s;
}
inline const std::string& UpdateOrganizationNamespaceRequest::_internal_new_public_namespace() const {
  return new_public_namespace_.Get();
}
inline void UpdateOrganizationNamespaceRequest::_internal_set_new_public_namespace(const std::string& value) {
  
  new_public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationNamespaceRequest::_internal_mutable_new_public_namespace() {
  
  return new_public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationNamespaceRequest::release_new_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationNamespaceRequest.new_public_namespace)
  return new_public_namespace_.Release();
}
inline void UpdateOrganizationNamespaceRequest::set_allocated_new_public_namespace(std::string* new_public_namespace) {
  if (new_public_namespace != nullptr) {
    
  } else {
    
  }
  new_public_namespace_.SetAllocated(new_public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_public_namespace_.IsDefault()) {
    new_public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationNamespaceRequest.new_public_namespace)
}

// -------------------------------------------------------------------

// UpdateOrganizationNamespaceResponse

// .viam.app.v1.Organization organization = 1 [json_name = "organization"];
inline bool UpdateOrganizationNamespaceResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool UpdateOrganizationNamespaceResponse::has_organization() const {
  return _internal_has_organization();
}
inline void UpdateOrganizationNamespaceResponse::clear_organization() {
  if (GetArenaForAllocation() == nullptr && organization_ != nullptr) {
    delete organization_;
  }
  organization_ = nullptr;
}
inline const ::viam::app::v1::Organization& UpdateOrganizationNamespaceResponse::_internal_organization() const {
  const ::viam::app::v1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Organization&>(
      ::viam::app::v1::_Organization_default_instance_);
}
inline const ::viam::app::v1::Organization& UpdateOrganizationNamespaceResponse::organization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationNamespaceResponse.organization)
  return _internal_organization();
}
inline void UpdateOrganizationNamespaceResponse::unsafe_arena_set_allocated_organization(
    ::viam::app::v1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOrganizationNamespaceResponse.organization)
}
inline ::viam::app::v1::Organization* UpdateOrganizationNamespaceResponse::release_organization() {
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Organization* UpdateOrganizationNamespaceResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationNamespaceResponse.organization)
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Organization* UpdateOrganizationNamespaceResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::viam::app::v1::Organization* UpdateOrganizationNamespaceResponse::mutable_organization() {
  ::viam::app::v1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationNamespaceResponse.organization)
  return _msg;
}
inline void UpdateOrganizationNamespaceResponse::set_allocated_organization(::viam::app::v1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationNamespaceResponse.organization)
}

// -------------------------------------------------------------------

// DeleteOrganizationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void DeleteOrganizationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationRequest.organization_id)
}
inline std::string* DeleteOrganizationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationRequest.organization_id)
  return _s;
}
inline const std::string& DeleteOrganizationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void DeleteOrganizationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationRequest.organization_id)
  return organization_id_.Release();
}
inline void DeleteOrganizationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// DeleteOrganizationResponse

// -------------------------------------------------------------------

// GetOrganizationMetadataRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetOrganizationMetadataRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& GetOrganizationMetadataRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationMetadataRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationMetadataRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationMetadataRequest.organization_id)
}
inline std::string* GetOrganizationMetadataRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationMetadataRequest.organization_id)
  return _s;
}
inline const std::string& GetOrganizationMetadataRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void GetOrganizationMetadataRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationMetadataRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationMetadataRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationMetadataRequest.organization_id)
  return organization_id_.Release();
}
inline void GetOrganizationMetadataRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationMetadataRequest.organization_id)
}

// -------------------------------------------------------------------

// GetOrganizationMetadataResponse

// .google.protobuf.Struct data = 1 [json_name = "data"];
inline bool GetOrganizationMetadataResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool GetOrganizationMetadataResponse::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetOrganizationMetadataResponse::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetOrganizationMetadataResponse::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationMetadataResponse.data)
  return _internal_data();
}
inline void GetOrganizationMetadataResponse::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetOrganizationMetadataResponse.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetOrganizationMetadataResponse::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetOrganizationMetadataResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationMetadataResponse.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetOrganizationMetadataResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetOrganizationMetadataResponse::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationMetadataResponse.data)
  return _msg;
}
inline void GetOrganizationMetadataResponse::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationMetadataResponse.data)
}

// -------------------------------------------------------------------

// UpdateOrganizationMetadataRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void UpdateOrganizationMetadataRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationMetadataRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationMetadataRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationMetadataRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationMetadataRequest.organization_id)
}
inline std::string* UpdateOrganizationMetadataRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationMetadataRequest.organization_id)
  return _s;
}
inline const std::string& UpdateOrganizationMetadataRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UpdateOrganizationMetadataRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationMetadataRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationMetadataRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationMetadataRequest.organization_id)
  return organization_id_.Release();
}
inline void UpdateOrganizationMetadataRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationMetadataRequest.organization_id)
}

// .google.protobuf.Struct data = 2 [json_name = "data"];
inline bool UpdateOrganizationMetadataRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool UpdateOrganizationMetadataRequest::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateOrganizationMetadataRequest::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateOrganizationMetadataRequest::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationMetadataRequest.data)
  return _internal_data();
}
inline void UpdateOrganizationMetadataRequest::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOrganizationMetadataRequest.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateOrganizationMetadataRequest::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateOrganizationMetadataRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationMetadataRequest.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateOrganizationMetadataRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateOrganizationMetadataRequest::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationMetadataRequest.data)
  return _msg;
}
inline void UpdateOrganizationMetadataRequest::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationMetadataRequest.data)
}

// -------------------------------------------------------------------

// UpdateOrganizationMetadataResponse

// -------------------------------------------------------------------

// ListOrganizationMembersRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListOrganizationMembersRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListOrganizationMembersRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOrganizationMembersRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOrganizationMembersRequest.organization_id)
}
inline std::string* ListOrganizationMembersRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersRequest.organization_id)
  return _s;
}
inline const std::string& ListOrganizationMembersRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListOrganizationMembersRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListOrganizationMembersRequest.organization_id)
  return organization_id_.Release();
}
inline void ListOrganizationMembersRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListOrganizationMembersRequest.organization_id)
}

// -------------------------------------------------------------------

// ListOrganizationMembersResponse

// string organization_id = 1 [json_name = "organizationId"];
inline void ListOrganizationMembersResponse::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListOrganizationMembersResponse::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersResponse.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOrganizationMembersResponse::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOrganizationMembersResponse.organization_id)
}
inline std::string* ListOrganizationMembersResponse::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersResponse.organization_id)
  return _s;
}
inline const std::string& ListOrganizationMembersResponse::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListOrganizationMembersResponse::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersResponse::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersResponse::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListOrganizationMembersResponse.organization_id)
  return organization_id_.Release();
}
inline void ListOrganizationMembersResponse::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListOrganizationMembersResponse.organization_id)
}

// repeated .viam.app.v1.OrganizationMember members = 2 [json_name = "members"];
inline int ListOrganizationMembersResponse::_internal_members_size() const {
  return members_.size();
}
inline int ListOrganizationMembersResponse::members_size() const {
  return _internal_members_size();
}
inline void ListOrganizationMembersResponse::clear_members() {
  members_.Clear();
}
inline ::viam::app::v1::OrganizationMember* ListOrganizationMembersResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersResponse.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >*
ListOrganizationMembersResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationMembersResponse.members)
  return &members_;
}
inline const ::viam::app::v1::OrganizationMember& ListOrganizationMembersResponse::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::viam::app::v1::OrganizationMember& ListOrganizationMembersResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersResponse.members)
  return _internal_members(index);
}
inline ::viam::app::v1::OrganizationMember* ListOrganizationMembersResponse::_internal_add_members() {
  return members_.Add();
}
inline ::viam::app::v1::OrganizationMember* ListOrganizationMembersResponse::add_members() {
  ::viam::app::v1::OrganizationMember* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationMembersResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >&
ListOrganizationMembersResponse::members() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationMembersResponse.members)
  return members_;
}

// repeated .viam.app.v1.OrganizationInvite invites = 3 [json_name = "invites"];
inline int ListOrganizationMembersResponse::_internal_invites_size() const {
  return invites_.size();
}
inline int ListOrganizationMembersResponse::invites_size() const {
  return _internal_invites_size();
}
inline void ListOrganizationMembersResponse::clear_invites() {
  invites_.Clear();
}
inline ::viam::app::v1::OrganizationInvite* ListOrganizationMembersResponse::mutable_invites(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersResponse.invites)
  return invites_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >*
ListOrganizationMembersResponse::mutable_invites() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationMembersResponse.invites)
  return &invites_;
}
inline const ::viam::app::v1::OrganizationInvite& ListOrganizationMembersResponse::_internal_invites(int index) const {
  return invites_.Get(index);
}
inline const ::viam::app::v1::OrganizationInvite& ListOrganizationMembersResponse::invites(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersResponse.invites)
  return _internal_invites(index);
}
inline ::viam::app::v1::OrganizationInvite* ListOrganizationMembersResponse::_internal_add_invites() {
  return invites_.Add();
}
inline ::viam::app::v1::OrganizationInvite* ListOrganizationMembersResponse::add_invites() {
  ::viam::app::v1::OrganizationInvite* _add = _internal_add_invites();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationMembersResponse.invites)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >&
ListOrganizationMembersResponse::invites() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationMembersResponse.invites)
  return invites_;
}

// -------------------------------------------------------------------

// CreateOrganizationInviteRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateOrganizationInviteRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateOrganizationInviteRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOrganizationInviteRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
}
inline std::string* CreateOrganizationInviteRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
  return _s;
}
inline const std::string& CreateOrganizationInviteRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateOrganizationInviteRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateOrganizationInviteRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void CreateOrganizationInviteRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& CreateOrganizationInviteRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOrganizationInviteRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationInviteRequest.email)
}
inline std::string* CreateOrganizationInviteRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteRequest.email)
  return _s;
}
inline const std::string& CreateOrganizationInviteRequest::_internal_email() const {
  return email_.Get();
}
inline void CreateOrganizationInviteRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationInviteRequest.email)
  return email_.Release();
}
inline void CreateOrganizationInviteRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationInviteRequest.email)
}

// repeated .viam.app.v1.Authorization authorizations = 3 [json_name = "authorizations"];
inline int CreateOrganizationInviteRequest::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int CreateOrganizationInviteRequest::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void CreateOrganizationInviteRequest::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* CreateOrganizationInviteRequest::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
CreateOrganizationInviteRequest::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& CreateOrganizationInviteRequest::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& CreateOrganizationInviteRequest::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* CreateOrganizationInviteRequest::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* CreateOrganizationInviteRequest::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
CreateOrganizationInviteRequest::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return authorizations_;
}

// optional bool send_email_invite = 4 [json_name = "sendEmailInvite"];
inline bool CreateOrganizationInviteRequest::_internal_has_send_email_invite() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateOrganizationInviteRequest::has_send_email_invite() const {
  return _internal_has_send_email_invite();
}
inline void CreateOrganizationInviteRequest::clear_send_email_invite() {
  send_email_invite_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CreateOrganizationInviteRequest::_internal_send_email_invite() const {
  return send_email_invite_;
}
inline bool CreateOrganizationInviteRequest::send_email_invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.send_email_invite)
  return _internal_send_email_invite();
}
inline void CreateOrganizationInviteRequest::_internal_set_send_email_invite(bool value) {
  _has_bits_[0] |= 0x00000001u;
  send_email_invite_ = value;
}
inline void CreateOrganizationInviteRequest::set_send_email_invite(bool value) {
  _internal_set_send_email_invite(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationInviteRequest.send_email_invite)
}

// -------------------------------------------------------------------

// CreateOrganizationInviteResponse

// .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
inline bool CreateOrganizationInviteResponse::_internal_has_invite() const {
  return this != internal_default_instance() && invite_ != nullptr;
}
inline bool CreateOrganizationInviteResponse::has_invite() const {
  return _internal_has_invite();
}
inline void CreateOrganizationInviteResponse::clear_invite() {
  if (GetArenaForAllocation() == nullptr && invite_ != nullptr) {
    delete invite_;
  }
  invite_ = nullptr;
}
inline const ::viam::app::v1::OrganizationInvite& CreateOrganizationInviteResponse::_internal_invite() const {
  const ::viam::app::v1::OrganizationInvite* p = invite_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OrganizationInvite&>(
      ::viam::app::v1::_OrganizationInvite_default_instance_);
}
inline const ::viam::app::v1::OrganizationInvite& CreateOrganizationInviteResponse::invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteResponse.invite)
  return _internal_invite();
}
inline void CreateOrganizationInviteResponse::unsafe_arena_set_allocated_invite(
    ::viam::app::v1::OrganizationInvite* invite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invite_);
  }
  invite_ = invite;
  if (invite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateOrganizationInviteResponse.invite)
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::release_invite() {
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::unsafe_arena_release_invite() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationInviteResponse.invite)
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::_internal_mutable_invite() {
  
  if (invite_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(GetArenaForAllocation());
    invite_ = p;
  }
  return invite_;
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::mutable_invite() {
  ::viam::app::v1::OrganizationInvite* _msg = _internal_mutable_invite();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteResponse.invite)
  return _msg;
}
inline void CreateOrganizationInviteResponse::set_allocated_invite(::viam::app::v1::OrganizationInvite* invite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invite_;
  }
  if (invite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invite);
    if (message_arena != submessage_arena) {
      invite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invite, submessage_arena);
    }
    
  } else {
    
  }
  invite_ = invite;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationInviteResponse.invite)
}

// -------------------------------------------------------------------

// UpdateOrganizationInviteAuthorizationsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationInviteAuthorizationsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
  return _s;
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
  return organization_id_.Release();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationInviteAuthorizationsRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
  return _s;
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::_internal_email() const {
  return email_.Get();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
  return email_.Release();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
}

// repeated .viam.app.v1.Authorization add_authorizations = 3 [json_name = "addAuthorizations"];
inline int UpdateOrganizationInviteAuthorizationsRequest::_internal_add_authorizations_size() const {
  return add_authorizations_.size();
}
inline int UpdateOrganizationInviteAuthorizationsRequest::add_authorizations_size() const {
  return _internal_add_authorizations_size();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_add_authorizations() {
  add_authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::mutable_add_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return add_authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
UpdateOrganizationInviteAuthorizationsRequest::mutable_add_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return &add_authorizations_;
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::_internal_add_authorizations(int index) const {
  return add_authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::add_authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return _internal_add_authorizations(index);
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::_internal_add_add_authorizations() {
  return add_authorizations_.Add();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::add_add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
UpdateOrganizationInviteAuthorizationsRequest::add_authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return add_authorizations_;
}

// repeated .viam.app.v1.Authorization remove_authorizations = 4 [json_name = "removeAuthorizations"];
inline int UpdateOrganizationInviteAuthorizationsRequest::_internal_remove_authorizations_size() const {
  return remove_authorizations_.size();
}
inline int UpdateOrganizationInviteAuthorizationsRequest::remove_authorizations_size() const {
  return _internal_remove_authorizations_size();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_remove_authorizations() {
  remove_authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::mutable_remove_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return remove_authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
UpdateOrganizationInviteAuthorizationsRequest::mutable_remove_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return &remove_authorizations_;
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::_internal_remove_authorizations(int index) const {
  return remove_authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::remove_authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return _internal_remove_authorizations(index);
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::_internal_add_remove_authorizations() {
  return remove_authorizations_.Add();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::add_remove_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_remove_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
UpdateOrganizationInviteAuthorizationsRequest::remove_authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return remove_authorizations_;
}

// -------------------------------------------------------------------

// UpdateOrganizationInviteAuthorizationsResponse

// .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
inline bool UpdateOrganizationInviteAuthorizationsResponse::_internal_has_invite() const {
  return this != internal_default_instance() && invite_ != nullptr;
}
inline bool UpdateOrganizationInviteAuthorizationsResponse::has_invite() const {
  return _internal_has_invite();
}
inline void UpdateOrganizationInviteAuthorizationsResponse::clear_invite() {
  if (GetArenaForAllocation() == nullptr && invite_ != nullptr) {
    delete invite_;
  }
  invite_ = nullptr;
}
inline const ::viam::app::v1::OrganizationInvite& UpdateOrganizationInviteAuthorizationsResponse::_internal_invite() const {
  const ::viam::app::v1::OrganizationInvite* p = invite_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OrganizationInvite&>(
      ::viam::app::v1::_OrganizationInvite_default_instance_);
}
inline const ::viam::app::v1::OrganizationInvite& UpdateOrganizationInviteAuthorizationsResponse::invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
  return _internal_invite();
}
inline void UpdateOrganizationInviteAuthorizationsResponse::unsafe_arena_set_allocated_invite(
    ::viam::app::v1::OrganizationInvite* invite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invite_);
  }
  invite_ = invite;
  if (invite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::release_invite() {
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::unsafe_arena_release_invite() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::_internal_mutable_invite() {
  
  if (invite_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(GetArenaForAllocation());
    invite_ = p;
  }
  return invite_;
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::mutable_invite() {
  ::viam::app::v1::OrganizationInvite* _msg = _internal_mutable_invite();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
  return _msg;
}
inline void UpdateOrganizationInviteAuthorizationsResponse::set_allocated_invite(::viam::app::v1::OrganizationInvite* invite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invite_;
  }
  if (invite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invite);
    if (message_arena != submessage_arena) {
      invite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invite, submessage_arena);
    }
    
  } else {
    
  }
  invite_ = invite;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
}

// -------------------------------------------------------------------

// DeleteOrganizationInviteRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void DeleteOrganizationInviteRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationInviteRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationInviteRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
}
inline std::string* DeleteOrganizationInviteRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
  return _s;
}
inline const std::string& DeleteOrganizationInviteRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void DeleteOrganizationInviteRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
  return organization_id_.Release();
}
inline void DeleteOrganizationInviteRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void DeleteOrganizationInviteRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationInviteRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationInviteRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationInviteRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationInviteRequest.email)
}
inline std::string* DeleteOrganizationInviteRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationInviteRequest.email)
  return _s;
}
inline const std::string& DeleteOrganizationInviteRequest::_internal_email() const {
  return email_.Get();
}
inline void DeleteOrganizationInviteRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationInviteRequest.email)
  return email_.Release();
}
inline void DeleteOrganizationInviteRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationInviteRequest.email)
}

// -------------------------------------------------------------------

// DeleteOrganizationInviteResponse

// -------------------------------------------------------------------

// ResendOrganizationInviteRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ResendOrganizationInviteRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ResendOrganizationInviteRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResendOrganizationInviteRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
}
inline std::string* ResendOrganizationInviteRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
  return _s;
}
inline const std::string& ResendOrganizationInviteRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ResendOrganizationInviteRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
  return organization_id_.Release();
}
inline void ResendOrganizationInviteRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void ResendOrganizationInviteRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& ResendOrganizationInviteRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResendOrganizationInviteRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResendOrganizationInviteRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResendOrganizationInviteRequest.email)
}
inline std::string* ResendOrganizationInviteRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResendOrganizationInviteRequest.email)
  return _s;
}
inline const std::string& ResendOrganizationInviteRequest::_internal_email() const {
  return email_.Get();
}
inline void ResendOrganizationInviteRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResendOrganizationInviteRequest.email)
  return email_.Release();
}
inline void ResendOrganizationInviteRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResendOrganizationInviteRequest.email)
}

// optional bool send_email_invite = 3 [json_name = "sendEmailInvite"];
inline bool ResendOrganizationInviteRequest::_internal_has_send_email_invite() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResendOrganizationInviteRequest::has_send_email_invite() const {
  return _internal_has_send_email_invite();
}
inline void ResendOrganizationInviteRequest::clear_send_email_invite() {
  send_email_invite_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ResendOrganizationInviteRequest::_internal_send_email_invite() const {
  return send_email_invite_;
}
inline bool ResendOrganizationInviteRequest::send_email_invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResendOrganizationInviteRequest.send_email_invite)
  return _internal_send_email_invite();
}
inline void ResendOrganizationInviteRequest::_internal_set_send_email_invite(bool value) {
  _has_bits_[0] |= 0x00000001u;
  send_email_invite_ = value;
}
inline void ResendOrganizationInviteRequest::set_send_email_invite(bool value) {
  _internal_set_send_email_invite(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ResendOrganizationInviteRequest.send_email_invite)
}

// -------------------------------------------------------------------

// ResendOrganizationInviteResponse

// .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
inline bool ResendOrganizationInviteResponse::_internal_has_invite() const {
  return this != internal_default_instance() && invite_ != nullptr;
}
inline bool ResendOrganizationInviteResponse::has_invite() const {
  return _internal_has_invite();
}
inline void ResendOrganizationInviteResponse::clear_invite() {
  if (GetArenaForAllocation() == nullptr && invite_ != nullptr) {
    delete invite_;
  }
  invite_ = nullptr;
}
inline const ::viam::app::v1::OrganizationInvite& ResendOrganizationInviteResponse::_internal_invite() const {
  const ::viam::app::v1::OrganizationInvite* p = invite_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OrganizationInvite&>(
      ::viam::app::v1::_OrganizationInvite_default_instance_);
}
inline const ::viam::app::v1::OrganizationInvite& ResendOrganizationInviteResponse::invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResendOrganizationInviteResponse.invite)
  return _internal_invite();
}
inline void ResendOrganizationInviteResponse::unsafe_arena_set_allocated_invite(
    ::viam::app::v1::OrganizationInvite* invite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invite_);
  }
  invite_ = invite;
  if (invite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ResendOrganizationInviteResponse.invite)
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::release_invite() {
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::unsafe_arena_release_invite() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResendOrganizationInviteResponse.invite)
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::_internal_mutable_invite() {
  
  if (invite_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(GetArenaForAllocation());
    invite_ = p;
  }
  return invite_;
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::mutable_invite() {
  ::viam::app::v1::OrganizationInvite* _msg = _internal_mutable_invite();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResendOrganizationInviteResponse.invite)
  return _msg;
}
inline void ResendOrganizationInviteResponse::set_allocated_invite(::viam::app::v1::OrganizationInvite* invite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invite_;
  }
  if (invite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invite);
    if (message_arena != submessage_arena) {
      invite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invite, submessage_arena);
    }
    
  } else {
    
  }
  invite_ = invite;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResendOrganizationInviteResponse.invite)
}

// -------------------------------------------------------------------

// DeleteOrganizationMemberRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void DeleteOrganizationMemberRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationMemberRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationMemberRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
}
inline std::string* DeleteOrganizationMemberRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
  return _s;
}
inline const std::string& DeleteOrganizationMemberRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void DeleteOrganizationMemberRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
  return organization_id_.Release();
}
inline void DeleteOrganizationMemberRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
}

// string user_id = 2 [json_name = "userId"];
inline void DeleteOrganizationMemberRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationMemberRequest::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationMemberRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
}
inline std::string* DeleteOrganizationMemberRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
  return _s;
}
inline const std::string& DeleteOrganizationMemberRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DeleteOrganizationMemberRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
  return user_id_.Release();
}
inline void DeleteOrganizationMemberRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
}

// -------------------------------------------------------------------

// DeleteOrganizationMemberResponse

// -------------------------------------------------------------------

// BillingAddress

// string address_line_1 = 1 [json_name = "addressLine1"];
inline void BillingAddress::clear_address_line_1() {
  address_line_1_.ClearToEmpty();
}
inline const std::string& BillingAddress::address_line_1() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.BillingAddress.address_line_1)
  return _internal_address_line_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BillingAddress::set_address_line_1(ArgT0&& arg0, ArgT... args) {
 
 address_line_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.BillingAddress.address_line_1)
}
inline std::string* BillingAddress::mutable_address_line_1() {
  std::string* _s = _internal_mutable_address_line_1();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.BillingAddress.address_line_1)
  return _s;
}
inline const std::string& BillingAddress::_internal_address_line_1() const {
  return address_line_1_.Get();
}
inline void BillingAddress::_internal_set_address_line_1(const std::string& value) {
  
  address_line_1_.Set(value, GetArenaForAllocation());
}
inline std::string* BillingAddress::_internal_mutable_address_line_1() {
  
  return address_line_1_.Mutable(GetArenaForAllocation());
}
inline std::string* BillingAddress::release_address_line_1() {
  // @@protoc_insertion_point(field_release:viam.app.v1.BillingAddress.address_line_1)
  return address_line_1_.Release();
}
inline void BillingAddress::set_allocated_address_line_1(std::string* address_line_1) {
  if (address_line_1 != nullptr) {
    
  } else {
    
  }
  address_line_1_.SetAllocated(address_line_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_line_1_.IsDefault()) {
    address_line_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.BillingAddress.address_line_1)
}

// optional string address_line_2 = 2 [json_name = "addressLine2"];
inline bool BillingAddress::_internal_has_address_line_2() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BillingAddress::has_address_line_2() const {
  return _internal_has_address_line_2();
}
inline void BillingAddress::clear_address_line_2() {
  address_line_2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BillingAddress::address_line_2() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.BillingAddress.address_line_2)
  return _internal_address_line_2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BillingAddress::set_address_line_2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_line_2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.BillingAddress.address_line_2)
}
inline std::string* BillingAddress::mutable_address_line_2() {
  std::string* _s = _internal_mutable_address_line_2();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.BillingAddress.address_line_2)
  return _s;
}
inline const std::string& BillingAddress::_internal_address_line_2() const {
  return address_line_2_.Get();
}
inline void BillingAddress::_internal_set_address_line_2(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_line_2_.Set(value, GetArenaForAllocation());
}
inline std::string* BillingAddress::_internal_mutable_address_line_2() {
  _has_bits_[0] |= 0x00000001u;
  return address_line_2_.Mutable(GetArenaForAllocation());
}
inline std::string* BillingAddress::release_address_line_2() {
  // @@protoc_insertion_point(field_release:viam.app.v1.BillingAddress.address_line_2)
  if (!_internal_has_address_line_2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = address_line_2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_line_2_.IsDefault()) {
    address_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BillingAddress::set_allocated_address_line_2(std::string* address_line_2) {
  if (address_line_2 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_line_2_.SetAllocated(address_line_2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_line_2_.IsDefault()) {
    address_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.BillingAddress.address_line_2)
}

// string city = 3 [json_name = "city"];
inline void BillingAddress::clear_city() {
  city_.ClearToEmpty();
}
inline const std::string& BillingAddress::city() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.BillingAddress.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BillingAddress::set_city(ArgT0&& arg0, ArgT... args) {
 
 city_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.BillingAddress.city)
}
inline std::string* BillingAddress::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.BillingAddress.city)
  return _s;
}
inline const std::string& BillingAddress::_internal_city() const {
  return city_.Get();
}
inline void BillingAddress::_internal_set_city(const std::string& value) {
  
  city_.Set(value, GetArenaForAllocation());
}
inline std::string* BillingAddress::_internal_mutable_city() {
  
  return city_.Mutable(GetArenaForAllocation());
}
inline std::string* BillingAddress::release_city() {
  // @@protoc_insertion_point(field_release:viam.app.v1.BillingAddress.city)
  return city_.Release();
}
inline void BillingAddress::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    
  } else {
    
  }
  city_.SetAllocated(city, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault()) {
    city_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.BillingAddress.city)
}

// string state = 4 [json_name = "state"];
inline void BillingAddress::clear_state() {
  state_.ClearToEmpty();
}
inline const std::string& BillingAddress::state() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.BillingAddress.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BillingAddress::set_state(ArgT0&& arg0, ArgT... args) {
 
 state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.BillingAddress.state)
}
inline std::string* BillingAddress::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.BillingAddress.state)
  return _s;
}
inline const std::string& BillingAddress::_internal_state() const {
  return state_.Get();
}
inline void BillingAddress::_internal_set_state(const std::string& value) {
  
  state_.Set(value, GetArenaForAllocation());
}
inline std::string* BillingAddress::_internal_mutable_state() {
  
  return state_.Mutable(GetArenaForAllocation());
}
inline std::string* BillingAddress::release_state() {
  // @@protoc_insertion_point(field_release:viam.app.v1.BillingAddress.state)
  return state_.Release();
}
inline void BillingAddress::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault()) {
    state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.BillingAddress.state)
}

// string zipcode = 5 [json_name = "zipcode"];
inline void BillingAddress::clear_zipcode() {
  zipcode_.ClearToEmpty();
}
inline const std::string& BillingAddress::zipcode() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.BillingAddress.zipcode)
  return _internal_zipcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BillingAddress::set_zipcode(ArgT0&& arg0, ArgT... args) {
 
 zipcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.BillingAddress.zipcode)
}
inline std::string* BillingAddress::mutable_zipcode() {
  std::string* _s = _internal_mutable_zipcode();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.BillingAddress.zipcode)
  return _s;
}
inline const std::string& BillingAddress::_internal_zipcode() const {
  return zipcode_.Get();
}
inline void BillingAddress::_internal_set_zipcode(const std::string& value) {
  
  zipcode_.Set(value, GetArenaForAllocation());
}
inline std::string* BillingAddress::_internal_mutable_zipcode() {
  
  return zipcode_.Mutable(GetArenaForAllocation());
}
inline std::string* BillingAddress::release_zipcode() {
  // @@protoc_insertion_point(field_release:viam.app.v1.BillingAddress.zipcode)
  return zipcode_.Release();
}
inline void BillingAddress::set_allocated_zipcode(std::string* zipcode) {
  if (zipcode != nullptr) {
    
  } else {
    
  }
  zipcode_.SetAllocated(zipcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (zipcode_.IsDefault()) {
    zipcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.BillingAddress.zipcode)
}

// string country = 6 [json_name = "country"];
inline void BillingAddress::clear_country() {
  country_.ClearToEmpty();
}
inline const std::string& BillingAddress::country() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.BillingAddress.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BillingAddress::set_country(ArgT0&& arg0, ArgT... args) {
 
 country_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.BillingAddress.country)
}
inline std::string* BillingAddress::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.BillingAddress.country)
  return _s;
}
inline const std::string& BillingAddress::_internal_country() const {
  return country_.Get();
}
inline void BillingAddress::_internal_set_country(const std::string& value) {
  
  country_.Set(value, GetArenaForAllocation());
}
inline std::string* BillingAddress::_internal_mutable_country() {
  
  return country_.Mutable(GetArenaForAllocation());
}
inline std::string* BillingAddress::release_country() {
  // @@protoc_insertion_point(field_release:viam.app.v1.BillingAddress.country)
  return country_.Release();
}
inline void BillingAddress::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    
  } else {
    
  }
  country_.SetAllocated(country, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault()) {
    country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.BillingAddress.country)
}

// -------------------------------------------------------------------

// EnableBillingServiceRequest

// string org_id = 1 [json_name = "orgId"];
inline void EnableBillingServiceRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& EnableBillingServiceRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.EnableBillingServiceRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnableBillingServiceRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.EnableBillingServiceRequest.org_id)
}
inline std::string* EnableBillingServiceRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.EnableBillingServiceRequest.org_id)
  return _s;
}
inline const std::string& EnableBillingServiceRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void EnableBillingServiceRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EnableBillingServiceRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EnableBillingServiceRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.EnableBillingServiceRequest.org_id)
  return org_id_.Release();
}
inline void EnableBillingServiceRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.EnableBillingServiceRequest.org_id)
}

// .viam.app.v1.BillingAddress billing_address = 2 [json_name = "billingAddress"];
inline bool EnableBillingServiceRequest::_internal_has_billing_address() const {
  return this != internal_default_instance() && billing_address_ != nullptr;
}
inline bool EnableBillingServiceRequest::has_billing_address() const {
  return _internal_has_billing_address();
}
inline void EnableBillingServiceRequest::clear_billing_address() {
  if (GetArenaForAllocation() == nullptr && billing_address_ != nullptr) {
    delete billing_address_;
  }
  billing_address_ = nullptr;
}
inline const ::viam::app::v1::BillingAddress& EnableBillingServiceRequest::_internal_billing_address() const {
  const ::viam::app::v1::BillingAddress* p = billing_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::BillingAddress&>(
      ::viam::app::v1::_BillingAddress_default_instance_);
}
inline const ::viam::app::v1::BillingAddress& EnableBillingServiceRequest::billing_address() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.EnableBillingServiceRequest.billing_address)
  return _internal_billing_address();
}
inline void EnableBillingServiceRequest::unsafe_arena_set_allocated_billing_address(
    ::viam::app::v1::BillingAddress* billing_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(billing_address_);
  }
  billing_address_ = billing_address;
  if (billing_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.EnableBillingServiceRequest.billing_address)
}
inline ::viam::app::v1::BillingAddress* EnableBillingServiceRequest::release_billing_address() {
  
  ::viam::app::v1::BillingAddress* temp = billing_address_;
  billing_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::BillingAddress* EnableBillingServiceRequest::unsafe_arena_release_billing_address() {
  // @@protoc_insertion_point(field_release:viam.app.v1.EnableBillingServiceRequest.billing_address)
  
  ::viam::app::v1::BillingAddress* temp = billing_address_;
  billing_address_ = nullptr;
  return temp;
}
inline ::viam::app::v1::BillingAddress* EnableBillingServiceRequest::_internal_mutable_billing_address() {
  
  if (billing_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::BillingAddress>(GetArenaForAllocation());
    billing_address_ = p;
  }
  return billing_address_;
}
inline ::viam::app::v1::BillingAddress* EnableBillingServiceRequest::mutable_billing_address() {
  ::viam::app::v1::BillingAddress* _msg = _internal_mutable_billing_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.EnableBillingServiceRequest.billing_address)
  return _msg;
}
inline void EnableBillingServiceRequest::set_allocated_billing_address(::viam::app::v1::BillingAddress* billing_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete billing_address_;
  }
  if (billing_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(billing_address);
    if (message_arena != submessage_arena) {
      billing_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, billing_address, submessage_arena);
    }
    
  } else {
    
  }
  billing_address_ = billing_address;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.EnableBillingServiceRequest.billing_address)
}

// -------------------------------------------------------------------

// EnableBillingServiceResponse

// -------------------------------------------------------------------

// UpdateBillingServiceRequest

// string org_id = 1 [json_name = "orgId"];
inline void UpdateBillingServiceRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& UpdateBillingServiceRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateBillingServiceRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateBillingServiceRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateBillingServiceRequest.org_id)
}
inline std::string* UpdateBillingServiceRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateBillingServiceRequest.org_id)
  return _s;
}
inline const std::string& UpdateBillingServiceRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void UpdateBillingServiceRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateBillingServiceRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateBillingServiceRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateBillingServiceRequest.org_id)
  return org_id_.Release();
}
inline void UpdateBillingServiceRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateBillingServiceRequest.org_id)
}

// .viam.app.v1.BillingAddress billing_address = 2 [json_name = "billingAddress"];
inline bool UpdateBillingServiceRequest::_internal_has_billing_address() const {
  return this != internal_default_instance() && billing_address_ != nullptr;
}
inline bool UpdateBillingServiceRequest::has_billing_address() const {
  return _internal_has_billing_address();
}
inline void UpdateBillingServiceRequest::clear_billing_address() {
  if (GetArenaForAllocation() == nullptr && billing_address_ != nullptr) {
    delete billing_address_;
  }
  billing_address_ = nullptr;
}
inline const ::viam::app::v1::BillingAddress& UpdateBillingServiceRequest::_internal_billing_address() const {
  const ::viam::app::v1::BillingAddress* p = billing_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::BillingAddress&>(
      ::viam::app::v1::_BillingAddress_default_instance_);
}
inline const ::viam::app::v1::BillingAddress& UpdateBillingServiceRequest::billing_address() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateBillingServiceRequest.billing_address)
  return _internal_billing_address();
}
inline void UpdateBillingServiceRequest::unsafe_arena_set_allocated_billing_address(
    ::viam::app::v1::BillingAddress* billing_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(billing_address_);
  }
  billing_address_ = billing_address;
  if (billing_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateBillingServiceRequest.billing_address)
}
inline ::viam::app::v1::BillingAddress* UpdateBillingServiceRequest::release_billing_address() {
  
  ::viam::app::v1::BillingAddress* temp = billing_address_;
  billing_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::BillingAddress* UpdateBillingServiceRequest::unsafe_arena_release_billing_address() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateBillingServiceRequest.billing_address)
  
  ::viam::app::v1::BillingAddress* temp = billing_address_;
  billing_address_ = nullptr;
  return temp;
}
inline ::viam::app::v1::BillingAddress* UpdateBillingServiceRequest::_internal_mutable_billing_address() {
  
  if (billing_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::BillingAddress>(GetArenaForAllocation());
    billing_address_ = p;
  }
  return billing_address_;
}
inline ::viam::app::v1::BillingAddress* UpdateBillingServiceRequest::mutable_billing_address() {
  ::viam::app::v1::BillingAddress* _msg = _internal_mutable_billing_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateBillingServiceRequest.billing_address)
  return _msg;
}
inline void UpdateBillingServiceRequest::set_allocated_billing_address(::viam::app::v1::BillingAddress* billing_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete billing_address_;
  }
  if (billing_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(billing_address);
    if (message_arena != submessage_arena) {
      billing_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, billing_address, submessage_arena);
    }
    
  } else {
    
  }
  billing_address_ = billing_address;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateBillingServiceRequest.billing_address)
}

// -------------------------------------------------------------------

// UpdateBillingServiceResponse

// -------------------------------------------------------------------

// GetBillingServiceConfigRequest

// string org_id = 1 [json_name = "orgId"];
inline void GetBillingServiceConfigRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& GetBillingServiceConfigRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetBillingServiceConfigRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBillingServiceConfigRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetBillingServiceConfigRequest.org_id)
}
inline std::string* GetBillingServiceConfigRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetBillingServiceConfigRequest.org_id)
  return _s;
}
inline const std::string& GetBillingServiceConfigRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void GetBillingServiceConfigRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetBillingServiceConfigRequest.org_id)
  return org_id_.Release();
}
inline void GetBillingServiceConfigRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetBillingServiceConfigRequest.org_id)
}

// -------------------------------------------------------------------

// GetBillingServiceConfigResponse

// .viam.app.v1.BillingAddress billing_address = 1 [json_name = "billingAddress"];
inline bool GetBillingServiceConfigResponse::_internal_has_billing_address() const {
  return this != internal_default_instance() && billing_address_ != nullptr;
}
inline bool GetBillingServiceConfigResponse::has_billing_address() const {
  return _internal_has_billing_address();
}
inline void GetBillingServiceConfigResponse::clear_billing_address() {
  if (GetArenaForAllocation() == nullptr && billing_address_ != nullptr) {
    delete billing_address_;
  }
  billing_address_ = nullptr;
}
inline const ::viam::app::v1::BillingAddress& GetBillingServiceConfigResponse::_internal_billing_address() const {
  const ::viam::app::v1::BillingAddress* p = billing_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::BillingAddress&>(
      ::viam::app::v1::_BillingAddress_default_instance_);
}
inline const ::viam::app::v1::BillingAddress& GetBillingServiceConfigResponse::billing_address() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetBillingServiceConfigResponse.billing_address)
  return _internal_billing_address();
}
inline void GetBillingServiceConfigResponse::unsafe_arena_set_allocated_billing_address(
    ::viam::app::v1::BillingAddress* billing_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(billing_address_);
  }
  billing_address_ = billing_address;
  if (billing_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetBillingServiceConfigResponse.billing_address)
}
inline ::viam::app::v1::BillingAddress* GetBillingServiceConfigResponse::release_billing_address() {
  
  ::viam::app::v1::BillingAddress* temp = billing_address_;
  billing_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::BillingAddress* GetBillingServiceConfigResponse::unsafe_arena_release_billing_address() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetBillingServiceConfigResponse.billing_address)
  
  ::viam::app::v1::BillingAddress* temp = billing_address_;
  billing_address_ = nullptr;
  return temp;
}
inline ::viam::app::v1::BillingAddress* GetBillingServiceConfigResponse::_internal_mutable_billing_address() {
  
  if (billing_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::BillingAddress>(GetArenaForAllocation());
    billing_address_ = p;
  }
  return billing_address_;
}
inline ::viam::app::v1::BillingAddress* GetBillingServiceConfigResponse::mutable_billing_address() {
  ::viam::app::v1::BillingAddress* _msg = _internal_mutable_billing_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetBillingServiceConfigResponse.billing_address)
  return _msg;
}
inline void GetBillingServiceConfigResponse::set_allocated_billing_address(::viam::app::v1::BillingAddress* billing_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete billing_address_;
  }
  if (billing_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(billing_address);
    if (message_arena != submessage_arena) {
      billing_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, billing_address, submessage_arena);
    }
    
  } else {
    
  }
  billing_address_ = billing_address;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetBillingServiceConfigResponse.billing_address)
}

// string support_email = 2 [json_name = "supportEmail"];
inline void GetBillingServiceConfigResponse::clear_support_email() {
  support_email_.ClearToEmpty();
}
inline const std::string& GetBillingServiceConfigResponse::support_email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetBillingServiceConfigResponse.support_email)
  return _internal_support_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBillingServiceConfigResponse::set_support_email(ArgT0&& arg0, ArgT... args) {
 
 support_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetBillingServiceConfigResponse.support_email)
}
inline std::string* GetBillingServiceConfigResponse::mutable_support_email() {
  std::string* _s = _internal_mutable_support_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetBillingServiceConfigResponse.support_email)
  return _s;
}
inline const std::string& GetBillingServiceConfigResponse::_internal_support_email() const {
  return support_email_.Get();
}
inline void GetBillingServiceConfigResponse::_internal_set_support_email(const std::string& value) {
  
  support_email_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigResponse::_internal_mutable_support_email() {
  
  return support_email_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigResponse::release_support_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetBillingServiceConfigResponse.support_email)
  return support_email_.Release();
}
inline void GetBillingServiceConfigResponse::set_allocated_support_email(std::string* support_email) {
  if (support_email != nullptr) {
    
  } else {
    
  }
  support_email_.SetAllocated(support_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (support_email_.IsDefault()) {
    support_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetBillingServiceConfigResponse.support_email)
}

// string logo_url = 3 [json_name = "logoUrl"];
inline void GetBillingServiceConfigResponse::clear_logo_url() {
  logo_url_.ClearToEmpty();
}
inline const std::string& GetBillingServiceConfigResponse::logo_url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetBillingServiceConfigResponse.logo_url)
  return _internal_logo_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBillingServiceConfigResponse::set_logo_url(ArgT0&& arg0, ArgT... args) {
 
 logo_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetBillingServiceConfigResponse.logo_url)
}
inline std::string* GetBillingServiceConfigResponse::mutable_logo_url() {
  std::string* _s = _internal_mutable_logo_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetBillingServiceConfigResponse.logo_url)
  return _s;
}
inline const std::string& GetBillingServiceConfigResponse::_internal_logo_url() const {
  return logo_url_.Get();
}
inline void GetBillingServiceConfigResponse::_internal_set_logo_url(const std::string& value) {
  
  logo_url_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigResponse::_internal_mutable_logo_url() {
  
  return logo_url_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigResponse::release_logo_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetBillingServiceConfigResponse.logo_url)
  return logo_url_.Release();
}
inline void GetBillingServiceConfigResponse::set_allocated_logo_url(std::string* logo_url) {
  if (logo_url != nullptr) {
    
  } else {
    
  }
  logo_url_.SetAllocated(logo_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logo_url_.IsDefault()) {
    logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetBillingServiceConfigResponse.logo_url)
}

// string billing_dashboard_url = 4 [json_name = "billingDashboardUrl"];
inline void GetBillingServiceConfigResponse::clear_billing_dashboard_url() {
  billing_dashboard_url_.ClearToEmpty();
}
inline const std::string& GetBillingServiceConfigResponse::billing_dashboard_url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetBillingServiceConfigResponse.billing_dashboard_url)
  return _internal_billing_dashboard_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBillingServiceConfigResponse::set_billing_dashboard_url(ArgT0&& arg0, ArgT... args) {
 
 billing_dashboard_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetBillingServiceConfigResponse.billing_dashboard_url)
}
inline std::string* GetBillingServiceConfigResponse::mutable_billing_dashboard_url() {
  std::string* _s = _internal_mutable_billing_dashboard_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetBillingServiceConfigResponse.billing_dashboard_url)
  return _s;
}
inline const std::string& GetBillingServiceConfigResponse::_internal_billing_dashboard_url() const {
  return billing_dashboard_url_.Get();
}
inline void GetBillingServiceConfigResponse::_internal_set_billing_dashboard_url(const std::string& value) {
  
  billing_dashboard_url_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigResponse::_internal_mutable_billing_dashboard_url() {
  
  return billing_dashboard_url_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBillingServiceConfigResponse::release_billing_dashboard_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetBillingServiceConfigResponse.billing_dashboard_url)
  return billing_dashboard_url_.Release();
}
inline void GetBillingServiceConfigResponse::set_allocated_billing_dashboard_url(std::string* billing_dashboard_url) {
  if (billing_dashboard_url != nullptr) {
    
  } else {
    
  }
  billing_dashboard_url_.SetAllocated(billing_dashboard_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (billing_dashboard_url_.IsDefault()) {
    billing_dashboard_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetBillingServiceConfigResponse.billing_dashboard_url)
}

// -------------------------------------------------------------------

// DisableBillingServiceRequest

// string org_id = 1 [json_name = "orgId"];
inline void DisableBillingServiceRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& DisableBillingServiceRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DisableBillingServiceRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisableBillingServiceRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DisableBillingServiceRequest.org_id)
}
inline std::string* DisableBillingServiceRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DisableBillingServiceRequest.org_id)
  return _s;
}
inline const std::string& DisableBillingServiceRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void DisableBillingServiceRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DisableBillingServiceRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DisableBillingServiceRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DisableBillingServiceRequest.org_id)
  return org_id_.Release();
}
inline void DisableBillingServiceRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DisableBillingServiceRequest.org_id)
}

// -------------------------------------------------------------------

// DisableBillingServiceResponse

// -------------------------------------------------------------------

// OrganizationSetSupportEmailRequest

// string org_id = 1 [json_name = "orgId"];
inline void OrganizationSetSupportEmailRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& OrganizationSetSupportEmailRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationSetSupportEmailRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationSetSupportEmailRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationSetSupportEmailRequest.org_id)
}
inline std::string* OrganizationSetSupportEmailRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationSetSupportEmailRequest.org_id)
  return _s;
}
inline const std::string& OrganizationSetSupportEmailRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void OrganizationSetSupportEmailRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationSetSupportEmailRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationSetSupportEmailRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationSetSupportEmailRequest.org_id)
  return org_id_.Release();
}
inline void OrganizationSetSupportEmailRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationSetSupportEmailRequest.org_id)
}

// string email = 2 [json_name = "email"];
inline void OrganizationSetSupportEmailRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& OrganizationSetSupportEmailRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationSetSupportEmailRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationSetSupportEmailRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationSetSupportEmailRequest.email)
}
inline std::string* OrganizationSetSupportEmailRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationSetSupportEmailRequest.email)
  return _s;
}
inline const std::string& OrganizationSetSupportEmailRequest::_internal_email() const {
  return email_.Get();
}
inline void OrganizationSetSupportEmailRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationSetSupportEmailRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationSetSupportEmailRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationSetSupportEmailRequest.email)
  return email_.Release();
}
inline void OrganizationSetSupportEmailRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationSetSupportEmailRequest.email)
}

// -------------------------------------------------------------------

// OrganizationSetSupportEmailResponse

// -------------------------------------------------------------------

// OrganizationGetSupportEmailRequest

// string org_id = 1 [json_name = "orgId"];
inline void OrganizationGetSupportEmailRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& OrganizationGetSupportEmailRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationGetSupportEmailRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationGetSupportEmailRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationGetSupportEmailRequest.org_id)
}
inline std::string* OrganizationGetSupportEmailRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationGetSupportEmailRequest.org_id)
  return _s;
}
inline const std::string& OrganizationGetSupportEmailRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void OrganizationGetSupportEmailRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationGetSupportEmailRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationGetSupportEmailRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationGetSupportEmailRequest.org_id)
  return org_id_.Release();
}
inline void OrganizationGetSupportEmailRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationGetSupportEmailRequest.org_id)
}

// -------------------------------------------------------------------

// OrganizationGetSupportEmailResponse

// string email = 1 [json_name = "email"];
inline void OrganizationGetSupportEmailResponse::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& OrganizationGetSupportEmailResponse::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationGetSupportEmailResponse.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationGetSupportEmailResponse::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationGetSupportEmailResponse.email)
}
inline std::string* OrganizationGetSupportEmailResponse::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationGetSupportEmailResponse.email)
  return _s;
}
inline const std::string& OrganizationGetSupportEmailResponse::_internal_email() const {
  return email_.Get();
}
inline void OrganizationGetSupportEmailResponse::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationGetSupportEmailResponse::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationGetSupportEmailResponse::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationGetSupportEmailResponse.email)
  return email_.Release();
}
inline void OrganizationGetSupportEmailResponse::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationGetSupportEmailResponse.email)
}

// -------------------------------------------------------------------

// OrganizationIdentity

// string id = 1 [json_name = "id"];
inline void OrganizationIdentity::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& OrganizationIdentity::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationIdentity.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationIdentity::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationIdentity.id)
}
inline std::string* OrganizationIdentity::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationIdentity.id)
  return _s;
}
inline const std::string& OrganizationIdentity::_internal_id() const {
  return id_.Get();
}
inline void OrganizationIdentity::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationIdentity.id)
  return id_.Release();
}
inline void OrganizationIdentity::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationIdentity.id)
}

// string name = 2 [json_name = "name"];
inline void OrganizationIdentity::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& OrganizationIdentity::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationIdentity.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationIdentity::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationIdentity.name)
}
inline std::string* OrganizationIdentity::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationIdentity.name)
  return _s;
}
inline const std::string& OrganizationIdentity::_internal_name() const {
  return name_.Get();
}
inline void OrganizationIdentity::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationIdentity.name)
  return name_.Release();
}
inline void OrganizationIdentity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationIdentity.name)
}

// -------------------------------------------------------------------

// LocationOrganization

// string organization_id = 1 [json_name = "organizationId"];
inline void LocationOrganization::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& LocationOrganization::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationOrganization.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationOrganization::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationOrganization.organization_id)
}
inline std::string* LocationOrganization::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationOrganization.organization_id)
  return _s;
}
inline const std::string& LocationOrganization::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void LocationOrganization::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationOrganization::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationOrganization::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationOrganization.organization_id)
  return organization_id_.Release();
}
inline void LocationOrganization::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationOrganization.organization_id)
}

// bool primary = 2 [json_name = "primary"];
inline void LocationOrganization::clear_primary() {
  primary_ = false;
}
inline bool LocationOrganization::_internal_primary() const {
  return primary_;
}
inline bool LocationOrganization::primary() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationOrganization.primary)
  return _internal_primary();
}
inline void LocationOrganization::_internal_set_primary(bool value) {
  
  primary_ = value;
}
inline void LocationOrganization::set_primary(bool value) {
  _internal_set_primary(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationOrganization.primary)
}

// -------------------------------------------------------------------

// LocationAuth

// string secret = 1 [json_name = "secret", deprecated = true];
inline void LocationAuth::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& LocationAuth::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuth::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuth.secret)
}
inline std::string* LocationAuth::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.secret)
  return _s;
}
inline const std::string& LocationAuth::_internal_secret() const {
  return secret_.Get();
}
inline void LocationAuth::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuth::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuth::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuth.secret)
  return secret_.Release();
}
inline void LocationAuth::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuth.secret)
}

// string location_id = 2 [json_name = "locationId"];
inline void LocationAuth::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& LocationAuth::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuth::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuth.location_id)
}
inline std::string* LocationAuth::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.location_id)
  return _s;
}
inline const std::string& LocationAuth::_internal_location_id() const {
  return location_id_.Get();
}
inline void LocationAuth::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuth::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuth::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuth.location_id)
  return location_id_.Release();
}
inline void LocationAuth::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuth.location_id)
}

// repeated .viam.app.v1.SharedSecret secrets = 3 [json_name = "secrets"];
inline int LocationAuth::_internal_secrets_size() const {
  return secrets_.size();
}
inline int LocationAuth::secrets_size() const {
  return _internal_secrets_size();
}
inline void LocationAuth::clear_secrets() {
  secrets_.Clear();
}
inline ::viam::app::v1::SharedSecret* LocationAuth::mutable_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.secrets)
  return secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
LocationAuth::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.LocationAuth.secrets)
  return &secrets_;
}
inline const ::viam::app::v1::SharedSecret& LocationAuth::_internal_secrets(int index) const {
  return secrets_.Get(index);
}
inline const ::viam::app::v1::SharedSecret& LocationAuth::secrets(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.secrets)
  return _internal_secrets(index);
}
inline ::viam::app::v1::SharedSecret* LocationAuth::_internal_add_secrets() {
  return secrets_.Add();
}
inline ::viam::app::v1::SharedSecret* LocationAuth::add_secrets() {
  ::viam::app::v1::SharedSecret* _add = _internal_add_secrets();
  // @@protoc_insertion_point(field_add:viam.app.v1.LocationAuth.secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
LocationAuth::secrets() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.LocationAuth.secrets)
  return secrets_;
}

// -------------------------------------------------------------------

// StorageConfig

// string region = 1 [json_name = "region"];
inline void StorageConfig::clear_region() {
  region_.ClearToEmpty();
}
inline const std::string& StorageConfig::region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.StorageConfig.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageConfig::set_region(ArgT0&& arg0, ArgT... args) {
 
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.StorageConfig.region)
}
inline std::string* StorageConfig::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.StorageConfig.region)
  return _s;
}
inline const std::string& StorageConfig::_internal_region() const {
  return region_.Get();
}
inline void StorageConfig::_internal_set_region(const std::string& value) {
  
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageConfig::_internal_mutable_region() {
  
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageConfig::release_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.StorageConfig.region)
  return region_.Release();
}
inline void StorageConfig::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.StorageConfig.region)
}

// -------------------------------------------------------------------

// Location

// string id = 1 [json_name = "id"];
inline void Location::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Location::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.id)
}
inline std::string* Location::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.id)
  return _s;
}
inline const std::string& Location::_internal_id() const {
  return id_.Get();
}
inline void Location::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.id)
  return id_.Release();
}
inline void Location::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.id)
}

// string name = 2 [json_name = "name"];
inline void Location::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Location::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.name)
}
inline std::string* Location::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.name)
  return _s;
}
inline const std::string& Location::_internal_name() const {
  return name_.Get();
}
inline void Location::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.name)
  return name_.Release();
}
inline void Location::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.name)
}

// string parent_location_id = 4 [json_name = "parentLocationId"];
inline void Location::clear_parent_location_id() {
  parent_location_id_.ClearToEmpty();
}
inline const std::string& Location::parent_location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.parent_location_id)
  return _internal_parent_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_parent_location_id(ArgT0&& arg0, ArgT... args) {
 
 parent_location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.parent_location_id)
}
inline std::string* Location::mutable_parent_location_id() {
  std::string* _s = _internal_mutable_parent_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.parent_location_id)
  return _s;
}
inline const std::string& Location::_internal_parent_location_id() const {
  return parent_location_id_.Get();
}
inline void Location::_internal_set_parent_location_id(const std::string& value) {
  
  parent_location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_parent_location_id() {
  
  return parent_location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_parent_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.parent_location_id)
  return parent_location_id_.Release();
}
inline void Location::set_allocated_parent_location_id(std::string* parent_location_id) {
  if (parent_location_id != nullptr) {
    
  } else {
    
  }
  parent_location_id_.SetAllocated(parent_location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.parent_location_id)
}

// .viam.app.v1.LocationAuth auth = 5 [json_name = "auth"];
inline bool Location::_internal_has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline bool Location::has_auth() const {
  return _internal_has_auth();
}
inline void Location::clear_auth() {
  if (GetArenaForAllocation() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& Location::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& Location::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.auth)
  return _internal_auth();
}
inline void Location::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.auth)
}
inline ::viam::app::v1::LocationAuth* Location::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* Location::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.auth)
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* Location::_internal_mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::LocationAuth* Location::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.auth)
  return _msg;
}
inline void Location::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.auth)
}

// repeated .viam.app.v1.LocationOrganization organizations = 6 [json_name = "organizations"];
inline int Location::_internal_organizations_size() const {
  return organizations_.size();
}
inline int Location::organizations_size() const {
  return _internal_organizations_size();
}
inline void Location::clear_organizations() {
  organizations_.Clear();
}
inline ::viam::app::v1::LocationOrganization* Location::mutable_organizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.organizations)
  return organizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >*
Location::mutable_organizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Location.organizations)
  return &organizations_;
}
inline const ::viam::app::v1::LocationOrganization& Location::_internal_organizations(int index) const {
  return organizations_.Get(index);
}
inline const ::viam::app::v1::LocationOrganization& Location::organizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.organizations)
  return _internal_organizations(index);
}
inline ::viam::app::v1::LocationOrganization* Location::_internal_add_organizations() {
  return organizations_.Add();
}
inline ::viam::app::v1::LocationOrganization* Location::add_organizations() {
  ::viam::app::v1::LocationOrganization* _add = _internal_add_organizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.Location.organizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >&
Location::organizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Location.organizations)
  return organizations_;
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool Location::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Location::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Location::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Location::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.created_on)
  return _internal_created_on();
}
inline void Location::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.created_on)
  return _msg;
}
inline void Location::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.created_on)
}

// int32 robot_count = 7 [json_name = "robotCount"];
inline void Location::clear_robot_count() {
  robot_count_ = 0;
}
inline int32_t Location::_internal_robot_count() const {
  return robot_count_;
}
inline int32_t Location::robot_count() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.robot_count)
  return _internal_robot_count();
}
inline void Location::_internal_set_robot_count(int32_t value) {
  
  robot_count_ = value;
}
inline void Location::set_robot_count(int32_t value) {
  _internal_set_robot_count(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.robot_count)
}

// .viam.app.v1.StorageConfig config = 8 [json_name = "config"];
inline bool Location::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool Location::has_config() const {
  return _internal_has_config();
}
inline void Location::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::viam::app::v1::StorageConfig& Location::_internal_config() const {
  const ::viam::app::v1::StorageConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::StorageConfig&>(
      ::viam::app::v1::_StorageConfig_default_instance_);
}
inline const ::viam::app::v1::StorageConfig& Location::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.config)
  return _internal_config();
}
inline void Location::unsafe_arena_set_allocated_config(
    ::viam::app::v1::StorageConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.config)
}
inline ::viam::app::v1::StorageConfig* Location::release_config() {
  
  ::viam::app::v1::StorageConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::StorageConfig* Location::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.config)
  
  ::viam::app::v1::StorageConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::StorageConfig* Location::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::StorageConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::viam::app::v1::StorageConfig* Location::mutable_config() {
  ::viam::app::v1::StorageConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.config)
  return _msg;
}
inline void Location::set_allocated_config(::viam::app::v1::StorageConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.config)
}

// optional .viam.app.v1.OrganizationIdentity primary_org_identity = 9 [json_name = "primaryOrgIdentity"];
inline bool Location::_internal_has_primary_org_identity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || primary_org_identity_ != nullptr);
  return value;
}
inline bool Location::has_primary_org_identity() const {
  return _internal_has_primary_org_identity();
}
inline void Location::clear_primary_org_identity() {
  if (primary_org_identity_ != nullptr) primary_org_identity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::OrganizationIdentity& Location::_internal_primary_org_identity() const {
  const ::viam::app::v1::OrganizationIdentity* p = primary_org_identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OrganizationIdentity&>(
      ::viam::app::v1::_OrganizationIdentity_default_instance_);
}
inline const ::viam::app::v1::OrganizationIdentity& Location::primary_org_identity() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.primary_org_identity)
  return _internal_primary_org_identity();
}
inline void Location::unsafe_arena_set_allocated_primary_org_identity(
    ::viam::app::v1::OrganizationIdentity* primary_org_identity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primary_org_identity_);
  }
  primary_org_identity_ = primary_org_identity;
  if (primary_org_identity) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.primary_org_identity)
}
inline ::viam::app::v1::OrganizationIdentity* Location::release_primary_org_identity() {
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::OrganizationIdentity* temp = primary_org_identity_;
  primary_org_identity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OrganizationIdentity* Location::unsafe_arena_release_primary_org_identity() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.primary_org_identity)
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::OrganizationIdentity* temp = primary_org_identity_;
  primary_org_identity_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OrganizationIdentity* Location::_internal_mutable_primary_org_identity() {
  _has_bits_[0] |= 0x00000001u;
  if (primary_org_identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OrganizationIdentity>(GetArenaForAllocation());
    primary_org_identity_ = p;
  }
  return primary_org_identity_;
}
inline ::viam::app::v1::OrganizationIdentity* Location::mutable_primary_org_identity() {
  ::viam::app::v1::OrganizationIdentity* _msg = _internal_mutable_primary_org_identity();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.primary_org_identity)
  return _msg;
}
inline void Location::set_allocated_primary_org_identity(::viam::app::v1::OrganizationIdentity* primary_org_identity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete primary_org_identity_;
  }
  if (primary_org_identity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(primary_org_identity);
    if (message_arena != submessage_arena) {
      primary_org_identity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary_org_identity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  primary_org_identity_ = primary_org_identity;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.primary_org_identity)
}

// -------------------------------------------------------------------

// SharedSecret

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"id\""];
inline void SharedSecret::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SharedSecret::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharedSecret::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.id)
}
inline std::string* SharedSecret::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.id)
  return _s;
}
inline const std::string& SharedSecret::_internal_id() const {
  return id_.Get();
}
inline void SharedSecret::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedSecret::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedSecret::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.id)
  return id_.Release();
}
inline void SharedSecret::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.id)
}

// string secret = 2 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\""];
inline void SharedSecret::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& SharedSecret::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharedSecret::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.secret)
}
inline std::string* SharedSecret::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.secret)
  return _s;
}
inline const std::string& SharedSecret::_internal_secret() const {
  return secret_.Get();
}
inline void SharedSecret::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedSecret::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedSecret::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.secret)
  return secret_.Release();
}
inline void SharedSecret::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.secret)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
inline bool SharedSecret::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool SharedSecret::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SharedSecret::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SharedSecret::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.created_on)
  return _internal_created_on();
}
inline void SharedSecret::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.SharedSecret.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.created_on)
  return _msg;
}
inline void SharedSecret::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.created_on)
}

// .viam.app.v1.SharedSecret.State state = 4 [json_name = "state", (.tagger.v1.tags) = "bson:\"state\""];
inline void SharedSecret::clear_state() {
  state_ = 0;
}
inline ::viam::app::v1::SharedSecret_State SharedSecret::_internal_state() const {
  return static_cast< ::viam::app::v1::SharedSecret_State >(state_);
}
inline ::viam::app::v1::SharedSecret_State SharedSecret::state() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.state)
  return _internal_state();
}
inline void SharedSecret::_internal_set_state(::viam::app::v1::SharedSecret_State value) {
  
  state_ = value;
}
inline void SharedSecret::set_state(::viam::app::v1::SharedSecret_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.state)
}

// -------------------------------------------------------------------

// CreateLocationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateLocationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateLocationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.organization_id)
}
inline std::string* CreateLocationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.organization_id)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateLocationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateLocationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.organization_id)
}

// string name = 2 [json_name = "name"];
inline void CreateLocationRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateLocationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.name)
}
inline std::string* CreateLocationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.name)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateLocationRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.name)
  return name_.Release();
}
inline void CreateLocationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.name)
}

// optional string parent_location_id = 3 [json_name = "parentLocationId"];
inline bool CreateLocationRequest::_internal_has_parent_location_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateLocationRequest::has_parent_location_id() const {
  return _internal_has_parent_location_id();
}
inline void CreateLocationRequest::clear_parent_location_id() {
  parent_location_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateLocationRequest::parent_location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.parent_location_id)
  return _internal_parent_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_parent_location_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 parent_location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.parent_location_id)
}
inline std::string* CreateLocationRequest::mutable_parent_location_id() {
  std::string* _s = _internal_mutable_parent_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.parent_location_id)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_parent_location_id() const {
  return parent_location_id_.Get();
}
inline void CreateLocationRequest::_internal_set_parent_location_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  parent_location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_parent_location_id() {
  _has_bits_[0] |= 0x00000001u;
  return parent_location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_parent_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.parent_location_id)
  if (!_internal_has_parent_location_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = parent_location_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateLocationRequest::set_allocated_parent_location_id(std::string* parent_location_id) {
  if (parent_location_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parent_location_id_.SetAllocated(parent_location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.parent_location_id)
}

// -------------------------------------------------------------------

// CreateLocationResponse

// .viam.app.v1.Location location = 1 [json_name = "location"];
inline bool CreateLocationResponse::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool CreateLocationResponse::has_location() const {
  return _internal_has_location();
}
inline void CreateLocationResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::viam::app::v1::Location& CreateLocationResponse::_internal_location() const {
  const ::viam::app::v1::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Location&>(
      ::viam::app::v1::_Location_default_instance_);
}
inline const ::viam::app::v1::Location& CreateLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationResponse.location)
  return _internal_location();
}
inline void CreateLocationResponse::unsafe_arena_set_allocated_location(
    ::viam::app::v1::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateLocationResponse.location)
}
inline ::viam::app::v1::Location* CreateLocationResponse::release_location() {
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Location* CreateLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationResponse.location)
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Location* CreateLocationResponse::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::viam::app::v1::Location* CreateLocationResponse::mutable_location() {
  ::viam::app::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationResponse.location)
  return _msg;
}
inline void CreateLocationResponse::set_allocated_location(::viam::app::v1::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationResponse.location)
}

// -------------------------------------------------------------------

// GetLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void GetLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& GetLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetLocationRequest.location_id)
}
inline std::string* GetLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetLocationRequest.location_id)
  return _s;
}
inline const std::string& GetLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void GetLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetLocationRequest.location_id)
  return location_id_.Release();
}
inline void GetLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetLocationRequest.location_id)
}

// -------------------------------------------------------------------

// GetLocationResponse

// .viam.app.v1.Location location = 1 [json_name = "location"];
inline bool GetLocationResponse::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool GetLocationResponse::has_location() const {
  return _internal_has_location();
}
inline void GetLocationResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::viam::app::v1::Location& GetLocationResponse::_internal_location() const {
  const ::viam::app::v1::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Location&>(
      ::viam::app::v1::_Location_default_instance_);
}
inline const ::viam::app::v1::Location& GetLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetLocationResponse.location)
  return _internal_location();
}
inline void GetLocationResponse::unsafe_arena_set_allocated_location(
    ::viam::app::v1::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetLocationResponse.location)
}
inline ::viam::app::v1::Location* GetLocationResponse::release_location() {
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Location* GetLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetLocationResponse.location)
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Location* GetLocationResponse::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::viam::app::v1::Location* GetLocationResponse::mutable_location() {
  ::viam::app::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetLocationResponse.location)
  return _msg;
}
inline void GetLocationResponse::set_allocated_location(::viam::app::v1::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetLocationResponse.location)
}

// -------------------------------------------------------------------

// UpdateLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void UpdateLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& UpdateLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.location_id)
}
inline std::string* UpdateLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.location_id)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void UpdateLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.location_id)
  return location_id_.Release();
}
inline void UpdateLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.location_id)
}

// optional string name = 2 [json_name = "name"];
inline bool UpdateLocationRequest::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateLocationRequest::has_name() const {
  return _internal_has_name();
}
inline void UpdateLocationRequest::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateLocationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.name)
}
inline std::string* UpdateLocationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.name)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateLocationRequest::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateLocationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.name)
}

// optional string parent_location_id = 3 [json_name = "parentLocationId"];
inline bool UpdateLocationRequest::_internal_has_parent_location_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateLocationRequest::has_parent_location_id() const {
  return _internal_has_parent_location_id();
}
inline void UpdateLocationRequest::clear_parent_location_id() {
  parent_location_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateLocationRequest::parent_location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.parent_location_id)
  return _internal_parent_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_parent_location_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 parent_location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.parent_location_id)
}
inline std::string* UpdateLocationRequest::mutable_parent_location_id() {
  std::string* _s = _internal_mutable_parent_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.parent_location_id)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_parent_location_id() const {
  return parent_location_id_.Get();
}
inline void UpdateLocationRequest::_internal_set_parent_location_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  parent_location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_parent_location_id() {
  _has_bits_[0] |= 0x00000002u;
  return parent_location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_parent_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.parent_location_id)
  if (!_internal_has_parent_location_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = parent_location_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateLocationRequest::set_allocated_parent_location_id(std::string* parent_location_id) {
  if (parent_location_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_location_id_.SetAllocated(parent_location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.parent_location_id)
}

// optional string region = 4 [json_name = "region"];
inline bool UpdateLocationRequest::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateLocationRequest::has_region() const {
  return _internal_has_region();
}
inline void UpdateLocationRequest::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UpdateLocationRequest::region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.region)
}
inline std::string* UpdateLocationRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.region)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_region() const {
  return region_.Get();
}
inline void UpdateLocationRequest::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000004u;
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateLocationRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.region)
}

// -------------------------------------------------------------------

// UpdateLocationResponse

// .viam.app.v1.Location location = 1 [json_name = "location"];
inline bool UpdateLocationResponse::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool UpdateLocationResponse::has_location() const {
  return _internal_has_location();
}
inline void UpdateLocationResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::viam::app::v1::Location& UpdateLocationResponse::_internal_location() const {
  const ::viam::app::v1::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Location&>(
      ::viam::app::v1::_Location_default_instance_);
}
inline const ::viam::app::v1::Location& UpdateLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationResponse.location)
  return _internal_location();
}
inline void UpdateLocationResponse::unsafe_arena_set_allocated_location(
    ::viam::app::v1::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateLocationResponse.location)
}
inline ::viam::app::v1::Location* UpdateLocationResponse::release_location() {
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Location* UpdateLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationResponse.location)
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Location* UpdateLocationResponse::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::viam::app::v1::Location* UpdateLocationResponse::mutable_location() {
  ::viam::app::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationResponse.location)
  return _msg;
}
inline void UpdateLocationResponse::set_allocated_location(::viam::app::v1::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationResponse.location)
}

// -------------------------------------------------------------------

// DeleteLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void DeleteLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationRequest.location_id)
}
inline std::string* DeleteLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationRequest.location_id)
  return _s;
}
inline const std::string& DeleteLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void DeleteLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationRequest.location_id)
  return location_id_.Release();
}
inline void DeleteLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationRequest.location_id)
}

// -------------------------------------------------------------------

// DeleteLocationResponse

// -------------------------------------------------------------------

// GetLocationMetadataRequest

// string location_id = 1 [json_name = "locationId"];
inline void GetLocationMetadataRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& GetLocationMetadataRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetLocationMetadataRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLocationMetadataRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetLocationMetadataRequest.location_id)
}
inline std::string* GetLocationMetadataRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetLocationMetadataRequest.location_id)
  return _s;
}
inline const std::string& GetLocationMetadataRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void GetLocationMetadataRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLocationMetadataRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLocationMetadataRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetLocationMetadataRequest.location_id)
  return location_id_.Release();
}
inline void GetLocationMetadataRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetLocationMetadataRequest.location_id)
}

// -------------------------------------------------------------------

// GetLocationMetadataResponse

// .google.protobuf.Struct data = 1 [json_name = "data"];
inline bool GetLocationMetadataResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool GetLocationMetadataResponse::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetLocationMetadataResponse::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetLocationMetadataResponse::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetLocationMetadataResponse.data)
  return _internal_data();
}
inline void GetLocationMetadataResponse::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetLocationMetadataResponse.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetLocationMetadataResponse::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetLocationMetadataResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetLocationMetadataResponse.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetLocationMetadataResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetLocationMetadataResponse::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetLocationMetadataResponse.data)
  return _msg;
}
inline void GetLocationMetadataResponse::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetLocationMetadataResponse.data)
}

// -------------------------------------------------------------------

// UpdateLocationMetadataRequest

// string location_id = 1 [json_name = "locationId"];
inline void UpdateLocationMetadataRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& UpdateLocationMetadataRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationMetadataRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationMetadataRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationMetadataRequest.location_id)
}
inline std::string* UpdateLocationMetadataRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationMetadataRequest.location_id)
  return _s;
}
inline const std::string& UpdateLocationMetadataRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void UpdateLocationMetadataRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationMetadataRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationMetadataRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationMetadataRequest.location_id)
  return location_id_.Release();
}
inline void UpdateLocationMetadataRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationMetadataRequest.location_id)
}

// .google.protobuf.Struct data = 2 [json_name = "data"];
inline bool UpdateLocationMetadataRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool UpdateLocationMetadataRequest::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateLocationMetadataRequest::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateLocationMetadataRequest::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationMetadataRequest.data)
  return _internal_data();
}
inline void UpdateLocationMetadataRequest::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateLocationMetadataRequest.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateLocationMetadataRequest::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateLocationMetadataRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationMetadataRequest.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateLocationMetadataRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateLocationMetadataRequest::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationMetadataRequest.data)
  return _msg;
}
inline void UpdateLocationMetadataRequest::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationMetadataRequest.data)
}

// -------------------------------------------------------------------

// UpdateLocationMetadataResponse

// -------------------------------------------------------------------

// GetOrganizationsWithAccessToLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void GetOrganizationsWithAccessToLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& GetOrganizationsWithAccessToLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationsWithAccessToLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
}
inline std::string* GetOrganizationsWithAccessToLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
  return _s;
}
inline const std::string& GetOrganizationsWithAccessToLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void GetOrganizationsWithAccessToLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationsWithAccessToLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationsWithAccessToLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
  return location_id_.Release();
}
inline void GetOrganizationsWithAccessToLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
}

// -------------------------------------------------------------------

// GetOrganizationsWithAccessToLocationResponse

// repeated .viam.app.v1.OrganizationIdentity organization_identities = 1 [json_name = "organizationIdentities"];
inline int GetOrganizationsWithAccessToLocationResponse::_internal_organization_identities_size() const {
  return organization_identities_.size();
}
inline int GetOrganizationsWithAccessToLocationResponse::organization_identities_size() const {
  return _internal_organization_identities_size();
}
inline void GetOrganizationsWithAccessToLocationResponse::clear_organization_identities() {
  organization_identities_.Clear();
}
inline ::viam::app::v1::OrganizationIdentity* GetOrganizationsWithAccessToLocationResponse::mutable_organization_identities(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return organization_identities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >*
GetOrganizationsWithAccessToLocationResponse::mutable_organization_identities() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return &organization_identities_;
}
inline const ::viam::app::v1::OrganizationIdentity& GetOrganizationsWithAccessToLocationResponse::_internal_organization_identities(int index) const {
  return organization_identities_.Get(index);
}
inline const ::viam::app::v1::OrganizationIdentity& GetOrganizationsWithAccessToLocationResponse::organization_identities(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return _internal_organization_identities(index);
}
inline ::viam::app::v1::OrganizationIdentity* GetOrganizationsWithAccessToLocationResponse::_internal_add_organization_identities() {
  return organization_identities_.Add();
}
inline ::viam::app::v1::OrganizationIdentity* GetOrganizationsWithAccessToLocationResponse::add_organization_identities() {
  ::viam::app::v1::OrganizationIdentity* _add = _internal_add_organization_identities();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >&
GetOrganizationsWithAccessToLocationResponse::organization_identities() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return organization_identities_;
}

// -------------------------------------------------------------------

// ListLocationsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListLocationsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListLocationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListLocationsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocationsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListLocationsRequest.organization_id)
}
inline std::string* ListLocationsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListLocationsRequest.organization_id)
  return _s;
}
inline const std::string& ListLocationsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListLocationsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocationsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocationsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListLocationsRequest.organization_id)
  return organization_id_.Release();
}
inline void ListLocationsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListLocationsRequest.organization_id)
}

// -------------------------------------------------------------------

// ShareLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void ShareLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& ShareLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ShareLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ShareLocationRequest.location_id)
}
inline std::string* ShareLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ShareLocationRequest.location_id)
  return _s;
}
inline const std::string& ShareLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void ShareLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ShareLocationRequest.location_id)
  return location_id_.Release();
}
inline void ShareLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ShareLocationRequest.location_id)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void ShareLocationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ShareLocationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ShareLocationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareLocationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ShareLocationRequest.organization_id)
}
inline std::string* ShareLocationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ShareLocationRequest.organization_id)
  return _s;
}
inline const std::string& ShareLocationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ShareLocationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ShareLocationRequest.organization_id)
  return organization_id_.Release();
}
inline void ShareLocationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ShareLocationRequest.organization_id)
}

// -------------------------------------------------------------------

// ShareLocationResponse

// -------------------------------------------------------------------

// UnshareLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void UnshareLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& UnshareLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UnshareLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnshareLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UnshareLocationRequest.location_id)
}
inline std::string* UnshareLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UnshareLocationRequest.location_id)
  return _s;
}
inline const std::string& UnshareLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void UnshareLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UnshareLocationRequest.location_id)
  return location_id_.Release();
}
inline void UnshareLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UnshareLocationRequest.location_id)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void UnshareLocationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UnshareLocationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UnshareLocationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnshareLocationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UnshareLocationRequest.organization_id)
}
inline std::string* UnshareLocationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UnshareLocationRequest.organization_id)
  return _s;
}
inline const std::string& UnshareLocationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UnshareLocationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UnshareLocationRequest.organization_id)
  return organization_id_.Release();
}
inline void UnshareLocationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UnshareLocationRequest.organization_id)
}

// -------------------------------------------------------------------

// UnshareLocationResponse

// -------------------------------------------------------------------

// ListLocationsResponse

// repeated .viam.app.v1.Location locations = 1 [json_name = "locations"];
inline int ListLocationsResponse::_internal_locations_size() const {
  return locations_.size();
}
inline int ListLocationsResponse::locations_size() const {
  return _internal_locations_size();
}
inline void ListLocationsResponse::clear_locations() {
  locations_.Clear();
}
inline ::viam::app::v1::Location* ListLocationsResponse::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListLocationsResponse.locations)
  return locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >*
ListLocationsResponse::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListLocationsResponse.locations)
  return &locations_;
}
inline const ::viam::app::v1::Location& ListLocationsResponse::_internal_locations(int index) const {
  return locations_.Get(index);
}
inline const ::viam::app::v1::Location& ListLocationsResponse::locations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListLocationsResponse.locations)
  return _internal_locations(index);
}
inline ::viam::app::v1::Location* ListLocationsResponse::_internal_add_locations() {
  return locations_.Add();
}
inline ::viam::app::v1::Location* ListLocationsResponse::add_locations() {
  ::viam::app::v1::Location* _add = _internal_add_locations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListLocationsResponse.locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >&
ListLocationsResponse::locations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListLocationsResponse.locations)
  return locations_;
}

// -------------------------------------------------------------------

// CreateLocationSecretRequest

// string location_id = 1 [json_name = "locationId"];
inline void CreateLocationSecretRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& CreateLocationSecretRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationSecretRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationSecretRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationSecretRequest.location_id)
}
inline std::string* CreateLocationSecretRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationSecretRequest.location_id)
  return _s;
}
inline const std::string& CreateLocationSecretRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void CreateLocationSecretRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationSecretRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationSecretRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationSecretRequest.location_id)
  return location_id_.Release();
}
inline void CreateLocationSecretRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationSecretRequest.location_id)
}

// -------------------------------------------------------------------

// CreateLocationSecretResponse

// .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
inline bool CreateLocationSecretResponse::_internal_has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline bool CreateLocationSecretResponse::has_auth() const {
  return _internal_has_auth();
}
inline void CreateLocationSecretResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& CreateLocationSecretResponse::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& CreateLocationSecretResponse::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationSecretResponse.auth)
  return _internal_auth();
}
inline void CreateLocationSecretResponse::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateLocationSecretResponse.auth)
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationSecretResponse.auth)
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::_internal_mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationSecretResponse.auth)
  return _msg;
}
inline void CreateLocationSecretResponse::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationSecretResponse.auth)
}

// -------------------------------------------------------------------

// DeleteLocationSecretRequest

// string location_id = 1 [json_name = "locationId"];
inline void DeleteLocationSecretRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationSecretRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationSecretRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationSecretRequest.location_id)
}
inline std::string* DeleteLocationSecretRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return _s;
}
inline const std::string& DeleteLocationSecretRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void DeleteLocationSecretRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return location_id_.Release();
}
inline void DeleteLocationSecretRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationSecretRequest.location_id)
}

// string secret_id = 2 [json_name = "secretId"];
inline void DeleteLocationSecretRequest::clear_secret_id() {
  secret_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationSecretRequest::secret_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return _internal_secret_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationSecretRequest::set_secret_id(ArgT0&& arg0, ArgT... args) {
 
 secret_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationSecretRequest.secret_id)
}
inline std::string* DeleteLocationSecretRequest::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return _s;
}
inline const std::string& DeleteLocationSecretRequest::_internal_secret_id() const {
  return secret_id_.Get();
}
inline void DeleteLocationSecretRequest::_internal_set_secret_id(const std::string& value) {
  
  secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::_internal_mutable_secret_id() {
  
  return secret_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::release_secret_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return secret_id_.Release();
}
inline void DeleteLocationSecretRequest::set_allocated_secret_id(std::string* secret_id) {
  if (secret_id != nullptr) {
    
  } else {
    
  }
  secret_id_.SetAllocated(secret_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_id_.IsDefault()) {
    secret_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationSecretRequest.secret_id)
}

// -------------------------------------------------------------------

// DeleteLocationSecretResponse

// -------------------------------------------------------------------

// LocationAuthRequest

// string location_id = 1 [json_name = "locationId"];
inline void LocationAuthRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& LocationAuthRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuthRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuthRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuthRequest.location_id)
}
inline std::string* LocationAuthRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuthRequest.location_id)
  return _s;
}
inline const std::string& LocationAuthRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void LocationAuthRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuthRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuthRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuthRequest.location_id)
  return location_id_.Release();
}
inline void LocationAuthRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuthRequest.location_id)
}

// -------------------------------------------------------------------

// LocationAuthResponse

// .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
inline bool LocationAuthResponse::_internal_has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline bool LocationAuthResponse::has_auth() const {
  return _internal_has_auth();
}
inline void LocationAuthResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& LocationAuthResponse::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& LocationAuthResponse::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuthResponse.auth)
  return _internal_auth();
}
inline void LocationAuthResponse::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.LocationAuthResponse.auth)
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuthResponse.auth)
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::_internal_mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuthResponse.auth)
  return _msg;
}
inline void LocationAuthResponse::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuthResponse.auth)
}

// -------------------------------------------------------------------

// GetRobotRequest

// string id = 1 [json_name = "id"];
inline void GetRobotRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotRequest.id)
}
inline std::string* GetRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotRequest.id)
  return _s;
}
inline const std::string& GetRobotRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotRequest.id)
  return id_.Release();
}
inline void GetRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotRequest.id)
}

// -------------------------------------------------------------------

// GetRoverRentalRobotsRequest

// string org_id = 1 [json_name = "orgId"];
inline void GetRoverRentalRobotsRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& GetRoverRentalRobotsRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRoverRentalRobotsRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
}
inline std::string* GetRoverRentalRobotsRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
  return _s;
}
inline const std::string& GetRoverRentalRobotsRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void GetRoverRentalRobotsRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRoverRentalRobotsRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRoverRentalRobotsRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
  return org_id_.Release();
}
inline void GetRoverRentalRobotsRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
}

// -------------------------------------------------------------------

// RoverRentalRobot

// string robot_id = 1 [json_name = "robotId"];
inline void RoverRentalRobot::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.robot_id)
}
inline std::string* RoverRentalRobot::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.robot_id)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void RoverRentalRobot::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.robot_id)
  return robot_id_.Release();
}
inline void RoverRentalRobot::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.robot_id)
}

// string location_id = 2 [json_name = "locationId"];
inline void RoverRentalRobot::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.location_id)
}
inline std::string* RoverRentalRobot::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.location_id)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_location_id() const {
  return location_id_.Get();
}
inline void RoverRentalRobot::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.location_id)
  return location_id_.Release();
}
inline void RoverRentalRobot::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.location_id)
}

// string robot_name = 3 [json_name = "robotName"];
inline void RoverRentalRobot::clear_robot_name() {
  robot_name_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::robot_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.robot_name)
  return _internal_robot_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_robot_name(ArgT0&& arg0, ArgT... args) {
 
 robot_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.robot_name)
}
inline std::string* RoverRentalRobot::mutable_robot_name() {
  std::string* _s = _internal_mutable_robot_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.robot_name)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_robot_name() const {
  return robot_name_.Get();
}
inline void RoverRentalRobot::_internal_set_robot_name(const std::string& value) {
  
  robot_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_robot_name() {
  
  return robot_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_robot_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.robot_name)
  return robot_name_.Release();
}
inline void RoverRentalRobot::set_allocated_robot_name(std::string* robot_name) {
  if (robot_name != nullptr) {
    
  } else {
    
  }
  robot_name_.SetAllocated(robot_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_name_.IsDefault()) {
    robot_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.robot_name)
}

// string robot_main_part_id = 4 [json_name = "robotMainPartId"];
inline void RoverRentalRobot::clear_robot_main_part_id() {
  robot_main_part_id_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::robot_main_part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.robot_main_part_id)
  return _internal_robot_main_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_robot_main_part_id(ArgT0&& arg0, ArgT... args) {
 
 robot_main_part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.robot_main_part_id)
}
inline std::string* RoverRentalRobot::mutable_robot_main_part_id() {
  std::string* _s = _internal_mutable_robot_main_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.robot_main_part_id)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_robot_main_part_id() const {
  return robot_main_part_id_.Get();
}
inline void RoverRentalRobot::_internal_set_robot_main_part_id(const std::string& value) {
  
  robot_main_part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_robot_main_part_id() {
  
  return robot_main_part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_robot_main_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.robot_main_part_id)
  return robot_main_part_id_.Release();
}
inline void RoverRentalRobot::set_allocated_robot_main_part_id(std::string* robot_main_part_id) {
  if (robot_main_part_id != nullptr) {
    
  } else {
    
  }
  robot_main_part_id_.SetAllocated(robot_main_part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_main_part_id_.IsDefault()) {
    robot_main_part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.robot_main_part_id)
}

// -------------------------------------------------------------------

// GetRoverRentalRobotsResponse

// repeated .viam.app.v1.RoverRentalRobot robots = 1 [json_name = "robots"];
inline int GetRoverRentalRobotsResponse::_internal_robots_size() const {
  return robots_.size();
}
inline int GetRoverRentalRobotsResponse::robots_size() const {
  return _internal_robots_size();
}
inline void GetRoverRentalRobotsResponse::clear_robots() {
  robots_.Clear();
}
inline ::viam::app::v1::RoverRentalRobot* GetRoverRentalRobotsResponse::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >*
GetRoverRentalRobotsResponse::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return &robots_;
}
inline const ::viam::app::v1::RoverRentalRobot& GetRoverRentalRobotsResponse::_internal_robots(int index) const {
  return robots_.Get(index);
}
inline const ::viam::app::v1::RoverRentalRobot& GetRoverRentalRobotsResponse::robots(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return _internal_robots(index);
}
inline ::viam::app::v1::RoverRentalRobot* GetRoverRentalRobotsResponse::_internal_add_robots() {
  return robots_.Add();
}
inline ::viam::app::v1::RoverRentalRobot* GetRoverRentalRobotsResponse::add_robots() {
  ::viam::app::v1::RoverRentalRobot* _add = _internal_add_robots();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >&
GetRoverRentalRobotsResponse::robots() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return robots_;
}

// -------------------------------------------------------------------

// GetRobotResponse

// .viam.app.v1.Robot robot = 1 [json_name = "robot"];
inline bool GetRobotResponse::_internal_has_robot() const {
  return this != internal_default_instance() && robot_ != nullptr;
}
inline bool GetRobotResponse::has_robot() const {
  return _internal_has_robot();
}
inline void GetRobotResponse::clear_robot() {
  if (GetArenaForAllocation() == nullptr && robot_ != nullptr) {
    delete robot_;
  }
  robot_ = nullptr;
}
inline const ::viam::app::v1::Robot& GetRobotResponse::_internal_robot() const {
  const ::viam::app::v1::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Robot&>(
      ::viam::app::v1::_Robot_default_instance_);
}
inline const ::viam::app::v1::Robot& GetRobotResponse::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotResponse.robot)
  return _internal_robot();
}
inline void GetRobotResponse::unsafe_arena_set_allocated_robot(
    ::viam::app::v1::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotResponse.robot)
}
inline ::viam::app::v1::Robot* GetRobotResponse::release_robot() {
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Robot* GetRobotResponse::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotResponse.robot)
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Robot* GetRobotResponse::_internal_mutable_robot() {
  
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Robot>(GetArenaForAllocation());
    robot_ = p;
  }
  return robot_;
}
inline ::viam::app::v1::Robot* GetRobotResponse::mutable_robot() {
  ::viam::app::v1::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotResponse.robot)
  return _msg;
}
inline void GetRobotResponse::set_allocated_robot(::viam::app::v1::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    
  } else {
    
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotResponse.robot)
}

// -------------------------------------------------------------------

// GetRobotPartsRequest

// string robot_id = 1 [json_name = "robotId"];
inline void GetRobotPartsRequest::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& GetRobotPartsRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartsRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartsRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartsRequest.robot_id)
}
inline std::string* GetRobotPartsRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartsRequest.robot_id)
  return _s;
}
inline const std::string& GetRobotPartsRequest::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void GetRobotPartsRequest::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartsRequest::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartsRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartsRequest.robot_id)
  return robot_id_.Release();
}
inline void GetRobotPartsRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartsRequest.robot_id)
}

// -------------------------------------------------------------------

// GetRobotPartsResponse

// repeated .viam.app.v1.RobotPart parts = 1 [json_name = "parts"];
inline int GetRobotPartsResponse::_internal_parts_size() const {
  return parts_.size();
}
inline int GetRobotPartsResponse::parts_size() const {
  return _internal_parts_size();
}
inline void GetRobotPartsResponse::clear_parts() {
  parts_.Clear();
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartsResponse.parts)
  return parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >*
GetRobotPartsResponse::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartsResponse.parts)
  return &parts_;
}
inline const ::viam::app::v1::RobotPart& GetRobotPartsResponse::_internal_parts(int index) const {
  return parts_.Get(index);
}
inline const ::viam::app::v1::RobotPart& GetRobotPartsResponse::parts(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartsResponse.parts)
  return _internal_parts(index);
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::_internal_add_parts() {
  return parts_.Add();
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::add_parts() {
  ::viam::app::v1::RobotPart* _add = _internal_add_parts();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartsResponse.parts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >&
GetRobotPartsResponse::parts() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartsResponse.parts)
  return parts_;
}

// -------------------------------------------------------------------

// GetRobotPartRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotPartRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartRequest.id)
}
inline std::string* GetRobotPartRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartRequest.id)
  return _s;
}
inline const std::string& GetRobotPartRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotPartRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartRequest.id)
  return id_.Release();
}
inline void GetRobotPartRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartRequest.id)
}

// -------------------------------------------------------------------

// GetRobotPartResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool GetRobotPartResponse::_internal_has_part() const {
  return this != internal_default_instance() && part_ != nullptr;
}
inline bool GetRobotPartResponse::has_part() const {
  return _internal_has_part();
}
inline void GetRobotPartResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && part_ != nullptr) {
    delete part_;
  }
  part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& GetRobotPartResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& GetRobotPartResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartResponse.part)
  return _internal_part();
}
inline void GetRobotPartResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(part_);
  }
  part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotPartResponse.part)
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartResponse.part)
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::_internal_mutable_part() {
  
  if (part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    part_ = p;
  }
  return part_;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartResponse.part)
  return _msg;
}
inline void GetRobotPartResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartResponse.part)
}

// string config_json = 2 [json_name = "configJson"];
inline void GetRobotPartResponse::clear_config_json() {
  config_json_.ClearToEmpty();
}
inline const std::string& GetRobotPartResponse::config_json() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartResponse.config_json)
  return _internal_config_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartResponse::set_config_json(ArgT0&& arg0, ArgT... args) {
 
 config_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartResponse.config_json)
}
inline std::string* GetRobotPartResponse::mutable_config_json() {
  std::string* _s = _internal_mutable_config_json();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartResponse.config_json)
  return _s;
}
inline const std::string& GetRobotPartResponse::_internal_config_json() const {
  return config_json_.Get();
}
inline void GetRobotPartResponse::_internal_set_config_json(const std::string& value) {
  
  config_json_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartResponse::_internal_mutable_config_json() {
  
  return config_json_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartResponse::release_config_json() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartResponse.config_json)
  return config_json_.Release();
}
inline void GetRobotPartResponse::set_allocated_config_json(std::string* config_json) {
  if (config_json != nullptr) {
    
  } else {
    
  }
  config_json_.SetAllocated(config_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_json_.IsDefault()) {
    config_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartResponse.config_json)
}

// -------------------------------------------------------------------

// GetRobotPartByNameAndLocationRequest

// string name = 1 [json_name = "name"];
inline void GetRobotPartByNameAndLocationRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetRobotPartByNameAndLocationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartByNameAndLocationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartByNameAndLocationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartByNameAndLocationRequest.name)
}
inline std::string* GetRobotPartByNameAndLocationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartByNameAndLocationRequest.name)
  return _s;
}
inline const std::string& GetRobotPartByNameAndLocationRequest::_internal_name() const {
  return name_.Get();
}
inline void GetRobotPartByNameAndLocationRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartByNameAndLocationRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartByNameAndLocationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartByNameAndLocationRequest.name)
  return name_.Release();
}
inline void GetRobotPartByNameAndLocationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartByNameAndLocationRequest.name)
}

// string location_id = 2 [json_name = "locationId"];
inline void GetRobotPartByNameAndLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& GetRobotPartByNameAndLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartByNameAndLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartByNameAndLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartByNameAndLocationRequest.location_id)
}
inline std::string* GetRobotPartByNameAndLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartByNameAndLocationRequest.location_id)
  return _s;
}
inline const std::string& GetRobotPartByNameAndLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void GetRobotPartByNameAndLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartByNameAndLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartByNameAndLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartByNameAndLocationRequest.location_id)
  return location_id_.Release();
}
inline void GetRobotPartByNameAndLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartByNameAndLocationRequest.location_id)
}

// -------------------------------------------------------------------

// GetRobotPartByNameAndLocationResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool GetRobotPartByNameAndLocationResponse::_internal_has_part() const {
  return this != internal_default_instance() && part_ != nullptr;
}
inline bool GetRobotPartByNameAndLocationResponse::has_part() const {
  return _internal_has_part();
}
inline void GetRobotPartByNameAndLocationResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && part_ != nullptr) {
    delete part_;
  }
  part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& GetRobotPartByNameAndLocationResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& GetRobotPartByNameAndLocationResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartByNameAndLocationResponse.part)
  return _internal_part();
}
inline void GetRobotPartByNameAndLocationResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(part_);
  }
  part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotPartByNameAndLocationResponse.part)
}
inline ::viam::app::v1::RobotPart* GetRobotPartByNameAndLocationResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartByNameAndLocationResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartByNameAndLocationResponse.part)
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartByNameAndLocationResponse::_internal_mutable_part() {
  
  if (part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    part_ = p;
  }
  return part_;
}
inline ::viam::app::v1::RobotPart* GetRobotPartByNameAndLocationResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartByNameAndLocationResponse.part)
  return _msg;
}
inline void GetRobotPartByNameAndLocationResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartByNameAndLocationResponse.part)
}

// -------------------------------------------------------------------

// GetRobotPartLogsRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartLogsRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotPartLogsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.id)
}
inline std::string* GetRobotPartLogsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.id)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.id)
  return id_.Release();
}
inline void GetRobotPartLogsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.id)
}

// bool errors_only = 2 [json_name = "errorsOnly", deprecated = true];
inline void GetRobotPartLogsRequest::clear_errors_only() {
  errors_only_ = false;
}
inline bool GetRobotPartLogsRequest::_internal_errors_only() const {
  return errors_only_;
}
inline bool GetRobotPartLogsRequest::errors_only() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.errors_only)
  return _internal_errors_only();
}
inline void GetRobotPartLogsRequest::_internal_set_errors_only(bool value) {
  
  errors_only_ = value;
}
inline void GetRobotPartLogsRequest::set_errors_only(bool value) {
  _internal_set_errors_only(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.errors_only)
}

// optional string filter = 3 [json_name = "filter"];
inline bool GetRobotPartLogsRequest::_internal_has_filter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetRobotPartLogsRequest::has_filter() const {
  return _internal_has_filter();
}
inline void GetRobotPartLogsRequest::clear_filter() {
  filter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetRobotPartLogsRequest::filter() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.filter)
}
inline std::string* GetRobotPartLogsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.filter)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_filter() const {
  return filter_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  return filter_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.filter)
  if (!_internal_has_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetRobotPartLogsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.filter)
}

// optional string page_token = 4 [json_name = "pageToken"];
inline bool GetRobotPartLogsRequest::_internal_has_page_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetRobotPartLogsRequest::has_page_token() const {
  return _internal_has_page_token();
}
inline void GetRobotPartLogsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetRobotPartLogsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.page_token)
}
inline std::string* GetRobotPartLogsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.page_token)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_page_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_page_token() {
  _has_bits_[0] |= 0x00000002u;
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.page_token)
  if (!_internal_has_page_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetRobotPartLogsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.page_token)
}

// repeated string levels = 5 [json_name = "levels"];
inline int GetRobotPartLogsRequest::_internal_levels_size() const {
  return levels_.size();
}
inline int GetRobotPartLogsRequest::levels_size() const {
  return _internal_levels_size();
}
inline void GetRobotPartLogsRequest::clear_levels() {
  levels_.Clear();
}
inline std::string* GetRobotPartLogsRequest::add_levels() {
  std::string* _s = _internal_add_levels();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.GetRobotPartLogsRequest.levels)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_levels(int index) const {
  return levels_.Get(index);
}
inline const std::string& GetRobotPartLogsRequest::levels(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.levels)
  return _internal_levels(index);
}
inline std::string* GetRobotPartLogsRequest::mutable_levels(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.levels)
  return levels_.Mutable(index);
}
inline void GetRobotPartLogsRequest::set_levels(int index, const std::string& value) {
  levels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::set_levels(int index, std::string&& value) {
  levels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::set_levels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  levels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::set_levels(int index, const char* value, size_t size) {
  levels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline std::string* GetRobotPartLogsRequest::_internal_add_levels() {
  return levels_.Add();
}
inline void GetRobotPartLogsRequest::add_levels(const std::string& value) {
  levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::add_levels(std::string&& value) {
  levels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::add_levels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::add_levels(const char* value, size_t size) {
  levels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetRobotPartLogsRequest::levels() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartLogsRequest.levels)
  return levels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetRobotPartLogsRequest::mutable_levels() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartLogsRequest.levels)
  return &levels_;
}

// optional .google.protobuf.Timestamp start = 6 [json_name = "start"];
inline bool GetRobotPartLogsRequest::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || start_ != nullptr);
  return value;
}
inline bool GetRobotPartLogsRequest::has_start() const {
  return _internal_has_start();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetRobotPartLogsRequest::_internal_start() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetRobotPartLogsRequest::start() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.start)
  return _internal_start();
}
inline void GetRobotPartLogsRequest::unsafe_arena_set_allocated_start(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotPartLogsRequest.start)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::release_start() {
  _has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.start)
  _has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::_internal_mutable_start() {
  _has_bits_[0] |= 0x00000008u;
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::mutable_start() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.start)
  return _msg;
}
inline void GetRobotPartLogsRequest::set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.start)
}

// optional .google.protobuf.Timestamp end = 7 [json_name = "end"];
inline bool GetRobotPartLogsRequest::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || end_ != nullptr);
  return value;
}
inline bool GetRobotPartLogsRequest::has_end() const {
  return _internal_has_end();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetRobotPartLogsRequest::_internal_end() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetRobotPartLogsRequest::end() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.end)
  return _internal_end();
}
inline void GetRobotPartLogsRequest::unsafe_arena_set_allocated_end(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotPartLogsRequest.end)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::release_end() {
  _has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.end)
  _has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::_internal_mutable_end() {
  _has_bits_[0] |= 0x00000010u;
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetRobotPartLogsRequest::mutable_end() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.end)
  return _msg;
}
inline void GetRobotPartLogsRequest::set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.end)
}

// optional int64 limit = 8 [json_name = "limit"];
inline bool GetRobotPartLogsRequest::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetRobotPartLogsRequest::has_limit() const {
  return _internal_has_limit();
}
inline void GetRobotPartLogsRequest::clear_limit() {
  limit_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t GetRobotPartLogsRequest::_internal_limit() const {
  return limit_;
}
inline int64_t GetRobotPartLogsRequest::limit() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.limit)
  return _internal_limit();
}
inline void GetRobotPartLogsRequest::_internal_set_limit(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  limit_ = value;
}
inline void GetRobotPartLogsRequest::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.limit)
}

// optional string source = 9 [json_name = "source"];
inline bool GetRobotPartLogsRequest::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetRobotPartLogsRequest::has_source() const {
  return _internal_has_source();
}
inline void GetRobotPartLogsRequest::clear_source() {
  source_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetRobotPartLogsRequest::source() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_source(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.source)
}
inline std::string* GetRobotPartLogsRequest::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.source)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_source() const {
  return source_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_source(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  source_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_source() {
  _has_bits_[0] |= 0x00000004u;
  return source_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_source() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.source)
  if (!_internal_has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_.IsDefault()) {
    source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetRobotPartLogsRequest::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_.IsDefault()) {
    source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.source)
}

// optional bool user_facing_only = 10 [json_name = "userFacingOnly"];
inline bool GetRobotPartLogsRequest::_internal_has_user_facing_only() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GetRobotPartLogsRequest::has_user_facing_only() const {
  return _internal_has_user_facing_only();
}
inline void GetRobotPartLogsRequest::clear_user_facing_only() {
  user_facing_only_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool GetRobotPartLogsRequest::_internal_user_facing_only() const {
  return user_facing_only_;
}
inline bool GetRobotPartLogsRequest::user_facing_only() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.user_facing_only)
  return _internal_user_facing_only();
}
inline void GetRobotPartLogsRequest::_internal_set_user_facing_only(bool value) {
  _has_bits_[0] |= 0x00000040u;
  user_facing_only_ = value;
}
inline void GetRobotPartLogsRequest::set_user_facing_only(bool value) {
  _internal_set_user_facing_only(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.user_facing_only)
}

// -------------------------------------------------------------------

// GetRobotPartLogsResponse

// repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
inline int GetRobotPartLogsResponse::_internal_logs_size() const {
  return logs_.size();
}
inline int GetRobotPartLogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline ::viam::common::v1::LogEntry* GetRobotPartLogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsResponse.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
GetRobotPartLogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartLogsResponse.logs)
  return &logs_;
}
inline const ::viam::common::v1::LogEntry& GetRobotPartLogsResponse::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::viam::common::v1::LogEntry& GetRobotPartLogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _internal_logs(index);
}
inline ::viam::common::v1::LogEntry* GetRobotPartLogsResponse::_internal_add_logs() {
  return logs_.Add();
}
inline ::viam::common::v1::LogEntry* GetRobotPartLogsResponse::add_logs() {
  ::viam::common::v1::LogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
GetRobotPartLogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartLogsResponse.logs)
  return logs_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void GetRobotPartLogsResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& GetRobotPartLogsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
}
inline std::string* GetRobotPartLogsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
  return _s;
}
inline const std::string& GetRobotPartLogsResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void GetRobotPartLogsResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
  return next_page_token_.Release();
}
inline void GetRobotPartLogsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
}

// -------------------------------------------------------------------

// TailRobotPartLogsRequest

// string id = 1 [json_name = "id"];
inline void TailRobotPartLogsRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TailRobotPartLogsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TailRobotPartLogsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.id)
}
inline std::string* TailRobotPartLogsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsRequest.id)
  return _s;
}
inline const std::string& TailRobotPartLogsRequest::_internal_id() const {
  return id_.Get();
}
inline void TailRobotPartLogsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TailRobotPartLogsRequest.id)
  return id_.Release();
}
inline void TailRobotPartLogsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TailRobotPartLogsRequest.id)
}

// bool errors_only = 2 [json_name = "errorsOnly"];
inline void TailRobotPartLogsRequest::clear_errors_only() {
  errors_only_ = false;
}
inline bool TailRobotPartLogsRequest::_internal_errors_only() const {
  return errors_only_;
}
inline bool TailRobotPartLogsRequest::errors_only() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.errors_only)
  return _internal_errors_only();
}
inline void TailRobotPartLogsRequest::_internal_set_errors_only(bool value) {
  
  errors_only_ = value;
}
inline void TailRobotPartLogsRequest::set_errors_only(bool value) {
  _internal_set_errors_only(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.errors_only)
}

// optional string filter = 3 [json_name = "filter"];
inline bool TailRobotPartLogsRequest::_internal_has_filter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TailRobotPartLogsRequest::has_filter() const {
  return _internal_has_filter();
}
inline void TailRobotPartLogsRequest::clear_filter() {
  filter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TailRobotPartLogsRequest::filter() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TailRobotPartLogsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.filter)
}
inline std::string* TailRobotPartLogsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsRequest.filter)
  return _s;
}
inline const std::string& TailRobotPartLogsRequest::_internal_filter() const {
  return filter_.Get();
}
inline void TailRobotPartLogsRequest::_internal_set_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_.Set(value, GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::_internal_mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  return filter_.Mutable(GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TailRobotPartLogsRequest.filter)
  if (!_internal_has_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TailRobotPartLogsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TailRobotPartLogsRequest.filter)
}

// -------------------------------------------------------------------

// TailRobotPartLogsResponse

// repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
inline int TailRobotPartLogsResponse::_internal_logs_size() const {
  return logs_.size();
}
inline int TailRobotPartLogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline ::viam::common::v1::LogEntry* TailRobotPartLogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsResponse.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
TailRobotPartLogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.TailRobotPartLogsResponse.logs)
  return &logs_;
}
inline const ::viam::common::v1::LogEntry& TailRobotPartLogsResponse::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::viam::common::v1::LogEntry& TailRobotPartLogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _internal_logs(index);
}
inline ::viam::common::v1::LogEntry* TailRobotPartLogsResponse::_internal_add_logs() {
  return logs_.Add();
}
inline ::viam::common::v1::LogEntry* TailRobotPartLogsResponse::add_logs() {
  ::viam::common::v1::LogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
TailRobotPartLogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.TailRobotPartLogsResponse.logs)
  return logs_;
}

// -------------------------------------------------------------------

// GetRobotPartHistoryRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartHistoryRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotPartHistoryRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartHistoryRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartHistoryRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartHistoryRequest.id)
}
inline std::string* GetRobotPartHistoryRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartHistoryRequest.id)
  return _s;
}
inline const std::string& GetRobotPartHistoryRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotPartHistoryRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartHistoryRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartHistoryRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartHistoryRequest.id)
  return id_.Release();
}
inline void GetRobotPartHistoryRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartHistoryRequest.id)
}

// -------------------------------------------------------------------

// GetRobotPartHistoryResponse

// repeated .viam.app.v1.RobotPartHistoryEntry history = 1 [json_name = "history"];
inline int GetRobotPartHistoryResponse::_internal_history_size() const {
  return history_.size();
}
inline int GetRobotPartHistoryResponse::history_size() const {
  return _internal_history_size();
}
inline void GetRobotPartHistoryResponse::clear_history() {
  history_.Clear();
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartHistoryResponse.history)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >*
GetRobotPartHistoryResponse::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartHistoryResponse.history)
  return &history_;
}
inline const ::viam::app::v1::RobotPartHistoryEntry& GetRobotPartHistoryResponse::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::viam::app::v1::RobotPartHistoryEntry& GetRobotPartHistoryResponse::history(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _internal_history(index);
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::_internal_add_history() {
  return history_.Add();
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::add_history() {
  ::viam::app::v1::RobotPartHistoryEntry* _add = _internal_add_history();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >&
GetRobotPartHistoryResponse::history() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartHistoryResponse.history)
  return history_;
}

// -------------------------------------------------------------------

// UpdateRobotPartRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotPartRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateRobotPartRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotPartRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotPartRequest.id)
}
inline std::string* UpdateRobotPartRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.id)
  return _s;
}
inline const std::string& UpdateRobotPartRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateRobotPartRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.id)
  return id_.Release();
}
inline void UpdateRobotPartRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateRobotPartRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateRobotPartRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotPartRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotPartRequest.name)
}
inline std::string* UpdateRobotPartRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.name)
  return _s;
}
inline const std::string& UpdateRobotPartRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateRobotPartRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.name)
  return name_.Release();
}
inline void UpdateRobotPartRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.name)
}

// .google.protobuf.Struct robot_config = 3 [json_name = "robotConfig"];
inline bool UpdateRobotPartRequest::_internal_has_robot_config() const {
  return this != internal_default_instance() && robot_config_ != nullptr;
}
inline bool UpdateRobotPartRequest::has_robot_config() const {
  return _internal_has_robot_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartRequest::_internal_robot_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = robot_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartRequest::robot_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.robot_config)
  return _internal_robot_config();
}
inline void UpdateRobotPartRequest::unsafe_arena_set_allocated_robot_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  robot_config_ = robot_config;
  if (robot_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartRequest.robot_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::release_robot_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::unsafe_arena_release_robot_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.robot_config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::_internal_mutable_robot_config() {
  
  if (robot_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    robot_config_ = p;
  }
  return robot_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::mutable_robot_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_robot_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.robot_config)
  return _msg;
}
inline void UpdateRobotPartRequest::set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  if (robot_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config));
    if (message_arena != submessage_arena) {
      robot_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_config, submessage_arena);
    }
    
  } else {
    
  }
  robot_config_ = robot_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.robot_config)
}

// optional .google.protobuf.Timestamp last_known_update = 4 [json_name = "lastKnownUpdate"];
inline bool UpdateRobotPartRequest::_internal_has_last_known_update() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || last_known_update_ != nullptr);
  return value;
}
inline bool UpdateRobotPartRequest::has_last_known_update() const {
  return _internal_has_last_known_update();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateRobotPartRequest::_internal_last_known_update() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_known_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateRobotPartRequest::last_known_update() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.last_known_update)
  return _internal_last_known_update();
}
inline void UpdateRobotPartRequest::unsafe_arena_set_allocated_last_known_update(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_known_update_);
  }
  last_known_update_ = last_known_update;
  if (last_known_update) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartRequest.last_known_update)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateRobotPartRequest::release_last_known_update() {
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_known_update_;
  last_known_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateRobotPartRequest::unsafe_arena_release_last_known_update() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.last_known_update)
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_known_update_;
  last_known_update_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateRobotPartRequest::_internal_mutable_last_known_update() {
  _has_bits_[0] |= 0x00000001u;
  if (last_known_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_known_update_ = p;
  }
  return last_known_update_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateRobotPartRequest::mutable_last_known_update() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_known_update();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.last_known_update)
  return _msg;
}
inline void UpdateRobotPartRequest::set_allocated_last_known_update(::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_known_update_);
  }
  if (last_known_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_known_update));
    if (message_arena != submessage_arena) {
      last_known_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_known_update, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_known_update_ = last_known_update;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.last_known_update)
}

// -------------------------------------------------------------------

// UpdateRobotPartResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool UpdateRobotPartResponse::_internal_has_part() const {
  return this != internal_default_instance() && part_ != nullptr;
}
inline bool UpdateRobotPartResponse::has_part() const {
  return _internal_has_part();
}
inline void UpdateRobotPartResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && part_ != nullptr) {
    delete part_;
  }
  part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& UpdateRobotPartResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& UpdateRobotPartResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartResponse.part)
  return _internal_part();
}
inline void UpdateRobotPartResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(part_);
  }
  part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartResponse.part)
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartResponse.part)
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::_internal_mutable_part() {
  
  if (part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    part_ = p;
  }
  return part_;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartResponse.part)
  return _msg;
}
inline void UpdateRobotPartResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartResponse.part)
}

// -------------------------------------------------------------------

// NewRobotPartRequest

// string robot_id = 1 [json_name = "robotId"];
inline void NewRobotPartRequest::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& NewRobotPartRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartRequest.robot_id)
}
inline std::string* NewRobotPartRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartRequest.robot_id)
  return _s;
}
inline const std::string& NewRobotPartRequest::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void NewRobotPartRequest::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartRequest.robot_id)
  return robot_id_.Release();
}
inline void NewRobotPartRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartRequest.robot_id)
}

// string part_name = 2 [json_name = "partName"];
inline void NewRobotPartRequest::clear_part_name() {
  part_name_.ClearToEmpty();
}
inline const std::string& NewRobotPartRequest::part_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartRequest.part_name)
  return _internal_part_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartRequest::set_part_name(ArgT0&& arg0, ArgT... args) {
 
 part_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartRequest.part_name)
}
inline std::string* NewRobotPartRequest::mutable_part_name() {
  std::string* _s = _internal_mutable_part_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartRequest.part_name)
  return _s;
}
inline const std::string& NewRobotPartRequest::_internal_part_name() const {
  return part_name_.Get();
}
inline void NewRobotPartRequest::_internal_set_part_name(const std::string& value) {
  
  part_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::_internal_mutable_part_name() {
  
  return part_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::release_part_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartRequest.part_name)
  return part_name_.Release();
}
inline void NewRobotPartRequest::set_allocated_part_name(std::string* part_name) {
  if (part_name != nullptr) {
    
  } else {
    
  }
  part_name_.SetAllocated(part_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_name_.IsDefault()) {
    part_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartRequest.part_name)
}

// -------------------------------------------------------------------

// NewRobotPartResponse

// string part_id = 1 [json_name = "partId"];
inline void NewRobotPartResponse::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& NewRobotPartResponse::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartResponse.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartResponse::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartResponse.part_id)
}
inline std::string* NewRobotPartResponse::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartResponse.part_id)
  return _s;
}
inline const std::string& NewRobotPartResponse::_internal_part_id() const {
  return part_id_.Get();
}
inline void NewRobotPartResponse::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartResponse::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartResponse::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartResponse.part_id)
  return part_id_.Release();
}
inline void NewRobotPartResponse::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartResponse.part_id)
}

// -------------------------------------------------------------------

// DeleteRobotPartRequest

// string part_id = 1 [json_name = "partId"];
inline void DeleteRobotPartRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartRequest.part_id)
}
inline std::string* DeleteRobotPartRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartRequest.part_id)
  return _s;
}
inline const std::string& DeleteRobotPartRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void DeleteRobotPartRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartRequest.part_id)
  return part_id_.Release();
}
inline void DeleteRobotPartRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartRequest.part_id)
}

// -------------------------------------------------------------------

// GetRobotPartMetadataRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartMetadataRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotPartMetadataRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartMetadataRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartMetadataRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartMetadataRequest.id)
}
inline std::string* GetRobotPartMetadataRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartMetadataRequest.id)
  return _s;
}
inline const std::string& GetRobotPartMetadataRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotPartMetadataRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartMetadataRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartMetadataRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartMetadataRequest.id)
  return id_.Release();
}
inline void GetRobotPartMetadataRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartMetadataRequest.id)
}

// -------------------------------------------------------------------

// GetRobotPartMetadataResponse

// .google.protobuf.Struct data = 1 [json_name = "data"];
inline bool GetRobotPartMetadataResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool GetRobotPartMetadataResponse::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetRobotPartMetadataResponse::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetRobotPartMetadataResponse::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartMetadataResponse.data)
  return _internal_data();
}
inline void GetRobotPartMetadataResponse::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotPartMetadataResponse.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotPartMetadataResponse::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotPartMetadataResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartMetadataResponse.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotPartMetadataResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotPartMetadataResponse::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartMetadataResponse.data)
  return _msg;
}
inline void GetRobotPartMetadataResponse::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartMetadataResponse.data)
}

// -------------------------------------------------------------------

// UpdateRobotPartMetadataRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotPartMetadataRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateRobotPartMetadataRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartMetadataRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotPartMetadataRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotPartMetadataRequest.id)
}
inline std::string* UpdateRobotPartMetadataRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartMetadataRequest.id)
  return _s;
}
inline const std::string& UpdateRobotPartMetadataRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateRobotPartMetadataRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotPartMetadataRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotPartMetadataRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartMetadataRequest.id)
  return id_.Release();
}
inline void UpdateRobotPartMetadataRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartMetadataRequest.id)
}

// .google.protobuf.Struct data = 2 [json_name = "data"];
inline bool UpdateRobotPartMetadataRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool UpdateRobotPartMetadataRequest::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartMetadataRequest::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartMetadataRequest::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartMetadataRequest.data)
  return _internal_data();
}
inline void UpdateRobotPartMetadataRequest::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartMetadataRequest.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartMetadataRequest::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartMetadataRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartMetadataRequest.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartMetadataRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartMetadataRequest::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartMetadataRequest.data)
  return _msg;
}
inline void UpdateRobotPartMetadataRequest::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartMetadataRequest.data)
}

// -------------------------------------------------------------------

// UpdateRobotPartMetadataResponse

// -------------------------------------------------------------------

// GetRobotAPIKeysRequest

// string robot_id = 1 [json_name = "robotId"];
inline void GetRobotAPIKeysRequest::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& GetRobotAPIKeysRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotAPIKeysRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
}
inline std::string* GetRobotAPIKeysRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
  return _s;
}
inline const std::string& GetRobotAPIKeysRequest::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void GetRobotAPIKeysRequest::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotAPIKeysRequest::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotAPIKeysRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
  return robot_id_.Release();
}
inline void GetRobotAPIKeysRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
}

// -------------------------------------------------------------------

// APIKey

// string id = 1 [json_name = "id"];
inline void APIKey::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& APIKey::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKey::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.APIKey.id)
}
inline std::string* APIKey::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.id)
  return _s;
}
inline const std::string& APIKey::_internal_id() const {
  return id_.Get();
}
inline void APIKey::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKey::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKey::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.id)
  return id_.Release();
}
inline void APIKey::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.id)
}

// string key = 2 [json_name = "key"];
inline void APIKey::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& APIKey::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKey::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.APIKey.key)
}
inline std::string* APIKey::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.key)
  return _s;
}
inline const std::string& APIKey::_internal_key() const {
  return key_.Get();
}
inline void APIKey::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKey::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKey::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.key)
  return key_.Release();
}
inline void APIKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.key)
}

// string name = 3 [json_name = "name"];
inline void APIKey::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& APIKey::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKey::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.APIKey.name)
}
inline std::string* APIKey::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.name)
  return _s;
}
inline const std::string& APIKey::_internal_name() const {
  return name_.Get();
}
inline void APIKey::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKey::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKey::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.name)
  return name_.Release();
}
inline void APIKey::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.name)
}

// .google.protobuf.Timestamp created_on = 4 [json_name = "createdOn"];
inline bool APIKey::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool APIKey::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& APIKey::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& APIKey::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.created_on)
  return _internal_created_on();
}
inline void APIKey::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.APIKey.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.created_on)
  return _msg;
}
inline void APIKey::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.created_on)
}

// -------------------------------------------------------------------

// GetRobotAPIKeysResponse

// repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
inline int GetRobotAPIKeysResponse::_internal_api_keys_size() const {
  return api_keys_.size();
}
inline int GetRobotAPIKeysResponse::api_keys_size() const {
  return _internal_api_keys_size();
}
inline void GetRobotAPIKeysResponse::clear_api_keys() {
  api_keys_.Clear();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* GetRobotAPIKeysResponse::mutable_api_keys(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return api_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
GetRobotAPIKeysResponse::mutable_api_keys() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return &api_keys_;
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& GetRobotAPIKeysResponse::_internal_api_keys(int index) const {
  return api_keys_.Get(index);
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& GetRobotAPIKeysResponse::api_keys(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return _internal_api_keys(index);
}
inline ::viam::app::v1::APIKeyWithAuthorizations* GetRobotAPIKeysResponse::_internal_add_api_keys() {
  return api_keys_.Add();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* GetRobotAPIKeysResponse::add_api_keys() {
  ::viam::app::v1::APIKeyWithAuthorizations* _add = _internal_add_api_keys();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
GetRobotAPIKeysResponse::api_keys() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return api_keys_;
}

// -------------------------------------------------------------------

// DeleteRobotPartResponse

// -------------------------------------------------------------------

// Fragment

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void Fragment::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Fragment::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.id)
}
inline std::string* Fragment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.id)
  return _s;
}
inline const std::string& Fragment::_internal_id() const {
  return id_.Get();
}
inline void Fragment::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.id)
  return id_.Release();
}
inline void Fragment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void Fragment::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Fragment::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.name)
}
inline std::string* Fragment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.name)
  return _s;
}
inline const std::string& Fragment::_internal_name() const {
  return name_.Get();
}
inline void Fragment::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.name)
  return name_.Release();
}
inline void Fragment::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.name)
}

// .google.protobuf.Struct fragment = 3 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
inline bool Fragment::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool Fragment::has_fragment() const {
  return _internal_has_fragment();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Fragment::_internal_fragment() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Fragment::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.fragment)
  return _internal_fragment();
}
inline void Fragment::unsafe_arena_set_allocated_fragment(
    ::PROTOBUF_NAMESPACE_ID::Struct* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Fragment.fragment)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::release_fragment() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.fragment)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::mutable_fragment() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.fragment)
  return _msg;
}
inline void Fragment::set_allocated_fragment(::PROTOBUF_NAMESPACE_ID::Struct* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment));
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.fragment)
}

// string organization_owner = 4 [json_name = "organizationOwner", (.tagger.v1.tags) = "bson:\"organization_owner\" json:\"owner\""];
inline void Fragment::clear_organization_owner() {
  organization_owner_.ClearToEmpty();
}
inline const std::string& Fragment::organization_owner() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.organization_owner)
  return _internal_organization_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_organization_owner(ArgT0&& arg0, ArgT... args) {
 
 organization_owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.organization_owner)
}
inline std::string* Fragment::mutable_organization_owner() {
  std::string* _s = _internal_mutable_organization_owner();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.organization_owner)
  return _s;
}
inline const std::string& Fragment::_internal_organization_owner() const {
  return organization_owner_.Get();
}
inline void Fragment::_internal_set_organization_owner(const std::string& value) {
  
  organization_owner_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_organization_owner() {
  
  return organization_owner_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_organization_owner() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.organization_owner)
  return organization_owner_.Release();
}
inline void Fragment::set_allocated_organization_owner(std::string* organization_owner) {
  if (organization_owner != nullptr) {
    
  } else {
    
  }
  organization_owner_.SetAllocated(organization_owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_owner_.IsDefault()) {
    organization_owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.organization_owner)
}

// bool public = 5 [json_name = "public", (.tagger.v1.tags) = "bson:\"public\" json:\"public\""];
inline void Fragment::clear_public_() {
  public__ = false;
}
inline bool Fragment::_internal_public_() const {
  return public__;
}
inline bool Fragment::public_() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.public)
  return _internal_public_();
}
inline void Fragment::_internal_set_public_(bool value) {
  
  public__ = value;
}
inline void Fragment::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.public)
}

// .google.protobuf.Timestamp created_on = 6 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool Fragment::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Fragment::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.created_on)
  return _internal_created_on();
}
inline void Fragment::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Fragment.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.created_on)
  return _msg;
}
inline void Fragment::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.created_on)
}

// string organization_name = 7 [json_name = "organizationName"];
inline void Fragment::clear_organization_name() {
  organization_name_.ClearToEmpty();
}
inline const std::string& Fragment::organization_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.organization_name)
  return _internal_organization_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_organization_name(ArgT0&& arg0, ArgT... args) {
 
 organization_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.organization_name)
}
inline std::string* Fragment::mutable_organization_name() {
  std::string* _s = _internal_mutable_organization_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.organization_name)
  return _s;
}
inline const std::string& Fragment::_internal_organization_name() const {
  return organization_name_.Get();
}
inline void Fragment::_internal_set_organization_name(const std::string& value) {
  
  organization_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_organization_name() {
  
  return organization_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_organization_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.organization_name)
  return organization_name_.Release();
}
inline void Fragment::set_allocated_organization_name(std::string* organization_name) {
  if (organization_name != nullptr) {
    
  } else {
    
  }
  organization_name_.SetAllocated(organization_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_name_.IsDefault()) {
    organization_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.organization_name)
}

// int32 robot_part_count = 9 [json_name = "robotPartCount"];
inline void Fragment::clear_robot_part_count() {
  robot_part_count_ = 0;
}
inline int32_t Fragment::_internal_robot_part_count() const {
  return robot_part_count_;
}
inline int32_t Fragment::robot_part_count() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.robot_part_count)
  return _internal_robot_part_count();
}
inline void Fragment::_internal_set_robot_part_count(int32_t value) {
  
  robot_part_count_ = value;
}
inline void Fragment::set_robot_part_count(int32_t value) {
  _internal_set_robot_part_count(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.robot_part_count)
}

// int32 organization_count = 10 [json_name = "organizationCount"];
inline void Fragment::clear_organization_count() {
  organization_count_ = 0;
}
inline int32_t Fragment::_internal_organization_count() const {
  return organization_count_;
}
inline int32_t Fragment::organization_count() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.organization_count)
  return _internal_organization_count();
}
inline void Fragment::_internal_set_organization_count(int32_t value) {
  
  organization_count_ = value;
}
inline void Fragment::set_organization_count(int32_t value) {
  _internal_set_organization_count(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.organization_count)
}

// bool only_used_by_owner = 11 [json_name = "onlyUsedByOwner"];
inline void Fragment::clear_only_used_by_owner() {
  only_used_by_owner_ = false;
}
inline bool Fragment::_internal_only_used_by_owner() const {
  return only_used_by_owner_;
}
inline bool Fragment::only_used_by_owner() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.only_used_by_owner)
  return _internal_only_used_by_owner();
}
inline void Fragment::_internal_set_only_used_by_owner(bool value) {
  
  only_used_by_owner_ = value;
}
inline void Fragment::set_only_used_by_owner(bool value) {
  _internal_set_only_used_by_owner(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.only_used_by_owner)
}

// .viam.app.v1.FragmentVisibility visibility = 12 [json_name = "visibility"];
inline void Fragment::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::FragmentVisibility Fragment::_internal_visibility() const {
  return static_cast< ::viam::app::v1::FragmentVisibility >(visibility_);
}
inline ::viam::app::v1::FragmentVisibility Fragment::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.visibility)
  return _internal_visibility();
}
inline void Fragment::_internal_set_visibility(::viam::app::v1::FragmentVisibility value) {
  
  visibility_ = value;
}
inline void Fragment::set_visibility(::viam::app::v1::FragmentVisibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.visibility)
}

// .google.protobuf.Timestamp last_updated = 13 [json_name = "lastUpdated", (.tagger.v1.tags) = "bson:\"last_updated_at\""];
inline bool Fragment::_internal_has_last_updated() const {
  return this != internal_default_instance() && last_updated_ != nullptr;
}
inline bool Fragment::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::last_updated() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.last_updated)
  return _internal_last_updated();
}
inline void Fragment::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Fragment.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::_internal_mutable_last_updated() {
  
  if (last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_updated_ = p;
  }
  return last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.last_updated)
  return _msg;
}
inline void Fragment::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.last_updated)
}

// string revision = 14 [json_name = "revision"];
inline void Fragment::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& Fragment::revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.revision)
}
inline std::string* Fragment::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.revision)
  return _s;
}
inline const std::string& Fragment::_internal_revision() const {
  return revision_.Get();
}
inline void Fragment::_internal_set_revision(const std::string& value) {
  
  revision_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_revision() {
  
  return revision_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.revision)
  return revision_.Release();
}
inline void Fragment::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault()) {
    revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.revision)
}

// -------------------------------------------------------------------

// FragmentHistoryEntry

// string fragment = 1 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
inline void FragmentHistoryEntry::clear_fragment() {
  fragment_.ClearToEmpty();
}
inline const std::string& FragmentHistoryEntry::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentHistoryEntry.fragment)
  return _internal_fragment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentHistoryEntry::set_fragment(ArgT0&& arg0, ArgT... args) {
 
 fragment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentHistoryEntry.fragment)
}
inline std::string* FragmentHistoryEntry::mutable_fragment() {
  std::string* _s = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentHistoryEntry.fragment)
  return _s;
}
inline const std::string& FragmentHistoryEntry::_internal_fragment() const {
  return fragment_.Get();
}
inline void FragmentHistoryEntry::_internal_set_fragment(const std::string& value) {
  
  fragment_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentHistoryEntry::_internal_mutable_fragment() {
  
  return fragment_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentHistoryEntry::release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentHistoryEntry.fragment)
  return fragment_.Release();
}
inline void FragmentHistoryEntry::set_allocated_fragment(std::string* fragment) {
  if (fragment != nullptr) {
    
  } else {
    
  }
  fragment_.SetAllocated(fragment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_.IsDefault()) {
    fragment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentHistoryEntry.fragment)
}

// .google.protobuf.Timestamp edited_on = 2 [json_name = "editedOn", (.tagger.v1.tags) = "bson:\"edited_on\" json:\"edited_on\""];
inline bool FragmentHistoryEntry::_internal_has_edited_on() const {
  return this != internal_default_instance() && edited_on_ != nullptr;
}
inline bool FragmentHistoryEntry::has_edited_on() const {
  return _internal_has_edited_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FragmentHistoryEntry::_internal_edited_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = edited_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FragmentHistoryEntry::edited_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentHistoryEntry.edited_on)
  return _internal_edited_on();
}
inline void FragmentHistoryEntry::unsafe_arena_set_allocated_edited_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* edited_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edited_on_);
  }
  edited_on_ = edited_on;
  if (edited_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.FragmentHistoryEntry.edited_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentHistoryEntry::release_edited_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = edited_on_;
  edited_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentHistoryEntry::unsafe_arena_release_edited_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentHistoryEntry.edited_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = edited_on_;
  edited_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentHistoryEntry::_internal_mutable_edited_on() {
  
  if (edited_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    edited_on_ = p;
  }
  return edited_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentHistoryEntry::mutable_edited_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_edited_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentHistoryEntry.edited_on)
  return _msg;
}
inline void FragmentHistoryEntry::set_allocated_edited_on(::PROTOBUF_NAMESPACE_ID::Timestamp* edited_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(edited_on_);
  }
  if (edited_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edited_on));
    if (message_arena != submessage_arena) {
      edited_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edited_on, submessage_arena);
    }
    
  } else {
    
  }
  edited_on_ = edited_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentHistoryEntry.edited_on)
}

// .viam.app.v1.Fragment old = 3 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
inline bool FragmentHistoryEntry::_internal_has_old() const {
  return this != internal_default_instance() && old_ != nullptr;
}
inline bool FragmentHistoryEntry::has_old() const {
  return _internal_has_old();
}
inline void FragmentHistoryEntry::clear_old() {
  if (GetArenaForAllocation() == nullptr && old_ != nullptr) {
    delete old_;
  }
  old_ = nullptr;
}
inline const ::viam::app::v1::Fragment& FragmentHistoryEntry::_internal_old() const {
  const ::viam::app::v1::Fragment* p = old_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Fragment&>(
      ::viam::app::v1::_Fragment_default_instance_);
}
inline const ::viam::app::v1::Fragment& FragmentHistoryEntry::old() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentHistoryEntry.old)
  return _internal_old();
}
inline void FragmentHistoryEntry::unsafe_arena_set_allocated_old(
    ::viam::app::v1::Fragment* old) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_);
  }
  old_ = old;
  if (old) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.FragmentHistoryEntry.old)
}
inline ::viam::app::v1::Fragment* FragmentHistoryEntry::release_old() {
  
  ::viam::app::v1::Fragment* temp = old_;
  old_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Fragment* FragmentHistoryEntry::unsafe_arena_release_old() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentHistoryEntry.old)
  
  ::viam::app::v1::Fragment* temp = old_;
  old_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Fragment* FragmentHistoryEntry::_internal_mutable_old() {
  
  if (old_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Fragment>(GetArenaForAllocation());
    old_ = p;
  }
  return old_;
}
inline ::viam::app::v1::Fragment* FragmentHistoryEntry::mutable_old() {
  ::viam::app::v1::Fragment* _msg = _internal_mutable_old();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentHistoryEntry.old)
  return _msg;
}
inline void FragmentHistoryEntry::set_allocated_old(::viam::app::v1::Fragment* old) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete old_;
  }
  if (old) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old);
    if (message_arena != submessage_arena) {
      old = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old, submessage_arena);
    }
    
  } else {
    
  }
  old_ = old;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentHistoryEntry.old)
}

// .viam.app.v1.AuthenticatorInfo edited_by = 4 [json_name = "editedBy", (.tagger.v1.tags) = "bson:\"edited_by\" json:\"edited_by\""];
inline bool FragmentHistoryEntry::_internal_has_edited_by() const {
  return this != internal_default_instance() && edited_by_ != nullptr;
}
inline bool FragmentHistoryEntry::has_edited_by() const {
  return _internal_has_edited_by();
}
inline void FragmentHistoryEntry::clear_edited_by() {
  if (GetArenaForAllocation() == nullptr && edited_by_ != nullptr) {
    delete edited_by_;
  }
  edited_by_ = nullptr;
}
inline const ::viam::app::v1::AuthenticatorInfo& FragmentHistoryEntry::_internal_edited_by() const {
  const ::viam::app::v1::AuthenticatorInfo* p = edited_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AuthenticatorInfo&>(
      ::viam::app::v1::_AuthenticatorInfo_default_instance_);
}
inline const ::viam::app::v1::AuthenticatorInfo& FragmentHistoryEntry::edited_by() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentHistoryEntry.edited_by)
  return _internal_edited_by();
}
inline void FragmentHistoryEntry::unsafe_arena_set_allocated_edited_by(
    ::viam::app::v1::AuthenticatorInfo* edited_by) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edited_by_);
  }
  edited_by_ = edited_by;
  if (edited_by) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.FragmentHistoryEntry.edited_by)
}
inline ::viam::app::v1::AuthenticatorInfo* FragmentHistoryEntry::release_edited_by() {
  
  ::viam::app::v1::AuthenticatorInfo* temp = edited_by_;
  edited_by_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::AuthenticatorInfo* FragmentHistoryEntry::unsafe_arena_release_edited_by() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentHistoryEntry.edited_by)
  
  ::viam::app::v1::AuthenticatorInfo* temp = edited_by_;
  edited_by_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AuthenticatorInfo* FragmentHistoryEntry::_internal_mutable_edited_by() {
  
  if (edited_by_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AuthenticatorInfo>(GetArenaForAllocation());
    edited_by_ = p;
  }
  return edited_by_;
}
inline ::viam::app::v1::AuthenticatorInfo* FragmentHistoryEntry::mutable_edited_by() {
  ::viam::app::v1::AuthenticatorInfo* _msg = _internal_mutable_edited_by();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentHistoryEntry.edited_by)
  return _msg;
}
inline void FragmentHistoryEntry::set_allocated_edited_by(::viam::app::v1::AuthenticatorInfo* edited_by) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edited_by_;
  }
  if (edited_by) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edited_by);
    if (message_arena != submessage_arena) {
      edited_by = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edited_by, submessage_arena);
    }
    
  } else {
    
  }
  edited_by_ = edited_by;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentHistoryEntry.edited_by)
}

// string revision = 5 [json_name = "revision", (.tagger.v1.tags) = "bson:\"revision\" json:\"revision\""];
inline void FragmentHistoryEntry::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& FragmentHistoryEntry::revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentHistoryEntry.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentHistoryEntry::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentHistoryEntry.revision)
}
inline std::string* FragmentHistoryEntry::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentHistoryEntry.revision)
  return _s;
}
inline const std::string& FragmentHistoryEntry::_internal_revision() const {
  return revision_.Get();
}
inline void FragmentHistoryEntry::_internal_set_revision(const std::string& value) {
  
  revision_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentHistoryEntry::_internal_mutable_revision() {
  
  return revision_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentHistoryEntry::release_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentHistoryEntry.revision)
  return revision_.Release();
}
inline void FragmentHistoryEntry::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault()) {
    revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentHistoryEntry.revision)
}

// .google.protobuf.Struct config = 6 [json_name = "config", (.tagger.v1.tags) = "bson:\"config\" json:\"config\""];
inline bool FragmentHistoryEntry::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool FragmentHistoryEntry::has_config() const {
  return _internal_has_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& FragmentHistoryEntry::_internal_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& FragmentHistoryEntry::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentHistoryEntry.config)
  return _internal_config();
}
inline void FragmentHistoryEntry::unsafe_arena_set_allocated_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.FragmentHistoryEntry.config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FragmentHistoryEntry::release_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FragmentHistoryEntry::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentHistoryEntry.config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FragmentHistoryEntry::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FragmentHistoryEntry::mutable_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentHistoryEntry.config)
  return _msg;
}
inline void FragmentHistoryEntry::set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentHistoryEntry.config)
}

// -------------------------------------------------------------------

// FragmentRevision

// string revision = 1 [json_name = "revision"];
inline void FragmentRevision::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& FragmentRevision::revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentRevision.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentRevision::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentRevision.revision)
}
inline std::string* FragmentRevision::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentRevision.revision)
  return _s;
}
inline const std::string& FragmentRevision::_internal_revision() const {
  return revision_.Get();
}
inline void FragmentRevision::_internal_set_revision(const std::string& value) {
  
  revision_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentRevision::_internal_mutable_revision() {
  
  return revision_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentRevision::release_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentRevision.revision)
  return revision_.Release();
}
inline void FragmentRevision::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault()) {
    revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentRevision.revision)
}

// .google.protobuf.Timestamp created_at = 2 [json_name = "createdAt"];
inline bool FragmentRevision::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool FragmentRevision::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FragmentRevision::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FragmentRevision::created_at() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentRevision.created_at)
  return _internal_created_at();
}
inline void FragmentRevision::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.FragmentRevision.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentRevision::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentRevision::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentRevision.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentRevision::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FragmentRevision::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentRevision.created_at)
  return _msg;
}
inline void FragmentRevision::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentRevision.created_at)
}

// -------------------------------------------------------------------

// FragmentTag

// string tag = 1 [json_name = "tag"];
inline void FragmentTag::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& FragmentTag::tag() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentTag.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentTag::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentTag.tag)
}
inline std::string* FragmentTag::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentTag.tag)
  return _s;
}
inline const std::string& FragmentTag::_internal_tag() const {
  return tag_.Get();
}
inline void FragmentTag::_internal_set_tag(const std::string& value) {
  
  tag_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentTag::_internal_mutable_tag() {
  
  return tag_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentTag::release_tag() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentTag.tag)
  return tag_.Release();
}
inline void FragmentTag::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentTag.tag)
}

// string revision = 2 [json_name = "revision"];
inline void FragmentTag::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& FragmentTag::revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentTag.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentTag::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentTag.revision)
}
inline std::string* FragmentTag::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentTag.revision)
  return _s;
}
inline const std::string& FragmentTag::_internal_revision() const {
  return revision_.Get();
}
inline void FragmentTag::_internal_set_revision(const std::string& value) {
  
  revision_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentTag::_internal_mutable_revision() {
  
  return revision_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentTag::release_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentTag.revision)
  return revision_.Release();
}
inline void FragmentTag::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault()) {
    revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentTag.revision)
}

// -------------------------------------------------------------------

// FragmentError

// .viam.app.v1.FragmentErrorType error_type = 1 [json_name = "errorType"];
inline void FragmentError::clear_error_type() {
  error_type_ = 0;
}
inline ::viam::app::v1::FragmentErrorType FragmentError::_internal_error_type() const {
  return static_cast< ::viam::app::v1::FragmentErrorType >(error_type_);
}
inline ::viam::app::v1::FragmentErrorType FragmentError::error_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentError.error_type)
  return _internal_error_type();
}
inline void FragmentError::_internal_set_error_type(::viam::app::v1::FragmentErrorType value) {
  
  error_type_ = value;
}
inline void FragmentError::set_error_type(::viam::app::v1::FragmentErrorType value) {
  _internal_set_error_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentError.error_type)
}

// string fragment_id = 2 [json_name = "fragmentId"];
inline void FragmentError::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& FragmentError::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentError.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentError::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentError.fragment_id)
}
inline std::string* FragmentError::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentError.fragment_id)
  return _s;
}
inline const std::string& FragmentError::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void FragmentError::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentError::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentError::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentError.fragment_id)
  return fragment_id_.Release();
}
inline void FragmentError::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentError.fragment_id)
}

// string detail = 3 [json_name = "detail"];
inline void FragmentError::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& FragmentError::detail() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentError.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentError::set_detail(ArgT0&& arg0, ArgT... args) {
 
 detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentError.detail)
}
inline std::string* FragmentError::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentError.detail)
  return _s;
}
inline const std::string& FragmentError::_internal_detail() const {
  return detail_.Get();
}
inline void FragmentError::_internal_set_detail(const std::string& value) {
  
  detail_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentError::_internal_mutable_detail() {
  
  return detail_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentError::release_detail() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentError.detail)
  return detail_.Release();
}
inline void FragmentError::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (detail_.IsDefault()) {
    detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentError.detail)
}

// -------------------------------------------------------------------

// FragmentUsage

// string fragment_id = 1 [json_name = "fragmentId"];
inline void FragmentUsage::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& FragmentUsage::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentUsage.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentUsage::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentUsage.fragment_id)
}
inline std::string* FragmentUsage::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentUsage.fragment_id)
  return _s;
}
inline const std::string& FragmentUsage::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void FragmentUsage::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentUsage::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentUsage::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentUsage.fragment_id)
  return fragment_id_.Release();
}
inline void FragmentUsage::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentUsage.fragment_id)
}

// int32 organizations = 2 [json_name = "organizations"];
inline void FragmentUsage::clear_organizations() {
  organizations_ = 0;
}
inline int32_t FragmentUsage::_internal_organizations() const {
  return organizations_;
}
inline int32_t FragmentUsage::organizations() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentUsage.organizations)
  return _internal_organizations();
}
inline void FragmentUsage::_internal_set_organizations(int32_t value) {
  
  organizations_ = value;
}
inline void FragmentUsage::set_organizations(int32_t value) {
  _internal_set_organizations(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentUsage.organizations)
}

// int32 machines = 3 [json_name = "machines"];
inline void FragmentUsage::clear_machines() {
  machines_ = 0;
}
inline int32_t FragmentUsage::_internal_machines() const {
  return machines_;
}
inline int32_t FragmentUsage::machines() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentUsage.machines)
  return _internal_machines();
}
inline void FragmentUsage::_internal_set_machines(int32_t value) {
  
  machines_ = value;
}
inline void FragmentUsage::set_machines(int32_t value) {
  _internal_set_machines(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentUsage.machines)
}

// int32 machines_in_current_org = 4 [json_name = "machinesInCurrentOrg"];
inline void FragmentUsage::clear_machines_in_current_org() {
  machines_in_current_org_ = 0;
}
inline int32_t FragmentUsage::_internal_machines_in_current_org() const {
  return machines_in_current_org_;
}
inline int32_t FragmentUsage::machines_in_current_org() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentUsage.machines_in_current_org)
  return _internal_machines_in_current_org();
}
inline void FragmentUsage::_internal_set_machines_in_current_org(int32_t value) {
  
  machines_in_current_org_ = value;
}
inline void FragmentUsage::set_machines_in_current_org(int32_t value) {
  _internal_set_machines_in_current_org(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentUsage.machines_in_current_org)
}

// optional string version = 5 [json_name = "version"];
inline bool FragmentUsage::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FragmentUsage::has_version() const {
  return _internal_has_version();
}
inline void FragmentUsage::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FragmentUsage::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentUsage.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentUsage::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentUsage.version)
}
inline std::string* FragmentUsage::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentUsage.version)
  return _s;
}
inline const std::string& FragmentUsage::_internal_version() const {
  return version_.Get();
}
inline void FragmentUsage::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentUsage::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentUsage::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentUsage.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FragmentUsage::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentUsage.version)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FragmentImport

// string fragment_id = 1 [json_name = "fragmentId"];
inline void FragmentImport::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& FragmentImport::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentImport.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentImport::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentImport.fragment_id)
}
inline std::string* FragmentImport::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentImport.fragment_id)
  return _s;
}
inline const std::string& FragmentImport::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void FragmentImport::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentImport::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentImport::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentImport.fragment_id)
  return fragment_id_.Release();
}
inline void FragmentImport::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentImport.fragment_id)
}

// string version = 2 [json_name = "version"];
inline void FragmentImport::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& FragmentImport::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentImport.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentImport::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentImport.version)
}
inline std::string* FragmentImport::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentImport.version)
  return _s;
}
inline const std::string& FragmentImport::_internal_version() const {
  return version_.Get();
}
inline void FragmentImport::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentImport::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentImport::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentImport.version)
  return version_.Release();
}
inline void FragmentImport::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentImport.version)
}

// optional string prefix = 3 [json_name = "prefix"];
inline bool FragmentImport::_internal_has_prefix() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FragmentImport::has_prefix() const {
  return _internal_has_prefix();
}
inline void FragmentImport::clear_prefix() {
  prefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FragmentImport::prefix() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentImport.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentImport::set_prefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentImport.prefix)
}
inline std::string* FragmentImport::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentImport.prefix)
  return _s;
}
inline const std::string& FragmentImport::_internal_prefix() const {
  return prefix_.Get();
}
inline void FragmentImport::_internal_set_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentImport::_internal_mutable_prefix() {
  _has_bits_[0] |= 0x00000001u;
  return prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentImport::release_prefix() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentImport.prefix)
  if (!_internal_has_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = prefix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault()) {
    prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FragmentImport::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prefix_.SetAllocated(prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault()) {
    prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentImport.prefix)
}

// map<string, string> variables = 4 [json_name = "variables"];
inline int FragmentImport::_internal_variables_size() const {
  return variables_.size();
}
inline int FragmentImport::variables_size() const {
  return _internal_variables_size();
}
inline void FragmentImport::clear_variables() {
  variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FragmentImport::_internal_variables() const {
  return variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FragmentImport::variables() const {
  // @@protoc_insertion_point(field_map:viam.app.v1.FragmentImport.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FragmentImport::_internal_mutable_variables() {
  return variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FragmentImport::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.v1.FragmentImport.variables)
  return _internal_mutable_variables();
}

// -------------------------------------------------------------------

// ResolvedFragment

// string fragment_id = 1 [json_name = "fragmentId"];
inline void ResolvedFragment::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& ResolvedFragment::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResolvedFragment.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedFragment::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResolvedFragment.fragment_id)
}
inline std::string* ResolvedFragment::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResolvedFragment.fragment_id)
  return _s;
}
inline const std::string& ResolvedFragment::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void ResolvedFragment::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedFragment::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedFragment::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResolvedFragment.fragment_id)
  return fragment_id_.Release();
}
inline void ResolvedFragment::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResolvedFragment.fragment_id)
}

// .google.protobuf.Struct resolved_config = 2 [json_name = "resolvedConfig"];
inline bool ResolvedFragment::_internal_has_resolved_config() const {
  return this != internal_default_instance() && resolved_config_ != nullptr;
}
inline bool ResolvedFragment::has_resolved_config() const {
  return _internal_has_resolved_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ResolvedFragment::_internal_resolved_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = resolved_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ResolvedFragment::resolved_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResolvedFragment.resolved_config)
  return _internal_resolved_config();
}
inline void ResolvedFragment::unsafe_arena_set_allocated_resolved_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* resolved_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolved_config_);
  }
  resolved_config_ = resolved_config;
  if (resolved_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ResolvedFragment.resolved_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResolvedFragment::release_resolved_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = resolved_config_;
  resolved_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResolvedFragment::unsafe_arena_release_resolved_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResolvedFragment.resolved_config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = resolved_config_;
  resolved_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResolvedFragment::_internal_mutable_resolved_config() {
  
  if (resolved_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    resolved_config_ = p;
  }
  return resolved_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResolvedFragment::mutable_resolved_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_resolved_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResolvedFragment.resolved_config)
  return _msg;
}
inline void ResolvedFragment::set_allocated_resolved_config(::PROTOBUF_NAMESPACE_ID::Struct* resolved_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolved_config_);
  }
  if (resolved_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolved_config));
    if (message_arena != submessage_arena) {
      resolved_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolved_config, submessage_arena);
    }
    
  } else {
    
  }
  resolved_config_ = resolved_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResolvedFragment.resolved_config)
}

// .viam.app.v1.FragmentError error = 3 [json_name = "error"];
inline bool ResolvedFragment::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool ResolvedFragment::has_error() const {
  return _internal_has_error();
}
inline void ResolvedFragment::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::viam::app::v1::FragmentError& ResolvedFragment::_internal_error() const {
  const ::viam::app::v1::FragmentError* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::FragmentError&>(
      ::viam::app::v1::_FragmentError_default_instance_);
}
inline const ::viam::app::v1::FragmentError& ResolvedFragment::error() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResolvedFragment.error)
  return _internal_error();
}
inline void ResolvedFragment::unsafe_arena_set_allocated_error(
    ::viam::app::v1::FragmentError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ResolvedFragment.error)
}
inline ::viam::app::v1::FragmentError* ResolvedFragment::release_error() {
  
  ::viam::app::v1::FragmentError* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::FragmentError* ResolvedFragment::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResolvedFragment.error)
  
  ::viam::app::v1::FragmentError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::viam::app::v1::FragmentError* ResolvedFragment::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::FragmentError>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::viam::app::v1::FragmentError* ResolvedFragment::mutable_error() {
  ::viam::app::v1::FragmentError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResolvedFragment.error)
  return _msg;
}
inline void ResolvedFragment::set_allocated_error(::viam::app::v1::FragmentError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResolvedFragment.error)
}

// string revision = 4 [json_name = "revision"];
inline void ResolvedFragment::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& ResolvedFragment::revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResolvedFragment.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedFragment::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResolvedFragment.revision)
}
inline std::string* ResolvedFragment::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResolvedFragment.revision)
  return _s;
}
inline const std::string& ResolvedFragment::_internal_revision() const {
  return revision_.Get();
}
inline void ResolvedFragment::_internal_set_revision(const std::string& value) {
  
  revision_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedFragment::_internal_mutable_revision() {
  
  return revision_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedFragment::release_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResolvedFragment.revision)
  return revision_.Release();
}
inline void ResolvedFragment::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault()) {
    revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResolvedFragment.revision)
}

// -------------------------------------------------------------------

// ListFragmentsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListFragmentsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListFragmentsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListFragmentsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListFragmentsRequest.organization_id)
}
inline std::string* ListFragmentsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListFragmentsRequest.organization_id)
  return _s;
}
inline const std::string& ListFragmentsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListFragmentsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListFragmentsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListFragmentsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListFragmentsRequest.organization_id)
  return organization_id_.Release();
}
inline void ListFragmentsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListFragmentsRequest.organization_id)
}

// bool show_public = 2 [json_name = "showPublic"];
inline void ListFragmentsRequest::clear_show_public() {
  show_public_ = false;
}
inline bool ListFragmentsRequest::_internal_show_public() const {
  return show_public_;
}
inline bool ListFragmentsRequest::show_public() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsRequest.show_public)
  return _internal_show_public();
}
inline void ListFragmentsRequest::_internal_set_show_public(bool value) {
  
  show_public_ = value;
}
inline void ListFragmentsRequest::set_show_public(bool value) {
  _internal_set_show_public(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListFragmentsRequest.show_public)
}

// repeated .viam.app.v1.FragmentVisibility fragment_visibility = 3 [json_name = "fragmentVisibility"];
inline int ListFragmentsRequest::_internal_fragment_visibility_size() const {
  return fragment_visibility_.size();
}
inline int ListFragmentsRequest::fragment_visibility_size() const {
  return _internal_fragment_visibility_size();
}
inline void ListFragmentsRequest::clear_fragment_visibility() {
  fragment_visibility_.Clear();
}
inline ::viam::app::v1::FragmentVisibility ListFragmentsRequest::_internal_fragment_visibility(int index) const {
  return static_cast< ::viam::app::v1::FragmentVisibility >(fragment_visibility_.Get(index));
}
inline ::viam::app::v1::FragmentVisibility ListFragmentsRequest::fragment_visibility(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsRequest.fragment_visibility)
  return _internal_fragment_visibility(index);
}
inline void ListFragmentsRequest::set_fragment_visibility(int index, ::viam::app::v1::FragmentVisibility value) {
  fragment_visibility_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListFragmentsRequest.fragment_visibility)
}
inline void ListFragmentsRequest::_internal_add_fragment_visibility(::viam::app::v1::FragmentVisibility value) {
  fragment_visibility_.Add(value);
}
inline void ListFragmentsRequest::add_fragment_visibility(::viam::app::v1::FragmentVisibility value) {
  _internal_add_fragment_visibility(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListFragmentsRequest.fragment_visibility)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListFragmentsRequest::fragment_visibility() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListFragmentsRequest.fragment_visibility)
  return fragment_visibility_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListFragmentsRequest::_internal_mutable_fragment_visibility() {
  return &fragment_visibility_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListFragmentsRequest::mutable_fragment_visibility() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListFragmentsRequest.fragment_visibility)
  return _internal_mutable_fragment_visibility();
}

// -------------------------------------------------------------------

// ListFragmentsResponse

// repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
inline int ListFragmentsResponse::_internal_fragments_size() const {
  return fragments_.size();
}
inline int ListFragmentsResponse::fragments_size() const {
  return _internal_fragments_size();
}
inline void ListFragmentsResponse::clear_fragments() {
  fragments_.Clear();
}
inline ::viam::app::v1::Fragment* ListFragmentsResponse::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListFragmentsResponse.fragments)
  return fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
ListFragmentsResponse::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListFragmentsResponse.fragments)
  return &fragments_;
}
inline const ::viam::app::v1::Fragment& ListFragmentsResponse::_internal_fragments(int index) const {
  return fragments_.Get(index);
}
inline const ::viam::app::v1::Fragment& ListFragmentsResponse::fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsResponse.fragments)
  return _internal_fragments(index);
}
inline ::viam::app::v1::Fragment* ListFragmentsResponse::_internal_add_fragments() {
  return fragments_.Add();
}
inline ::viam::app::v1::Fragment* ListFragmentsResponse::add_fragments() {
  ::viam::app::v1::Fragment* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListFragmentsResponse.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
ListFragmentsResponse::fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListFragmentsResponse.fragments)
  return fragments_;
}

// repeated .viam.app.v1.FragmentUsage fragment_usages = 2 [json_name = "fragmentUsages"];
inline int ListFragmentsResponse::_internal_fragment_usages_size() const {
  return fragment_usages_.size();
}
inline int ListFragmentsResponse::fragment_usages_size() const {
  return _internal_fragment_usages_size();
}
inline void ListFragmentsResponse::clear_fragment_usages() {
  fragment_usages_.Clear();
}
inline ::viam::app::v1::FragmentUsage* ListFragmentsResponse::mutable_fragment_usages(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListFragmentsResponse.fragment_usages)
  return fragment_usages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >*
ListFragmentsResponse::mutable_fragment_usages() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListFragmentsResponse.fragment_usages)
  return &fragment_usages_;
}
inline const ::viam::app::v1::FragmentUsage& ListFragmentsResponse::_internal_fragment_usages(int index) const {
  return fragment_usages_.Get(index);
}
inline const ::viam::app::v1::FragmentUsage& ListFragmentsResponse::fragment_usages(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsResponse.fragment_usages)
  return _internal_fragment_usages(index);
}
inline ::viam::app::v1::FragmentUsage* ListFragmentsResponse::_internal_add_fragment_usages() {
  return fragment_usages_.Add();
}
inline ::viam::app::v1::FragmentUsage* ListFragmentsResponse::add_fragment_usages() {
  ::viam::app::v1::FragmentUsage* _add = _internal_add_fragment_usages();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListFragmentsResponse.fragment_usages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >&
ListFragmentsResponse::fragment_usages() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListFragmentsResponse.fragment_usages)
  return fragment_usages_;
}

// -------------------------------------------------------------------

// GetFragmentRequest

// string id = 1 [json_name = "id"];
inline void GetFragmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetFragmentRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentRequest.id)
}
inline std::string* GetFragmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentRequest.id)
  return _s;
}
inline const std::string& GetFragmentRequest::_internal_id() const {
  return id_.Get();
}
inline void GetFragmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentRequest.id)
  return id_.Release();
}
inline void GetFragmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentRequest.id)
}

// string current_organization_id = 2 [json_name = "currentOrganizationId"];
inline void GetFragmentRequest::clear_current_organization_id() {
  current_organization_id_.ClearToEmpty();
}
inline const std::string& GetFragmentRequest::current_organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentRequest.current_organization_id)
  return _internal_current_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentRequest::set_current_organization_id(ArgT0&& arg0, ArgT... args) {
 
 current_organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentRequest.current_organization_id)
}
inline std::string* GetFragmentRequest::mutable_current_organization_id() {
  std::string* _s = _internal_mutable_current_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentRequest.current_organization_id)
  return _s;
}
inline const std::string& GetFragmentRequest::_internal_current_organization_id() const {
  return current_organization_id_.Get();
}
inline void GetFragmentRequest::_internal_set_current_organization_id(const std::string& value) {
  
  current_organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::_internal_mutable_current_organization_id() {
  
  return current_organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::release_current_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentRequest.current_organization_id)
  return current_organization_id_.Release();
}
inline void GetFragmentRequest::set_allocated_current_organization_id(std::string* current_organization_id) {
  if (current_organization_id != nullptr) {
    
  } else {
    
  }
  current_organization_id_.SetAllocated(current_organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_organization_id_.IsDefault()) {
    current_organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentRequest.current_organization_id)
}

// optional string version = 3 [json_name = "version"];
inline bool GetFragmentRequest::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetFragmentRequest::has_version() const {
  return _internal_has_version();
}
inline void GetFragmentRequest::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetFragmentRequest::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentRequest::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentRequest.version)
}
inline std::string* GetFragmentRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentRequest.version)
  return _s;
}
inline const std::string& GetFragmentRequest::_internal_version() const {
  return version_.Get();
}
inline void GetFragmentRequest::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentRequest.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetFragmentRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentRequest.version)
}

// -------------------------------------------------------------------

// GetFragmentResponse

// .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
inline bool GetFragmentResponse::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool GetFragmentResponse::has_fragment() const {
  return _internal_has_fragment();
}
inline void GetFragmentResponse::clear_fragment() {
  if (GetArenaForAllocation() == nullptr && fragment_ != nullptr) {
    delete fragment_;
  }
  fragment_ = nullptr;
}
inline const ::viam::app::v1::Fragment& GetFragmentResponse::_internal_fragment() const {
  const ::viam::app::v1::Fragment* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Fragment&>(
      ::viam::app::v1::_Fragment_default_instance_);
}
inline const ::viam::app::v1::Fragment& GetFragmentResponse::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentResponse.fragment)
  return _internal_fragment();
}
inline void GetFragmentResponse::unsafe_arena_set_allocated_fragment(
    ::viam::app::v1::Fragment* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetFragmentResponse.fragment)
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::release_fragment() {
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentResponse.fragment)
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Fragment>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::mutable_fragment() {
  ::viam::app::v1::Fragment* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentResponse.fragment)
  return _msg;
}
inline void GetFragmentResponse::set_allocated_fragment(::viam::app::v1::Fragment* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_;
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment);
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentResponse.fragment)
}

// .viam.app.v1.FragmentUsage fragment_usage = 2 [json_name = "fragmentUsage"];
inline bool GetFragmentResponse::_internal_has_fragment_usage() const {
  return this != internal_default_instance() && fragment_usage_ != nullptr;
}
inline bool GetFragmentResponse::has_fragment_usage() const {
  return _internal_has_fragment_usage();
}
inline void GetFragmentResponse::clear_fragment_usage() {
  if (GetArenaForAllocation() == nullptr && fragment_usage_ != nullptr) {
    delete fragment_usage_;
  }
  fragment_usage_ = nullptr;
}
inline const ::viam::app::v1::FragmentUsage& GetFragmentResponse::_internal_fragment_usage() const {
  const ::viam::app::v1::FragmentUsage* p = fragment_usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::FragmentUsage&>(
      ::viam::app::v1::_FragmentUsage_default_instance_);
}
inline const ::viam::app::v1::FragmentUsage& GetFragmentResponse::fragment_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentResponse.fragment_usage)
  return _internal_fragment_usage();
}
inline void GetFragmentResponse::unsafe_arena_set_allocated_fragment_usage(
    ::viam::app::v1::FragmentUsage* fragment_usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_usage_);
  }
  fragment_usage_ = fragment_usage;
  if (fragment_usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetFragmentResponse.fragment_usage)
}
inline ::viam::app::v1::FragmentUsage* GetFragmentResponse::release_fragment_usage() {
  
  ::viam::app::v1::FragmentUsage* temp = fragment_usage_;
  fragment_usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::FragmentUsage* GetFragmentResponse::unsafe_arena_release_fragment_usage() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentResponse.fragment_usage)
  
  ::viam::app::v1::FragmentUsage* temp = fragment_usage_;
  fragment_usage_ = nullptr;
  return temp;
}
inline ::viam::app::v1::FragmentUsage* GetFragmentResponse::_internal_mutable_fragment_usage() {
  
  if (fragment_usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::FragmentUsage>(GetArenaForAllocation());
    fragment_usage_ = p;
  }
  return fragment_usage_;
}
inline ::viam::app::v1::FragmentUsage* GetFragmentResponse::mutable_fragment_usage() {
  ::viam::app::v1::FragmentUsage* _msg = _internal_mutable_fragment_usage();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentResponse.fragment_usage)
  return _msg;
}
inline void GetFragmentResponse::set_allocated_fragment_usage(::viam::app::v1::FragmentUsage* fragment_usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_usage_;
  }
  if (fragment_usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment_usage);
    if (message_arena != submessage_arena) {
      fragment_usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment_usage, submessage_arena);
    }
    
  } else {
    
  }
  fragment_usage_ = fragment_usage;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentResponse.fragment_usage)
}

// repeated .viam.app.v1.FragmentRevision revisions = 3 [json_name = "revisions"];
inline int GetFragmentResponse::_internal_revisions_size() const {
  return revisions_.size();
}
inline int GetFragmentResponse::revisions_size() const {
  return _internal_revisions_size();
}
inline void GetFragmentResponse::clear_revisions() {
  revisions_.Clear();
}
inline ::viam::app::v1::FragmentRevision* GetFragmentResponse::mutable_revisions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentResponse.revisions)
  return revisions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentRevision >*
GetFragmentResponse::mutable_revisions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetFragmentResponse.revisions)
  return &revisions_;
}
inline const ::viam::app::v1::FragmentRevision& GetFragmentResponse::_internal_revisions(int index) const {
  return revisions_.Get(index);
}
inline const ::viam::app::v1::FragmentRevision& GetFragmentResponse::revisions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentResponse.revisions)
  return _internal_revisions(index);
}
inline ::viam::app::v1::FragmentRevision* GetFragmentResponse::_internal_add_revisions() {
  return revisions_.Add();
}
inline ::viam::app::v1::FragmentRevision* GetFragmentResponse::add_revisions() {
  ::viam::app::v1::FragmentRevision* _add = _internal_add_revisions();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetFragmentResponse.revisions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentRevision >&
GetFragmentResponse::revisions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetFragmentResponse.revisions)
  return revisions_;
}

// repeated .viam.app.v1.FragmentTag tags = 4 [json_name = "tags"];
inline int GetFragmentResponse::_internal_tags_size() const {
  return tags_.size();
}
inline int GetFragmentResponse::tags_size() const {
  return _internal_tags_size();
}
inline void GetFragmentResponse::clear_tags() {
  tags_.Clear();
}
inline ::viam::app::v1::FragmentTag* GetFragmentResponse::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentResponse.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >*
GetFragmentResponse::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetFragmentResponse.tags)
  return &tags_;
}
inline const ::viam::app::v1::FragmentTag& GetFragmentResponse::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::viam::app::v1::FragmentTag& GetFragmentResponse::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentResponse.tags)
  return _internal_tags(index);
}
inline ::viam::app::v1::FragmentTag* GetFragmentResponse::_internal_add_tags() {
  return tags_.Add();
}
inline ::viam::app::v1::FragmentTag* GetFragmentResponse::add_tags() {
  ::viam::app::v1::FragmentTag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetFragmentResponse.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >&
GetFragmentResponse::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetFragmentResponse.tags)
  return tags_;
}

// -------------------------------------------------------------------

// CreateFragmentRequest

// string name = 1 [json_name = "name"];
inline void CreateFragmentRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateFragmentRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFragmentRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateFragmentRequest.name)
}
inline std::string* CreateFragmentRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentRequest.name)
  return _s;
}
inline const std::string& CreateFragmentRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateFragmentRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentRequest.name)
  return name_.Release();
}
inline void CreateFragmentRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentRequest.name)
}

// .google.protobuf.Struct config = 2 [json_name = "config"];
inline bool CreateFragmentRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool CreateFragmentRequest::has_config() const {
  return _internal_has_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CreateFragmentRequest::_internal_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CreateFragmentRequest::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentRequest.config)
  return _internal_config();
}
inline void CreateFragmentRequest::unsafe_arena_set_allocated_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateFragmentRequest.config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::release_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentRequest.config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::mutable_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentRequest.config)
  return _msg;
}
inline void CreateFragmentRequest::set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentRequest.config)
}

// string organization_id = 3 [json_name = "organizationId"];
inline void CreateFragmentRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateFragmentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFragmentRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateFragmentRequest.organization_id)
}
inline std::string* CreateFragmentRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentRequest.organization_id)
  return _s;
}
inline const std::string& CreateFragmentRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateFragmentRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateFragmentRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentRequest.organization_id)
}

// optional .viam.app.v1.FragmentVisibility visibility = 4 [json_name = "visibility"];
inline bool CreateFragmentRequest::_internal_has_visibility() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateFragmentRequest::has_visibility() const {
  return _internal_has_visibility();
}
inline void CreateFragmentRequest::clear_visibility() {
  visibility_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::viam::app::v1::FragmentVisibility CreateFragmentRequest::_internal_visibility() const {
  return static_cast< ::viam::app::v1::FragmentVisibility >(visibility_);
}
inline ::viam::app::v1::FragmentVisibility CreateFragmentRequest::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentRequest.visibility)
  return _internal_visibility();
}
inline void CreateFragmentRequest::_internal_set_visibility(::viam::app::v1::FragmentVisibility value) {
  _has_bits_[0] |= 0x00000001u;
  visibility_ = value;
}
inline void CreateFragmentRequest::set_visibility(::viam::app::v1::FragmentVisibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateFragmentRequest.visibility)
}

// -------------------------------------------------------------------

// CreateFragmentResponse

// .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
inline bool CreateFragmentResponse::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool CreateFragmentResponse::has_fragment() const {
  return _internal_has_fragment();
}
inline void CreateFragmentResponse::clear_fragment() {
  if (GetArenaForAllocation() == nullptr && fragment_ != nullptr) {
    delete fragment_;
  }
  fragment_ = nullptr;
}
inline const ::viam::app::v1::Fragment& CreateFragmentResponse::_internal_fragment() const {
  const ::viam::app::v1::Fragment* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Fragment&>(
      ::viam::app::v1::_Fragment_default_instance_);
}
inline const ::viam::app::v1::Fragment& CreateFragmentResponse::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentResponse.fragment)
  return _internal_fragment();
}
inline void CreateFragmentResponse::unsafe_arena_set_allocated_fragment(
    ::viam::app::v1::Fragment* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateFragmentResponse.fragment)
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::release_fragment() {
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentResponse.fragment)
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Fragment>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::mutable_fragment() {
  ::viam::app::v1::Fragment* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentResponse.fragment)
  return _msg;
}
inline void CreateFragmentResponse::set_allocated_fragment(::viam::app::v1::Fragment* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_;
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment);
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentResponse.fragment)
}

// -------------------------------------------------------------------

// UpdateFragmentRequest

// string id = 1 [json_name = "id"];
inline void UpdateFragmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateFragmentRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateFragmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateFragmentRequest.id)
}
inline std::string* UpdateFragmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentRequest.id)
  return _s;
}
inline const std::string& UpdateFragmentRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateFragmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentRequest.id)
  return id_.Release();
}
inline void UpdateFragmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateFragmentRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateFragmentRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateFragmentRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateFragmentRequest.name)
}
inline std::string* UpdateFragmentRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentRequest.name)
  return _s;
}
inline const std::string& UpdateFragmentRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateFragmentRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentRequest.name)
  return name_.Release();
}
inline void UpdateFragmentRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentRequest.name)
}

// .google.protobuf.Struct config = 3 [json_name = "config"];
inline bool UpdateFragmentRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool UpdateFragmentRequest::has_config() const {
  return _internal_has_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateFragmentRequest::_internal_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateFragmentRequest::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.config)
  return _internal_config();
}
inline void UpdateFragmentRequest::unsafe_arena_set_allocated_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateFragmentRequest.config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::release_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentRequest.config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::mutable_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentRequest.config)
  return _msg;
}
inline void UpdateFragmentRequest::set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentRequest.config)
}

// optional bool public = 4 [json_name = "public"];
inline bool UpdateFragmentRequest::_internal_has_public_() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateFragmentRequest::has_public_() const {
  return _internal_has_public_();
}
inline void UpdateFragmentRequest::clear_public_() {
  public__ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UpdateFragmentRequest::_internal_public_() const {
  return public__;
}
inline bool UpdateFragmentRequest::public_() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.public)
  return _internal_public_();
}
inline void UpdateFragmentRequest::_internal_set_public_(bool value) {
  _has_bits_[0] |= 0x00000002u;
  public__ = value;
}
inline void UpdateFragmentRequest::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateFragmentRequest.public)
}

// optional .viam.app.v1.FragmentVisibility visibility = 5 [json_name = "visibility"];
inline bool UpdateFragmentRequest::_internal_has_visibility() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateFragmentRequest::has_visibility() const {
  return _internal_has_visibility();
}
inline void UpdateFragmentRequest::clear_visibility() {
  visibility_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::viam::app::v1::FragmentVisibility UpdateFragmentRequest::_internal_visibility() const {
  return static_cast< ::viam::app::v1::FragmentVisibility >(visibility_);
}
inline ::viam::app::v1::FragmentVisibility UpdateFragmentRequest::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.visibility)
  return _internal_visibility();
}
inline void UpdateFragmentRequest::_internal_set_visibility(::viam::app::v1::FragmentVisibility value) {
  _has_bits_[0] |= 0x00000004u;
  visibility_ = value;
}
inline void UpdateFragmentRequest::set_visibility(::viam::app::v1::FragmentVisibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateFragmentRequest.visibility)
}

// optional .google.protobuf.Timestamp last_known_update = 6 [json_name = "lastKnownUpdate"];
inline bool UpdateFragmentRequest::_internal_has_last_known_update() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || last_known_update_ != nullptr);
  return value;
}
inline bool UpdateFragmentRequest::has_last_known_update() const {
  return _internal_has_last_known_update();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateFragmentRequest::_internal_last_known_update() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_known_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateFragmentRequest::last_known_update() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.last_known_update)
  return _internal_last_known_update();
}
inline void UpdateFragmentRequest::unsafe_arena_set_allocated_last_known_update(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_known_update_);
  }
  last_known_update_ = last_known_update;
  if (last_known_update) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateFragmentRequest.last_known_update)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateFragmentRequest::release_last_known_update() {
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_known_update_;
  last_known_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateFragmentRequest::unsafe_arena_release_last_known_update() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentRequest.last_known_update)
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_known_update_;
  last_known_update_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateFragmentRequest::_internal_mutable_last_known_update() {
  _has_bits_[0] |= 0x00000001u;
  if (last_known_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_known_update_ = p;
  }
  return last_known_update_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateFragmentRequest::mutable_last_known_update() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_known_update();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentRequest.last_known_update)
  return _msg;
}
inline void UpdateFragmentRequest::set_allocated_last_known_update(::PROTOBUF_NAMESPACE_ID::Timestamp* last_known_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_known_update_);
  }
  if (last_known_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_known_update));
    if (message_arena != submessage_arena) {
      last_known_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_known_update, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_known_update_ = last_known_update;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentRequest.last_known_update)
}

// -------------------------------------------------------------------

// UpdateFragmentResponse

// .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
inline bool UpdateFragmentResponse::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool UpdateFragmentResponse::has_fragment() const {
  return _internal_has_fragment();
}
inline void UpdateFragmentResponse::clear_fragment() {
  if (GetArenaForAllocation() == nullptr && fragment_ != nullptr) {
    delete fragment_;
  }
  fragment_ = nullptr;
}
inline const ::viam::app::v1::Fragment& UpdateFragmentResponse::_internal_fragment() const {
  const ::viam::app::v1::Fragment* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Fragment&>(
      ::viam::app::v1::_Fragment_default_instance_);
}
inline const ::viam::app::v1::Fragment& UpdateFragmentResponse::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentResponse.fragment)
  return _internal_fragment();
}
inline void UpdateFragmentResponse::unsafe_arena_set_allocated_fragment(
    ::viam::app::v1::Fragment* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateFragmentResponse.fragment)
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::release_fragment() {
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentResponse.fragment)
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Fragment>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::mutable_fragment() {
  ::viam::app::v1::Fragment* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentResponse.fragment)
  return _msg;
}
inline void UpdateFragmentResponse::set_allocated_fragment(::viam::app::v1::Fragment* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_;
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment);
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentResponse.fragment)
}

// -------------------------------------------------------------------

// DeleteFragmentRequest

// string id = 1 [json_name = "id"];
inline void DeleteFragmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteFragmentRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteFragmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFragmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteFragmentRequest.id)
}
inline std::string* DeleteFragmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteFragmentRequest.id)
  return _s;
}
inline const std::string& DeleteFragmentRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteFragmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFragmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFragmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteFragmentRequest.id)
  return id_.Release();
}
inline void DeleteFragmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteFragmentRequest.id)
}

// -------------------------------------------------------------------

// DeleteFragmentResponse

// -------------------------------------------------------------------

// GetFragmentHistoryRequest

// string id = 1 [json_name = "id"];
inline void GetFragmentHistoryRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetFragmentHistoryRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentHistoryRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentHistoryRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentHistoryRequest.id)
}
inline std::string* GetFragmentHistoryRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentHistoryRequest.id)
  return _s;
}
inline const std::string& GetFragmentHistoryRequest::_internal_id() const {
  return id_.Get();
}
inline void GetFragmentHistoryRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentHistoryRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentHistoryRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentHistoryRequest.id)
  return id_.Release();
}
inline void GetFragmentHistoryRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentHistoryRequest.id)
}

// optional string page_token = 2 [json_name = "pageToken"];
inline bool GetFragmentHistoryRequest::_internal_has_page_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetFragmentHistoryRequest::has_page_token() const {
  return _internal_has_page_token();
}
inline void GetFragmentHistoryRequest::clear_page_token() {
  page_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetFragmentHistoryRequest::page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentHistoryRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentHistoryRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentHistoryRequest.page_token)
}
inline std::string* GetFragmentHistoryRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentHistoryRequest.page_token)
  return _s;
}
inline const std::string& GetFragmentHistoryRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void GetFragmentHistoryRequest::_internal_set_page_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentHistoryRequest::_internal_mutable_page_token() {
  _has_bits_[0] |= 0x00000001u;
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentHistoryRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentHistoryRequest.page_token)
  if (!_internal_has_page_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetFragmentHistoryRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentHistoryRequest.page_token)
}

// optional int64 page_limit = 3 [json_name = "pageLimit"];
inline bool GetFragmentHistoryRequest::_internal_has_page_limit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetFragmentHistoryRequest::has_page_limit() const {
  return _internal_has_page_limit();
}
inline void GetFragmentHistoryRequest::clear_page_limit() {
  page_limit_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t GetFragmentHistoryRequest::_internal_page_limit() const {
  return page_limit_;
}
inline int64_t GetFragmentHistoryRequest::page_limit() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentHistoryRequest.page_limit)
  return _internal_page_limit();
}
inline void GetFragmentHistoryRequest::_internal_set_page_limit(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  page_limit_ = value;
}
inline void GetFragmentHistoryRequest::set_page_limit(int64_t value) {
  _internal_set_page_limit(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentHistoryRequest.page_limit)
}

// -------------------------------------------------------------------

// GetFragmentHistoryResponse

// repeated .viam.app.v1.FragmentHistoryEntry history = 1 [json_name = "history"];
inline int GetFragmentHistoryResponse::_internal_history_size() const {
  return history_.size();
}
inline int GetFragmentHistoryResponse::history_size() const {
  return _internal_history_size();
}
inline void GetFragmentHistoryResponse::clear_history() {
  history_.Clear();
}
inline ::viam::app::v1::FragmentHistoryEntry* GetFragmentHistoryResponse::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentHistoryResponse.history)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentHistoryEntry >*
GetFragmentHistoryResponse::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetFragmentHistoryResponse.history)
  return &history_;
}
inline const ::viam::app::v1::FragmentHistoryEntry& GetFragmentHistoryResponse::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::viam::app::v1::FragmentHistoryEntry& GetFragmentHistoryResponse::history(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentHistoryResponse.history)
  return _internal_history(index);
}
inline ::viam::app::v1::FragmentHistoryEntry* GetFragmentHistoryResponse::_internal_add_history() {
  return history_.Add();
}
inline ::viam::app::v1::FragmentHistoryEntry* GetFragmentHistoryResponse::add_history() {
  ::viam::app::v1::FragmentHistoryEntry* _add = _internal_add_history();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetFragmentHistoryResponse.history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentHistoryEntry >&
GetFragmentHistoryResponse::history() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetFragmentHistoryResponse.history)
  return history_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void GetFragmentHistoryResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& GetFragmentHistoryResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentHistoryResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentHistoryResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentHistoryResponse.next_page_token)
}
inline std::string* GetFragmentHistoryResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentHistoryResponse.next_page_token)
  return _s;
}
inline const std::string& GetFragmentHistoryResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void GetFragmentHistoryResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentHistoryResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentHistoryResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentHistoryResponse.next_page_token)
  return next_page_token_.Release();
}
inline void GetFragmentHistoryResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentHistoryResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetFragmentUsageRequest

// string fragment_id = 1 [json_name = "fragmentId"];
inline void GetFragmentUsageRequest::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& GetFragmentUsageRequest::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentUsageRequest.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentUsageRequest::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentUsageRequest.fragment_id)
}
inline std::string* GetFragmentUsageRequest::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentUsageRequest.fragment_id)
  return _s;
}
inline const std::string& GetFragmentUsageRequest::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void GetFragmentUsageRequest::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentUsageRequest::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentUsageRequest::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentUsageRequest.fragment_id)
  return fragment_id_.Release();
}
inline void GetFragmentUsageRequest::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentUsageRequest.fragment_id)
}

// -------------------------------------------------------------------

// GetFragmentUsageResponse

// repeated .viam.app.v1.FragmentUsage version_usages = 1 [json_name = "versionUsages"];
inline int GetFragmentUsageResponse::_internal_version_usages_size() const {
  return version_usages_.size();
}
inline int GetFragmentUsageResponse::version_usages_size() const {
  return _internal_version_usages_size();
}
inline void GetFragmentUsageResponse::clear_version_usages() {
  version_usages_.Clear();
}
inline ::viam::app::v1::FragmentUsage* GetFragmentUsageResponse::mutable_version_usages(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentUsageResponse.version_usages)
  return version_usages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >*
GetFragmentUsageResponse::mutable_version_usages() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetFragmentUsageResponse.version_usages)
  return &version_usages_;
}
inline const ::viam::app::v1::FragmentUsage& GetFragmentUsageResponse::_internal_version_usages(int index) const {
  return version_usages_.Get(index);
}
inline const ::viam::app::v1::FragmentUsage& GetFragmentUsageResponse::version_usages(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentUsageResponse.version_usages)
  return _internal_version_usages(index);
}
inline ::viam::app::v1::FragmentUsage* GetFragmentUsageResponse::_internal_add_version_usages() {
  return version_usages_.Add();
}
inline ::viam::app::v1::FragmentUsage* GetFragmentUsageResponse::add_version_usages() {
  ::viam::app::v1::FragmentUsage* _add = _internal_add_version_usages();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetFragmentUsageResponse.version_usages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentUsage >&
GetFragmentUsageResponse::version_usages() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetFragmentUsageResponse.version_usages)
  return version_usages_;
}

// -------------------------------------------------------------------

// SetFragmentTagRequest

// string fragment_id = 1 [json_name = "fragmentId"];
inline void SetFragmentTagRequest::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& SetFragmentTagRequest::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SetFragmentTagRequest.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetFragmentTagRequest::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SetFragmentTagRequest.fragment_id)
}
inline std::string* SetFragmentTagRequest::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SetFragmentTagRequest.fragment_id)
  return _s;
}
inline const std::string& SetFragmentTagRequest::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void SetFragmentTagRequest::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetFragmentTagRequest::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetFragmentTagRequest::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SetFragmentTagRequest.fragment_id)
  return fragment_id_.Release();
}
inline void SetFragmentTagRequest::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SetFragmentTagRequest.fragment_id)
}

// string tag = 2 [json_name = "tag"];
inline void SetFragmentTagRequest::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& SetFragmentTagRequest::tag() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SetFragmentTagRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetFragmentTagRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SetFragmentTagRequest.tag)
}
inline std::string* SetFragmentTagRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SetFragmentTagRequest.tag)
  return _s;
}
inline const std::string& SetFragmentTagRequest::_internal_tag() const {
  return tag_.Get();
}
inline void SetFragmentTagRequest::_internal_set_tag(const std::string& value) {
  
  tag_.Set(value, GetArenaForAllocation());
}
inline std::string* SetFragmentTagRequest::_internal_mutable_tag() {
  
  return tag_.Mutable(GetArenaForAllocation());
}
inline std::string* SetFragmentTagRequest::release_tag() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SetFragmentTagRequest.tag)
  return tag_.Release();
}
inline void SetFragmentTagRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SetFragmentTagRequest.tag)
}

// string revision = 3 [json_name = "revision"];
inline void SetFragmentTagRequest::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& SetFragmentTagRequest::revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SetFragmentTagRequest.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetFragmentTagRequest::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SetFragmentTagRequest.revision)
}
inline std::string* SetFragmentTagRequest::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SetFragmentTagRequest.revision)
  return _s;
}
inline const std::string& SetFragmentTagRequest::_internal_revision() const {
  return revision_.Get();
}
inline void SetFragmentTagRequest::_internal_set_revision(const std::string& value) {
  
  revision_.Set(value, GetArenaForAllocation());
}
inline std::string* SetFragmentTagRequest::_internal_mutable_revision() {
  
  return revision_.Mutable(GetArenaForAllocation());
}
inline std::string* SetFragmentTagRequest::release_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SetFragmentTagRequest.revision)
  return revision_.Release();
}
inline void SetFragmentTagRequest::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault()) {
    revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SetFragmentTagRequest.revision)
}

// -------------------------------------------------------------------

// SetFragmentTagResponse

// repeated .viam.app.v1.FragmentTag tags = 1 [json_name = "tags"];
inline int SetFragmentTagResponse::_internal_tags_size() const {
  return tags_.size();
}
inline int SetFragmentTagResponse::tags_size() const {
  return _internal_tags_size();
}
inline void SetFragmentTagResponse::clear_tags() {
  tags_.Clear();
}
inline ::viam::app::v1::FragmentTag* SetFragmentTagResponse::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SetFragmentTagResponse.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >*
SetFragmentTagResponse::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.SetFragmentTagResponse.tags)
  return &tags_;
}
inline const ::viam::app::v1::FragmentTag& SetFragmentTagResponse::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::viam::app::v1::FragmentTag& SetFragmentTagResponse::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SetFragmentTagResponse.tags)
  return _internal_tags(index);
}
inline ::viam::app::v1::FragmentTag* SetFragmentTagResponse::_internal_add_tags() {
  return tags_.Add();
}
inline ::viam::app::v1::FragmentTag* SetFragmentTagResponse::add_tags() {
  ::viam::app::v1::FragmentTag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:viam.app.v1.SetFragmentTagResponse.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >&
SetFragmentTagResponse::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.SetFragmentTagResponse.tags)
  return tags_;
}

// -------------------------------------------------------------------

// DeleteFragmentTagRequest

// string fragment_id = 1 [json_name = "fragmentId"];
inline void DeleteFragmentTagRequest::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& DeleteFragmentTagRequest::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteFragmentTagRequest.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFragmentTagRequest::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteFragmentTagRequest.fragment_id)
}
inline std::string* DeleteFragmentTagRequest::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteFragmentTagRequest.fragment_id)
  return _s;
}
inline const std::string& DeleteFragmentTagRequest::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void DeleteFragmentTagRequest::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFragmentTagRequest::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFragmentTagRequest::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteFragmentTagRequest.fragment_id)
  return fragment_id_.Release();
}
inline void DeleteFragmentTagRequest::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteFragmentTagRequest.fragment_id)
}

// string tag = 2 [json_name = "tag"];
inline void DeleteFragmentTagRequest::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& DeleteFragmentTagRequest::tag() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteFragmentTagRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFragmentTagRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteFragmentTagRequest.tag)
}
inline std::string* DeleteFragmentTagRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteFragmentTagRequest.tag)
  return _s;
}
inline const std::string& DeleteFragmentTagRequest::_internal_tag() const {
  return tag_.Get();
}
inline void DeleteFragmentTagRequest::_internal_set_tag(const std::string& value) {
  
  tag_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFragmentTagRequest::_internal_mutable_tag() {
  
  return tag_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFragmentTagRequest::release_tag() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteFragmentTagRequest.tag)
  return tag_.Release();
}
inline void DeleteFragmentTagRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteFragmentTagRequest.tag)
}

// -------------------------------------------------------------------

// DeleteFragmentTagResponse

// repeated .viam.app.v1.FragmentTag tags = 1 [json_name = "tags"];
inline int DeleteFragmentTagResponse::_internal_tags_size() const {
  return tags_.size();
}
inline int DeleteFragmentTagResponse::tags_size() const {
  return _internal_tags_size();
}
inline void DeleteFragmentTagResponse::clear_tags() {
  tags_.Clear();
}
inline ::viam::app::v1::FragmentTag* DeleteFragmentTagResponse::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteFragmentTagResponse.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >*
DeleteFragmentTagResponse::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.DeleteFragmentTagResponse.tags)
  return &tags_;
}
inline const ::viam::app::v1::FragmentTag& DeleteFragmentTagResponse::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::viam::app::v1::FragmentTag& DeleteFragmentTagResponse::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteFragmentTagResponse.tags)
  return _internal_tags(index);
}
inline ::viam::app::v1::FragmentTag* DeleteFragmentTagResponse::_internal_add_tags() {
  return tags_.Add();
}
inline ::viam::app::v1::FragmentTag* DeleteFragmentTagResponse::add_tags() {
  ::viam::app::v1::FragmentTag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:viam.app.v1.DeleteFragmentTagResponse.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentTag >&
DeleteFragmentTagResponse::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.DeleteFragmentTagResponse.tags)
  return tags_;
}

// -------------------------------------------------------------------

// ListRobotsRequest

// string location_id = 1 [json_name = "locationId"];
inline void ListRobotsRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& ListRobotsRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRobotsRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRobotsRequest.location_id)
}
inline std::string* ListRobotsRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsRequest.location_id)
  return _s;
}
inline const std::string& ListRobotsRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void ListRobotsRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRobotsRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRobotsRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRobotsRequest.location_id)
  return location_id_.Release();
}
inline void ListRobotsRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRobotsRequest.location_id)
}

// -------------------------------------------------------------------

// ListRobotsForLocationsRequest

// repeated string location_ids = 1 [json_name = "locationIds"];
inline int ListRobotsForLocationsRequest::_internal_location_ids_size() const {
  return location_ids_.size();
}
inline int ListRobotsForLocationsRequest::location_ids_size() const {
  return _internal_location_ids_size();
}
inline void ListRobotsForLocationsRequest::clear_location_ids() {
  location_ids_.Clear();
}
inline std::string* ListRobotsForLocationsRequest::add_location_ids() {
  std::string* _s = _internal_add_location_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
  return _s;
}
inline const std::string& ListRobotsForLocationsRequest::_internal_location_ids(int index) const {
  return location_ids_.Get(index);
}
inline const std::string& ListRobotsForLocationsRequest::location_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
  return _internal_location_ids(index);
}
inline std::string* ListRobotsForLocationsRequest::mutable_location_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
  return location_ids_.Mutable(index);
}
inline void ListRobotsForLocationsRequest::set_location_ids(int index, const std::string& value) {
  location_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline void ListRobotsForLocationsRequest::set_location_ids(int index, std::string&& value) {
  location_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline void ListRobotsForLocationsRequest::set_location_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  location_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline void ListRobotsForLocationsRequest::set_location_ids(int index, const char* value, size_t size) {
  location_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline std::string* ListRobotsForLocationsRequest::_internal_add_location_ids() {
  return location_ids_.Add();
}
inline void ListRobotsForLocationsRequest::add_location_ids(const std::string& value) {
  location_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline void ListRobotsForLocationsRequest::add_location_ids(std::string&& value) {
  location_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline void ListRobotsForLocationsRequest::add_location_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  location_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline void ListRobotsForLocationsRequest::add_location_ids(const char* value, size_t size) {
  location_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRobotsForLocationsRequest::location_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
  return location_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRobotsForLocationsRequest::mutable_location_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRobotsForLocationsRequest.location_ids)
  return &location_ids_;
}

// -------------------------------------------------------------------

// ListRobotsForOrgRequest

// string org_id = 1 [json_name = "orgId"];
inline void ListRobotsForOrgRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& ListRobotsForOrgRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsForOrgRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRobotsForOrgRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRobotsForOrgRequest.org_id)
}
inline std::string* ListRobotsForOrgRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsForOrgRequest.org_id)
  return _s;
}
inline const std::string& ListRobotsForOrgRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void ListRobotsForOrgRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRobotsForOrgRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRobotsForOrgRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRobotsForOrgRequest.org_id)
  return org_id_.Release();
}
inline void ListRobotsForOrgRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRobotsForOrgRequest.org_id)
}

// -------------------------------------------------------------------

// AdditionalFragment

// string fragment_id = 1 [json_name = "fragmentId"];
inline void AdditionalFragment::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
}
inline const std::string& AdditionalFragment::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AdditionalFragment.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdditionalFragment::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AdditionalFragment.fragment_id)
}
inline std::string* AdditionalFragment::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AdditionalFragment.fragment_id)
  return _s;
}
inline const std::string& AdditionalFragment::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void AdditionalFragment::_internal_set_fragment_id(const std::string& value) {
  
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AdditionalFragment::_internal_mutable_fragment_id() {
  
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AdditionalFragment::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AdditionalFragment.fragment_id)
  return fragment_id_.Release();
}
inline void AdditionalFragment::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    
  } else {
    
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AdditionalFragment.fragment_id)
}

// optional string version = 2 [json_name = "version"];
inline bool AdditionalFragment::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdditionalFragment::has_version() const {
  return _internal_has_version();
}
inline void AdditionalFragment::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdditionalFragment::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AdditionalFragment.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdditionalFragment::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AdditionalFragment.version)
}
inline std::string* AdditionalFragment::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AdditionalFragment.version)
  return _s;
}
inline const std::string& AdditionalFragment::_internal_version() const {
  return version_.Get();
}
inline void AdditionalFragment::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* AdditionalFragment::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* AdditionalFragment::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AdditionalFragment.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdditionalFragment::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AdditionalFragment.version)
}

// -------------------------------------------------------------------

// ListNestedFragmentsRequest

// optional string fragment_id = 1 [json_name = "fragmentId"];
inline bool ListNestedFragmentsRequest::_internal_has_fragment_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListNestedFragmentsRequest::has_fragment_id() const {
  return _internal_has_fragment_id();
}
inline void ListNestedFragmentsRequest::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListNestedFragmentsRequest::fragment_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListNestedFragmentsRequest.fragment_id)
  return _internal_fragment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNestedFragmentsRequest::set_fragment_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 fragment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListNestedFragmentsRequest.fragment_id)
}
inline std::string* ListNestedFragmentsRequest::mutable_fragment_id() {
  std::string* _s = _internal_mutable_fragment_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListNestedFragmentsRequest.fragment_id)
  return _s;
}
inline const std::string& ListNestedFragmentsRequest::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void ListNestedFragmentsRequest::_internal_set_fragment_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  fragment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNestedFragmentsRequest::_internal_mutable_fragment_id() {
  _has_bits_[0] |= 0x00000001u;
  return fragment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNestedFragmentsRequest::release_fragment_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListNestedFragmentsRequest.fragment_id)
  if (!_internal_has_fragment_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = fragment_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListNestedFragmentsRequest::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fragment_id_.SetAllocated(fragment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fragment_id_.IsDefault()) {
    fragment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListNestedFragmentsRequest.fragment_id)
}

// repeated .viam.app.v1.AdditionalFragment additional_fragments = 2 [json_name = "additionalFragments"];
inline int ListNestedFragmentsRequest::_internal_additional_fragments_size() const {
  return additional_fragments_.size();
}
inline int ListNestedFragmentsRequest::additional_fragments_size() const {
  return _internal_additional_fragments_size();
}
inline void ListNestedFragmentsRequest::clear_additional_fragments() {
  additional_fragments_.Clear();
}
inline ::viam::app::v1::AdditionalFragment* ListNestedFragmentsRequest::mutable_additional_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListNestedFragmentsRequest.additional_fragments)
  return additional_fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >*
ListNestedFragmentsRequest::mutable_additional_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListNestedFragmentsRequest.additional_fragments)
  return &additional_fragments_;
}
inline const ::viam::app::v1::AdditionalFragment& ListNestedFragmentsRequest::_internal_additional_fragments(int index) const {
  return additional_fragments_.Get(index);
}
inline const ::viam::app::v1::AdditionalFragment& ListNestedFragmentsRequest::additional_fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListNestedFragmentsRequest.additional_fragments)
  return _internal_additional_fragments(index);
}
inline ::viam::app::v1::AdditionalFragment* ListNestedFragmentsRequest::_internal_add_additional_fragments() {
  return additional_fragments_.Add();
}
inline ::viam::app::v1::AdditionalFragment* ListNestedFragmentsRequest::add_additional_fragments() {
  ::viam::app::v1::AdditionalFragment* _add = _internal_add_additional_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListNestedFragmentsRequest.additional_fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >&
ListNestedFragmentsRequest::additional_fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListNestedFragmentsRequest.additional_fragments)
  return additional_fragments_;
}

// -------------------------------------------------------------------

// ListNestedFragmentsResponse

// repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
inline int ListNestedFragmentsResponse::_internal_fragments_size() const {
  return fragments_.size();
}
inline int ListNestedFragmentsResponse::fragments_size() const {
  return _internal_fragments_size();
}
inline void ListNestedFragmentsResponse::clear_fragments() {
  fragments_.Clear();
}
inline ::viam::app::v1::Fragment* ListNestedFragmentsResponse::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListNestedFragmentsResponse.fragments)
  return fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
ListNestedFragmentsResponse::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListNestedFragmentsResponse.fragments)
  return &fragments_;
}
inline const ::viam::app::v1::Fragment& ListNestedFragmentsResponse::_internal_fragments(int index) const {
  return fragments_.Get(index);
}
inline const ::viam::app::v1::Fragment& ListNestedFragmentsResponse::fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListNestedFragmentsResponse.fragments)
  return _internal_fragments(index);
}
inline ::viam::app::v1::Fragment* ListNestedFragmentsResponse::_internal_add_fragments() {
  return fragments_.Add();
}
inline ::viam::app::v1::Fragment* ListNestedFragmentsResponse::add_fragments() {
  ::viam::app::v1::Fragment* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListNestedFragmentsResponse.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
ListNestedFragmentsResponse::fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListNestedFragmentsResponse.fragments)
  return fragments_;
}

// repeated .viam.app.v1.ResolvedFragment resolved_fragments = 2 [json_name = "resolvedFragments"];
inline int ListNestedFragmentsResponse::_internal_resolved_fragments_size() const {
  return resolved_fragments_.size();
}
inline int ListNestedFragmentsResponse::resolved_fragments_size() const {
  return _internal_resolved_fragments_size();
}
inline void ListNestedFragmentsResponse::clear_resolved_fragments() {
  resolved_fragments_.Clear();
}
inline ::viam::app::v1::ResolvedFragment* ListNestedFragmentsResponse::mutable_resolved_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListNestedFragmentsResponse.resolved_fragments)
  return resolved_fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >*
ListNestedFragmentsResponse::mutable_resolved_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListNestedFragmentsResponse.resolved_fragments)
  return &resolved_fragments_;
}
inline const ::viam::app::v1::ResolvedFragment& ListNestedFragmentsResponse::_internal_resolved_fragments(int index) const {
  return resolved_fragments_.Get(index);
}
inline const ::viam::app::v1::ResolvedFragment& ListNestedFragmentsResponse::resolved_fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListNestedFragmentsResponse.resolved_fragments)
  return _internal_resolved_fragments(index);
}
inline ::viam::app::v1::ResolvedFragment* ListNestedFragmentsResponse::_internal_add_resolved_fragments() {
  return resolved_fragments_.Add();
}
inline ::viam::app::v1::ResolvedFragment* ListNestedFragmentsResponse::add_resolved_fragments() {
  ::viam::app::v1::ResolvedFragment* _add = _internal_add_resolved_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListNestedFragmentsResponse.resolved_fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >&
ListNestedFragmentsResponse::resolved_fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListNestedFragmentsResponse.resolved_fragments)
  return resolved_fragments_;
}

// -------------------------------------------------------------------

// ListMachineFragmentsRequest

// string machine_id = 1 [json_name = "machineId"];
inline void ListMachineFragmentsRequest::clear_machine_id() {
  machine_id_.ClearToEmpty();
}
inline const std::string& ListMachineFragmentsRequest::machine_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineFragmentsRequest.machine_id)
  return _internal_machine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMachineFragmentsRequest::set_machine_id(ArgT0&& arg0, ArgT... args) {
 
 machine_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineFragmentsRequest.machine_id)
}
inline std::string* ListMachineFragmentsRequest::mutable_machine_id() {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineFragmentsRequest.machine_id)
  return _s;
}
inline const std::string& ListMachineFragmentsRequest::_internal_machine_id() const {
  return machine_id_.Get();
}
inline void ListMachineFragmentsRequest::_internal_set_machine_id(const std::string& value) {
  
  machine_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMachineFragmentsRequest::_internal_mutable_machine_id() {
  
  return machine_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMachineFragmentsRequest::release_machine_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListMachineFragmentsRequest.machine_id)
  return machine_id_.Release();
}
inline void ListMachineFragmentsRequest::set_allocated_machine_id(std::string* machine_id) {
  if (machine_id != nullptr) {
    
  } else {
    
  }
  machine_id_.SetAllocated(machine_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (machine_id_.IsDefault()) {
    machine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListMachineFragmentsRequest.machine_id)
}

// repeated string additional_fragment_ids = 2 [json_name = "additionalFragmentIds"];
inline int ListMachineFragmentsRequest::_internal_additional_fragment_ids_size() const {
  return additional_fragment_ids_.size();
}
inline int ListMachineFragmentsRequest::additional_fragment_ids_size() const {
  return _internal_additional_fragment_ids_size();
}
inline void ListMachineFragmentsRequest::clear_additional_fragment_ids() {
  additional_fragment_ids_.Clear();
}
inline std::string* ListMachineFragmentsRequest::add_additional_fragment_ids() {
  std::string* _s = _internal_add_additional_fragment_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
  return _s;
}
inline const std::string& ListMachineFragmentsRequest::_internal_additional_fragment_ids(int index) const {
  return additional_fragment_ids_.Get(index);
}
inline const std::string& ListMachineFragmentsRequest::additional_fragment_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
  return _internal_additional_fragment_ids(index);
}
inline std::string* ListMachineFragmentsRequest::mutable_additional_fragment_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
  return additional_fragment_ids_.Mutable(index);
}
inline void ListMachineFragmentsRequest::set_additional_fragment_ids(int index, const std::string& value) {
  additional_fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline void ListMachineFragmentsRequest::set_additional_fragment_ids(int index, std::string&& value) {
  additional_fragment_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline void ListMachineFragmentsRequest::set_additional_fragment_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline void ListMachineFragmentsRequest::set_additional_fragment_ids(int index, const char* value, size_t size) {
  additional_fragment_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline std::string* ListMachineFragmentsRequest::_internal_add_additional_fragment_ids() {
  return additional_fragment_ids_.Add();
}
inline void ListMachineFragmentsRequest::add_additional_fragment_ids(const std::string& value) {
  additional_fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline void ListMachineFragmentsRequest::add_additional_fragment_ids(std::string&& value) {
  additional_fragment_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline void ListMachineFragmentsRequest::add_additional_fragment_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline void ListMachineFragmentsRequest::add_additional_fragment_ids(const char* value, size_t size) {
  additional_fragment_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListMachineFragmentsRequest::additional_fragment_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
  return additional_fragment_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListMachineFragmentsRequest::mutable_additional_fragment_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListMachineFragmentsRequest.additional_fragment_ids)
  return &additional_fragment_ids_;
}

// repeated .viam.app.v1.AdditionalFragment additional_fragments = 3 [json_name = "additionalFragments"];
inline int ListMachineFragmentsRequest::_internal_additional_fragments_size() const {
  return additional_fragments_.size();
}
inline int ListMachineFragmentsRequest::additional_fragments_size() const {
  return _internal_additional_fragments_size();
}
inline void ListMachineFragmentsRequest::clear_additional_fragments() {
  additional_fragments_.Clear();
}
inline ::viam::app::v1::AdditionalFragment* ListMachineFragmentsRequest::mutable_additional_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineFragmentsRequest.additional_fragments)
  return additional_fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >*
ListMachineFragmentsRequest::mutable_additional_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListMachineFragmentsRequest.additional_fragments)
  return &additional_fragments_;
}
inline const ::viam::app::v1::AdditionalFragment& ListMachineFragmentsRequest::_internal_additional_fragments(int index) const {
  return additional_fragments_.Get(index);
}
inline const ::viam::app::v1::AdditionalFragment& ListMachineFragmentsRequest::additional_fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineFragmentsRequest.additional_fragments)
  return _internal_additional_fragments(index);
}
inline ::viam::app::v1::AdditionalFragment* ListMachineFragmentsRequest::_internal_add_additional_fragments() {
  return additional_fragments_.Add();
}
inline ::viam::app::v1::AdditionalFragment* ListMachineFragmentsRequest::add_additional_fragments() {
  ::viam::app::v1::AdditionalFragment* _add = _internal_add_additional_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineFragmentsRequest.additional_fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AdditionalFragment >&
ListMachineFragmentsRequest::additional_fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListMachineFragmentsRequest.additional_fragments)
  return additional_fragments_;
}

// -------------------------------------------------------------------

// ListMachineFragmentsResponse

// repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
inline int ListMachineFragmentsResponse::_internal_fragments_size() const {
  return fragments_.size();
}
inline int ListMachineFragmentsResponse::fragments_size() const {
  return _internal_fragments_size();
}
inline void ListMachineFragmentsResponse::clear_fragments() {
  fragments_.Clear();
}
inline ::viam::app::v1::Fragment* ListMachineFragmentsResponse::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineFragmentsResponse.fragments)
  return fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
ListMachineFragmentsResponse::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListMachineFragmentsResponse.fragments)
  return &fragments_;
}
inline const ::viam::app::v1::Fragment& ListMachineFragmentsResponse::_internal_fragments(int index) const {
  return fragments_.Get(index);
}
inline const ::viam::app::v1::Fragment& ListMachineFragmentsResponse::fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineFragmentsResponse.fragments)
  return _internal_fragments(index);
}
inline ::viam::app::v1::Fragment* ListMachineFragmentsResponse::_internal_add_fragments() {
  return fragments_.Add();
}
inline ::viam::app::v1::Fragment* ListMachineFragmentsResponse::add_fragments() {
  ::viam::app::v1::Fragment* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineFragmentsResponse.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
ListMachineFragmentsResponse::fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListMachineFragmentsResponse.fragments)
  return fragments_;
}

// repeated .viam.app.v1.ResolvedFragment resolved_fragments = 2 [json_name = "resolvedFragments"];
inline int ListMachineFragmentsResponse::_internal_resolved_fragments_size() const {
  return resolved_fragments_.size();
}
inline int ListMachineFragmentsResponse::resolved_fragments_size() const {
  return _internal_resolved_fragments_size();
}
inline void ListMachineFragmentsResponse::clear_resolved_fragments() {
  resolved_fragments_.Clear();
}
inline ::viam::app::v1::ResolvedFragment* ListMachineFragmentsResponse::mutable_resolved_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineFragmentsResponse.resolved_fragments)
  return resolved_fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >*
ListMachineFragmentsResponse::mutable_resolved_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListMachineFragmentsResponse.resolved_fragments)
  return &resolved_fragments_;
}
inline const ::viam::app::v1::ResolvedFragment& ListMachineFragmentsResponse::_internal_resolved_fragments(int index) const {
  return resolved_fragments_.Get(index);
}
inline const ::viam::app::v1::ResolvedFragment& ListMachineFragmentsResponse::resolved_fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineFragmentsResponse.resolved_fragments)
  return _internal_resolved_fragments(index);
}
inline ::viam::app::v1::ResolvedFragment* ListMachineFragmentsResponse::_internal_add_resolved_fragments() {
  return resolved_fragments_.Add();
}
inline ::viam::app::v1::ResolvedFragment* ListMachineFragmentsResponse::add_resolved_fragments() {
  ::viam::app::v1::ResolvedFragment* _add = _internal_add_resolved_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineFragmentsResponse.resolved_fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResolvedFragment >&
ListMachineFragmentsResponse::resolved_fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListMachineFragmentsResponse.resolved_fragments)
  return resolved_fragments_;
}

// -------------------------------------------------------------------

// ListMachineSummariesRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListMachineSummariesRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListMachineSummariesRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineSummariesRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMachineSummariesRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineSummariesRequest.organization_id)
}
inline std::string* ListMachineSummariesRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineSummariesRequest.organization_id)
  return _s;
}
inline const std::string& ListMachineSummariesRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListMachineSummariesRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMachineSummariesRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMachineSummariesRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListMachineSummariesRequest.organization_id)
  return organization_id_.Release();
}
inline void ListMachineSummariesRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListMachineSummariesRequest.organization_id)
}

// repeated string fragment_ids = 2 [json_name = "fragmentIds"];
inline int ListMachineSummariesRequest::_internal_fragment_ids_size() const {
  return fragment_ids_.size();
}
inline int ListMachineSummariesRequest::fragment_ids_size() const {
  return _internal_fragment_ids_size();
}
inline void ListMachineSummariesRequest::clear_fragment_ids() {
  fragment_ids_.Clear();
}
inline std::string* ListMachineSummariesRequest::add_fragment_ids() {
  std::string* _s = _internal_add_fragment_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
  return _s;
}
inline const std::string& ListMachineSummariesRequest::_internal_fragment_ids(int index) const {
  return fragment_ids_.Get(index);
}
inline const std::string& ListMachineSummariesRequest::fragment_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
  return _internal_fragment_ids(index);
}
inline std::string* ListMachineSummariesRequest::mutable_fragment_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
  return fragment_ids_.Mutable(index);
}
inline void ListMachineSummariesRequest::set_fragment_ids(int index, const std::string& value) {
  fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline void ListMachineSummariesRequest::set_fragment_ids(int index, std::string&& value) {
  fragment_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline void ListMachineSummariesRequest::set_fragment_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline void ListMachineSummariesRequest::set_fragment_ids(int index, const char* value, size_t size) {
  fragment_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline std::string* ListMachineSummariesRequest::_internal_add_fragment_ids() {
  return fragment_ids_.Add();
}
inline void ListMachineSummariesRequest::add_fragment_ids(const std::string& value) {
  fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline void ListMachineSummariesRequest::add_fragment_ids(std::string&& value) {
  fragment_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline void ListMachineSummariesRequest::add_fragment_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline void ListMachineSummariesRequest::add_fragment_ids(const char* value, size_t size) {
  fragment_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListMachineSummariesRequest::fragment_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
  return fragment_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListMachineSummariesRequest::mutable_fragment_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListMachineSummariesRequest.fragment_ids)
  return &fragment_ids_;
}

// repeated string location_ids = 3 [json_name = "locationIds"];
inline int ListMachineSummariesRequest::_internal_location_ids_size() const {
  return location_ids_.size();
}
inline int ListMachineSummariesRequest::location_ids_size() const {
  return _internal_location_ids_size();
}
inline void ListMachineSummariesRequest::clear_location_ids() {
  location_ids_.Clear();
}
inline std::string* ListMachineSummariesRequest::add_location_ids() {
  std::string* _s = _internal_add_location_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListMachineSummariesRequest.location_ids)
  return _s;
}
inline const std::string& ListMachineSummariesRequest::_internal_location_ids(int index) const {
  return location_ids_.Get(index);
}
inline const std::string& ListMachineSummariesRequest::location_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineSummariesRequest.location_ids)
  return _internal_location_ids(index);
}
inline std::string* ListMachineSummariesRequest::mutable_location_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineSummariesRequest.location_ids)
  return location_ids_.Mutable(index);
}
inline void ListMachineSummariesRequest::set_location_ids(int index, const std::string& value) {
  location_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline void ListMachineSummariesRequest::set_location_ids(int index, std::string&& value) {
  location_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline void ListMachineSummariesRequest::set_location_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  location_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline void ListMachineSummariesRequest::set_location_ids(int index, const char* value, size_t size) {
  location_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline std::string* ListMachineSummariesRequest::_internal_add_location_ids() {
  return location_ids_.Add();
}
inline void ListMachineSummariesRequest::add_location_ids(const std::string& value) {
  location_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline void ListMachineSummariesRequest::add_location_ids(std::string&& value) {
  location_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline void ListMachineSummariesRequest::add_location_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  location_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline void ListMachineSummariesRequest::add_location_ids(const char* value, size_t size) {
  location_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListMachineSummariesRequest.location_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListMachineSummariesRequest::location_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListMachineSummariesRequest.location_ids)
  return location_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListMachineSummariesRequest::mutable_location_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListMachineSummariesRequest.location_ids)
  return &location_ids_;
}

// optional int32 limit = 4 [json_name = "limit"];
inline bool ListMachineSummariesRequest::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListMachineSummariesRequest::has_limit() const {
  return _internal_has_limit();
}
inline void ListMachineSummariesRequest::clear_limit() {
  limit_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ListMachineSummariesRequest::_internal_limit() const {
  return limit_;
}
inline int32_t ListMachineSummariesRequest::limit() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineSummariesRequest.limit)
  return _internal_limit();
}
inline void ListMachineSummariesRequest::_internal_set_limit(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  limit_ = value;
}
inline void ListMachineSummariesRequest::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListMachineSummariesRequest.limit)
}

// -------------------------------------------------------------------

// ListMachineSummariesResponse

// repeated .viam.app.v1.LocationSummary location_summaries = 1 [json_name = "locationSummaries"];
inline int ListMachineSummariesResponse::_internal_location_summaries_size() const {
  return location_summaries_.size();
}
inline int ListMachineSummariesResponse::location_summaries_size() const {
  return _internal_location_summaries_size();
}
inline void ListMachineSummariesResponse::clear_location_summaries() {
  location_summaries_.Clear();
}
inline ::viam::app::v1::LocationSummary* ListMachineSummariesResponse::mutable_location_summaries(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListMachineSummariesResponse.location_summaries)
  return location_summaries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSummary >*
ListMachineSummariesResponse::mutable_location_summaries() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListMachineSummariesResponse.location_summaries)
  return &location_summaries_;
}
inline const ::viam::app::v1::LocationSummary& ListMachineSummariesResponse::_internal_location_summaries(int index) const {
  return location_summaries_.Get(index);
}
inline const ::viam::app::v1::LocationSummary& ListMachineSummariesResponse::location_summaries(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListMachineSummariesResponse.location_summaries)
  return _internal_location_summaries(index);
}
inline ::viam::app::v1::LocationSummary* ListMachineSummariesResponse::_internal_add_location_summaries() {
  return location_summaries_.Add();
}
inline ::viam::app::v1::LocationSummary* ListMachineSummariesResponse::add_location_summaries() {
  ::viam::app::v1::LocationSummary* _add = _internal_add_location_summaries();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListMachineSummariesResponse.location_summaries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSummary >&
ListMachineSummariesResponse::location_summaries() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListMachineSummariesResponse.location_summaries)
  return location_summaries_;
}

// -------------------------------------------------------------------

// LocationSummary

// string location_id = 1 [json_name = "locationId"];
inline void LocationSummary::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& LocationSummary::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationSummary.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationSummary::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationSummary.location_id)
}
inline std::string* LocationSummary::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationSummary.location_id)
  return _s;
}
inline const std::string& LocationSummary::_internal_location_id() const {
  return location_id_.Get();
}
inline void LocationSummary::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationSummary::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationSummary::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationSummary.location_id)
  return location_id_.Release();
}
inline void LocationSummary::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationSummary.location_id)
}

// string location_name = 2 [json_name = "locationName"];
inline void LocationSummary::clear_location_name() {
  location_name_.ClearToEmpty();
}
inline const std::string& LocationSummary::location_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationSummary.location_name)
  return _internal_location_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationSummary::set_location_name(ArgT0&& arg0, ArgT... args) {
 
 location_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationSummary.location_name)
}
inline std::string* LocationSummary::mutable_location_name() {
  std::string* _s = _internal_mutable_location_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationSummary.location_name)
  return _s;
}
inline const std::string& LocationSummary::_internal_location_name() const {
  return location_name_.Get();
}
inline void LocationSummary::_internal_set_location_name(const std::string& value) {
  
  location_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationSummary::_internal_mutable_location_name() {
  
  return location_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationSummary::release_location_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationSummary.location_name)
  return location_name_.Release();
}
inline void LocationSummary::set_allocated_location_name(std::string* location_name) {
  if (location_name != nullptr) {
    
  } else {
    
  }
  location_name_.SetAllocated(location_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_name_.IsDefault()) {
    location_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationSummary.location_name)
}

// repeated .viam.app.v1.MachineSummary machine_summaries = 3 [json_name = "machineSummaries"];
inline int LocationSummary::_internal_machine_summaries_size() const {
  return machine_summaries_.size();
}
inline int LocationSummary::machine_summaries_size() const {
  return _internal_machine_summaries_size();
}
inline void LocationSummary::clear_machine_summaries() {
  machine_summaries_.Clear();
}
inline ::viam::app::v1::MachineSummary* LocationSummary::mutable_machine_summaries(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationSummary.machine_summaries)
  return machine_summaries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MachineSummary >*
LocationSummary::mutable_machine_summaries() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.LocationSummary.machine_summaries)
  return &machine_summaries_;
}
inline const ::viam::app::v1::MachineSummary& LocationSummary::_internal_machine_summaries(int index) const {
  return machine_summaries_.Get(index);
}
inline const ::viam::app::v1::MachineSummary& LocationSummary::machine_summaries(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationSummary.machine_summaries)
  return _internal_machine_summaries(index);
}
inline ::viam::app::v1::MachineSummary* LocationSummary::_internal_add_machine_summaries() {
  return machine_summaries_.Add();
}
inline ::viam::app::v1::MachineSummary* LocationSummary::add_machine_summaries() {
  ::viam::app::v1::MachineSummary* _add = _internal_add_machine_summaries();
  // @@protoc_insertion_point(field_add:viam.app.v1.LocationSummary.machine_summaries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MachineSummary >&
LocationSummary::machine_summaries() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.LocationSummary.machine_summaries)
  return machine_summaries_;
}

// -------------------------------------------------------------------

// MachineSummary

// string machine_id = 1 [json_name = "machineId"];
inline void MachineSummary::clear_machine_id() {
  machine_id_.ClearToEmpty();
}
inline const std::string& MachineSummary::machine_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MachineSummary.machine_id)
  return _internal_machine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MachineSummary::set_machine_id(ArgT0&& arg0, ArgT... args) {
 
 machine_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MachineSummary.machine_id)
}
inline std::string* MachineSummary::mutable_machine_id() {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MachineSummary.machine_id)
  return _s;
}
inline const std::string& MachineSummary::_internal_machine_id() const {
  return machine_id_.Get();
}
inline void MachineSummary::_internal_set_machine_id(const std::string& value) {
  
  machine_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MachineSummary::_internal_mutable_machine_id() {
  
  return machine_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MachineSummary::release_machine_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MachineSummary.machine_id)
  return machine_id_.Release();
}
inline void MachineSummary::set_allocated_machine_id(std::string* machine_id) {
  if (machine_id != nullptr) {
    
  } else {
    
  }
  machine_id_.SetAllocated(machine_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (machine_id_.IsDefault()) {
    machine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MachineSummary.machine_id)
}

// string machine_name = 2 [json_name = "machineName"];
inline void MachineSummary::clear_machine_name() {
  machine_name_.ClearToEmpty();
}
inline const std::string& MachineSummary::machine_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MachineSummary.machine_name)
  return _internal_machine_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MachineSummary::set_machine_name(ArgT0&& arg0, ArgT... args) {
 
 machine_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MachineSummary.machine_name)
}
inline std::string* MachineSummary::mutable_machine_name() {
  std::string* _s = _internal_mutable_machine_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MachineSummary.machine_name)
  return _s;
}
inline const std::string& MachineSummary::_internal_machine_name() const {
  return machine_name_.Get();
}
inline void MachineSummary::_internal_set_machine_name(const std::string& value) {
  
  machine_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MachineSummary::_internal_mutable_machine_name() {
  
  return machine_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MachineSummary::release_machine_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MachineSummary.machine_name)
  return machine_name_.Release();
}
inline void MachineSummary::set_allocated_machine_name(std::string* machine_name) {
  if (machine_name != nullptr) {
    
  } else {
    
  }
  machine_name_.SetAllocated(machine_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (machine_name_.IsDefault()) {
    machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MachineSummary.machine_name)
}

// repeated .viam.app.v1.PartSummary part_summaries = 3 [json_name = "partSummaries"];
inline int MachineSummary::_internal_part_summaries_size() const {
  return part_summaries_.size();
}
inline int MachineSummary::part_summaries_size() const {
  return _internal_part_summaries_size();
}
inline void MachineSummary::clear_part_summaries() {
  part_summaries_.Clear();
}
inline ::viam::app::v1::PartSummary* MachineSummary::mutable_part_summaries(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MachineSummary.part_summaries)
  return part_summaries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PartSummary >*
MachineSummary::mutable_part_summaries() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.MachineSummary.part_summaries)
  return &part_summaries_;
}
inline const ::viam::app::v1::PartSummary& MachineSummary::_internal_part_summaries(int index) const {
  return part_summaries_.Get(index);
}
inline const ::viam::app::v1::PartSummary& MachineSummary::part_summaries(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MachineSummary.part_summaries)
  return _internal_part_summaries(index);
}
inline ::viam::app::v1::PartSummary* MachineSummary::_internal_add_part_summaries() {
  return part_summaries_.Add();
}
inline ::viam::app::v1::PartSummary* MachineSummary::add_part_summaries() {
  ::viam::app::v1::PartSummary* _add = _internal_add_part_summaries();
  // @@protoc_insertion_point(field_add:viam.app.v1.MachineSummary.part_summaries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PartSummary >&
MachineSummary::part_summaries() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.MachineSummary.part_summaries)
  return part_summaries_;
}

// -------------------------------------------------------------------

// FragmentSummary

// string id = 1 [json_name = "id"];
inline void FragmentSummary::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& FragmentSummary::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentSummary.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentSummary::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentSummary.id)
}
inline std::string* FragmentSummary::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentSummary.id)
  return _s;
}
inline const std::string& FragmentSummary::_internal_id() const {
  return id_.Get();
}
inline void FragmentSummary::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentSummary::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentSummary::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentSummary.id)
  return id_.Release();
}
inline void FragmentSummary::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentSummary.id)
}

// string name = 3 [json_name = "name"];
inline void FragmentSummary::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FragmentSummary::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FragmentSummary.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FragmentSummary::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FragmentSummary.name)
}
inline std::string* FragmentSummary::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FragmentSummary.name)
  return _s;
}
inline const std::string& FragmentSummary::_internal_name() const {
  return name_.Get();
}
inline void FragmentSummary::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* FragmentSummary::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* FragmentSummary::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FragmentSummary.name)
  return name_.Release();
}
inline void FragmentSummary::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FragmentSummary.name)
}

// -------------------------------------------------------------------

// ViamServerVersion

// string major = 1 [json_name = "major"];
inline bool ViamServerVersion::_internal_has_major() const {
  return version_case() == kMajor;
}
inline bool ViamServerVersion::has_major() const {
  return _internal_has_major();
}
inline void ViamServerVersion::set_has_major() {
  _oneof_case_[0] = kMajor;
}
inline void ViamServerVersion::clear_major() {
  if (_internal_has_major()) {
    version_.major_.Destroy();
    clear_has_version();
  }
}
inline const std::string& ViamServerVersion::major() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ViamServerVersion.major)
  return _internal_major();
}
template <typename ArgT0, typename... ArgT>
inline void ViamServerVersion::set_major(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_major()) {
    clear_version();
    set_has_major();
    version_.major_.InitDefault();
  }
  version_.major_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ViamServerVersion.major)
}
inline std::string* ViamServerVersion::mutable_major() {
  std::string* _s = _internal_mutable_major();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ViamServerVersion.major)
  return _s;
}
inline const std::string& ViamServerVersion::_internal_major() const {
  if (_internal_has_major()) {
    return version_.major_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ViamServerVersion::_internal_set_major(const std::string& value) {
  if (!_internal_has_major()) {
    clear_version();
    set_has_major();
    version_.major_.InitDefault();
  }
  version_.major_.Set(value, GetArenaForAllocation());
}
inline std::string* ViamServerVersion::_internal_mutable_major() {
  if (!_internal_has_major()) {
    clear_version();
    set_has_major();
    version_.major_.InitDefault();
  }
  return version_.major_.Mutable(      GetArenaForAllocation());
}
inline std::string* ViamServerVersion::release_major() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ViamServerVersion.major)
  if (_internal_has_major()) {
    clear_has_version();
    return version_.major_.Release();
  } else {
    return nullptr;
  }
}
inline void ViamServerVersion::set_allocated_major(std::string* major) {
  if (has_version()) {
    clear_version();
  }
  if (major != nullptr) {
    set_has_major();
    version_.major_.InitAllocated(major, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ViamServerVersion.major)
}

// string minor = 2 [json_name = "minor"];
inline bool ViamServerVersion::_internal_has_minor() const {
  return version_case() == kMinor;
}
inline bool ViamServerVersion::has_minor() const {
  return _internal_has_minor();
}
inline void ViamServerVersion::set_has_minor() {
  _oneof_case_[0] = kMinor;
}
inline void ViamServerVersion::clear_minor() {
  if (_internal_has_minor()) {
    version_.minor_.Destroy();
    clear_has_version();
  }
}
inline const std::string& ViamServerVersion::minor() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ViamServerVersion.minor)
  return _internal_minor();
}
template <typename ArgT0, typename... ArgT>
inline void ViamServerVersion::set_minor(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_minor()) {
    clear_version();
    set_has_minor();
    version_.minor_.InitDefault();
  }
  version_.minor_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ViamServerVersion.minor)
}
inline std::string* ViamServerVersion::mutable_minor() {
  std::string* _s = _internal_mutable_minor();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ViamServerVersion.minor)
  return _s;
}
inline const std::string& ViamServerVersion::_internal_minor() const {
  if (_internal_has_minor()) {
    return version_.minor_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ViamServerVersion::_internal_set_minor(const std::string& value) {
  if (!_internal_has_minor()) {
    clear_version();
    set_has_minor();
    version_.minor_.InitDefault();
  }
  version_.minor_.Set(value, GetArenaForAllocation());
}
inline std::string* ViamServerVersion::_internal_mutable_minor() {
  if (!_internal_has_minor()) {
    clear_version();
    set_has_minor();
    version_.minor_.InitDefault();
  }
  return version_.minor_.Mutable(      GetArenaForAllocation());
}
inline std::string* ViamServerVersion::release_minor() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ViamServerVersion.minor)
  if (_internal_has_minor()) {
    clear_has_version();
    return version_.minor_.Release();
  } else {
    return nullptr;
  }
}
inline void ViamServerVersion::set_allocated_minor(std::string* minor) {
  if (has_version()) {
    clear_version();
  }
  if (minor != nullptr) {
    set_has_minor();
    version_.minor_.InitAllocated(minor, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ViamServerVersion.minor)
}

inline bool ViamServerVersion::has_version() const {
  return version_case() != VERSION_NOT_SET;
}
inline void ViamServerVersion::clear_has_version() {
  _oneof_case_[0] = VERSION_NOT_SET;
}
inline ViamServerVersion::VersionCase ViamServerVersion::version_case() const {
  return ViamServerVersion::VersionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ViamAgentVersion

// string major = 1 [json_name = "major"];
inline bool ViamAgentVersion::_internal_has_major() const {
  return version_case() == kMajor;
}
inline bool ViamAgentVersion::has_major() const {
  return _internal_has_major();
}
inline void ViamAgentVersion::set_has_major() {
  _oneof_case_[0] = kMajor;
}
inline void ViamAgentVersion::clear_major() {
  if (_internal_has_major()) {
    version_.major_.Destroy();
    clear_has_version();
  }
}
inline const std::string& ViamAgentVersion::major() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ViamAgentVersion.major)
  return _internal_major();
}
template <typename ArgT0, typename... ArgT>
inline void ViamAgentVersion::set_major(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_major()) {
    clear_version();
    set_has_major();
    version_.major_.InitDefault();
  }
  version_.major_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ViamAgentVersion.major)
}
inline std::string* ViamAgentVersion::mutable_major() {
  std::string* _s = _internal_mutable_major();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ViamAgentVersion.major)
  return _s;
}
inline const std::string& ViamAgentVersion::_internal_major() const {
  if (_internal_has_major()) {
    return version_.major_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ViamAgentVersion::_internal_set_major(const std::string& value) {
  if (!_internal_has_major()) {
    clear_version();
    set_has_major();
    version_.major_.InitDefault();
  }
  version_.major_.Set(value, GetArenaForAllocation());
}
inline std::string* ViamAgentVersion::_internal_mutable_major() {
  if (!_internal_has_major()) {
    clear_version();
    set_has_major();
    version_.major_.InitDefault();
  }
  return version_.major_.Mutable(      GetArenaForAllocation());
}
inline std::string* ViamAgentVersion::release_major() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ViamAgentVersion.major)
  if (_internal_has_major()) {
    clear_has_version();
    return version_.major_.Release();
  } else {
    return nullptr;
  }
}
inline void ViamAgentVersion::set_allocated_major(std::string* major) {
  if (has_version()) {
    clear_version();
  }
  if (major != nullptr) {
    set_has_major();
    version_.major_.InitAllocated(major, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ViamAgentVersion.major)
}

// string minor = 2 [json_name = "minor"];
inline bool ViamAgentVersion::_internal_has_minor() const {
  return version_case() == kMinor;
}
inline bool ViamAgentVersion::has_minor() const {
  return _internal_has_minor();
}
inline void ViamAgentVersion::set_has_minor() {
  _oneof_case_[0] = kMinor;
}
inline void ViamAgentVersion::clear_minor() {
  if (_internal_has_minor()) {
    version_.minor_.Destroy();
    clear_has_version();
  }
}
inline const std::string& ViamAgentVersion::minor() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ViamAgentVersion.minor)
  return _internal_minor();
}
template <typename ArgT0, typename... ArgT>
inline void ViamAgentVersion::set_minor(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_minor()) {
    clear_version();
    set_has_minor();
    version_.minor_.InitDefault();
  }
  version_.minor_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ViamAgentVersion.minor)
}
inline std::string* ViamAgentVersion::mutable_minor() {
  std::string* _s = _internal_mutable_minor();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ViamAgentVersion.minor)
  return _s;
}
inline const std::string& ViamAgentVersion::_internal_minor() const {
  if (_internal_has_minor()) {
    return version_.minor_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ViamAgentVersion::_internal_set_minor(const std::string& value) {
  if (!_internal_has_minor()) {
    clear_version();
    set_has_minor();
    version_.minor_.InitDefault();
  }
  version_.minor_.Set(value, GetArenaForAllocation());
}
inline std::string* ViamAgentVersion::_internal_mutable_minor() {
  if (!_internal_has_minor()) {
    clear_version();
    set_has_minor();
    version_.minor_.InitDefault();
  }
  return version_.minor_.Mutable(      GetArenaForAllocation());
}
inline std::string* ViamAgentVersion::release_minor() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ViamAgentVersion.minor)
  if (_internal_has_minor()) {
    clear_has_version();
    return version_.minor_.Release();
  } else {
    return nullptr;
  }
}
inline void ViamAgentVersion::set_allocated_minor(std::string* minor) {
  if (has_version()) {
    clear_version();
  }
  if (minor != nullptr) {
    set_has_minor();
    version_.minor_.InitAllocated(minor, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ViamAgentVersion.minor)
}

inline bool ViamAgentVersion::has_version() const {
  return version_case() != VERSION_NOT_SET;
}
inline void ViamAgentVersion::clear_has_version() {
  _oneof_case_[0] = VERSION_NOT_SET;
}
inline ViamAgentVersion::VersionCase ViamAgentVersion::version_case() const {
  return ViamAgentVersion::VersionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PartSummary

// string part_id = 1 [json_name = "partId"];
inline void PartSummary::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& PartSummary::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartSummary::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.part_id)
}
inline std::string* PartSummary::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.part_id)
  return _s;
}
inline const std::string& PartSummary::_internal_part_id() const {
  return part_id_.Get();
}
inline void PartSummary::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PartSummary::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PartSummary::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.part_id)
  return part_id_.Release();
}
inline void PartSummary::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.part_id)
}

// string part_name = 2 [json_name = "partName"];
inline void PartSummary::clear_part_name() {
  part_name_.ClearToEmpty();
}
inline const std::string& PartSummary::part_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.part_name)
  return _internal_part_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartSummary::set_part_name(ArgT0&& arg0, ArgT... args) {
 
 part_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.part_name)
}
inline std::string* PartSummary::mutable_part_name() {
  std::string* _s = _internal_mutable_part_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.part_name)
  return _s;
}
inline const std::string& PartSummary::_internal_part_name() const {
  return part_name_.Get();
}
inline void PartSummary::_internal_set_part_name(const std::string& value) {
  
  part_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PartSummary::_internal_mutable_part_name() {
  
  return part_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PartSummary::release_part_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.part_name)
  return part_name_.Release();
}
inline void PartSummary::set_allocated_part_name(std::string* part_name) {
  if (part_name != nullptr) {
    
  } else {
    
  }
  part_name_.SetAllocated(part_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_name_.IsDefault()) {
    part_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.part_name)
}

// bool is_main_part = 11 [json_name = "isMainPart"];
inline void PartSummary::clear_is_main_part() {
  is_main_part_ = false;
}
inline bool PartSummary::_internal_is_main_part() const {
  return is_main_part_;
}
inline bool PartSummary::is_main_part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.is_main_part)
  return _internal_is_main_part();
}
inline void PartSummary::_internal_set_is_main_part(bool value) {
  
  is_main_part_ = value;
}
inline void PartSummary::set_is_main_part(bool value) {
  _internal_set_is_main_part(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.is_main_part)
}

// .viam.app.v1.OnlineState online_state = 12 [json_name = "onlineState"];
inline void PartSummary::clear_online_state() {
  online_state_ = 0;
}
inline ::viam::app::v1::OnlineState PartSummary::_internal_online_state() const {
  return static_cast< ::viam::app::v1::OnlineState >(online_state_);
}
inline ::viam::app::v1::OnlineState PartSummary::online_state() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.online_state)
  return _internal_online_state();
}
inline void PartSummary::_internal_set_online_state(::viam::app::v1::OnlineState value) {
  
  online_state_ = value;
}
inline void PartSummary::set_online_state(::viam::app::v1::OnlineState value) {
  _internal_set_online_state(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.online_state)
}

// int64 seconds_since_online = 13 [json_name = "secondsSinceOnline"];
inline void PartSummary::clear_seconds_since_online() {
  seconds_since_online_ = int64_t{0};
}
inline int64_t PartSummary::_internal_seconds_since_online() const {
  return seconds_since_online_;
}
inline int64_t PartSummary::seconds_since_online() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.seconds_since_online)
  return _internal_seconds_since_online();
}
inline void PartSummary::_internal_set_seconds_since_online(int64_t value) {
  
  seconds_since_online_ = value;
}
inline void PartSummary::set_seconds_since_online(int64_t value) {
  _internal_set_seconds_since_online(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.seconds_since_online)
}

// optional .google.protobuf.Timestamp last_access = 14 [json_name = "lastAccess"];
inline bool PartSummary::_internal_has_last_access() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || last_access_ != nullptr);
  return value;
}
inline bool PartSummary::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PartSummary::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PartSummary::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.last_access)
  return _internal_last_access();
}
inline void PartSummary::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  last_access_ = last_access;
  if (last_access) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.PartSummary.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::release_last_access() {
  _has_bits_[0] &= ~0x00000080u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.last_access)
  _has_bits_[0] &= ~0x00000080u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::_internal_mutable_last_access() {
  _has_bits_[0] |= 0x00000080u;
  if (last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_access_ = p;
  }
  return last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.last_access)
  return _msg;
}
inline void PartSummary::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.last_access)
}

// optional .google.protobuf.Timestamp last_online = 3 [json_name = "lastOnline"];
inline bool PartSummary::_internal_has_last_online() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || last_online_ != nullptr);
  return value;
}
inline bool PartSummary::has_last_online() const {
  return _internal_has_last_online();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PartSummary::_internal_last_online() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_online_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PartSummary::last_online() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.last_online)
  return _internal_last_online();
}
inline void PartSummary::unsafe_arena_set_allocated_last_online(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_online) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_online_);
  }
  last_online_ = last_online;
  if (last_online) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.PartSummary.last_online)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::release_last_online() {
  _has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_online_;
  last_online_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::unsafe_arena_release_last_online() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.last_online)
  _has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_online_;
  last_online_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::_internal_mutable_last_online() {
  _has_bits_[0] |= 0x00000010u;
  if (last_online_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_online_ = p;
  }
  return last_online_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PartSummary::mutable_last_online() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_online();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.last_online)
  return _msg;
}
inline void PartSummary::set_allocated_last_online(::PROTOBUF_NAMESPACE_ID::Timestamp* last_online) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_online_);
  }
  if (last_online) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_online));
    if (message_arena != submessage_arena) {
      last_online = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_online, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  last_online_ = last_online;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.last_online)
}

// optional .viam.app.v1.ViamServerVersion viam_server_version = 4 [json_name = "viamServerVersion"];
inline bool PartSummary::_internal_has_viam_server_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || viam_server_version_ != nullptr);
  return value;
}
inline bool PartSummary::has_viam_server_version() const {
  return _internal_has_viam_server_version();
}
inline void PartSummary::clear_viam_server_version() {
  if (viam_server_version_ != nullptr) viam_server_version_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::viam::app::v1::ViamServerVersion& PartSummary::_internal_viam_server_version() const {
  const ::viam::app::v1::ViamServerVersion* p = viam_server_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::ViamServerVersion&>(
      ::viam::app::v1::_ViamServerVersion_default_instance_);
}
inline const ::viam::app::v1::ViamServerVersion& PartSummary::viam_server_version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.viam_server_version)
  return _internal_viam_server_version();
}
inline void PartSummary::unsafe_arena_set_allocated_viam_server_version(
    ::viam::app::v1::ViamServerVersion* viam_server_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(viam_server_version_);
  }
  viam_server_version_ = viam_server_version;
  if (viam_server_version) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.PartSummary.viam_server_version)
}
inline ::viam::app::v1::ViamServerVersion* PartSummary::release_viam_server_version() {
  _has_bits_[0] &= ~0x00000020u;
  ::viam::app::v1::ViamServerVersion* temp = viam_server_version_;
  viam_server_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::ViamServerVersion* PartSummary::unsafe_arena_release_viam_server_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.viam_server_version)
  _has_bits_[0] &= ~0x00000020u;
  ::viam::app::v1::ViamServerVersion* temp = viam_server_version_;
  viam_server_version_ = nullptr;
  return temp;
}
inline ::viam::app::v1::ViamServerVersion* PartSummary::_internal_mutable_viam_server_version() {
  _has_bits_[0] |= 0x00000020u;
  if (viam_server_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::ViamServerVersion>(GetArenaForAllocation());
    viam_server_version_ = p;
  }
  return viam_server_version_;
}
inline ::viam::app::v1::ViamServerVersion* PartSummary::mutable_viam_server_version() {
  ::viam::app::v1::ViamServerVersion* _msg = _internal_mutable_viam_server_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.viam_server_version)
  return _msg;
}
inline void PartSummary::set_allocated_viam_server_version(::viam::app::v1::ViamServerVersion* viam_server_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete viam_server_version_;
  }
  if (viam_server_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(viam_server_version);
    if (message_arena != submessage_arena) {
      viam_server_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, viam_server_version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  viam_server_version_ = viam_server_version;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.viam_server_version)
}

// optional .viam.app.v1.ViamAgentVersion viam_agent_version = 5 [json_name = "viamAgentVersion"];
inline bool PartSummary::_internal_has_viam_agent_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || viam_agent_version_ != nullptr);
  return value;
}
inline bool PartSummary::has_viam_agent_version() const {
  return _internal_has_viam_agent_version();
}
inline void PartSummary::clear_viam_agent_version() {
  if (viam_agent_version_ != nullptr) viam_agent_version_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::viam::app::v1::ViamAgentVersion& PartSummary::_internal_viam_agent_version() const {
  const ::viam::app::v1::ViamAgentVersion* p = viam_agent_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::ViamAgentVersion&>(
      ::viam::app::v1::_ViamAgentVersion_default_instance_);
}
inline const ::viam::app::v1::ViamAgentVersion& PartSummary::viam_agent_version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.viam_agent_version)
  return _internal_viam_agent_version();
}
inline void PartSummary::unsafe_arena_set_allocated_viam_agent_version(
    ::viam::app::v1::ViamAgentVersion* viam_agent_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(viam_agent_version_);
  }
  viam_agent_version_ = viam_agent_version;
  if (viam_agent_version) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.PartSummary.viam_agent_version)
}
inline ::viam::app::v1::ViamAgentVersion* PartSummary::release_viam_agent_version() {
  _has_bits_[0] &= ~0x00000040u;
  ::viam::app::v1::ViamAgentVersion* temp = viam_agent_version_;
  viam_agent_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::ViamAgentVersion* PartSummary::unsafe_arena_release_viam_agent_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.viam_agent_version)
  _has_bits_[0] &= ~0x00000040u;
  ::viam::app::v1::ViamAgentVersion* temp = viam_agent_version_;
  viam_agent_version_ = nullptr;
  return temp;
}
inline ::viam::app::v1::ViamAgentVersion* PartSummary::_internal_mutable_viam_agent_version() {
  _has_bits_[0] |= 0x00000040u;
  if (viam_agent_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::ViamAgentVersion>(GetArenaForAllocation());
    viam_agent_version_ = p;
  }
  return viam_agent_version_;
}
inline ::viam::app::v1::ViamAgentVersion* PartSummary::mutable_viam_agent_version() {
  ::viam::app::v1::ViamAgentVersion* _msg = _internal_mutable_viam_agent_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.viam_agent_version)
  return _msg;
}
inline void PartSummary::set_allocated_viam_agent_version(::viam::app::v1::ViamAgentVersion* viam_agent_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete viam_agent_version_;
  }
  if (viam_agent_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(viam_agent_version);
    if (message_arena != submessage_arena) {
      viam_agent_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, viam_agent_version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  viam_agent_version_ = viam_agent_version;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.viam_agent_version)
}

// optional string os = 6 [json_name = "os"];
inline bool PartSummary::_internal_has_os() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartSummary::has_os() const {
  return _internal_has_os();
}
inline void PartSummary::clear_os() {
  os_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartSummary::os() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartSummary::set_os(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 os_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.os)
}
inline std::string* PartSummary::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.os)
  return _s;
}
inline const std::string& PartSummary::_internal_os() const {
  return os_.Get();
}
inline void PartSummary::_internal_set_os(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  os_.Set(value, GetArenaForAllocation());
}
inline std::string* PartSummary::_internal_mutable_os() {
  _has_bits_[0] |= 0x00000001u;
  return os_.Mutable(GetArenaForAllocation());
}
inline std::string* PartSummary::release_os() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.os)
  if (!_internal_has_os()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = os_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault()) {
    os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartSummary::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  os_.SetAllocated(os, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault()) {
    os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.os)
}

// optional string platform = 7 [json_name = "platform"];
inline bool PartSummary::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PartSummary::has_platform() const {
  return _internal_has_platform();
}
inline void PartSummary::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PartSummary::platform() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartSummary::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.platform)
}
inline std::string* PartSummary::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.platform)
  return _s;
}
inline const std::string& PartSummary::_internal_platform() const {
  return platform_.Get();
}
inline void PartSummary::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* PartSummary::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000002u;
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* PartSummary::release_platform() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = platform_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartSummary::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.platform)
}

// optional string public_ip_address = 8 [json_name = "publicIpAddress"];
inline bool PartSummary::_internal_has_public_ip_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PartSummary::has_public_ip_address() const {
  return _internal_has_public_ip_address();
}
inline void PartSummary::clear_public_ip_address() {
  public_ip_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PartSummary::public_ip_address() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.public_ip_address)
  return _internal_public_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartSummary::set_public_ip_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 public_ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.public_ip_address)
}
inline std::string* PartSummary::mutable_public_ip_address() {
  std::string* _s = _internal_mutable_public_ip_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.public_ip_address)
  return _s;
}
inline const std::string& PartSummary::_internal_public_ip_address() const {
  return public_ip_address_.Get();
}
inline void PartSummary::_internal_set_public_ip_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  public_ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PartSummary::_internal_mutable_public_ip_address() {
  _has_bits_[0] |= 0x00000004u;
  return public_ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* PartSummary::release_public_ip_address() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.public_ip_address)
  if (!_internal_has_public_ip_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = public_ip_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_address_.IsDefault()) {
    public_ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartSummary::set_allocated_public_ip_address(std::string* public_ip_address) {
  if (public_ip_address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  public_ip_address_.SetAllocated(public_ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_address_.IsDefault()) {
    public_ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.public_ip_address)
}

// optional string dns_name = 10 [json_name = "dnsName"];
inline bool PartSummary::_internal_has_dns_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PartSummary::has_dns_name() const {
  return _internal_has_dns_name();
}
inline void PartSummary::clear_dns_name() {
  dns_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PartSummary::dns_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.dns_name)
  return _internal_dns_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartSummary::set_dns_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 dns_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PartSummary.dns_name)
}
inline std::string* PartSummary::mutable_dns_name() {
  std::string* _s = _internal_mutable_dns_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.dns_name)
  return _s;
}
inline const std::string& PartSummary::_internal_dns_name() const {
  return dns_name_.Get();
}
inline void PartSummary::_internal_set_dns_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  dns_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PartSummary::_internal_mutable_dns_name() {
  _has_bits_[0] |= 0x00000008u;
  return dns_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PartSummary::release_dns_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PartSummary.dns_name)
  if (!_internal_has_dns_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = dns_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dns_name_.IsDefault()) {
    dns_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PartSummary::set_allocated_dns_name(std::string* dns_name) {
  if (dns_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dns_name_.SetAllocated(dns_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dns_name_.IsDefault()) {
    dns_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PartSummary.dns_name)
}

// repeated .viam.app.v1.FragmentSummary fragments = 9 [json_name = "fragments"];
inline int PartSummary::_internal_fragments_size() const {
  return fragments_.size();
}
inline int PartSummary::fragments_size() const {
  return _internal_fragments_size();
}
inline void PartSummary::clear_fragments() {
  fragments_.Clear();
}
inline ::viam::app::v1::FragmentSummary* PartSummary::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PartSummary.fragments)
  return fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentSummary >*
PartSummary::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.PartSummary.fragments)
  return &fragments_;
}
inline const ::viam::app::v1::FragmentSummary& PartSummary::_internal_fragments(int index) const {
  return fragments_.Get(index);
}
inline const ::viam::app::v1::FragmentSummary& PartSummary::fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PartSummary.fragments)
  return _internal_fragments(index);
}
inline ::viam::app::v1::FragmentSummary* PartSummary::_internal_add_fragments() {
  return fragments_.Add();
}
inline ::viam::app::v1::FragmentSummary* PartSummary::add_fragments() {
  ::viam::app::v1::FragmentSummary* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.PartSummary.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::FragmentSummary >&
PartSummary::fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.PartSummary.fragments)
  return fragments_;
}

// -------------------------------------------------------------------

// ListRobotsResponse

// repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
inline int ListRobotsResponse::_internal_robots_size() const {
  return robots_.size();
}
inline int ListRobotsResponse::robots_size() const {
  return _internal_robots_size();
}
inline void ListRobotsResponse::clear_robots() {
  robots_.Clear();
}
inline ::viam::app::v1::Robot* ListRobotsResponse::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsResponse.robots)
  return robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
ListRobotsResponse::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRobotsResponse.robots)
  return &robots_;
}
inline const ::viam::app::v1::Robot& ListRobotsResponse::_internal_robots(int index) const {
  return robots_.Get(index);
}
inline const ::viam::app::v1::Robot& ListRobotsResponse::robots(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsResponse.robots)
  return _internal_robots(index);
}
inline ::viam::app::v1::Robot* ListRobotsResponse::_internal_add_robots() {
  return robots_.Add();
}
inline ::viam::app::v1::Robot* ListRobotsResponse::add_robots() {
  ::viam::app::v1::Robot* _add = _internal_add_robots();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRobotsResponse.robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
ListRobotsResponse::robots() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRobotsResponse.robots)
  return robots_;
}

// -------------------------------------------------------------------

// ListRobotsForLocationsResponse

// repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
inline int ListRobotsForLocationsResponse::_internal_robots_size() const {
  return robots_.size();
}
inline int ListRobotsForLocationsResponse::robots_size() const {
  return _internal_robots_size();
}
inline void ListRobotsForLocationsResponse::clear_robots() {
  robots_.Clear();
}
inline ::viam::app::v1::Robot* ListRobotsForLocationsResponse::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsForLocationsResponse.robots)
  return robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
ListRobotsForLocationsResponse::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRobotsForLocationsResponse.robots)
  return &robots_;
}
inline const ::viam::app::v1::Robot& ListRobotsForLocationsResponse::_internal_robots(int index) const {
  return robots_.Get(index);
}
inline const ::viam::app::v1::Robot& ListRobotsForLocationsResponse::robots(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsForLocationsResponse.robots)
  return _internal_robots(index);
}
inline ::viam::app::v1::Robot* ListRobotsForLocationsResponse::_internal_add_robots() {
  return robots_.Add();
}
inline ::viam::app::v1::Robot* ListRobotsForLocationsResponse::add_robots() {
  ::viam::app::v1::Robot* _add = _internal_add_robots();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRobotsForLocationsResponse.robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
ListRobotsForLocationsResponse::robots() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRobotsForLocationsResponse.robots)
  return robots_;
}

// -------------------------------------------------------------------

// ListRobotsForOrgResponse

// repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
inline int ListRobotsForOrgResponse::_internal_robots_size() const {
  return robots_.size();
}
inline int ListRobotsForOrgResponse::robots_size() const {
  return _internal_robots_size();
}
inline void ListRobotsForOrgResponse::clear_robots() {
  robots_.Clear();
}
inline ::viam::app::v1::Robot* ListRobotsForOrgResponse::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsForOrgResponse.robots)
  return robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
ListRobotsForOrgResponse::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRobotsForOrgResponse.robots)
  return &robots_;
}
inline const ::viam::app::v1::Robot& ListRobotsForOrgResponse::_internal_robots(int index) const {
  return robots_.Get(index);
}
inline const ::viam::app::v1::Robot& ListRobotsForOrgResponse::robots(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsForOrgResponse.robots)
  return _internal_robots(index);
}
inline ::viam::app::v1::Robot* ListRobotsForOrgResponse::_internal_add_robots() {
  return robots_.Add();
}
inline ::viam::app::v1::Robot* ListRobotsForOrgResponse::add_robots() {
  ::viam::app::v1::Robot* _add = _internal_add_robots();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRobotsForOrgResponse.robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
ListRobotsForOrgResponse::robots() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRobotsForOrgResponse.robots)
  return robots_;
}

// -------------------------------------------------------------------

// NewRobotRequest

// string name = 1 [json_name = "name"];
inline void NewRobotRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NewRobotRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotRequest.name)
}
inline std::string* NewRobotRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotRequest.name)
  return _s;
}
inline const std::string& NewRobotRequest::_internal_name() const {
  return name_.Get();
}
inline void NewRobotRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotRequest.name)
  return name_.Release();
}
inline void NewRobotRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotRequest.name)
}

// string location = 2 [json_name = "location"];
inline void NewRobotRequest::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& NewRobotRequest::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotRequest.location)
}
inline std::string* NewRobotRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotRequest.location)
  return _s;
}
inline const std::string& NewRobotRequest::_internal_location() const {
  return location_.Get();
}
inline void NewRobotRequest::_internal_set_location(const std::string& value) {
  
  location_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotRequest::_internal_mutable_location() {
  
  return location_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotRequest::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotRequest.location)
  return location_.Release();
}
inline void NewRobotRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault()) {
    location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotRequest.location)
}

// -------------------------------------------------------------------

// NewRobotResponse

// string id = 1 [json_name = "id"];
inline void NewRobotResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& NewRobotResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotResponse.id)
}
inline std::string* NewRobotResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotResponse.id)
  return _s;
}
inline const std::string& NewRobotResponse::_internal_id() const {
  return id_.Get();
}
inline void NewRobotResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotResponse.id)
  return id_.Release();
}
inline void NewRobotResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotResponse.id)
}

// -------------------------------------------------------------------

// UpdateRobotRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.id)
}
inline std::string* UpdateRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.id)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateRobotRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.id)
  return id_.Release();
}
inline void UpdateRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateRobotRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.name)
}
inline std::string* UpdateRobotRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.name)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateRobotRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.name)
  return name_.Release();
}
inline void UpdateRobotRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.name)
}

// string location = 3 [json_name = "location"];
inline void UpdateRobotRequest::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.location)
}
inline std::string* UpdateRobotRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.location)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_location() const {
  return location_.Get();
}
inline void UpdateRobotRequest::_internal_set_location(const std::string& value) {
  
  location_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_location() {
  
  return location_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.location)
  return location_.Release();
}
inline void UpdateRobotRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault()) {
    location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.location)
}

// -------------------------------------------------------------------

// UpdateRobotResponse

// .viam.app.v1.Robot robot = 1 [json_name = "robot"];
inline bool UpdateRobotResponse::_internal_has_robot() const {
  return this != internal_default_instance() && robot_ != nullptr;
}
inline bool UpdateRobotResponse::has_robot() const {
  return _internal_has_robot();
}
inline void UpdateRobotResponse::clear_robot() {
  if (GetArenaForAllocation() == nullptr && robot_ != nullptr) {
    delete robot_;
  }
  robot_ = nullptr;
}
inline const ::viam::app::v1::Robot& UpdateRobotResponse::_internal_robot() const {
  const ::viam::app::v1::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Robot&>(
      ::viam::app::v1::_Robot_default_instance_);
}
inline const ::viam::app::v1::Robot& UpdateRobotResponse::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotResponse.robot)
  return _internal_robot();
}
inline void UpdateRobotResponse::unsafe_arena_set_allocated_robot(
    ::viam::app::v1::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotResponse.robot)
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::release_robot() {
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotResponse.robot)
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::_internal_mutable_robot() {
  
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Robot>(GetArenaForAllocation());
    robot_ = p;
  }
  return robot_;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::mutable_robot() {
  ::viam::app::v1::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotResponse.robot)
  return _msg;
}
inline void UpdateRobotResponse::set_allocated_robot(::viam::app::v1::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    
  } else {
    
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotResponse.robot)
}

// -------------------------------------------------------------------

// DeleteRobotRequest

// string id = 1 [json_name = "id"];
inline void DeleteRobotRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotRequest.id)
}
inline std::string* DeleteRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotRequest.id)
  return _s;
}
inline const std::string& DeleteRobotRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteRobotRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotRequest.id)
  return id_.Release();
}
inline void DeleteRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotRequest.id)
}

// -------------------------------------------------------------------

// DeleteRobotResponse

// -------------------------------------------------------------------

// GetRobotMetadataRequest

// string id = 1 [json_name = "id"];
inline void GetRobotMetadataRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotMetadataRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotMetadataRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotMetadataRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotMetadataRequest.id)
}
inline std::string* GetRobotMetadataRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotMetadataRequest.id)
  return _s;
}
inline const std::string& GetRobotMetadataRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotMetadataRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotMetadataRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotMetadataRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotMetadataRequest.id)
  return id_.Release();
}
inline void GetRobotMetadataRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotMetadataRequest.id)
}

// -------------------------------------------------------------------

// GetRobotMetadataResponse

// .google.protobuf.Struct data = 1 [json_name = "data"];
inline bool GetRobotMetadataResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool GetRobotMetadataResponse::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetRobotMetadataResponse::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetRobotMetadataResponse::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotMetadataResponse.data)
  return _internal_data();
}
inline void GetRobotMetadataResponse::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotMetadataResponse.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotMetadataResponse::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotMetadataResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotMetadataResponse.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotMetadataResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetRobotMetadataResponse::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotMetadataResponse.data)
  return _msg;
}
inline void GetRobotMetadataResponse::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotMetadataResponse.data)
}

// -------------------------------------------------------------------

// UpdateRobotMetadataRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotMetadataRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateRobotMetadataRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotMetadataRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotMetadataRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotMetadataRequest.id)
}
inline std::string* UpdateRobotMetadataRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotMetadataRequest.id)
  return _s;
}
inline const std::string& UpdateRobotMetadataRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateRobotMetadataRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotMetadataRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotMetadataRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotMetadataRequest.id)
  return id_.Release();
}
inline void UpdateRobotMetadataRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotMetadataRequest.id)
}

// .google.protobuf.Struct data = 2 [json_name = "data"];
inline bool UpdateRobotMetadataRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool UpdateRobotMetadataRequest::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotMetadataRequest::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotMetadataRequest::data() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotMetadataRequest.data)
  return _internal_data();
}
inline void UpdateRobotMetadataRequest::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotMetadataRequest.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotMetadataRequest::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotMetadataRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotMetadataRequest.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotMetadataRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotMetadataRequest::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotMetadataRequest.data)
  return _msg;
}
inline void UpdateRobotMetadataRequest::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotMetadataRequest.data)
}

// -------------------------------------------------------------------

// UpdateRobotMetadataResponse

// -------------------------------------------------------------------

// MarkPartAsMainRequest

// string part_id = 1 [json_name = "partId"];
inline void MarkPartAsMainRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& MarkPartAsMainRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MarkPartAsMainRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkPartAsMainRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MarkPartAsMainRequest.part_id)
}
inline std::string* MarkPartAsMainRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MarkPartAsMainRequest.part_id)
  return _s;
}
inline const std::string& MarkPartAsMainRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void MarkPartAsMainRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkPartAsMainRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkPartAsMainRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MarkPartAsMainRequest.part_id)
  return part_id_.Release();
}
inline void MarkPartAsMainRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MarkPartAsMainRequest.part_id)
}

// -------------------------------------------------------------------

// MarkPartAsMainResponse

// -------------------------------------------------------------------

// MarkPartForRestartRequest

// string part_id = 1 [json_name = "partId"];
inline void MarkPartForRestartRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& MarkPartForRestartRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MarkPartForRestartRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkPartForRestartRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MarkPartForRestartRequest.part_id)
}
inline std::string* MarkPartForRestartRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MarkPartForRestartRequest.part_id)
  return _s;
}
inline const std::string& MarkPartForRestartRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void MarkPartForRestartRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkPartForRestartRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkPartForRestartRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MarkPartForRestartRequest.part_id)
  return part_id_.Release();
}
inline void MarkPartForRestartRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MarkPartForRestartRequest.part_id)
}

// -------------------------------------------------------------------

// MarkPartForRestartResponse

// -------------------------------------------------------------------

// CreateRobotPartSecretRequest

// string part_id = 1 [json_name = "partId"];
inline void CreateRobotPartSecretRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& CreateRobotPartSecretRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRobotPartSecretRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRobotPartSecretRequest.part_id)
}
inline std::string* CreateRobotPartSecretRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return _s;
}
inline const std::string& CreateRobotPartSecretRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void CreateRobotPartSecretRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRobotPartSecretRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRobotPartSecretRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return part_id_.Release();
}
inline void CreateRobotPartSecretRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRobotPartSecretRequest.part_id)
}

// -------------------------------------------------------------------

// CreateRobotPartSecretResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool CreateRobotPartSecretResponse::_internal_has_part() const {
  return this != internal_default_instance() && part_ != nullptr;
}
inline bool CreateRobotPartSecretResponse::has_part() const {
  return _internal_has_part();
}
inline void CreateRobotPartSecretResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && part_ != nullptr) {
    delete part_;
  }
  part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& CreateRobotPartSecretResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& CreateRobotPartSecretResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRobotPartSecretResponse.part)
  return _internal_part();
}
inline void CreateRobotPartSecretResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(part_);
  }
  part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateRobotPartSecretResponse.part)
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRobotPartSecretResponse.part)
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::_internal_mutable_part() {
  
  if (part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    part_ = p;
  }
  return part_;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRobotPartSecretResponse.part)
  return _msg;
}
inline void CreateRobotPartSecretResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRobotPartSecretResponse.part)
}

// -------------------------------------------------------------------

// DeleteRobotPartSecretRequest

// string part_id = 1 [json_name = "partId"];
inline void DeleteRobotPartSecretRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartSecretRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartSecretRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
}
inline std::string* DeleteRobotPartSecretRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return _s;
}
inline const std::string& DeleteRobotPartSecretRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void DeleteRobotPartSecretRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return part_id_.Release();
}
inline void DeleteRobotPartSecretRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
}

// string secret_id = 2 [json_name = "secretId"];
inline void DeleteRobotPartSecretRequest::clear_secret_id() {
  secret_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartSecretRequest::secret_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return _internal_secret_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartSecretRequest::set_secret_id(ArgT0&& arg0, ArgT... args) {
 
 secret_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
}
inline std::string* DeleteRobotPartSecretRequest::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return _s;
}
inline const std::string& DeleteRobotPartSecretRequest::_internal_secret_id() const {
  return secret_id_.Get();
}
inline void DeleteRobotPartSecretRequest::_internal_set_secret_id(const std::string& value) {
  
  secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::_internal_mutable_secret_id() {
  
  return secret_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::release_secret_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return secret_id_.Release();
}
inline void DeleteRobotPartSecretRequest::set_allocated_secret_id(std::string* secret_id) {
  if (secret_id != nullptr) {
    
  } else {
    
  }
  secret_id_.SetAllocated(secret_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_id_.IsDefault()) {
    secret_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
}

// -------------------------------------------------------------------

// DeleteRobotPartSecretResponse

// -------------------------------------------------------------------

// Authorization

// string authorization_type = 1 [json_name = "authorizationType"];
inline void Authorization::clear_authorization_type() {
  authorization_type_.ClearToEmpty();
}
inline const std::string& Authorization::authorization_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.authorization_type)
  return _internal_authorization_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_authorization_type(ArgT0&& arg0, ArgT... args) {
 
 authorization_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.authorization_type)
}
inline std::string* Authorization::mutable_authorization_type() {
  std::string* _s = _internal_mutable_authorization_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.authorization_type)
  return _s;
}
inline const std::string& Authorization::_internal_authorization_type() const {
  return authorization_type_.Get();
}
inline void Authorization::_internal_set_authorization_type(const std::string& value) {
  
  authorization_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_authorization_type() {
  
  return authorization_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_authorization_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.authorization_type)
  return authorization_type_.Release();
}
inline void Authorization::set_allocated_authorization_type(std::string* authorization_type) {
  if (authorization_type != nullptr) {
    
  } else {
    
  }
  authorization_type_.SetAllocated(authorization_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_type_.IsDefault()) {
    authorization_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.authorization_type)
}

// string authorization_id = 2 [json_name = "authorizationId"];
inline void Authorization::clear_authorization_id() {
  authorization_id_.ClearToEmpty();
}
inline const std::string& Authorization::authorization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.authorization_id)
  return _internal_authorization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_authorization_id(ArgT0&& arg0, ArgT... args) {
 
 authorization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.authorization_id)
}
inline std::string* Authorization::mutable_authorization_id() {
  std::string* _s = _internal_mutable_authorization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.authorization_id)
  return _s;
}
inline const std::string& Authorization::_internal_authorization_id() const {
  return authorization_id_.Get();
}
inline void Authorization::_internal_set_authorization_id(const std::string& value) {
  
  authorization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_authorization_id() {
  
  return authorization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_authorization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.authorization_id)
  return authorization_id_.Release();
}
inline void Authorization::set_allocated_authorization_id(std::string* authorization_id) {
  if (authorization_id != nullptr) {
    
  } else {
    
  }
  authorization_id_.SetAllocated(authorization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_id_.IsDefault()) {
    authorization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.authorization_id)
}

// string resource_type = 3 [json_name = "resourceType"];
inline void Authorization::clear_resource_type() {
  resource_type_.ClearToEmpty();
}
inline const std::string& Authorization::resource_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.resource_type)
}
inline std::string* Authorization::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.resource_type)
  return _s;
}
inline const std::string& Authorization::_internal_resource_type() const {
  return resource_type_.Get();
}
inline void Authorization::_internal_set_resource_type(const std::string& value) {
  
  resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_resource_type() {
  
  return resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_resource_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.resource_type)
  return resource_type_.Release();
}
inline void Authorization::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_type_.IsDefault()) {
    resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.resource_type)
}

// string resource_id = 4 [json_name = "resourceId"];
inline void Authorization::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& Authorization::resource_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.resource_id)
}
inline std::string* Authorization::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.resource_id)
  return _s;
}
inline const std::string& Authorization::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void Authorization::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_resource_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.resource_id)
  return resource_id_.Release();
}
inline void Authorization::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault()) {
    resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.resource_id)
}

// string identity_id = 5 [json_name = "identityId"];
inline void Authorization::clear_identity_id() {
  identity_id_.ClearToEmpty();
}
inline const std::string& Authorization::identity_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.identity_id)
  return _internal_identity_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_identity_id(ArgT0&& arg0, ArgT... args) {
 
 identity_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.identity_id)
}
inline std::string* Authorization::mutable_identity_id() {
  std::string* _s = _internal_mutable_identity_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.identity_id)
  return _s;
}
inline const std::string& Authorization::_internal_identity_id() const {
  return identity_id_.Get();
}
inline void Authorization::_internal_set_identity_id(const std::string& value) {
  
  identity_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_identity_id() {
  
  return identity_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_identity_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.identity_id)
  return identity_id_.Release();
}
inline void Authorization::set_allocated_identity_id(std::string* identity_id) {
  if (identity_id != nullptr) {
    
  } else {
    
  }
  identity_id_.SetAllocated(identity_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identity_id_.IsDefault()) {
    identity_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.identity_id)
}

// string organization_id = 6 [json_name = "organizationId"];
inline void Authorization::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& Authorization::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.organization_id)
}
inline std::string* Authorization::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.organization_id)
  return _s;
}
inline const std::string& Authorization::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void Authorization::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.organization_id)
  return organization_id_.Release();
}
inline void Authorization::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.organization_id)
}

// string identity_type = 7 [json_name = "identityType"];
inline void Authorization::clear_identity_type() {
  identity_type_.ClearToEmpty();
}
inline const std::string& Authorization::identity_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.identity_type)
  return _internal_identity_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_identity_type(ArgT0&& arg0, ArgT... args) {
 
 identity_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.identity_type)
}
inline std::string* Authorization::mutable_identity_type() {
  std::string* _s = _internal_mutable_identity_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.identity_type)
  return _s;
}
inline const std::string& Authorization::_internal_identity_type() const {
  return identity_type_.Get();
}
inline void Authorization::_internal_set_identity_type(const std::string& value) {
  
  identity_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_identity_type() {
  
  return identity_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_identity_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.identity_type)
  return identity_type_.Release();
}
inline void Authorization::set_allocated_identity_type(std::string* identity_type) {
  if (identity_type != nullptr) {
    
  } else {
    
  }
  identity_type_.SetAllocated(identity_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identity_type_.IsDefault()) {
    identity_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.identity_type)
}

// -------------------------------------------------------------------

// AddRoleRequest

// .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
inline bool AddRoleRequest::_internal_has_authorization() const {
  return this != internal_default_instance() && authorization_ != nullptr;
}
inline bool AddRoleRequest::has_authorization() const {
  return _internal_has_authorization();
}
inline void AddRoleRequest::clear_authorization() {
  if (GetArenaForAllocation() == nullptr && authorization_ != nullptr) {
    delete authorization_;
  }
  authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& AddRoleRequest::_internal_authorization() const {
  const ::viam::app::v1::Authorization* p = authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& AddRoleRequest::authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AddRoleRequest.authorization)
  return _internal_authorization();
}
inline void AddRoleRequest::unsafe_arena_set_allocated_authorization(
    ::viam::app::v1::Authorization* authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authorization_);
  }
  authorization_ = authorization;
  if (authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.AddRoleRequest.authorization)
}
inline ::viam::app::v1::Authorization* AddRoleRequest::release_authorization() {
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* AddRoleRequest::unsafe_arena_release_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AddRoleRequest.authorization)
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* AddRoleRequest::_internal_mutable_authorization() {
  
  if (authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    authorization_ = p;
  }
  return authorization_;
}
inline ::viam::app::v1::Authorization* AddRoleRequest::mutable_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AddRoleRequest.authorization)
  return _msg;
}
inline void AddRoleRequest::set_allocated_authorization(::viam::app::v1::Authorization* authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authorization_;
  }
  if (authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorization);
    if (message_arena != submessage_arena) {
      authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization, submessage_arena);
    }
    
  } else {
    
  }
  authorization_ = authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AddRoleRequest.authorization)
}

// -------------------------------------------------------------------

// AddRoleResponse

// -------------------------------------------------------------------

// RemoveRoleRequest

// .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
inline bool RemoveRoleRequest::_internal_has_authorization() const {
  return this != internal_default_instance() && authorization_ != nullptr;
}
inline bool RemoveRoleRequest::has_authorization() const {
  return _internal_has_authorization();
}
inline void RemoveRoleRequest::clear_authorization() {
  if (GetArenaForAllocation() == nullptr && authorization_ != nullptr) {
    delete authorization_;
  }
  authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& RemoveRoleRequest::_internal_authorization() const {
  const ::viam::app::v1::Authorization* p = authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& RemoveRoleRequest::authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoveRoleRequest.authorization)
  return _internal_authorization();
}
inline void RemoveRoleRequest::unsafe_arena_set_allocated_authorization(
    ::viam::app::v1::Authorization* authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authorization_);
  }
  authorization_ = authorization;
  if (authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoveRoleRequest.authorization)
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::release_authorization() {
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::unsafe_arena_release_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoveRoleRequest.authorization)
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::_internal_mutable_authorization() {
  
  if (authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    authorization_ = p;
  }
  return authorization_;
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::mutable_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoveRoleRequest.authorization)
  return _msg;
}
inline void RemoveRoleRequest::set_allocated_authorization(::viam::app::v1::Authorization* authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authorization_;
  }
  if (authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorization);
    if (message_arena != submessage_arena) {
      authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization, submessage_arena);
    }
    
  } else {
    
  }
  authorization_ = authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoveRoleRequest.authorization)
}

// -------------------------------------------------------------------

// RemoveRoleResponse

// -------------------------------------------------------------------

// ChangeRoleRequest

// .viam.app.v1.Authorization old_authorization = 1 [json_name = "oldAuthorization"];
inline bool ChangeRoleRequest::_internal_has_old_authorization() const {
  return this != internal_default_instance() && old_authorization_ != nullptr;
}
inline bool ChangeRoleRequest::has_old_authorization() const {
  return _internal_has_old_authorization();
}
inline void ChangeRoleRequest::clear_old_authorization() {
  if (GetArenaForAllocation() == nullptr && old_authorization_ != nullptr) {
    delete old_authorization_;
  }
  old_authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::_internal_old_authorization() const {
  const ::viam::app::v1::Authorization* p = old_authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::old_authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ChangeRoleRequest.old_authorization)
  return _internal_old_authorization();
}
inline void ChangeRoleRequest::unsafe_arena_set_allocated_old_authorization(
    ::viam::app::v1::Authorization* old_authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_authorization_);
  }
  old_authorization_ = old_authorization;
  if (old_authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ChangeRoleRequest.old_authorization)
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::release_old_authorization() {
  
  ::viam::app::v1::Authorization* temp = old_authorization_;
  old_authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::unsafe_arena_release_old_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ChangeRoleRequest.old_authorization)
  
  ::viam::app::v1::Authorization* temp = old_authorization_;
  old_authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::_internal_mutable_old_authorization() {
  
  if (old_authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    old_authorization_ = p;
  }
  return old_authorization_;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::mutable_old_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_old_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ChangeRoleRequest.old_authorization)
  return _msg;
}
inline void ChangeRoleRequest::set_allocated_old_authorization(::viam::app::v1::Authorization* old_authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete old_authorization_;
  }
  if (old_authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_authorization);
    if (message_arena != submessage_arena) {
      old_authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_authorization, submessage_arena);
    }
    
  } else {
    
  }
  old_authorization_ = old_authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ChangeRoleRequest.old_authorization)
}

// .viam.app.v1.Authorization new_authorization = 2 [json_name = "newAuthorization"];
inline bool ChangeRoleRequest::_internal_has_new_authorization() const {
  return this != internal_default_instance() && new_authorization_ != nullptr;
}
inline bool ChangeRoleRequest::has_new_authorization() const {
  return _internal_has_new_authorization();
}
inline void ChangeRoleRequest::clear_new_authorization() {
  if (GetArenaForAllocation() == nullptr && new_authorization_ != nullptr) {
    delete new_authorization_;
  }
  new_authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::_internal_new_authorization() const {
  const ::viam::app::v1::Authorization* p = new_authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::new_authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ChangeRoleRequest.new_authorization)
  return _internal_new_authorization();
}
inline void ChangeRoleRequest::unsafe_arena_set_allocated_new_authorization(
    ::viam::app::v1::Authorization* new_authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_authorization_);
  }
  new_authorization_ = new_authorization;
  if (new_authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ChangeRoleRequest.new_authorization)
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::release_new_authorization() {
  
  ::viam::app::v1::Authorization* temp = new_authorization_;
  new_authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::unsafe_arena_release_new_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ChangeRoleRequest.new_authorization)
  
  ::viam::app::v1::Authorization* temp = new_authorization_;
  new_authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::_internal_mutable_new_authorization() {
  
  if (new_authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    new_authorization_ = p;
  }
  return new_authorization_;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::mutable_new_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_new_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ChangeRoleRequest.new_authorization)
  return _msg;
}
inline void ChangeRoleRequest::set_allocated_new_authorization(::viam::app::v1::Authorization* new_authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete new_authorization_;
  }
  if (new_authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_authorization);
    if (message_arena != submessage_arena) {
      new_authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_authorization, submessage_arena);
    }
    
  } else {
    
  }
  new_authorization_ = new_authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ChangeRoleRequest.new_authorization)
}

// -------------------------------------------------------------------

// ChangeRoleResponse

// -------------------------------------------------------------------

// ListAuthorizationsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListAuthorizationsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListAuthorizationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListAuthorizationsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListAuthorizationsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListAuthorizationsRequest.organization_id)
}
inline std::string* ListAuthorizationsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListAuthorizationsRequest.organization_id)
  return _s;
}
inline const std::string& ListAuthorizationsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListAuthorizationsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAuthorizationsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListAuthorizationsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListAuthorizationsRequest.organization_id)
  return organization_id_.Release();
}
inline void ListAuthorizationsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListAuthorizationsRequest.organization_id)
}

// repeated string resource_ids = 2 [json_name = "resourceIds"];
inline int ListAuthorizationsRequest::_internal_resource_ids_size() const {
  return resource_ids_.size();
}
inline int ListAuthorizationsRequest::resource_ids_size() const {
  return _internal_resource_ids_size();
}
inline void ListAuthorizationsRequest::clear_resource_ids() {
  resource_ids_.Clear();
}
inline std::string* ListAuthorizationsRequest::add_resource_ids() {
  std::string* _s = _internal_add_resource_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return _s;
}
inline const std::string& ListAuthorizationsRequest::_internal_resource_ids(int index) const {
  return resource_ids_.Get(index);
}
inline const std::string& ListAuthorizationsRequest::resource_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return _internal_resource_ids(index);
}
inline std::string* ListAuthorizationsRequest::mutable_resource_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return resource_ids_.Mutable(index);
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, const std::string& value) {
  resource_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, std::string&& value) {
  resource_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resource_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, const char* value, size_t size) {
  resource_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline std::string* ListAuthorizationsRequest::_internal_add_resource_ids() {
  return resource_ids_.Add();
}
inline void ListAuthorizationsRequest::add_resource_ids(const std::string& value) {
  resource_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::add_resource_ids(std::string&& value) {
  resource_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::add_resource_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resource_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::add_resource_ids(const char* value, size_t size) {
  resource_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListAuthorizationsRequest::resource_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return resource_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListAuthorizationsRequest::mutable_resource_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return &resource_ids_;
}

// -------------------------------------------------------------------

// ListAuthorizationsResponse

// repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
inline int ListAuthorizationsResponse::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int ListAuthorizationsResponse::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void ListAuthorizationsResponse::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* ListAuthorizationsResponse::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
ListAuthorizationsResponse::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& ListAuthorizationsResponse::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& ListAuthorizationsResponse::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* ListAuthorizationsResponse::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* ListAuthorizationsResponse::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
ListAuthorizationsResponse::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return authorizations_;
}

// -------------------------------------------------------------------

// CheckPermissionsRequest

// repeated .viam.app.v1.AuthorizedPermissions permissions = 1 [json_name = "permissions"];
inline int CheckPermissionsRequest::_internal_permissions_size() const {
  return permissions_.size();
}
inline int CheckPermissionsRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void CheckPermissionsRequest::clear_permissions() {
  permissions_.Clear();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CheckPermissionsRequest.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
CheckPermissionsRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CheckPermissionsRequest.permissions)
  return &permissions_;
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsRequest::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CheckPermissionsRequest.permissions)
  return _internal_permissions(index);
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsRequest::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsRequest::add_permissions() {
  ::viam::app::v1::AuthorizedPermissions* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:viam.app.v1.CheckPermissionsRequest.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
CheckPermissionsRequest::permissions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CheckPermissionsRequest.permissions)
  return permissions_;
}

// -------------------------------------------------------------------

// AuthorizedPermissions

// string resource_type = 1 [json_name = "resourceType"];
inline void AuthorizedPermissions::clear_resource_type() {
  resource_type_.ClearToEmpty();
}
inline const std::string& AuthorizedPermissions::resource_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizedPermissions.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizedPermissions::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.resource_type)
}
inline std::string* AuthorizedPermissions::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizedPermissions.resource_type)
  return _s;
}
inline const std::string& AuthorizedPermissions::_internal_resource_type() const {
  return resource_type_.Get();
}
inline void AuthorizedPermissions::_internal_set_resource_type(const std::string& value) {
  
  resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::_internal_mutable_resource_type() {
  
  return resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::release_resource_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizedPermissions.resource_type)
  return resource_type_.Release();
}
inline void AuthorizedPermissions::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_type_.IsDefault()) {
    resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizedPermissions.resource_type)
}

// string resource_id = 2 [json_name = "resourceId"];
inline void AuthorizedPermissions::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& AuthorizedPermissions::resource_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizedPermissions.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizedPermissions::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.resource_id)
}
inline std::string* AuthorizedPermissions::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizedPermissions.resource_id)
  return _s;
}
inline const std::string& AuthorizedPermissions::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void AuthorizedPermissions::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::release_resource_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizedPermissions.resource_id)
  return resource_id_.Release();
}
inline void AuthorizedPermissions::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault()) {
    resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizedPermissions.resource_id)
}

// repeated string permissions = 3 [json_name = "permissions"];
inline int AuthorizedPermissions::_internal_permissions_size() const {
  return permissions_.size();
}
inline int AuthorizedPermissions::permissions_size() const {
  return _internal_permissions_size();
}
inline void AuthorizedPermissions::clear_permissions() {
  permissions_.Clear();
}
inline std::string* AuthorizedPermissions::add_permissions() {
  std::string* _s = _internal_add_permissions();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.AuthorizedPermissions.permissions)
  return _s;
}
inline const std::string& AuthorizedPermissions::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const std::string& AuthorizedPermissions::permissions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizedPermissions.permissions)
  return _internal_permissions(index);
}
inline std::string* AuthorizedPermissions::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizedPermissions.permissions)
  return permissions_.Mutable(index);
}
inline void AuthorizedPermissions::set_permissions(int index, const std::string& value) {
  permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::set_permissions(int index, std::string&& value) {
  permissions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::set_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::set_permissions(int index, const char* value, size_t size) {
  permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.AuthorizedPermissions.permissions)
}
inline std::string* AuthorizedPermissions::_internal_add_permissions() {
  return permissions_.Add();
}
inline void AuthorizedPermissions::add_permissions(const std::string& value) {
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::add_permissions(std::string&& value) {
  permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::add_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::add_permissions(const char* value, size_t size) {
  permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.AuthorizedPermissions.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthorizedPermissions::permissions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.AuthorizedPermissions.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AuthorizedPermissions::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AuthorizedPermissions.permissions)
  return &permissions_;
}

// -------------------------------------------------------------------

// CheckPermissionsResponse

// repeated .viam.app.v1.AuthorizedPermissions authorized_permissions = 1 [json_name = "authorizedPermissions"];
inline int CheckPermissionsResponse::_internal_authorized_permissions_size() const {
  return authorized_permissions_.size();
}
inline int CheckPermissionsResponse::authorized_permissions_size() const {
  return _internal_authorized_permissions_size();
}
inline void CheckPermissionsResponse::clear_authorized_permissions() {
  authorized_permissions_.Clear();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsResponse::mutable_authorized_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return authorized_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
CheckPermissionsResponse::mutable_authorized_permissions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return &authorized_permissions_;
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsResponse::_internal_authorized_permissions(int index) const {
  return authorized_permissions_.Get(index);
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsResponse::authorized_permissions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return _internal_authorized_permissions(index);
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsResponse::_internal_add_authorized_permissions() {
  return authorized_permissions_.Add();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsResponse::add_authorized_permissions() {
  ::viam::app::v1::AuthorizedPermissions* _add = _internal_add_authorized_permissions();
  // @@protoc_insertion_point(field_add:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
CheckPermissionsResponse::authorized_permissions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return authorized_permissions_;
}

// -------------------------------------------------------------------

// ModuleVersion

// string version = 1 [json_name = "version"];
inline void ModuleVersion::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ModuleVersion::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleVersion.version)
}
inline std::string* ModuleVersion::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.version)
  return _s;
}
inline const std::string& ModuleVersion::_internal_version() const {
  return version_.Get();
}
inline void ModuleVersion::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleVersion.version)
  return version_.Release();
}
inline void ModuleVersion::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleVersion.version)
}

// repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
inline int ModuleVersion::_internal_files_size() const {
  return files_.size();
}
inline int ModuleVersion::files_size() const {
  return _internal_files_size();
}
inline void ModuleVersion::clear_files() {
  files_.Clear();
}
inline ::viam::app::v1::Uploads* ModuleVersion::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
ModuleVersion::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleVersion.files)
  return &files_;
}
inline const ::viam::app::v1::Uploads& ModuleVersion::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::viam::app::v1::Uploads& ModuleVersion::files(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.files)
  return _internal_files(index);
}
inline ::viam::app::v1::Uploads* ModuleVersion::_internal_add_files() {
  return files_.Add();
}
inline ::viam::app::v1::Uploads* ModuleVersion::add_files() {
  ::viam::app::v1::Uploads* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleVersion.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
ModuleVersion::files() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleVersion.files)
  return files_;
}

// repeated .viam.app.v1.Model models = 3 [json_name = "models"];
inline int ModuleVersion::_internal_models_size() const {
  return models_.size();
}
inline int ModuleVersion::models_size() const {
  return _internal_models_size();
}
inline void ModuleVersion::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* ModuleVersion::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
ModuleVersion::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleVersion.models)
  return &models_;
}
inline const ::viam::app::v1::Model& ModuleVersion::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& ModuleVersion::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* ModuleVersion::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* ModuleVersion::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleVersion.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
ModuleVersion::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleVersion.models)
  return models_;
}

// string entrypoint = 4 [json_name = "entrypoint"];
inline void ModuleVersion::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& ModuleVersion::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleVersion.entrypoint)
}
inline std::string* ModuleVersion::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.entrypoint)
  return _s;
}
inline const std::string& ModuleVersion::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void ModuleVersion::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleVersion.entrypoint)
  return entrypoint_.Release();
}
inline void ModuleVersion::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleVersion.entrypoint)
}

// optional string first_run = 5 [json_name = "firstRun"];
inline bool ModuleVersion::_internal_has_first_run() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModuleVersion::has_first_run() const {
  return _internal_has_first_run();
}
inline void ModuleVersion::clear_first_run() {
  first_run_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModuleVersion::first_run() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.first_run)
  return _internal_first_run();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_first_run(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 first_run_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleVersion.first_run)
}
inline std::string* ModuleVersion::mutable_first_run() {
  std::string* _s = _internal_mutable_first_run();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.first_run)
  return _s;
}
inline const std::string& ModuleVersion::_internal_first_run() const {
  return first_run_.Get();
}
inline void ModuleVersion::_internal_set_first_run(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  first_run_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_first_run() {
  _has_bits_[0] |= 0x00000001u;
  return first_run_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_first_run() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleVersion.first_run)
  if (!_internal_has_first_run()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = first_run_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModuleVersion::set_allocated_first_run(std::string* first_run) {
  if (first_run != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_run_.SetAllocated(first_run, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleVersion.first_run)
}

// optional string markdown_description = 6 [json_name = "markdownDescription"];
inline bool ModuleVersion::_internal_has_markdown_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModuleVersion::has_markdown_description() const {
  return _internal_has_markdown_description();
}
inline void ModuleVersion::clear_markdown_description() {
  markdown_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModuleVersion::markdown_description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.markdown_description)
  return _internal_markdown_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_markdown_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 markdown_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleVersion.markdown_description)
}
inline std::string* ModuleVersion::mutable_markdown_description() {
  std::string* _s = _internal_mutable_markdown_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.markdown_description)
  return _s;
}
inline const std::string& ModuleVersion::_internal_markdown_description() const {
  return markdown_description_.Get();
}
inline void ModuleVersion::_internal_set_markdown_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  markdown_description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_markdown_description() {
  _has_bits_[0] |= 0x00000002u;
  return markdown_description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_markdown_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleVersion.markdown_description)
  if (!_internal_has_markdown_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = markdown_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModuleVersion::set_allocated_markdown_description(std::string* markdown_description) {
  if (markdown_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  markdown_description_.SetAllocated(markdown_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleVersion.markdown_description)
}

// repeated .viam.app.v1.App apps = 7 [json_name = "apps"];
inline int ModuleVersion::_internal_apps_size() const {
  return apps_.size();
}
inline int ModuleVersion::apps_size() const {
  return _internal_apps_size();
}
inline void ModuleVersion::clear_apps() {
  apps_.Clear();
}
inline ::viam::app::v1::App* ModuleVersion::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
ModuleVersion::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleVersion.apps)
  return &apps_;
}
inline const ::viam::app::v1::App& ModuleVersion::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::viam::app::v1::App& ModuleVersion::apps(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.apps)
  return _internal_apps(index);
}
inline ::viam::app::v1::App* ModuleVersion::_internal_add_apps() {
  return apps_.Add();
}
inline ::viam::app::v1::App* ModuleVersion::add_apps() {
  ::viam::app::v1::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleVersion.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
ModuleVersion::apps() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleVersion.apps)
  return apps_;
}

// -------------------------------------------------------------------

// ModuleMetadata

// repeated .viam.app.v1.Model models = 1 [json_name = "models"];
inline int ModuleMetadata::_internal_models_size() const {
  return models_.size();
}
inline int ModuleMetadata::models_size() const {
  return _internal_models_size();
}
inline void ModuleMetadata::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* ModuleMetadata::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
ModuleMetadata::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleMetadata.models)
  return &models_;
}
inline const ::viam::app::v1::Model& ModuleMetadata::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& ModuleMetadata::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* ModuleMetadata::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* ModuleMetadata::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleMetadata.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
ModuleMetadata::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleMetadata.models)
  return models_;
}

// repeated .viam.app.v1.ModuleVersion versions = 2 [json_name = "versions"];
inline int ModuleMetadata::_internal_versions_size() const {
  return versions_.size();
}
inline int ModuleMetadata::versions_size() const {
  return _internal_versions_size();
}
inline void ModuleMetadata::clear_versions() {
  versions_.Clear();
}
inline ::viam::app::v1::ModuleVersion* ModuleMetadata::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.versions)
  return versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >*
ModuleMetadata::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleMetadata.versions)
  return &versions_;
}
inline const ::viam::app::v1::ModuleVersion& ModuleMetadata::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const ::viam::app::v1::ModuleVersion& ModuleMetadata::versions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.versions)
  return _internal_versions(index);
}
inline ::viam::app::v1::ModuleVersion* ModuleMetadata::_internal_add_versions() {
  return versions_.Add();
}
inline ::viam::app::v1::ModuleVersion* ModuleMetadata::add_versions() {
  ::viam::app::v1::ModuleVersion* _add = _internal_add_versions();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleMetadata.versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >&
ModuleMetadata::versions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleMetadata.versions)
  return versions_;
}

// string entrypoint = 3 [json_name = "entrypoint"];
inline void ModuleMetadata::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& ModuleMetadata::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleMetadata::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleMetadata.entrypoint)
}
inline std::string* ModuleMetadata::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.entrypoint)
  return _s;
}
inline const std::string& ModuleMetadata::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void ModuleMetadata::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleMetadata::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleMetadata::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleMetadata.entrypoint)
  return entrypoint_.Release();
}
inline void ModuleMetadata::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleMetadata.entrypoint)
}

// optional string first_run = 4 [json_name = "firstRun"];
inline bool ModuleMetadata::_internal_has_first_run() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModuleMetadata::has_first_run() const {
  return _internal_has_first_run();
}
inline void ModuleMetadata::clear_first_run() {
  first_run_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModuleMetadata::first_run() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.first_run)
  return _internal_first_run();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleMetadata::set_first_run(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 first_run_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleMetadata.first_run)
}
inline std::string* ModuleMetadata::mutable_first_run() {
  std::string* _s = _internal_mutable_first_run();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.first_run)
  return _s;
}
inline const std::string& ModuleMetadata::_internal_first_run() const {
  return first_run_.Get();
}
inline void ModuleMetadata::_internal_set_first_run(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  first_run_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleMetadata::_internal_mutable_first_run() {
  _has_bits_[0] |= 0x00000001u;
  return first_run_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleMetadata::release_first_run() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleMetadata.first_run)
  if (!_internal_has_first_run()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = first_run_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModuleMetadata::set_allocated_first_run(std::string* first_run) {
  if (first_run != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_run_.SetAllocated(first_run, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleMetadata.first_run)
}

// optional string markdown_description = 5 [json_name = "markdownDescription"];
inline bool ModuleMetadata::_internal_has_markdown_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModuleMetadata::has_markdown_description() const {
  return _internal_has_markdown_description();
}
inline void ModuleMetadata::clear_markdown_description() {
  markdown_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModuleMetadata::markdown_description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.markdown_description)
  return _internal_markdown_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleMetadata::set_markdown_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 markdown_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleMetadata.markdown_description)
}
inline std::string* ModuleMetadata::mutable_markdown_description() {
  std::string* _s = _internal_mutable_markdown_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.markdown_description)
  return _s;
}
inline const std::string& ModuleMetadata::_internal_markdown_description() const {
  return markdown_description_.Get();
}
inline void ModuleMetadata::_internal_set_markdown_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  markdown_description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleMetadata::_internal_mutable_markdown_description() {
  _has_bits_[0] |= 0x00000002u;
  return markdown_description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleMetadata::release_markdown_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleMetadata.markdown_description)
  if (!_internal_has_markdown_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = markdown_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModuleMetadata::set_allocated_markdown_description(std::string* markdown_description) {
  if (markdown_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  markdown_description_.SetAllocated(markdown_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleMetadata.markdown_description)
}

// repeated .viam.app.v1.App apps = 6 [json_name = "apps"];
inline int ModuleMetadata::_internal_apps_size() const {
  return apps_.size();
}
inline int ModuleMetadata::apps_size() const {
  return _internal_apps_size();
}
inline void ModuleMetadata::clear_apps() {
  apps_.Clear();
}
inline ::viam::app::v1::App* ModuleMetadata::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
ModuleMetadata::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleMetadata.apps)
  return &apps_;
}
inline const ::viam::app::v1::App& ModuleMetadata::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::viam::app::v1::App& ModuleMetadata::apps(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.apps)
  return _internal_apps(index);
}
inline ::viam::app::v1::App* ModuleMetadata::_internal_add_apps() {
  return apps_.Add();
}
inline ::viam::app::v1::App* ModuleMetadata::add_apps() {
  ::viam::app::v1::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleMetadata.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
ModuleMetadata::apps() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleMetadata.apps)
  return apps_;
}

// optional .viam.app.v1.ModuleSourceType source_type = 7 [json_name = "sourceType"];
inline bool ModuleMetadata::_internal_has_source_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModuleMetadata::has_source_type() const {
  return _internal_has_source_type();
}
inline void ModuleMetadata::clear_source_type() {
  source_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::viam::app::v1::ModuleSourceType ModuleMetadata::_internal_source_type() const {
  return static_cast< ::viam::app::v1::ModuleSourceType >(source_type_);
}
inline ::viam::app::v1::ModuleSourceType ModuleMetadata::source_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.source_type)
  return _internal_source_type();
}
inline void ModuleMetadata::_internal_set_source_type(::viam::app::v1::ModuleSourceType value) {
  _has_bits_[0] |= 0x00000004u;
  source_type_ = value;
}
inline void ModuleMetadata::set_source_type(::viam::app::v1::ModuleSourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleMetadata.source_type)
}

// optional .viam.app.v1.ModuleLanguage language = 8 [json_name = "language"];
inline bool ModuleMetadata::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModuleMetadata::has_language() const {
  return _internal_has_language();
}
inline void ModuleMetadata::clear_language() {
  language_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::viam::app::v1::ModuleLanguage ModuleMetadata::_internal_language() const {
  return static_cast< ::viam::app::v1::ModuleLanguage >(language_);
}
inline ::viam::app::v1::ModuleLanguage ModuleMetadata::language() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.language)
  return _internal_language();
}
inline void ModuleMetadata::_internal_set_language(::viam::app::v1::ModuleLanguage value) {
  _has_bits_[0] |= 0x00000008u;
  language_ = value;
}
inline void ModuleMetadata::set_language(::viam::app::v1::ModuleLanguage value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleMetadata.language)
}

// -------------------------------------------------------------------

// MLModelMetadata

// repeated string versions = 1 [json_name = "versions"];
inline int MLModelMetadata::_internal_versions_size() const {
  return versions_.size();
}
inline int MLModelMetadata::versions_size() const {
  return _internal_versions_size();
}
inline void MLModelMetadata::clear_versions() {
  versions_.Clear();
}
inline std::string* MLModelMetadata::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.MLModelMetadata.versions)
  return _s;
}
inline const std::string& MLModelMetadata::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const std::string& MLModelMetadata::versions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLModelMetadata.versions)
  return _internal_versions(index);
}
inline std::string* MLModelMetadata::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MLModelMetadata.versions)
  return versions_.Mutable(index);
}
inline void MLModelMetadata::set_versions(int index, const std::string& value) {
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::set_versions(int index, std::string&& value) {
  versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::set_versions(int index, const char* value, size_t size) {
  versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.MLModelMetadata.versions)
}
inline std::string* MLModelMetadata::_internal_add_versions() {
  return versions_.Add();
}
inline void MLModelMetadata::add_versions(const std::string& value) {
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::add_versions(std::string&& value) {
  versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::add_versions(const char* value, size_t size) {
  versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.MLModelMetadata.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MLModelMetadata::versions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.MLModelMetadata.versions)
  return versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MLModelMetadata::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.MLModelMetadata.versions)
  return &versions_;
}

// .viam.app.mltraining.v1.ModelType model_type = 2 [json_name = "modelType"];
inline void MLModelMetadata::clear_model_type() {
  model_type_ = 0;
}
inline ::viam::app::mltraining::v1::ModelType MLModelMetadata::_internal_model_type() const {
  return static_cast< ::viam::app::mltraining::v1::ModelType >(model_type_);
}
inline ::viam::app::mltraining::v1::ModelType MLModelMetadata::model_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLModelMetadata.model_type)
  return _internal_model_type();
}
inline void MLModelMetadata::_internal_set_model_type(::viam::app::mltraining::v1::ModelType value) {
  
  model_type_ = value;
}
inline void MLModelMetadata::set_model_type(::viam::app::mltraining::v1::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.MLModelMetadata.model_type)
}

// .viam.app.mltraining.v1.ModelFramework model_framework = 3 [json_name = "modelFramework"];
inline void MLModelMetadata::clear_model_framework() {
  model_framework_ = 0;
}
inline ::viam::app::mltraining::v1::ModelFramework MLModelMetadata::_internal_model_framework() const {
  return static_cast< ::viam::app::mltraining::v1::ModelFramework >(model_framework_);
}
inline ::viam::app::mltraining::v1::ModelFramework MLModelMetadata::model_framework() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLModelMetadata.model_framework)
  return _internal_model_framework();
}
inline void MLModelMetadata::_internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  
  model_framework_ = value;
}
inline void MLModelMetadata::set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  _internal_set_model_framework(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.MLModelMetadata.model_framework)
}

// -------------------------------------------------------------------

// MLTrainingVersion

// string version = 1 [json_name = "version"];
inline void MLTrainingVersion::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& MLTrainingVersion::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLTrainingVersion.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MLTrainingVersion::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MLTrainingVersion.version)
}
inline std::string* MLTrainingVersion::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MLTrainingVersion.version)
  return _s;
}
inline const std::string& MLTrainingVersion::_internal_version() const {
  return version_.Get();
}
inline void MLTrainingVersion::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* MLTrainingVersion::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* MLTrainingVersion::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MLTrainingVersion.version)
  return version_.Release();
}
inline void MLTrainingVersion::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MLTrainingVersion.version)
}

// .google.protobuf.Timestamp created_on = 2 [json_name = "createdOn"];
inline bool MLTrainingVersion::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool MLTrainingVersion::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MLTrainingVersion::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MLTrainingVersion::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLTrainingVersion.created_on)
  return _internal_created_on();
}
inline void MLTrainingVersion::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.MLTrainingVersion.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MLTrainingVersion::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MLTrainingVersion::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MLTrainingVersion.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MLTrainingVersion::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MLTrainingVersion::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MLTrainingVersion.created_on)
  return _msg;
}
inline void MLTrainingVersion::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MLTrainingVersion.created_on)
}

// -------------------------------------------------------------------

// MLTrainingMetadata

// repeated .viam.app.v1.MLTrainingVersion versions = 5 [json_name = "versions"];
inline int MLTrainingMetadata::_internal_versions_size() const {
  return versions_.size();
}
inline int MLTrainingMetadata::versions_size() const {
  return _internal_versions_size();
}
inline void MLTrainingMetadata::clear_versions() {
  versions_.Clear();
}
inline ::viam::app::v1::MLTrainingVersion* MLTrainingMetadata::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MLTrainingMetadata.versions)
  return versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MLTrainingVersion >*
MLTrainingMetadata::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.MLTrainingMetadata.versions)
  return &versions_;
}
inline const ::viam::app::v1::MLTrainingVersion& MLTrainingMetadata::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const ::viam::app::v1::MLTrainingVersion& MLTrainingMetadata::versions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLTrainingMetadata.versions)
  return _internal_versions(index);
}
inline ::viam::app::v1::MLTrainingVersion* MLTrainingMetadata::_internal_add_versions() {
  return versions_.Add();
}
inline ::viam::app::v1::MLTrainingVersion* MLTrainingMetadata::add_versions() {
  ::viam::app::v1::MLTrainingVersion* _add = _internal_add_versions();
  // @@protoc_insertion_point(field_add:viam.app.v1.MLTrainingMetadata.versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::MLTrainingVersion >&
MLTrainingMetadata::versions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.MLTrainingMetadata.versions)
  return versions_;
}

// .viam.app.mltraining.v1.ModelType model_type = 2 [json_name = "modelType"];
inline void MLTrainingMetadata::clear_model_type() {
  model_type_ = 0;
}
inline ::viam::app::mltraining::v1::ModelType MLTrainingMetadata::_internal_model_type() const {
  return static_cast< ::viam::app::mltraining::v1::ModelType >(model_type_);
}
inline ::viam::app::mltraining::v1::ModelType MLTrainingMetadata::model_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLTrainingMetadata.model_type)
  return _internal_model_type();
}
inline void MLTrainingMetadata::_internal_set_model_type(::viam::app::mltraining::v1::ModelType value) {
  
  model_type_ = value;
}
inline void MLTrainingMetadata::set_model_type(::viam::app::mltraining::v1::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.MLTrainingMetadata.model_type)
}

// .viam.app.mltraining.v1.ModelFramework model_framework = 3 [json_name = "modelFramework"];
inline void MLTrainingMetadata::clear_model_framework() {
  model_framework_ = 0;
}
inline ::viam::app::mltraining::v1::ModelFramework MLTrainingMetadata::_internal_model_framework() const {
  return static_cast< ::viam::app::mltraining::v1::ModelFramework >(model_framework_);
}
inline ::viam::app::mltraining::v1::ModelFramework MLTrainingMetadata::model_framework() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLTrainingMetadata.model_framework)
  return _internal_model_framework();
}
inline void MLTrainingMetadata::_internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  
  model_framework_ = value;
}
inline void MLTrainingMetadata::set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  _internal_set_model_framework(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.MLTrainingMetadata.model_framework)
}

// bool draft = 4 [json_name = "draft"];
inline void MLTrainingMetadata::clear_draft() {
  draft_ = false;
}
inline bool MLTrainingMetadata::_internal_draft() const {
  return draft_;
}
inline bool MLTrainingMetadata::draft() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLTrainingMetadata.draft)
  return _internal_draft();
}
inline void MLTrainingMetadata::_internal_set_draft(bool value) {
  
  draft_ = value;
}
inline void MLTrainingMetadata::set_draft(bool value) {
  _internal_set_draft(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.MLTrainingMetadata.draft)
}

// -------------------------------------------------------------------

// RegistryItem

// string item_id = 1 [json_name = "itemId"];
inline void RegistryItem::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& RegistryItem::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.item_id)
}
inline std::string* RegistryItem::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.item_id)
  return _s;
}
inline const std::string& RegistryItem::_internal_item_id() const {
  return item_id_.Get();
}
inline void RegistryItem::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.item_id)
  return item_id_.Release();
}
inline void RegistryItem::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.item_id)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void RegistryItem::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& RegistryItem::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.organization_id)
}
inline std::string* RegistryItem::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.organization_id)
  return _s;
}
inline const std::string& RegistryItem::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void RegistryItem::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.organization_id)
  return organization_id_.Release();
}
inline void RegistryItem::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.organization_id)
}

// string public_namespace = 3 [json_name = "publicNamespace"];
inline void RegistryItem::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& RegistryItem::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.public_namespace)
}
inline std::string* RegistryItem::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.public_namespace)
  return _s;
}
inline const std::string& RegistryItem::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void RegistryItem::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.public_namespace)
  return public_namespace_.Release();
}
inline void RegistryItem::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.public_namespace)
}

// string name = 4 [json_name = "name"];
inline void RegistryItem::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RegistryItem::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.name)
}
inline std::string* RegistryItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.name)
  return _s;
}
inline const std::string& RegistryItem::_internal_name() const {
  return name_.Get();
}
inline void RegistryItem::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.name)
  return name_.Release();
}
inline void RegistryItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.name)
}

// .viam.app.packages.v1.PackageType type = 5 [json_name = "type"];
inline void RegistryItem::clear_type() {
  type_ = 0;
}
inline ::viam::app::packages::v1::PackageType RegistryItem::_internal_type() const {
  return static_cast< ::viam::app::packages::v1::PackageType >(type_);
}
inline ::viam::app::packages::v1::PackageType RegistryItem::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.type)
  return _internal_type();
}
inline void RegistryItem::_internal_set_type(::viam::app::packages::v1::PackageType value) {
  
  type_ = value;
}
inline void RegistryItem::set_type(::viam::app::packages::v1::PackageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.type)
}

// .viam.app.v1.Visibility visibility = 6 [json_name = "visibility"];
inline void RegistryItem::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility RegistryItem::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility RegistryItem::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.visibility)
  return _internal_visibility();
}
inline void RegistryItem::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void RegistryItem::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.visibility)
}

// string url = 7 [json_name = "url"];
inline void RegistryItem::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& RegistryItem::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.url)
}
inline std::string* RegistryItem::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.url)
  return _s;
}
inline const std::string& RegistryItem::_internal_url() const {
  return url_.Get();
}
inline void RegistryItem::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.url)
  return url_.Release();
}
inline void RegistryItem::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.url)
}

// string description = 8 [json_name = "description"];
inline void RegistryItem::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& RegistryItem::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.description)
}
inline std::string* RegistryItem::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.description)
  return _s;
}
inline const std::string& RegistryItem::_internal_description() const {
  return description_.Get();
}
inline void RegistryItem::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.description)
  return description_.Release();
}
inline void RegistryItem::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.description)
}

// int64 total_robot_usage = 9 [json_name = "totalRobotUsage"];
inline void RegistryItem::clear_total_robot_usage() {
  total_robot_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_robot_usage() const {
  return total_robot_usage_;
}
inline int64_t RegistryItem::total_robot_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_robot_usage)
  return _internal_total_robot_usage();
}
inline void RegistryItem::_internal_set_total_robot_usage(int64_t value) {
  
  total_robot_usage_ = value;
}
inline void RegistryItem::set_total_robot_usage(int64_t value) {
  _internal_set_total_robot_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_robot_usage)
}

// int64 total_external_robot_usage = 13 [json_name = "totalExternalRobotUsage"];
inline void RegistryItem::clear_total_external_robot_usage() {
  total_external_robot_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_external_robot_usage() const {
  return total_external_robot_usage_;
}
inline int64_t RegistryItem::total_external_robot_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_external_robot_usage)
  return _internal_total_external_robot_usage();
}
inline void RegistryItem::_internal_set_total_external_robot_usage(int64_t value) {
  
  total_external_robot_usage_ = value;
}
inline void RegistryItem::set_total_external_robot_usage(int64_t value) {
  _internal_set_total_external_robot_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_external_robot_usage)
}

// int64 total_organization_usage = 10 [json_name = "totalOrganizationUsage"];
inline void RegistryItem::clear_total_organization_usage() {
  total_organization_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_organization_usage() const {
  return total_organization_usage_;
}
inline int64_t RegistryItem::total_organization_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_organization_usage)
  return _internal_total_organization_usage();
}
inline void RegistryItem::_internal_set_total_organization_usage(int64_t value) {
  
  total_organization_usage_ = value;
}
inline void RegistryItem::set_total_organization_usage(int64_t value) {
  _internal_set_total_organization_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_organization_usage)
}

// int64 total_external_organization_usage = 14 [json_name = "totalExternalOrganizationUsage"];
inline void RegistryItem::clear_total_external_organization_usage() {
  total_external_organization_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_external_organization_usage() const {
  return total_external_organization_usage_;
}
inline int64_t RegistryItem::total_external_organization_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_external_organization_usage)
  return _internal_total_external_organization_usage();
}
inline void RegistryItem::_internal_set_total_external_organization_usage(int64_t value) {
  
  total_external_organization_usage_ = value;
}
inline void RegistryItem::set_total_external_organization_usage(int64_t value) {
  _internal_set_total_external_organization_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_external_organization_usage)
}

// .viam.app.v1.ModuleMetadata module_metadata = 11 [json_name = "moduleMetadata"];
inline bool RegistryItem::_internal_has_module_metadata() const {
  return metadata_case() == kModuleMetadata;
}
inline bool RegistryItem::has_module_metadata() const {
  return _internal_has_module_metadata();
}
inline void RegistryItem::set_has_module_metadata() {
  _oneof_case_[0] = kModuleMetadata;
}
inline void RegistryItem::clear_module_metadata() {
  if (_internal_has_module_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.module_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::release_module_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.module_metadata)
  if (_internal_has_module_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::ModuleMetadata* temp = metadata_.module_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.module_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::ModuleMetadata& RegistryItem::_internal_module_metadata() const {
  return _internal_has_module_metadata()
      ? *metadata_.module_metadata_
      : reinterpret_cast< ::viam::app::v1::ModuleMetadata&>(::viam::app::v1::_ModuleMetadata_default_instance_);
}
inline const ::viam::app::v1::ModuleMetadata& RegistryItem::module_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.module_metadata)
  return _internal_module_metadata();
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::unsafe_arena_release_module_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.RegistryItem.module_metadata)
  if (_internal_has_module_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::ModuleMetadata* temp = metadata_.module_metadata_;
    metadata_.module_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistryItem::unsafe_arena_set_allocated_module_metadata(::viam::app::v1::ModuleMetadata* module_metadata) {
  clear_metadata();
  if (module_metadata) {
    set_has_module_metadata();
    metadata_.module_metadata_ = module_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.module_metadata)
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::_internal_mutable_module_metadata() {
  if (!_internal_has_module_metadata()) {
    clear_metadata();
    set_has_module_metadata();
    metadata_.module_metadata_ = CreateMaybeMessage< ::viam::app::v1::ModuleMetadata >(GetArenaForAllocation());
  }
  return metadata_.module_metadata_;
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::mutable_module_metadata() {
  ::viam::app::v1::ModuleMetadata* _msg = _internal_mutable_module_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.module_metadata)
  return _msg;
}

// .viam.app.v1.MLModelMetadata ml_model_metadata = 12 [json_name = "mlModelMetadata"];
inline bool RegistryItem::_internal_has_ml_model_metadata() const {
  return metadata_case() == kMlModelMetadata;
}
inline bool RegistryItem::has_ml_model_metadata() const {
  return _internal_has_ml_model_metadata();
}
inline void RegistryItem::set_has_ml_model_metadata() {
  _oneof_case_[0] = kMlModelMetadata;
}
inline void RegistryItem::clear_ml_model_metadata() {
  if (_internal_has_ml_model_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.ml_model_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::release_ml_model_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.ml_model_metadata)
  if (_internal_has_ml_model_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::MLModelMetadata* temp = metadata_.ml_model_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.ml_model_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::MLModelMetadata& RegistryItem::_internal_ml_model_metadata() const {
  return _internal_has_ml_model_metadata()
      ? *metadata_.ml_model_metadata_
      : reinterpret_cast< ::viam::app::v1::MLModelMetadata&>(::viam::app::v1::_MLModelMetadata_default_instance_);
}
inline const ::viam::app::v1::MLModelMetadata& RegistryItem::ml_model_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.ml_model_metadata)
  return _internal_ml_model_metadata();
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::unsafe_arena_release_ml_model_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.RegistryItem.ml_model_metadata)
  if (_internal_has_ml_model_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::MLModelMetadata* temp = metadata_.ml_model_metadata_;
    metadata_.ml_model_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistryItem::unsafe_arena_set_allocated_ml_model_metadata(::viam::app::v1::MLModelMetadata* ml_model_metadata) {
  clear_metadata();
  if (ml_model_metadata) {
    set_has_ml_model_metadata();
    metadata_.ml_model_metadata_ = ml_model_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.ml_model_metadata)
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::_internal_mutable_ml_model_metadata() {
  if (!_internal_has_ml_model_metadata()) {
    clear_metadata();
    set_has_ml_model_metadata();
    metadata_.ml_model_metadata_ = CreateMaybeMessage< ::viam::app::v1::MLModelMetadata >(GetArenaForAllocation());
  }
  return metadata_.ml_model_metadata_;
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::mutable_ml_model_metadata() {
  ::viam::app::v1::MLModelMetadata* _msg = _internal_mutable_ml_model_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.ml_model_metadata)
  return _msg;
}

// .viam.app.v1.MLTrainingMetadata ml_training_metadata = 18 [json_name = "mlTrainingMetadata"];
inline bool RegistryItem::_internal_has_ml_training_metadata() const {
  return metadata_case() == kMlTrainingMetadata;
}
inline bool RegistryItem::has_ml_training_metadata() const {
  return _internal_has_ml_training_metadata();
}
inline void RegistryItem::set_has_ml_training_metadata() {
  _oneof_case_[0] = kMlTrainingMetadata;
}
inline void RegistryItem::clear_ml_training_metadata() {
  if (_internal_has_ml_training_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.ml_training_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::MLTrainingMetadata* RegistryItem::release_ml_training_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.ml_training_metadata)
  if (_internal_has_ml_training_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::MLTrainingMetadata* temp = metadata_.ml_training_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.ml_training_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::MLTrainingMetadata& RegistryItem::_internal_ml_training_metadata() const {
  return _internal_has_ml_training_metadata()
      ? *metadata_.ml_training_metadata_
      : reinterpret_cast< ::viam::app::v1::MLTrainingMetadata&>(::viam::app::v1::_MLTrainingMetadata_default_instance_);
}
inline const ::viam::app::v1::MLTrainingMetadata& RegistryItem::ml_training_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.ml_training_metadata)
  return _internal_ml_training_metadata();
}
inline ::viam::app::v1::MLTrainingMetadata* RegistryItem::unsafe_arena_release_ml_training_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.RegistryItem.ml_training_metadata)
  if (_internal_has_ml_training_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::MLTrainingMetadata* temp = metadata_.ml_training_metadata_;
    metadata_.ml_training_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistryItem::unsafe_arena_set_allocated_ml_training_metadata(::viam::app::v1::MLTrainingMetadata* ml_training_metadata) {
  clear_metadata();
  if (ml_training_metadata) {
    set_has_ml_training_metadata();
    metadata_.ml_training_metadata_ = ml_training_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.ml_training_metadata)
}
inline ::viam::app::v1::MLTrainingMetadata* RegistryItem::_internal_mutable_ml_training_metadata() {
  if (!_internal_has_ml_training_metadata()) {
    clear_metadata();
    set_has_ml_training_metadata();
    metadata_.ml_training_metadata_ = CreateMaybeMessage< ::viam::app::v1::MLTrainingMetadata >(GetArenaForAllocation());
  }
  return metadata_.ml_training_metadata_;
}
inline ::viam::app::v1::MLTrainingMetadata* RegistryItem::mutable_ml_training_metadata() {
  ::viam::app::v1::MLTrainingMetadata* _msg = _internal_mutable_ml_training_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.ml_training_metadata)
  return _msg;
}

// .google.protobuf.Timestamp created_at = 15 [json_name = "createdAt"];
inline bool RegistryItem::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool RegistryItem::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::created_at() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.created_at)
  return _internal_created_at();
}
inline void RegistryItem::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.created_at)
  return _msg;
}
inline void RegistryItem::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.created_at)
}

// .google.protobuf.Timestamp updated_at = 16 [json_name = "updatedAt"];
inline bool RegistryItem::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool RegistryItem::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::updated_at() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.updated_at)
  return _internal_updated_at();
}
inline void RegistryItem::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.updated_at)
  return _msg;
}
inline void RegistryItem::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.updated_at)
}

inline bool RegistryItem::has_metadata() const {
  return metadata_case() != METADATA_NOT_SET;
}
inline void RegistryItem::clear_has_metadata() {
  _oneof_case_[0] = METADATA_NOT_SET;
}
inline RegistryItem::MetadataCase RegistryItem::metadata_case() const {
  return RegistryItem::MetadataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void GetRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& GetRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRegistryItemRequest.item_id)
}
inline std::string* GetRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& GetRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void GetRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void GetRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRegistryItemRequest.item_id)
}

// optional bool include_markdown_documentation = 2 [json_name = "includeMarkdownDocumentation"];
inline bool GetRegistryItemRequest::_internal_has_include_markdown_documentation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetRegistryItemRequest::has_include_markdown_documentation() const {
  return _internal_has_include_markdown_documentation();
}
inline void GetRegistryItemRequest::clear_include_markdown_documentation() {
  include_markdown_documentation_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool GetRegistryItemRequest::_internal_include_markdown_documentation() const {
  return include_markdown_documentation_;
}
inline bool GetRegistryItemRequest::include_markdown_documentation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRegistryItemRequest.include_markdown_documentation)
  return _internal_include_markdown_documentation();
}
inline void GetRegistryItemRequest::_internal_set_include_markdown_documentation(bool value) {
  _has_bits_[0] |= 0x00000001u;
  include_markdown_documentation_ = value;
}
inline void GetRegistryItemRequest::set_include_markdown_documentation(bool value) {
  _internal_set_include_markdown_documentation(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRegistryItemRequest.include_markdown_documentation)
}

// -------------------------------------------------------------------

// GetRegistryItemResponse

// .viam.app.v1.RegistryItem item = 1 [json_name = "item"];
inline bool GetRegistryItemResponse::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool GetRegistryItemResponse::has_item() const {
  return _internal_has_item();
}
inline void GetRegistryItemResponse::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::viam::app::v1::RegistryItem& GetRegistryItemResponse::_internal_item() const {
  const ::viam::app::v1::RegistryItem* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RegistryItem&>(
      ::viam::app::v1::_RegistryItem_default_instance_);
}
inline const ::viam::app::v1::RegistryItem& GetRegistryItemResponse::item() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRegistryItemResponse.item)
  return _internal_item();
}
inline void GetRegistryItemResponse::unsafe_arena_set_allocated_item(
    ::viam::app::v1::RegistryItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRegistryItemResponse.item)
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::release_item() {
  
  ::viam::app::v1::RegistryItem* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRegistryItemResponse.item)
  
  ::viam::app::v1::RegistryItem* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RegistryItem>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::mutable_item() {
  ::viam::app::v1::RegistryItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRegistryItemResponse.item)
  return _msg;
}
inline void GetRegistryItemResponse::set_allocated_item(::viam::app::v1::RegistryItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRegistryItemResponse.item)
}

// -------------------------------------------------------------------

// CreateRegistryItemRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateRegistryItemRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateRegistryItemRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRegistryItemRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRegistryItemRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRegistryItemRequest.organization_id)
}
inline std::string* CreateRegistryItemRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRegistryItemRequest.organization_id)
  return _s;
}
inline const std::string& CreateRegistryItemRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateRegistryItemRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRegistryItemRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateRegistryItemRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRegistryItemRequest.organization_id)
}

// string name = 2 [json_name = "name"];
inline void CreateRegistryItemRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateRegistryItemRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRegistryItemRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRegistryItemRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRegistryItemRequest.name)
}
inline std::string* CreateRegistryItemRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRegistryItemRequest.name)
  return _s;
}
inline const std::string& CreateRegistryItemRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateRegistryItemRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRegistryItemRequest.name)
  return name_.Release();
}
inline void CreateRegistryItemRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRegistryItemRequest.name)
}

// .viam.app.packages.v1.PackageType type = 3 [json_name = "type"];
inline void CreateRegistryItemRequest::clear_type() {
  type_ = 0;
}
inline ::viam::app::packages::v1::PackageType CreateRegistryItemRequest::_internal_type() const {
  return static_cast< ::viam::app::packages::v1::PackageType >(type_);
}
inline ::viam::app::packages::v1::PackageType CreateRegistryItemRequest::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRegistryItemRequest.type)
  return _internal_type();
}
inline void CreateRegistryItemRequest::_internal_set_type(::viam::app::packages::v1::PackageType value) {
  
  type_ = value;
}
inline void CreateRegistryItemRequest::set_type(::viam::app::packages::v1::PackageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRegistryItemRequest.type)
}

// -------------------------------------------------------------------

// CreateRegistryItemResponse

// -------------------------------------------------------------------

// UpdateRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void UpdateRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& UpdateRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.item_id)
}
inline std::string* UpdateRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& UpdateRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void UpdateRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void UpdateRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRegistryItemRequest.item_id)
}

// .viam.app.packages.v1.PackageType type = 2 [json_name = "type"];
inline void UpdateRegistryItemRequest::clear_type() {
  type_ = 0;
}
inline ::viam::app::packages::v1::PackageType UpdateRegistryItemRequest::_internal_type() const {
  return static_cast< ::viam::app::packages::v1::PackageType >(type_);
}
inline ::viam::app::packages::v1::PackageType UpdateRegistryItemRequest::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.type)
  return _internal_type();
}
inline void UpdateRegistryItemRequest::_internal_set_type(::viam::app::packages::v1::PackageType value) {
  
  type_ = value;
}
inline void UpdateRegistryItemRequest::set_type(::viam::app::packages::v1::PackageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.type)
}

// string description = 3 [json_name = "description"];
inline void UpdateRegistryItemRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& UpdateRegistryItemRequest::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRegistryItemRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.description)
}
inline std::string* UpdateRegistryItemRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.description)
  return _s;
}
inline const std::string& UpdateRegistryItemRequest::_internal_description() const {
  return description_.Get();
}
inline void UpdateRegistryItemRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.description)
  return description_.Release();
}
inline void UpdateRegistryItemRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRegistryItemRequest.description)
}

// .viam.app.v1.Visibility visibility = 4 [json_name = "visibility"];
inline void UpdateRegistryItemRequest::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility UpdateRegistryItemRequest::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility UpdateRegistryItemRequest::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.visibility)
  return _internal_visibility();
}
inline void UpdateRegistryItemRequest::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void UpdateRegistryItemRequest::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.visibility)
}

// optional string url = 5 [json_name = "url"];
inline bool UpdateRegistryItemRequest::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateRegistryItemRequest::has_url() const {
  return _internal_has_url();
}
inline void UpdateRegistryItemRequest::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateRegistryItemRequest::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRegistryItemRequest::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.url)
}
inline std::string* UpdateRegistryItemRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.url)
  return _s;
}
inline const std::string& UpdateRegistryItemRequest::_internal_url() const {
  return url_.Get();
}
inline void UpdateRegistryItemRequest::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateRegistryItemRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRegistryItemRequest.url)
}

// .viam.app.v1.UpdateModuleMetadata update_module_metadata = 6 [json_name = "updateModuleMetadata"];
inline bool UpdateRegistryItemRequest::_internal_has_update_module_metadata() const {
  return metadata_case() == kUpdateModuleMetadata;
}
inline bool UpdateRegistryItemRequest::has_update_module_metadata() const {
  return _internal_has_update_module_metadata();
}
inline void UpdateRegistryItemRequest::set_has_update_module_metadata() {
  _oneof_case_[0] = kUpdateModuleMetadata;
}
inline void UpdateRegistryItemRequest::clear_update_module_metadata() {
  if (_internal_has_update_module_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.update_module_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::UpdateModuleMetadata* UpdateRegistryItemRequest::release_update_module_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.update_module_metadata)
  if (_internal_has_update_module_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::UpdateModuleMetadata* temp = metadata_.update_module_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.update_module_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::UpdateModuleMetadata& UpdateRegistryItemRequest::_internal_update_module_metadata() const {
  return _internal_has_update_module_metadata()
      ? *metadata_.update_module_metadata_
      : reinterpret_cast< ::viam::app::v1::UpdateModuleMetadata&>(::viam::app::v1::_UpdateModuleMetadata_default_instance_);
}
inline const ::viam::app::v1::UpdateModuleMetadata& UpdateRegistryItemRequest::update_module_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.update_module_metadata)
  return _internal_update_module_metadata();
}
inline ::viam::app::v1::UpdateModuleMetadata* UpdateRegistryItemRequest::unsafe_arena_release_update_module_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.UpdateRegistryItemRequest.update_module_metadata)
  if (_internal_has_update_module_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::UpdateModuleMetadata* temp = metadata_.update_module_metadata_;
    metadata_.update_module_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateRegistryItemRequest::unsafe_arena_set_allocated_update_module_metadata(::viam::app::v1::UpdateModuleMetadata* update_module_metadata) {
  clear_metadata();
  if (update_module_metadata) {
    set_has_update_module_metadata();
    metadata_.update_module_metadata_ = update_module_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRegistryItemRequest.update_module_metadata)
}
inline ::viam::app::v1::UpdateModuleMetadata* UpdateRegistryItemRequest::_internal_mutable_update_module_metadata() {
  if (!_internal_has_update_module_metadata()) {
    clear_metadata();
    set_has_update_module_metadata();
    metadata_.update_module_metadata_ = CreateMaybeMessage< ::viam::app::v1::UpdateModuleMetadata >(GetArenaForAllocation());
  }
  return metadata_.update_module_metadata_;
}
inline ::viam::app::v1::UpdateModuleMetadata* UpdateRegistryItemRequest::mutable_update_module_metadata() {
  ::viam::app::v1::UpdateModuleMetadata* _msg = _internal_mutable_update_module_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.update_module_metadata)
  return _msg;
}

// .viam.app.v1.UpdateMLModelMetadata update_ml_model_metadata = 7 [json_name = "updateMlModelMetadata"];
inline bool UpdateRegistryItemRequest::_internal_has_update_ml_model_metadata() const {
  return metadata_case() == kUpdateMlModelMetadata;
}
inline bool UpdateRegistryItemRequest::has_update_ml_model_metadata() const {
  return _internal_has_update_ml_model_metadata();
}
inline void UpdateRegistryItemRequest::set_has_update_ml_model_metadata() {
  _oneof_case_[0] = kUpdateMlModelMetadata;
}
inline void UpdateRegistryItemRequest::clear_update_ml_model_metadata() {
  if (_internal_has_update_ml_model_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.update_ml_model_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::UpdateMLModelMetadata* UpdateRegistryItemRequest::release_update_ml_model_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.update_ml_model_metadata)
  if (_internal_has_update_ml_model_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::UpdateMLModelMetadata* temp = metadata_.update_ml_model_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.update_ml_model_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::UpdateMLModelMetadata& UpdateRegistryItemRequest::_internal_update_ml_model_metadata() const {
  return _internal_has_update_ml_model_metadata()
      ? *metadata_.update_ml_model_metadata_
      : reinterpret_cast< ::viam::app::v1::UpdateMLModelMetadata&>(::viam::app::v1::_UpdateMLModelMetadata_default_instance_);
}
inline const ::viam::app::v1::UpdateMLModelMetadata& UpdateRegistryItemRequest::update_ml_model_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.update_ml_model_metadata)
  return _internal_update_ml_model_metadata();
}
inline ::viam::app::v1::UpdateMLModelMetadata* UpdateRegistryItemRequest::unsafe_arena_release_update_ml_model_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.UpdateRegistryItemRequest.update_ml_model_metadata)
  if (_internal_has_update_ml_model_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::UpdateMLModelMetadata* temp = metadata_.update_ml_model_metadata_;
    metadata_.update_ml_model_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateRegistryItemRequest::unsafe_arena_set_allocated_update_ml_model_metadata(::viam::app::v1::UpdateMLModelMetadata* update_ml_model_metadata) {
  clear_metadata();
  if (update_ml_model_metadata) {
    set_has_update_ml_model_metadata();
    metadata_.update_ml_model_metadata_ = update_ml_model_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRegistryItemRequest.update_ml_model_metadata)
}
inline ::viam::app::v1::UpdateMLModelMetadata* UpdateRegistryItemRequest::_internal_mutable_update_ml_model_metadata() {
  if (!_internal_has_update_ml_model_metadata()) {
    clear_metadata();
    set_has_update_ml_model_metadata();
    metadata_.update_ml_model_metadata_ = CreateMaybeMessage< ::viam::app::v1::UpdateMLModelMetadata >(GetArenaForAllocation());
  }
  return metadata_.update_ml_model_metadata_;
}
inline ::viam::app::v1::UpdateMLModelMetadata* UpdateRegistryItemRequest::mutable_update_ml_model_metadata() {
  ::viam::app::v1::UpdateMLModelMetadata* _msg = _internal_mutable_update_ml_model_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.update_ml_model_metadata)
  return _msg;
}

// .viam.app.v1.UpdateMLTrainingMetadata update_ml_training_metadata = 8 [json_name = "updateMlTrainingMetadata"];
inline bool UpdateRegistryItemRequest::_internal_has_update_ml_training_metadata() const {
  return metadata_case() == kUpdateMlTrainingMetadata;
}
inline bool UpdateRegistryItemRequest::has_update_ml_training_metadata() const {
  return _internal_has_update_ml_training_metadata();
}
inline void UpdateRegistryItemRequest::set_has_update_ml_training_metadata() {
  _oneof_case_[0] = kUpdateMlTrainingMetadata;
}
inline void UpdateRegistryItemRequest::clear_update_ml_training_metadata() {
  if (_internal_has_update_ml_training_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.update_ml_training_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::UpdateMLTrainingMetadata* UpdateRegistryItemRequest::release_update_ml_training_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.update_ml_training_metadata)
  if (_internal_has_update_ml_training_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::UpdateMLTrainingMetadata* temp = metadata_.update_ml_training_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.update_ml_training_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::UpdateMLTrainingMetadata& UpdateRegistryItemRequest::_internal_update_ml_training_metadata() const {
  return _internal_has_update_ml_training_metadata()
      ? *metadata_.update_ml_training_metadata_
      : reinterpret_cast< ::viam::app::v1::UpdateMLTrainingMetadata&>(::viam::app::v1::_UpdateMLTrainingMetadata_default_instance_);
}
inline const ::viam::app::v1::UpdateMLTrainingMetadata& UpdateRegistryItemRequest::update_ml_training_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.update_ml_training_metadata)
  return _internal_update_ml_training_metadata();
}
inline ::viam::app::v1::UpdateMLTrainingMetadata* UpdateRegistryItemRequest::unsafe_arena_release_update_ml_training_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.UpdateRegistryItemRequest.update_ml_training_metadata)
  if (_internal_has_update_ml_training_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::UpdateMLTrainingMetadata* temp = metadata_.update_ml_training_metadata_;
    metadata_.update_ml_training_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateRegistryItemRequest::unsafe_arena_set_allocated_update_ml_training_metadata(::viam::app::v1::UpdateMLTrainingMetadata* update_ml_training_metadata) {
  clear_metadata();
  if (update_ml_training_metadata) {
    set_has_update_ml_training_metadata();
    metadata_.update_ml_training_metadata_ = update_ml_training_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRegistryItemRequest.update_ml_training_metadata)
}
inline ::viam::app::v1::UpdateMLTrainingMetadata* UpdateRegistryItemRequest::_internal_mutable_update_ml_training_metadata() {
  if (!_internal_has_update_ml_training_metadata()) {
    clear_metadata();
    set_has_update_ml_training_metadata();
    metadata_.update_ml_training_metadata_ = CreateMaybeMessage< ::viam::app::v1::UpdateMLTrainingMetadata >(GetArenaForAllocation());
  }
  return metadata_.update_ml_training_metadata_;
}
inline ::viam::app::v1::UpdateMLTrainingMetadata* UpdateRegistryItemRequest::mutable_update_ml_training_metadata() {
  ::viam::app::v1::UpdateMLTrainingMetadata* _msg = _internal_mutable_update_ml_training_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.update_ml_training_metadata)
  return _msg;
}

// optional string markdown_description = 9 [json_name = "markdownDescription"];
inline bool UpdateRegistryItemRequest::_internal_has_markdown_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateRegistryItemRequest::has_markdown_description() const {
  return _internal_has_markdown_description();
}
inline void UpdateRegistryItemRequest::clear_markdown_description() {
  markdown_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateRegistryItemRequest::markdown_description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.markdown_description)
  return _internal_markdown_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRegistryItemRequest::set_markdown_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 markdown_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.markdown_description)
}
inline std::string* UpdateRegistryItemRequest::mutable_markdown_description() {
  std::string* _s = _internal_mutable_markdown_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.markdown_description)
  return _s;
}
inline const std::string& UpdateRegistryItemRequest::_internal_markdown_description() const {
  return markdown_description_.Get();
}
inline void UpdateRegistryItemRequest::_internal_set_markdown_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  markdown_description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::_internal_mutable_markdown_description() {
  _has_bits_[0] |= 0x00000002u;
  return markdown_description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::release_markdown_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.markdown_description)
  if (!_internal_has_markdown_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = markdown_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateRegistryItemRequest::set_allocated_markdown_description(std::string* markdown_description) {
  if (markdown_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  markdown_description_.SetAllocated(markdown_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRegistryItemRequest.markdown_description)
}

inline bool UpdateRegistryItemRequest::has_metadata() const {
  return metadata_case() != METADATA_NOT_SET;
}
inline void UpdateRegistryItemRequest::clear_has_metadata() {
  _oneof_case_[0] = METADATA_NOT_SET;
}
inline UpdateRegistryItemRequest::MetadataCase UpdateRegistryItemRequest::metadata_case() const {
  return UpdateRegistryItemRequest::MetadataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateRegistryItemResponse

// -------------------------------------------------------------------

// ListRegistryItemsRequest

// optional string organization_id = 1 [json_name = "organizationId"];
inline bool ListRegistryItemsRequest::_internal_has_organization_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListRegistryItemsRequest::has_organization_id() const {
  return _internal_has_organization_id();
}
inline void ListRegistryItemsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListRegistryItemsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRegistryItemsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.organization_id)
}
inline std::string* ListRegistryItemsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.organization_id)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListRegistryItemsRequest::_internal_set_organization_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::_internal_mutable_organization_id() {
  _has_bits_[0] |= 0x00000001u;
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRegistryItemsRequest.organization_id)
  if (!_internal_has_organization_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = organization_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListRegistryItemsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRegistryItemsRequest.organization_id)
}

// repeated .viam.app.packages.v1.PackageType types = 2 [json_name = "types"];
inline int ListRegistryItemsRequest::_internal_types_size() const {
  return types_.size();
}
inline int ListRegistryItemsRequest::types_size() const {
  return _internal_types_size();
}
inline void ListRegistryItemsRequest::clear_types() {
  types_.Clear();
}
inline ::viam::app::packages::v1::PackageType ListRegistryItemsRequest::_internal_types(int index) const {
  return static_cast< ::viam::app::packages::v1::PackageType >(types_.Get(index));
}
inline ::viam::app::packages::v1::PackageType ListRegistryItemsRequest::types(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.types)
  return _internal_types(index);
}
inline void ListRegistryItemsRequest::set_types(int index, ::viam::app::packages::v1::PackageType value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.types)
}
inline void ListRegistryItemsRequest::_internal_add_types(::viam::app::packages::v1::PackageType value) {
  types_.Add(value);
}
inline void ListRegistryItemsRequest::add_types(::viam::app::packages::v1::PackageType value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::types() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.types)
  return types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_types() {
  return &types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.types)
  return _internal_mutable_types();
}

// repeated .viam.app.v1.Visibility visibilities = 3 [json_name = "visibilities"];
inline int ListRegistryItemsRequest::_internal_visibilities_size() const {
  return visibilities_.size();
}
inline int ListRegistryItemsRequest::visibilities_size() const {
  return _internal_visibilities_size();
}
inline void ListRegistryItemsRequest::clear_visibilities() {
  visibilities_.Clear();
}
inline ::viam::app::v1::Visibility ListRegistryItemsRequest::_internal_visibilities(int index) const {
  return static_cast< ::viam::app::v1::Visibility >(visibilities_.Get(index));
}
inline ::viam::app::v1::Visibility ListRegistryItemsRequest::visibilities(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.visibilities)
  return _internal_visibilities(index);
}
inline void ListRegistryItemsRequest::set_visibilities(int index, ::viam::app::v1::Visibility value) {
  visibilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.visibilities)
}
inline void ListRegistryItemsRequest::_internal_add_visibilities(::viam::app::v1::Visibility value) {
  visibilities_.Add(value);
}
inline void ListRegistryItemsRequest::add_visibilities(::viam::app::v1::Visibility value) {
  _internal_add_visibilities(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.visibilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::visibilities() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.visibilities)
  return visibilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_visibilities() {
  return &visibilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_visibilities() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.visibilities)
  return _internal_mutable_visibilities();
}

// repeated string platforms = 4 [json_name = "platforms"];
inline int ListRegistryItemsRequest::_internal_platforms_size() const {
  return platforms_.size();
}
inline int ListRegistryItemsRequest::platforms_size() const {
  return _internal_platforms_size();
}
inline void ListRegistryItemsRequest::clear_platforms() {
  platforms_.Clear();
}
inline std::string* ListRegistryItemsRequest::add_platforms() {
  std::string* _s = _internal_add_platforms();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListRegistryItemsRequest.platforms)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_platforms(int index) const {
  return platforms_.Get(index);
}
inline const std::string& ListRegistryItemsRequest::platforms(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.platforms)
  return _internal_platforms(index);
}
inline std::string* ListRegistryItemsRequest::mutable_platforms(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.platforms)
  return platforms_.Mutable(index);
}
inline void ListRegistryItemsRequest::set_platforms(int index, const std::string& value) {
  platforms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::set_platforms(int index, std::string&& value) {
  platforms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::set_platforms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platforms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::set_platforms(int index, const char* value, size_t size) {
  platforms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline std::string* ListRegistryItemsRequest::_internal_add_platforms() {
  return platforms_.Add();
}
inline void ListRegistryItemsRequest::add_platforms(const std::string& value) {
  platforms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::add_platforms(std::string&& value) {
  platforms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::add_platforms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platforms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::add_platforms(const char* value, size_t size) {
  platforms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRegistryItemsRequest::platforms() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.platforms)
  return platforms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRegistryItemsRequest::mutable_platforms() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.platforms)
  return &platforms_;
}

// repeated .viam.app.v1.RegistryItemStatus statuses = 5 [json_name = "statuses"];
inline int ListRegistryItemsRequest::_internal_statuses_size() const {
  return statuses_.size();
}
inline int ListRegistryItemsRequest::statuses_size() const {
  return _internal_statuses_size();
}
inline void ListRegistryItemsRequest::clear_statuses() {
  statuses_.Clear();
}
inline ::viam::app::v1::RegistryItemStatus ListRegistryItemsRequest::_internal_statuses(int index) const {
  return static_cast< ::viam::app::v1::RegistryItemStatus >(statuses_.Get(index));
}
inline ::viam::app::v1::RegistryItemStatus ListRegistryItemsRequest::statuses(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.statuses)
  return _internal_statuses(index);
}
inline void ListRegistryItemsRequest::set_statuses(int index, ::viam::app::v1::RegistryItemStatus value) {
  statuses_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.statuses)
}
inline void ListRegistryItemsRequest::_internal_add_statuses(::viam::app::v1::RegistryItemStatus value) {
  statuses_.Add(value);
}
inline void ListRegistryItemsRequest::add_statuses(::viam::app::v1::RegistryItemStatus value) {
  _internal_add_statuses(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.statuses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::statuses() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.statuses)
  return statuses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_statuses() {
  return &statuses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.statuses)
  return _internal_mutable_statuses();
}

// optional string search_term = 6 [json_name = "searchTerm"];
inline bool ListRegistryItemsRequest::_internal_has_search_term() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListRegistryItemsRequest::has_search_term() const {
  return _internal_has_search_term();
}
inline void ListRegistryItemsRequest::clear_search_term() {
  search_term_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListRegistryItemsRequest::search_term() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.search_term)
  return _internal_search_term();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRegistryItemsRequest::set_search_term(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 search_term_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.search_term)
}
inline std::string* ListRegistryItemsRequest::mutable_search_term() {
  std::string* _s = _internal_mutable_search_term();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.search_term)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_search_term() const {
  return search_term_.Get();
}
inline void ListRegistryItemsRequest::_internal_set_search_term(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  search_term_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::_internal_mutable_search_term() {
  _has_bits_[0] |= 0x00000002u;
  return search_term_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::release_search_term() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRegistryItemsRequest.search_term)
  if (!_internal_has_search_term()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = search_term_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_term_.IsDefault()) {
    search_term_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListRegistryItemsRequest::set_allocated_search_term(std::string* search_term) {
  if (search_term != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  search_term_.SetAllocated(search_term, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_term_.IsDefault()) {
    search_term_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRegistryItemsRequest.search_term)
}

// optional string page_token = 7 [json_name = "pageToken"];
inline bool ListRegistryItemsRequest::_internal_has_page_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListRegistryItemsRequest::has_page_token() const {
  return _internal_has_page_token();
}
inline void ListRegistryItemsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ListRegistryItemsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRegistryItemsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.page_token)
}
inline std::string* ListRegistryItemsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.page_token)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListRegistryItemsRequest::_internal_set_page_token(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::_internal_mutable_page_token() {
  _has_bits_[0] |= 0x00000004u;
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRegistryItemsRequest.page_token)
  if (!_internal_has_page_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListRegistryItemsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRegistryItemsRequest.page_token)
}

// repeated string public_namespaces = 8 [json_name = "publicNamespaces"];
inline int ListRegistryItemsRequest::_internal_public_namespaces_size() const {
  return public_namespaces_.size();
}
inline int ListRegistryItemsRequest::public_namespaces_size() const {
  return _internal_public_namespaces_size();
}
inline void ListRegistryItemsRequest::clear_public_namespaces() {
  public_namespaces_.Clear();
}
inline std::string* ListRegistryItemsRequest::add_public_namespaces() {
  std::string* _s = _internal_add_public_namespaces();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_public_namespaces(int index) const {
  return public_namespaces_.Get(index);
}
inline const std::string& ListRegistryItemsRequest::public_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
  return _internal_public_namespaces(index);
}
inline std::string* ListRegistryItemsRequest::mutable_public_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
  return public_namespaces_.Mutable(index);
}
inline void ListRegistryItemsRequest::set_public_namespaces(int index, const std::string& value) {
  public_namespaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline void ListRegistryItemsRequest::set_public_namespaces(int index, std::string&& value) {
  public_namespaces_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline void ListRegistryItemsRequest::set_public_namespaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  public_namespaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline void ListRegistryItemsRequest::set_public_namespaces(int index, const char* value, size_t size) {
  public_namespaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline std::string* ListRegistryItemsRequest::_internal_add_public_namespaces() {
  return public_namespaces_.Add();
}
inline void ListRegistryItemsRequest::add_public_namespaces(const std::string& value) {
  public_namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline void ListRegistryItemsRequest::add_public_namespaces(std::string&& value) {
  public_namespaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline void ListRegistryItemsRequest::add_public_namespaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  public_namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline void ListRegistryItemsRequest::add_public_namespaces(const char* value, size_t size) {
  public_namespaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRegistryItemsRequest::public_namespaces() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
  return public_namespaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRegistryItemsRequest::mutable_public_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.public_namespaces)
  return &public_namespaces_;
}

// optional bool include_markdown_documentation = 9 [json_name = "includeMarkdownDocumentation"];
inline bool ListRegistryItemsRequest::_internal_has_include_markdown_documentation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ListRegistryItemsRequest::has_include_markdown_documentation() const {
  return _internal_has_include_markdown_documentation();
}
inline void ListRegistryItemsRequest::clear_include_markdown_documentation() {
  include_markdown_documentation_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ListRegistryItemsRequest::_internal_include_markdown_documentation() const {
  return include_markdown_documentation_;
}
inline bool ListRegistryItemsRequest::include_markdown_documentation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.include_markdown_documentation)
  return _internal_include_markdown_documentation();
}
inline void ListRegistryItemsRequest::_internal_set_include_markdown_documentation(bool value) {
  _has_bits_[0] |= 0x00000008u;
  include_markdown_documentation_ = value;
}
inline void ListRegistryItemsRequest::set_include_markdown_documentation(bool value) {
  _internal_set_include_markdown_documentation(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.include_markdown_documentation)
}

// repeated .viam.app.v1.ModuleSourceType module_source_types = 10 [json_name = "moduleSourceTypes"];
inline int ListRegistryItemsRequest::_internal_module_source_types_size() const {
  return module_source_types_.size();
}
inline int ListRegistryItemsRequest::module_source_types_size() const {
  return _internal_module_source_types_size();
}
inline void ListRegistryItemsRequest::clear_module_source_types() {
  module_source_types_.Clear();
}
inline ::viam::app::v1::ModuleSourceType ListRegistryItemsRequest::_internal_module_source_types(int index) const {
  return static_cast< ::viam::app::v1::ModuleSourceType >(module_source_types_.Get(index));
}
inline ::viam::app::v1::ModuleSourceType ListRegistryItemsRequest::module_source_types(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.module_source_types)
  return _internal_module_source_types(index);
}
inline void ListRegistryItemsRequest::set_module_source_types(int index, ::viam::app::v1::ModuleSourceType value) {
  module_source_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.module_source_types)
}
inline void ListRegistryItemsRequest::_internal_add_module_source_types(::viam::app::v1::ModuleSourceType value) {
  module_source_types_.Add(value);
}
inline void ListRegistryItemsRequest::add_module_source_types(::viam::app::v1::ModuleSourceType value) {
  _internal_add_module_source_types(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.module_source_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::module_source_types() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.module_source_types)
  return module_source_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_module_source_types() {
  return &module_source_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_module_source_types() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.module_source_types)
  return _internal_mutable_module_source_types();
}

// repeated .viam.app.v1.ModuleLanguage module_languages = 11 [json_name = "moduleLanguages"];
inline int ListRegistryItemsRequest::_internal_module_languages_size() const {
  return module_languages_.size();
}
inline int ListRegistryItemsRequest::module_languages_size() const {
  return _internal_module_languages_size();
}
inline void ListRegistryItemsRequest::clear_module_languages() {
  module_languages_.Clear();
}
inline ::viam::app::v1::ModuleLanguage ListRegistryItemsRequest::_internal_module_languages(int index) const {
  return static_cast< ::viam::app::v1::ModuleLanguage >(module_languages_.Get(index));
}
inline ::viam::app::v1::ModuleLanguage ListRegistryItemsRequest::module_languages(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.module_languages)
  return _internal_module_languages(index);
}
inline void ListRegistryItemsRequest::set_module_languages(int index, ::viam::app::v1::ModuleLanguage value) {
  module_languages_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.module_languages)
}
inline void ListRegistryItemsRequest::_internal_add_module_languages(::viam::app::v1::ModuleLanguage value) {
  module_languages_.Add(value);
}
inline void ListRegistryItemsRequest::add_module_languages(::viam::app::v1::ModuleLanguage value) {
  _internal_add_module_languages(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.module_languages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::module_languages() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.module_languages)
  return module_languages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_module_languages() {
  return &module_languages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_module_languages() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.module_languages)
  return _internal_mutable_module_languages();
}

// -------------------------------------------------------------------

// ListRegistryItemsResponse

// repeated .viam.app.v1.RegistryItem items = 1 [json_name = "items"];
inline int ListRegistryItemsResponse::_internal_items_size() const {
  return items_.size();
}
inline int ListRegistryItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ListRegistryItemsResponse::clear_items() {
  items_.Clear();
}
inline ::viam::app::v1::RegistryItem* ListRegistryItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >*
ListRegistryItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsResponse.items)
  return &items_;
}
inline const ::viam::app::v1::RegistryItem& ListRegistryItemsResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::viam::app::v1::RegistryItem& ListRegistryItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsResponse.items)
  return _internal_items(index);
}
inline ::viam::app::v1::RegistryItem* ListRegistryItemsResponse::_internal_add_items() {
  return items_.Add();
}
inline ::viam::app::v1::RegistryItem* ListRegistryItemsResponse::add_items() {
  ::viam::app::v1::RegistryItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >&
ListRegistryItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// DeleteRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void DeleteRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& DeleteRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRegistryItemRequest.item_id)
}
inline std::string* DeleteRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& DeleteRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void DeleteRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void DeleteRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRegistryItemRequest.item_id)
}

// -------------------------------------------------------------------

// DeleteRegistryItemResponse

// -------------------------------------------------------------------

// RenameRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void RenameRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& RenameRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RenameRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RenameRegistryItemRequest.item_id)
}
inline std::string* RenameRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RenameRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& RenameRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void RenameRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RenameRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void RenameRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RenameRegistryItemRequest.item_id)
}

// string new_name = 2 [json_name = "newName"];
inline void RenameRegistryItemRequest::clear_new_name() {
  new_name_.ClearToEmpty();
}
inline const std::string& RenameRegistryItemRequest::new_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RenameRegistryItemRequest.new_name)
  return _internal_new_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRegistryItemRequest::set_new_name(ArgT0&& arg0, ArgT... args) {
 
 new_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RenameRegistryItemRequest.new_name)
}
inline std::string* RenameRegistryItemRequest::mutable_new_name() {
  std::string* _s = _internal_mutable_new_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RenameRegistryItemRequest.new_name)
  return _s;
}
inline const std::string& RenameRegistryItemRequest::_internal_new_name() const {
  return new_name_.Get();
}
inline void RenameRegistryItemRequest::_internal_set_new_name(const std::string& value) {
  
  new_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRegistryItemRequest::_internal_mutable_new_name() {
  
  return new_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRegistryItemRequest::release_new_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RenameRegistryItemRequest.new_name)
  return new_name_.Release();
}
inline void RenameRegistryItemRequest::set_allocated_new_name(std::string* new_name) {
  if (new_name != nullptr) {
    
  } else {
    
  }
  new_name_.SetAllocated(new_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_name_.IsDefault()) {
    new_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RenameRegistryItemRequest.new_name)
}

// -------------------------------------------------------------------

// RenameRegistryItemResponse

// .viam.app.v1.RegistryItem item = 1 [json_name = "item"];
inline bool RenameRegistryItemResponse::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool RenameRegistryItemResponse::has_item() const {
  return _internal_has_item();
}
inline void RenameRegistryItemResponse::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::viam::app::v1::RegistryItem& RenameRegistryItemResponse::_internal_item() const {
  const ::viam::app::v1::RegistryItem* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RegistryItem&>(
      ::viam::app::v1::_RegistryItem_default_instance_);
}
inline const ::viam::app::v1::RegistryItem& RenameRegistryItemResponse::item() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RenameRegistryItemResponse.item)
  return _internal_item();
}
inline void RenameRegistryItemResponse::unsafe_arena_set_allocated_item(
    ::viam::app::v1::RegistryItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RenameRegistryItemResponse.item)
}
inline ::viam::app::v1::RegistryItem* RenameRegistryItemResponse::release_item() {
  
  ::viam::app::v1::RegistryItem* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RegistryItem* RenameRegistryItemResponse::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RenameRegistryItemResponse.item)
  
  ::viam::app::v1::RegistryItem* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RegistryItem* RenameRegistryItemResponse::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RegistryItem>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::viam::app::v1::RegistryItem* RenameRegistryItemResponse::mutable_item() {
  ::viam::app::v1::RegistryItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RenameRegistryItemResponse.item)
  return _msg;
}
inline void RenameRegistryItemResponse::set_allocated_item(::viam::app::v1::RegistryItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RenameRegistryItemResponse.item)
}

// -------------------------------------------------------------------

// TransferRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void TransferRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& TransferRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TransferRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.TransferRegistryItemRequest.item_id)
}
inline std::string* TransferRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TransferRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& TransferRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void TransferRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TransferRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void TransferRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TransferRegistryItemRequest.item_id)
}

// string new_public_namespace = 2 [json_name = "newPublicNamespace"];
inline void TransferRegistryItemRequest::clear_new_public_namespace() {
  new_public_namespace_.ClearToEmpty();
}
inline const std::string& TransferRegistryItemRequest::new_public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TransferRegistryItemRequest.new_public_namespace)
  return _internal_new_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferRegistryItemRequest::set_new_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 new_public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.TransferRegistryItemRequest.new_public_namespace)
}
inline std::string* TransferRegistryItemRequest::mutable_new_public_namespace() {
  std::string* _s = _internal_mutable_new_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TransferRegistryItemRequest.new_public_namespace)
  return _s;
}
inline const std::string& TransferRegistryItemRequest::_internal_new_public_namespace() const {
  return new_public_namespace_.Get();
}
inline void TransferRegistryItemRequest::_internal_set_new_public_namespace(const std::string& value) {
  
  new_public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferRegistryItemRequest::_internal_mutable_new_public_namespace() {
  
  return new_public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferRegistryItemRequest::release_new_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TransferRegistryItemRequest.new_public_namespace)
  return new_public_namespace_.Release();
}
inline void TransferRegistryItemRequest::set_allocated_new_public_namespace(std::string* new_public_namespace) {
  if (new_public_namespace != nullptr) {
    
  } else {
    
  }
  new_public_namespace_.SetAllocated(new_public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_public_namespace_.IsDefault()) {
    new_public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TransferRegistryItemRequest.new_public_namespace)
}

// -------------------------------------------------------------------

// TransferRegistryItemResponse

// -------------------------------------------------------------------

// CreateModuleRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateModuleRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateModuleRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleRequest.organization_id)
}
inline std::string* CreateModuleRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleRequest.organization_id)
  return _s;
}
inline const std::string& CreateModuleRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateModuleRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateModuleRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleRequest.organization_id)
}

// string name = 2 [json_name = "name"];
inline void CreateModuleRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateModuleRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleRequest.name)
}
inline std::string* CreateModuleRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleRequest.name)
  return _s;
}
inline const std::string& CreateModuleRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateModuleRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleRequest.name)
  return name_.Release();
}
inline void CreateModuleRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleRequest.name)
}

// -------------------------------------------------------------------

// CreateModuleResponse

// string module_id = 1 [json_name = "moduleId"];
inline void CreateModuleResponse::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& CreateModuleResponse::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleResponse.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleResponse::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleResponse.module_id)
}
inline std::string* CreateModuleResponse::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleResponse.module_id)
  return _s;
}
inline const std::string& CreateModuleResponse::_internal_module_id() const {
  return module_id_.Get();
}
inline void CreateModuleResponse::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleResponse.module_id)
  return module_id_.Release();
}
inline void CreateModuleResponse::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleResponse.module_id)
}

// string url = 2 [json_name = "url"];
inline void CreateModuleResponse::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& CreateModuleResponse::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleResponse.url)
}
inline std::string* CreateModuleResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleResponse.url)
  return _s;
}
inline const std::string& CreateModuleResponse::_internal_url() const {
  return url_.Get();
}
inline void CreateModuleResponse::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleResponse.url)
  return url_.Release();
}
inline void CreateModuleResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleResponse.url)
}

// -------------------------------------------------------------------

// UpdateModuleRequest

// string module_id = 1 [json_name = "moduleId"];
inline void UpdateModuleRequest::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.module_id)
}
inline std::string* UpdateModuleRequest::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.module_id)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_module_id() const {
  return module_id_.Get();
}
inline void UpdateModuleRequest::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.module_id)
  return module_id_.Release();
}
inline void UpdateModuleRequest::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.module_id)
}

// .viam.app.v1.Visibility visibility = 2 [json_name = "visibility"];
inline void UpdateModuleRequest::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility UpdateModuleRequest::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility UpdateModuleRequest::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.visibility)
  return _internal_visibility();
}
inline void UpdateModuleRequest::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void UpdateModuleRequest::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.visibility)
}

// string url = 3 [json_name = "url"];
inline void UpdateModuleRequest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.url)
}
inline std::string* UpdateModuleRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.url)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_url() const {
  return url_.Get();
}
inline void UpdateModuleRequest::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.url)
  return url_.Release();
}
inline void UpdateModuleRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.url)
}

// string description = 4 [json_name = "description"];
inline void UpdateModuleRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.description)
}
inline std::string* UpdateModuleRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.description)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_description() const {
  return description_.Get();
}
inline void UpdateModuleRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.description)
  return description_.Release();
}
inline void UpdateModuleRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.description)
}

// repeated .viam.app.v1.Model models = 5 [json_name = "models"];
inline int UpdateModuleRequest::_internal_models_size() const {
  return models_.size();
}
inline int UpdateModuleRequest::models_size() const {
  return _internal_models_size();
}
inline void UpdateModuleRequest::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* UpdateModuleRequest::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
UpdateModuleRequest::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateModuleRequest.models)
  return &models_;
}
inline const ::viam::app::v1::Model& UpdateModuleRequest::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& UpdateModuleRequest::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* UpdateModuleRequest::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* UpdateModuleRequest::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateModuleRequest.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
UpdateModuleRequest::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateModuleRequest.models)
  return models_;
}

// string entrypoint = 6 [json_name = "entrypoint"];
inline void UpdateModuleRequest::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.entrypoint)
}
inline std::string* UpdateModuleRequest::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.entrypoint)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void UpdateModuleRequest::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.entrypoint)
  return entrypoint_.Release();
}
inline void UpdateModuleRequest::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.entrypoint)
}

// optional string first_run = 7 [json_name = "firstRun"];
inline bool UpdateModuleRequest::_internal_has_first_run() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateModuleRequest::has_first_run() const {
  return _internal_has_first_run();
}
inline void UpdateModuleRequest::clear_first_run() {
  first_run_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateModuleRequest::first_run() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.first_run)
  return _internal_first_run();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_first_run(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 first_run_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.first_run)
}
inline std::string* UpdateModuleRequest::mutable_first_run() {
  std::string* _s = _internal_mutable_first_run();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.first_run)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_first_run() const {
  return first_run_.Get();
}
inline void UpdateModuleRequest::_internal_set_first_run(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  first_run_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_first_run() {
  _has_bits_[0] |= 0x00000001u;
  return first_run_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_first_run() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.first_run)
  if (!_internal_has_first_run()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = first_run_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateModuleRequest::set_allocated_first_run(std::string* first_run) {
  if (first_run != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_run_.SetAllocated(first_run, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.first_run)
}

// repeated .viam.app.v1.App apps = 8 [json_name = "apps"];
inline int UpdateModuleRequest::_internal_apps_size() const {
  return apps_.size();
}
inline int UpdateModuleRequest::apps_size() const {
  return _internal_apps_size();
}
inline void UpdateModuleRequest::clear_apps() {
  apps_.Clear();
}
inline ::viam::app::v1::App* UpdateModuleRequest::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
UpdateModuleRequest::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateModuleRequest.apps)
  return &apps_;
}
inline const ::viam::app::v1::App& UpdateModuleRequest::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::viam::app::v1::App& UpdateModuleRequest::apps(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.apps)
  return _internal_apps(index);
}
inline ::viam::app::v1::App* UpdateModuleRequest::_internal_add_apps() {
  return apps_.Add();
}
inline ::viam::app::v1::App* UpdateModuleRequest::add_apps() {
  ::viam::app::v1::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateModuleRequest.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
UpdateModuleRequest::apps() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateModuleRequest.apps)
  return apps_;
}

// optional string markdown_description = 9 [json_name = "markdownDescription"];
inline bool UpdateModuleRequest::_internal_has_markdown_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateModuleRequest::has_markdown_description() const {
  return _internal_has_markdown_description();
}
inline void UpdateModuleRequest::clear_markdown_description() {
  markdown_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateModuleRequest::markdown_description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.markdown_description)
  return _internal_markdown_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_markdown_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 markdown_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.markdown_description)
}
inline std::string* UpdateModuleRequest::mutable_markdown_description() {
  std::string* _s = _internal_mutable_markdown_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.markdown_description)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_markdown_description() const {
  return markdown_description_.Get();
}
inline void UpdateModuleRequest::_internal_set_markdown_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  markdown_description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_markdown_description() {
  _has_bits_[0] |= 0x00000002u;
  return markdown_description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_markdown_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.markdown_description)
  if (!_internal_has_markdown_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = markdown_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateModuleRequest::set_allocated_markdown_description(std::string* markdown_description) {
  if (markdown_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  markdown_description_.SetAllocated(markdown_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.markdown_description)
}

// -------------------------------------------------------------------

// App

// string name = 1 [json_name = "name"];
inline void App::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& App::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.App.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.App.name)
}
inline std::string* App::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.App.name)
  return _s;
}
inline const std::string& App::_internal_name() const {
  return name_.Get();
}
inline void App::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.App.name)
  return name_.Release();
}
inline void App::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.App.name)
}

// string type = 2 [json_name = "type"];
inline void App::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& App::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.App.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.App.type)
}
inline std::string* App::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.App.type)
  return _s;
}
inline const std::string& App::_internal_type() const {
  return type_.Get();
}
inline void App::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.App.type)
  return type_.Release();
}
inline void App::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.App.type)
}

// string entrypoint = 3 [json_name = "entrypoint"];
inline void App::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& App::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.App.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.App.entrypoint)
}
inline std::string* App::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.App.entrypoint)
  return _s;
}
inline const std::string& App::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void App::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.App.entrypoint)
  return entrypoint_.Release();
}
inline void App::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.App.entrypoint)
}

// repeated string fragment_ids = 4 [json_name = "fragmentIds"];
inline int App::_internal_fragment_ids_size() const {
  return fragment_ids_.size();
}
inline int App::fragment_ids_size() const {
  return _internal_fragment_ids_size();
}
inline void App::clear_fragment_ids() {
  fragment_ids_.Clear();
}
inline std::string* App::add_fragment_ids() {
  std::string* _s = _internal_add_fragment_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.App.fragment_ids)
  return _s;
}
inline const std::string& App::_internal_fragment_ids(int index) const {
  return fragment_ids_.Get(index);
}
inline const std::string& App::fragment_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.App.fragment_ids)
  return _internal_fragment_ids(index);
}
inline std::string* App::mutable_fragment_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.App.fragment_ids)
  return fragment_ids_.Mutable(index);
}
inline void App::set_fragment_ids(int index, const std::string& value) {
  fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.App.fragment_ids)
}
inline void App::set_fragment_ids(int index, std::string&& value) {
  fragment_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.App.fragment_ids)
}
inline void App::set_fragment_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.App.fragment_ids)
}
inline void App::set_fragment_ids(int index, const char* value, size_t size) {
  fragment_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.App.fragment_ids)
}
inline std::string* App::_internal_add_fragment_ids() {
  return fragment_ids_.Add();
}
inline void App::add_fragment_ids(const std::string& value) {
  fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.App.fragment_ids)
}
inline void App::add_fragment_ids(std::string&& value) {
  fragment_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.App.fragment_ids)
}
inline void App::add_fragment_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.App.fragment_ids)
}
inline void App::add_fragment_ids(const char* value, size_t size) {
  fragment_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.App.fragment_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
App::fragment_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.App.fragment_ids)
  return fragment_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
App::mutable_fragment_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.App.fragment_ids)
  return &fragment_ids_;
}

// optional string logo_path = 5 [json_name = "logoPath"];
inline bool App::_internal_has_logo_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool App::has_logo_path() const {
  return _internal_has_logo_path();
}
inline void App::clear_logo_path() {
  logo_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& App::logo_path() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.App.logo_path)
  return _internal_logo_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_logo_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 logo_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.App.logo_path)
}
inline std::string* App::mutable_logo_path() {
  std::string* _s = _internal_mutable_logo_path();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.App.logo_path)
  return _s;
}
inline const std::string& App::_internal_logo_path() const {
  return logo_path_.Get();
}
inline void App::_internal_set_logo_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  logo_path_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_logo_path() {
  _has_bits_[0] |= 0x00000001u;
  return logo_path_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_logo_path() {
  // @@protoc_insertion_point(field_release:viam.app.v1.App.logo_path)
  if (!_internal_has_logo_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = logo_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logo_path_.IsDefault()) {
    logo_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void App::set_allocated_logo_path(std::string* logo_path) {
  if (logo_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  logo_path_.SetAllocated(logo_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logo_path_.IsDefault()) {
    logo_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.App.logo_path)
}

// .viam.app.v1.AppCustomizations customizations = 6 [json_name = "customizations"];
inline bool App::_internal_has_customizations() const {
  return this != internal_default_instance() && customizations_ != nullptr;
}
inline bool App::has_customizations() const {
  return _internal_has_customizations();
}
inline void App::clear_customizations() {
  if (GetArenaForAllocation() == nullptr && customizations_ != nullptr) {
    delete customizations_;
  }
  customizations_ = nullptr;
}
inline const ::viam::app::v1::AppCustomizations& App::_internal_customizations() const {
  const ::viam::app::v1::AppCustomizations* p = customizations_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AppCustomizations&>(
      ::viam::app::v1::_AppCustomizations_default_instance_);
}
inline const ::viam::app::v1::AppCustomizations& App::customizations() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.App.customizations)
  return _internal_customizations();
}
inline void App::unsafe_arena_set_allocated_customizations(
    ::viam::app::v1::AppCustomizations* customizations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customizations_);
  }
  customizations_ = customizations;
  if (customizations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.App.customizations)
}
inline ::viam::app::v1::AppCustomizations* App::release_customizations() {
  
  ::viam::app::v1::AppCustomizations* temp = customizations_;
  customizations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::AppCustomizations* App::unsafe_arena_release_customizations() {
  // @@protoc_insertion_point(field_release:viam.app.v1.App.customizations)
  
  ::viam::app::v1::AppCustomizations* temp = customizations_;
  customizations_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AppCustomizations* App::_internal_mutable_customizations() {
  
  if (customizations_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AppCustomizations>(GetArenaForAllocation());
    customizations_ = p;
  }
  return customizations_;
}
inline ::viam::app::v1::AppCustomizations* App::mutable_customizations() {
  ::viam::app::v1::AppCustomizations* _msg = _internal_mutable_customizations();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.App.customizations)
  return _msg;
}
inline void App::set_allocated_customizations(::viam::app::v1::AppCustomizations* customizations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete customizations_;
  }
  if (customizations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(customizations);
    if (message_arena != submessage_arena) {
      customizations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customizations, submessage_arena);
    }
    
  } else {
    
  }
  customizations_ = customizations;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.App.customizations)
}

// -------------------------------------------------------------------

// UpdateModuleResponse

// string url = 1 [json_name = "url"];
inline void UpdateModuleResponse::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& UpdateModuleResponse::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleResponse.url)
}
inline std::string* UpdateModuleResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleResponse.url)
  return _s;
}
inline const std::string& UpdateModuleResponse::_internal_url() const {
  return url_.Get();
}
inline void UpdateModuleResponse::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleResponse::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleResponse::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleResponse.url)
  return url_.Release();
}
inline void UpdateModuleResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleResponse.url)
}

// -------------------------------------------------------------------

// UpdateModuleMetadata

// repeated .viam.app.v1.Model models = 1 [json_name = "models"];
inline int UpdateModuleMetadata::_internal_models_size() const {
  return models_.size();
}
inline int UpdateModuleMetadata::models_size() const {
  return _internal_models_size();
}
inline void UpdateModuleMetadata::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* UpdateModuleMetadata::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleMetadata.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
UpdateModuleMetadata::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateModuleMetadata.models)
  return &models_;
}
inline const ::viam::app::v1::Model& UpdateModuleMetadata::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& UpdateModuleMetadata::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleMetadata.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* UpdateModuleMetadata::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* UpdateModuleMetadata::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateModuleMetadata.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
UpdateModuleMetadata::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateModuleMetadata.models)
  return models_;
}

// string entrypoint = 2 [json_name = "entrypoint"];
inline void UpdateModuleMetadata::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& UpdateModuleMetadata::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleMetadata.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleMetadata::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleMetadata.entrypoint)
}
inline std::string* UpdateModuleMetadata::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleMetadata.entrypoint)
  return _s;
}
inline const std::string& UpdateModuleMetadata::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void UpdateModuleMetadata::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleMetadata::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleMetadata::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleMetadata.entrypoint)
  return entrypoint_.Release();
}
inline void UpdateModuleMetadata::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleMetadata.entrypoint)
}

// repeated .viam.app.v1.App apps = 3 [json_name = "apps"];
inline int UpdateModuleMetadata::_internal_apps_size() const {
  return apps_.size();
}
inline int UpdateModuleMetadata::apps_size() const {
  return _internal_apps_size();
}
inline void UpdateModuleMetadata::clear_apps() {
  apps_.Clear();
}
inline ::viam::app::v1::App* UpdateModuleMetadata::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleMetadata.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
UpdateModuleMetadata::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateModuleMetadata.apps)
  return &apps_;
}
inline const ::viam::app::v1::App& UpdateModuleMetadata::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::viam::app::v1::App& UpdateModuleMetadata::apps(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleMetadata.apps)
  return _internal_apps(index);
}
inline ::viam::app::v1::App* UpdateModuleMetadata::_internal_add_apps() {
  return apps_.Add();
}
inline ::viam::app::v1::App* UpdateModuleMetadata::add_apps() {
  ::viam::app::v1::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateModuleMetadata.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
UpdateModuleMetadata::apps() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateModuleMetadata.apps)
  return apps_;
}

// optional .viam.app.v1.ModuleSourceType source_type = 4 [json_name = "sourceType"];
inline bool UpdateModuleMetadata::_internal_has_source_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateModuleMetadata::has_source_type() const {
  return _internal_has_source_type();
}
inline void UpdateModuleMetadata::clear_source_type() {
  source_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::viam::app::v1::ModuleSourceType UpdateModuleMetadata::_internal_source_type() const {
  return static_cast< ::viam::app::v1::ModuleSourceType >(source_type_);
}
inline ::viam::app::v1::ModuleSourceType UpdateModuleMetadata::source_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleMetadata.source_type)
  return _internal_source_type();
}
inline void UpdateModuleMetadata::_internal_set_source_type(::viam::app::v1::ModuleSourceType value) {
  _has_bits_[0] |= 0x00000001u;
  source_type_ = value;
}
inline void UpdateModuleMetadata::set_source_type(::viam::app::v1::ModuleSourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleMetadata.source_type)
}

// optional .viam.app.v1.ModuleLanguage language = 5 [json_name = "language"];
inline bool UpdateModuleMetadata::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateModuleMetadata::has_language() const {
  return _internal_has_language();
}
inline void UpdateModuleMetadata::clear_language() {
  language_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::viam::app::v1::ModuleLanguage UpdateModuleMetadata::_internal_language() const {
  return static_cast< ::viam::app::v1::ModuleLanguage >(language_);
}
inline ::viam::app::v1::ModuleLanguage UpdateModuleMetadata::language() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleMetadata.language)
  return _internal_language();
}
inline void UpdateModuleMetadata::_internal_set_language(::viam::app::v1::ModuleLanguage value) {
  _has_bits_[0] |= 0x00000002u;
  language_ = value;
}
inline void UpdateModuleMetadata::set_language(::viam::app::v1::ModuleLanguage value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleMetadata.language)
}

// -------------------------------------------------------------------

// UpdateMLModelMetadata

// .viam.app.mltraining.v1.ModelType model_type = 1 [json_name = "modelType"];
inline void UpdateMLModelMetadata::clear_model_type() {
  model_type_ = 0;
}
inline ::viam::app::mltraining::v1::ModelType UpdateMLModelMetadata::_internal_model_type() const {
  return static_cast< ::viam::app::mltraining::v1::ModelType >(model_type_);
}
inline ::viam::app::mltraining::v1::ModelType UpdateMLModelMetadata::model_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateMLModelMetadata.model_type)
  return _internal_model_type();
}
inline void UpdateMLModelMetadata::_internal_set_model_type(::viam::app::mltraining::v1::ModelType value) {
  
  model_type_ = value;
}
inline void UpdateMLModelMetadata::set_model_type(::viam::app::mltraining::v1::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateMLModelMetadata.model_type)
}

// .viam.app.mltraining.v1.ModelFramework model_framework = 2 [json_name = "modelFramework"];
inline void UpdateMLModelMetadata::clear_model_framework() {
  model_framework_ = 0;
}
inline ::viam::app::mltraining::v1::ModelFramework UpdateMLModelMetadata::_internal_model_framework() const {
  return static_cast< ::viam::app::mltraining::v1::ModelFramework >(model_framework_);
}
inline ::viam::app::mltraining::v1::ModelFramework UpdateMLModelMetadata::model_framework() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateMLModelMetadata.model_framework)
  return _internal_model_framework();
}
inline void UpdateMLModelMetadata::_internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  
  model_framework_ = value;
}
inline void UpdateMLModelMetadata::set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  _internal_set_model_framework(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateMLModelMetadata.model_framework)
}

// -------------------------------------------------------------------

// UpdateMLTrainingMetadata

// .viam.app.mltraining.v1.ModelType model_type = 1 [json_name = "modelType"];
inline void UpdateMLTrainingMetadata::clear_model_type() {
  model_type_ = 0;
}
inline ::viam::app::mltraining::v1::ModelType UpdateMLTrainingMetadata::_internal_model_type() const {
  return static_cast< ::viam::app::mltraining::v1::ModelType >(model_type_);
}
inline ::viam::app::mltraining::v1::ModelType UpdateMLTrainingMetadata::model_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateMLTrainingMetadata.model_type)
  return _internal_model_type();
}
inline void UpdateMLTrainingMetadata::_internal_set_model_type(::viam::app::mltraining::v1::ModelType value) {
  
  model_type_ = value;
}
inline void UpdateMLTrainingMetadata::set_model_type(::viam::app::mltraining::v1::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateMLTrainingMetadata.model_type)
}

// .viam.app.mltraining.v1.ModelFramework model_framework = 2 [json_name = "modelFramework"];
inline void UpdateMLTrainingMetadata::clear_model_framework() {
  model_framework_ = 0;
}
inline ::viam::app::mltraining::v1::ModelFramework UpdateMLTrainingMetadata::_internal_model_framework() const {
  return static_cast< ::viam::app::mltraining::v1::ModelFramework >(model_framework_);
}
inline ::viam::app::mltraining::v1::ModelFramework UpdateMLTrainingMetadata::model_framework() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateMLTrainingMetadata.model_framework)
  return _internal_model_framework();
}
inline void UpdateMLTrainingMetadata::_internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  
  model_framework_ = value;
}
inline void UpdateMLTrainingMetadata::set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  _internal_set_model_framework(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateMLTrainingMetadata.model_framework)
}

// bool draft = 3 [json_name = "draft"];
inline void UpdateMLTrainingMetadata::clear_draft() {
  draft_ = false;
}
inline bool UpdateMLTrainingMetadata::_internal_draft() const {
  return draft_;
}
inline bool UpdateMLTrainingMetadata::draft() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateMLTrainingMetadata.draft)
  return _internal_draft();
}
inline void UpdateMLTrainingMetadata::_internal_set_draft(bool value) {
  
  draft_ = value;
}
inline void UpdateMLTrainingMetadata::set_draft(bool value) {
  _internal_set_draft(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateMLTrainingMetadata.draft)
}

// -------------------------------------------------------------------

// Model

// string api = 1 [json_name = "api"];
inline void Model::clear_api() {
  api_.ClearToEmpty();
}
inline const std::string& Model::api() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Model.api)
  return _internal_api();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_api(ArgT0&& arg0, ArgT... args) {
 
 api_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.api)
}
inline std::string* Model::mutable_api() {
  std::string* _s = _internal_mutable_api();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Model.api)
  return _s;
}
inline const std::string& Model::_internal_api() const {
  return api_.Get();
}
inline void Model::_internal_set_api(const std::string& value) {
  
  api_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_api() {
  
  return api_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_api() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Model.api)
  return api_.Release();
}
inline void Model::set_allocated_api(std::string* api) {
  if (api != nullptr) {
    
  } else {
    
  }
  api_.SetAllocated(api, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_.IsDefault()) {
    api_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Model.api)
}

// string model = 2 [json_name = "model"];
inline void Model::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& Model::model() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Model.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.model)
}
inline std::string* Model::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Model.model)
  return _s;
}
inline const std::string& Model::_internal_model() const {
  return model_.Get();
}
inline void Model::_internal_set_model(const std::string& value) {
  
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_model() {
  
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_model() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Model.model)
  return model_.Release();
}
inline void Model::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Model.model)
}

// optional string markdown_documentation = 3 [json_name = "markdownDocumentation"];
inline bool Model::_internal_has_markdown_documentation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Model::has_markdown_documentation() const {
  return _internal_has_markdown_documentation();
}
inline void Model::clear_markdown_documentation() {
  markdown_documentation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Model::markdown_documentation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Model.markdown_documentation)
  return _internal_markdown_documentation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_markdown_documentation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 markdown_documentation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.markdown_documentation)
}
inline std::string* Model::mutable_markdown_documentation() {
  std::string* _s = _internal_mutable_markdown_documentation();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Model.markdown_documentation)
  return _s;
}
inline const std::string& Model::_internal_markdown_documentation() const {
  return markdown_documentation_.Get();
}
inline void Model::_internal_set_markdown_documentation(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  markdown_documentation_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_markdown_documentation() {
  _has_bits_[0] |= 0x00000001u;
  return markdown_documentation_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_markdown_documentation() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Model.markdown_documentation)
  if (!_internal_has_markdown_documentation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = markdown_documentation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_documentation_.IsDefault()) {
    markdown_documentation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Model::set_allocated_markdown_documentation(std::string* markdown_documentation) {
  if (markdown_documentation != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  markdown_documentation_.SetAllocated(markdown_documentation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_documentation_.IsDefault()) {
    markdown_documentation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Model.markdown_documentation)
}

// optional string description = 4 [json_name = "description"];
inline bool Model::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Model::has_description() const {
  return _internal_has_description();
}
inline void Model::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Model::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Model.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.description)
}
inline std::string* Model::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Model.description)
  return _s;
}
inline const std::string& Model::_internal_description() const {
  return description_.Get();
}
inline void Model::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Model.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Model::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Model.description)
}

// repeated string supported_hardware = 5 [json_name = "supportedHardware"];
inline int Model::_internal_supported_hardware_size() const {
  return supported_hardware_.size();
}
inline int Model::supported_hardware_size() const {
  return _internal_supported_hardware_size();
}
inline void Model::clear_supported_hardware() {
  supported_hardware_.Clear();
}
inline std::string* Model::add_supported_hardware() {
  std::string* _s = _internal_add_supported_hardware();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.Model.supported_hardware)
  return _s;
}
inline const std::string& Model::_internal_supported_hardware(int index) const {
  return supported_hardware_.Get(index);
}
inline const std::string& Model::supported_hardware(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Model.supported_hardware)
  return _internal_supported_hardware(index);
}
inline std::string* Model::mutable_supported_hardware(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Model.supported_hardware)
  return supported_hardware_.Mutable(index);
}
inline void Model::set_supported_hardware(int index, const std::string& value) {
  supported_hardware_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.supported_hardware)
}
inline void Model::set_supported_hardware(int index, std::string&& value) {
  supported_hardware_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.supported_hardware)
}
inline void Model::set_supported_hardware(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_hardware_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.Model.supported_hardware)
}
inline void Model::set_supported_hardware(int index, const char* value, size_t size) {
  supported_hardware_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.Model.supported_hardware)
}
inline std::string* Model::_internal_add_supported_hardware() {
  return supported_hardware_.Add();
}
inline void Model::add_supported_hardware(const std::string& value) {
  supported_hardware_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.Model.supported_hardware)
}
inline void Model::add_supported_hardware(std::string&& value) {
  supported_hardware_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.Model.supported_hardware)
}
inline void Model::add_supported_hardware(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_hardware_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.Model.supported_hardware)
}
inline void Model::add_supported_hardware(const char* value, size_t size) {
  supported_hardware_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.Model.supported_hardware)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Model::supported_hardware() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Model.supported_hardware)
  return supported_hardware_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Model::mutable_supported_hardware() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Model.supported_hardware)
  return &supported_hardware_;
}

// -------------------------------------------------------------------

// ModuleFileInfo

// string module_id = 1 [json_name = "moduleId"];
inline void ModuleFileInfo::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& ModuleFileInfo::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleFileInfo.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleFileInfo::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.module_id)
}
inline std::string* ModuleFileInfo::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleFileInfo.module_id)
  return _s;
}
inline const std::string& ModuleFileInfo::_internal_module_id() const {
  return module_id_.Get();
}
inline void ModuleFileInfo::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleFileInfo.module_id)
  return module_id_.Release();
}
inline void ModuleFileInfo::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleFileInfo.module_id)
}

// string version = 2 [json_name = "version"];
inline void ModuleFileInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ModuleFileInfo::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleFileInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleFileInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.version)
}
inline std::string* ModuleFileInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleFileInfo.version)
  return _s;
}
inline const std::string& ModuleFileInfo::_internal_version() const {
  return version_.Get();
}
inline void ModuleFileInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleFileInfo.version)
  return version_.Release();
}
inline void ModuleFileInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleFileInfo.version)
}

// string platform = 3 [json_name = "platform"];
inline void ModuleFileInfo::clear_platform() {
  platform_.ClearToEmpty();
}
inline const std::string& ModuleFileInfo::platform() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleFileInfo.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleFileInfo::set_platform(ArgT0&& arg0, ArgT... args) {
 
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.platform)
}
inline std::string* ModuleFileInfo::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleFileInfo.platform)
  return _s;
}
inline const std::string& ModuleFileInfo::_internal_platform() const {
  return platform_.Get();
}
inline void ModuleFileInfo::_internal_set_platform(const std::string& value) {
  
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::_internal_mutable_platform() {
  
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::release_platform() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleFileInfo.platform)
  return platform_.Release();
}
inline void ModuleFileInfo::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleFileInfo.platform)
}

// repeated string platform_tags = 5 [json_name = "platformTags"];
inline int ModuleFileInfo::_internal_platform_tags_size() const {
  return platform_tags_.size();
}
inline int ModuleFileInfo::platform_tags_size() const {
  return _internal_platform_tags_size();
}
inline void ModuleFileInfo::clear_platform_tags() {
  platform_tags_.Clear();
}
inline std::string* ModuleFileInfo::add_platform_tags() {
  std::string* _s = _internal_add_platform_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ModuleFileInfo.platform_tags)
  return _s;
}
inline const std::string& ModuleFileInfo::_internal_platform_tags(int index) const {
  return platform_tags_.Get(index);
}
inline const std::string& ModuleFileInfo::platform_tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleFileInfo.platform_tags)
  return _internal_platform_tags(index);
}
inline std::string* ModuleFileInfo::mutable_platform_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleFileInfo.platform_tags)
  return platform_tags_.Mutable(index);
}
inline void ModuleFileInfo::set_platform_tags(int index, const std::string& value) {
  platform_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline void ModuleFileInfo::set_platform_tags(int index, std::string&& value) {
  platform_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline void ModuleFileInfo::set_platform_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platform_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline void ModuleFileInfo::set_platform_tags(int index, const char* value, size_t size) {
  platform_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline std::string* ModuleFileInfo::_internal_add_platform_tags() {
  return platform_tags_.Add();
}
inline void ModuleFileInfo::add_platform_tags(const std::string& value) {
  platform_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline void ModuleFileInfo::add_platform_tags(std::string&& value) {
  platform_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline void ModuleFileInfo::add_platform_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platform_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline void ModuleFileInfo::add_platform_tags(const char* value, size_t size) {
  platform_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ModuleFileInfo.platform_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModuleFileInfo::platform_tags() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleFileInfo.platform_tags)
  return platform_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModuleFileInfo::mutable_platform_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleFileInfo.platform_tags)
  return &platform_tags_;
}

// -------------------------------------------------------------------

// UploadModuleFileRequest

// .viam.app.v1.ModuleFileInfo module_file_info = 1 [json_name = "moduleFileInfo"];
inline bool UploadModuleFileRequest::_internal_has_module_file_info() const {
  return module_file_case() == kModuleFileInfo;
}
inline bool UploadModuleFileRequest::has_module_file_info() const {
  return _internal_has_module_file_info();
}
inline void UploadModuleFileRequest::set_has_module_file_info() {
  _oneof_case_[0] = kModuleFileInfo;
}
inline void UploadModuleFileRequest::clear_module_file_info() {
  if (_internal_has_module_file_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete module_file_.module_file_info_;
    }
    clear_has_module_file();
  }
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::release_module_file_info() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UploadModuleFileRequest.module_file_info)
  if (_internal_has_module_file_info()) {
    clear_has_module_file();
    ::viam::app::v1::ModuleFileInfo* temp = module_file_.module_file_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    module_file_.module_file_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::ModuleFileInfo& UploadModuleFileRequest::_internal_module_file_info() const {
  return _internal_has_module_file_info()
      ? *module_file_.module_file_info_
      : reinterpret_cast< ::viam::app::v1::ModuleFileInfo&>(::viam::app::v1::_ModuleFileInfo_default_instance_);
}
inline const ::viam::app::v1::ModuleFileInfo& UploadModuleFileRequest::module_file_info() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UploadModuleFileRequest.module_file_info)
  return _internal_module_file_info();
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::unsafe_arena_release_module_file_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.UploadModuleFileRequest.module_file_info)
  if (_internal_has_module_file_info()) {
    clear_has_module_file();
    ::viam::app::v1::ModuleFileInfo* temp = module_file_.module_file_info_;
    module_file_.module_file_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UploadModuleFileRequest::unsafe_arena_set_allocated_module_file_info(::viam::app::v1::ModuleFileInfo* module_file_info) {
  clear_module_file();
  if (module_file_info) {
    set_has_module_file_info();
    module_file_.module_file_info_ = module_file_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UploadModuleFileRequest.module_file_info)
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::_internal_mutable_module_file_info() {
  if (!_internal_has_module_file_info()) {
    clear_module_file();
    set_has_module_file_info();
    module_file_.module_file_info_ = CreateMaybeMessage< ::viam::app::v1::ModuleFileInfo >(GetArenaForAllocation());
  }
  return module_file_.module_file_info_;
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::mutable_module_file_info() {
  ::viam::app::v1::ModuleFileInfo* _msg = _internal_mutable_module_file_info();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UploadModuleFileRequest.module_file_info)
  return _msg;
}

// bytes file = 2 [json_name = "file"];
inline bool UploadModuleFileRequest::_internal_has_file() const {
  return module_file_case() == kFile;
}
inline bool UploadModuleFileRequest::has_file() const {
  return _internal_has_file();
}
inline void UploadModuleFileRequest::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline void UploadModuleFileRequest::clear_file() {
  if (_internal_has_file()) {
    module_file_.file_.Destroy();
    clear_has_module_file();
  }
}
inline const std::string& UploadModuleFileRequest::file() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UploadModuleFileRequest.file)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline void UploadModuleFileRequest::set_file(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_file()) {
    clear_module_file();
    set_has_file();
    module_file_.file_.InitDefault();
  }
  module_file_.file_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UploadModuleFileRequest.file)
}
inline std::string* UploadModuleFileRequest::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UploadModuleFileRequest.file)
  return _s;
}
inline const std::string& UploadModuleFileRequest::_internal_file() const {
  if (_internal_has_file()) {
    return module_file_.file_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UploadModuleFileRequest::_internal_set_file(const std::string& value) {
  if (!_internal_has_file()) {
    clear_module_file();
    set_has_file();
    module_file_.file_.InitDefault();
  }
  module_file_.file_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadModuleFileRequest::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_module_file();
    set_has_file();
    module_file_.file_.InitDefault();
  }
  return module_file_.file_.Mutable(      GetArenaForAllocation());
}
inline std::string* UploadModuleFileRequest::release_file() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UploadModuleFileRequest.file)
  if (_internal_has_file()) {
    clear_has_module_file();
    return module_file_.file_.Release();
  } else {
    return nullptr;
  }
}
inline void UploadModuleFileRequest::set_allocated_file(std::string* file) {
  if (has_module_file()) {
    clear_module_file();
  }
  if (file != nullptr) {
    set_has_file();
    module_file_.file_.InitAllocated(file, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UploadModuleFileRequest.file)
}

inline bool UploadModuleFileRequest::has_module_file() const {
  return module_file_case() != MODULE_FILE_NOT_SET;
}
inline void UploadModuleFileRequest::clear_has_module_file() {
  _oneof_case_[0] = MODULE_FILE_NOT_SET;
}
inline UploadModuleFileRequest::ModuleFileCase UploadModuleFileRequest::module_file_case() const {
  return UploadModuleFileRequest::ModuleFileCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UploadModuleFileResponse

// string url = 1 [json_name = "url"];
inline void UploadModuleFileResponse::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& UploadModuleFileResponse::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UploadModuleFileResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadModuleFileResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UploadModuleFileResponse.url)
}
inline std::string* UploadModuleFileResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UploadModuleFileResponse.url)
  return _s;
}
inline const std::string& UploadModuleFileResponse::_internal_url() const {
  return url_.Get();
}
inline void UploadModuleFileResponse::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadModuleFileResponse::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadModuleFileResponse::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UploadModuleFileResponse.url)
  return url_.Release();
}
inline void UploadModuleFileResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UploadModuleFileResponse.url)
}

// -------------------------------------------------------------------

// GetModuleRequest

// string module_id = 1 [json_name = "moduleId"];
inline void GetModuleRequest::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& GetModuleRequest::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetModuleRequest.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetModuleRequest::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetModuleRequest.module_id)
}
inline std::string* GetModuleRequest::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetModuleRequest.module_id)
  return _s;
}
inline const std::string& GetModuleRequest::_internal_module_id() const {
  return module_id_.Get();
}
inline void GetModuleRequest::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModuleRequest::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModuleRequest::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetModuleRequest.module_id)
  return module_id_.Release();
}
inline void GetModuleRequest::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetModuleRequest.module_id)
}

// optional bool include_markdown_documentation = 2 [json_name = "includeMarkdownDocumentation"];
inline bool GetModuleRequest::_internal_has_include_markdown_documentation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetModuleRequest::has_include_markdown_documentation() const {
  return _internal_has_include_markdown_documentation();
}
inline void GetModuleRequest::clear_include_markdown_documentation() {
  include_markdown_documentation_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool GetModuleRequest::_internal_include_markdown_documentation() const {
  return include_markdown_documentation_;
}
inline bool GetModuleRequest::include_markdown_documentation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetModuleRequest.include_markdown_documentation)
  return _internal_include_markdown_documentation();
}
inline void GetModuleRequest::_internal_set_include_markdown_documentation(bool value) {
  _has_bits_[0] |= 0x00000001u;
  include_markdown_documentation_ = value;
}
inline void GetModuleRequest::set_include_markdown_documentation(bool value) {
  _internal_set_include_markdown_documentation(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetModuleRequest.include_markdown_documentation)
}

// -------------------------------------------------------------------

// GetModuleResponse

// .viam.app.v1.Module module = 1 [json_name = "module"];
inline bool GetModuleResponse::_internal_has_module() const {
  return this != internal_default_instance() && module_ != nullptr;
}
inline bool GetModuleResponse::has_module() const {
  return _internal_has_module();
}
inline void GetModuleResponse::clear_module() {
  if (GetArenaForAllocation() == nullptr && module_ != nullptr) {
    delete module_;
  }
  module_ = nullptr;
}
inline const ::viam::app::v1::Module& GetModuleResponse::_internal_module() const {
  const ::viam::app::v1::Module* p = module_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Module&>(
      ::viam::app::v1::_Module_default_instance_);
}
inline const ::viam::app::v1::Module& GetModuleResponse::module() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetModuleResponse.module)
  return _internal_module();
}
inline void GetModuleResponse::unsafe_arena_set_allocated_module(
    ::viam::app::v1::Module* module) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetModuleResponse.module)
}
inline ::viam::app::v1::Module* GetModuleResponse::release_module() {
  
  ::viam::app::v1::Module* temp = module_;
  module_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Module* GetModuleResponse::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetModuleResponse.module)
  
  ::viam::app::v1::Module* temp = module_;
  module_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Module* GetModuleResponse::_internal_mutable_module() {
  
  if (module_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Module>(GetArenaForAllocation());
    module_ = p;
  }
  return module_;
}
inline ::viam::app::v1::Module* GetModuleResponse::mutable_module() {
  ::viam::app::v1::Module* _msg = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetModuleResponse.module)
  return _msg;
}
inline void GetModuleResponse::set_allocated_module(::viam::app::v1::Module* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete module_;
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(module);
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetModuleResponse.module)
}

// -------------------------------------------------------------------

// Module

// string module_id = 1 [json_name = "moduleId"];
inline void Module::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& Module::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.module_id)
}
inline std::string* Module::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.module_id)
  return _s;
}
inline const std::string& Module::_internal_module_id() const {
  return module_id_.Get();
}
inline void Module::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.module_id)
  return module_id_.Release();
}
inline void Module::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.module_id)
}

// string name = 2 [json_name = "name"];
inline void Module::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Module::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.name)
}
inline std::string* Module::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.name)
  return _s;
}
inline const std::string& Module::_internal_name() const {
  return name_.Get();
}
inline void Module::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.name)
  return name_.Release();
}
inline void Module::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.name)
}

// .viam.app.v1.Visibility visibility = 3 [json_name = "visibility"];
inline void Module::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility Module::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility Module::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.visibility)
  return _internal_visibility();
}
inline void Module::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void Module::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.visibility)
}

// repeated .viam.app.v1.VersionHistory versions = 4 [json_name = "versions"];
inline int Module::_internal_versions_size() const {
  return versions_.size();
}
inline int Module::versions_size() const {
  return _internal_versions_size();
}
inline void Module::clear_versions() {
  versions_.Clear();
}
inline ::viam::app::v1::VersionHistory* Module::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.versions)
  return versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >*
Module::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Module.versions)
  return &versions_;
}
inline const ::viam::app::v1::VersionHistory& Module::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const ::viam::app::v1::VersionHistory& Module::versions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.versions)
  return _internal_versions(index);
}
inline ::viam::app::v1::VersionHistory* Module::_internal_add_versions() {
  return versions_.Add();
}
inline ::viam::app::v1::VersionHistory* Module::add_versions() {
  ::viam::app::v1::VersionHistory* _add = _internal_add_versions();
  // @@protoc_insertion_point(field_add:viam.app.v1.Module.versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >&
Module::versions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Module.versions)
  return versions_;
}

// string url = 5 [json_name = "url"];
inline void Module::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Module::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.url)
}
inline std::string* Module::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.url)
  return _s;
}
inline const std::string& Module::_internal_url() const {
  return url_.Get();
}
inline void Module::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.url)
  return url_.Release();
}
inline void Module::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.url)
}

// string description = 6 [json_name = "description"];
inline void Module::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Module::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.description)
}
inline std::string* Module::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.description)
  return _s;
}
inline const std::string& Module::_internal_description() const {
  return description_.Get();
}
inline void Module::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.description)
  return description_.Release();
}
inline void Module::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.description)
}

// repeated .viam.app.v1.Model models = 7 [json_name = "models"];
inline int Module::_internal_models_size() const {
  return models_.size();
}
inline int Module::models_size() const {
  return _internal_models_size();
}
inline void Module::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* Module::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
Module::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Module.models)
  return &models_;
}
inline const ::viam::app::v1::Model& Module::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& Module::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* Module::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* Module::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.Module.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
Module::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Module.models)
  return models_;
}

// int64 total_robot_usage = 8 [json_name = "totalRobotUsage"];
inline void Module::clear_total_robot_usage() {
  total_robot_usage_ = int64_t{0};
}
inline int64_t Module::_internal_total_robot_usage() const {
  return total_robot_usage_;
}
inline int64_t Module::total_robot_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.total_robot_usage)
  return _internal_total_robot_usage();
}
inline void Module::_internal_set_total_robot_usage(int64_t value) {
  
  total_robot_usage_ = value;
}
inline void Module::set_total_robot_usage(int64_t value) {
  _internal_set_total_robot_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.total_robot_usage)
}

// int64 total_organization_usage = 9 [json_name = "totalOrganizationUsage"];
inline void Module::clear_total_organization_usage() {
  total_organization_usage_ = int64_t{0};
}
inline int64_t Module::_internal_total_organization_usage() const {
  return total_organization_usage_;
}
inline int64_t Module::total_organization_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.total_organization_usage)
  return _internal_total_organization_usage();
}
inline void Module::_internal_set_total_organization_usage(int64_t value) {
  
  total_organization_usage_ = value;
}
inline void Module::set_total_organization_usage(int64_t value) {
  _internal_set_total_organization_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.total_organization_usage)
}

// string organization_id = 10 [json_name = "organizationId"];
inline void Module::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& Module::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.organization_id)
}
inline std::string* Module::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.organization_id)
  return _s;
}
inline const std::string& Module::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void Module::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.organization_id)
  return organization_id_.Release();
}
inline void Module::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.organization_id)
}

// string entrypoint = 11 [json_name = "entrypoint"];
inline void Module::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& Module::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.entrypoint)
}
inline std::string* Module::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.entrypoint)
  return _s;
}
inline const std::string& Module::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void Module::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.entrypoint)
  return entrypoint_.Release();
}
inline void Module::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.entrypoint)
}

// string public_namespace = 12 [json_name = "publicNamespace"];
inline void Module::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& Module::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.public_namespace)
}
inline std::string* Module::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.public_namespace)
  return _s;
}
inline const std::string& Module::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void Module::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.public_namespace)
  return public_namespace_.Release();
}
inline void Module::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.public_namespace)
}

// optional string first_run = 13 [json_name = "firstRun"];
inline bool Module::_internal_has_first_run() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Module::has_first_run() const {
  return _internal_has_first_run();
}
inline void Module::clear_first_run() {
  first_run_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Module::first_run() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.first_run)
  return _internal_first_run();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_first_run(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 first_run_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.first_run)
}
inline std::string* Module::mutable_first_run() {
  std::string* _s = _internal_mutable_first_run();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.first_run)
  return _s;
}
inline const std::string& Module::_internal_first_run() const {
  return first_run_.Get();
}
inline void Module::_internal_set_first_run(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  first_run_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_first_run() {
  _has_bits_[0] |= 0x00000001u;
  return first_run_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_first_run() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.first_run)
  if (!_internal_has_first_run()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = first_run_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Module::set_allocated_first_run(std::string* first_run) {
  if (first_run != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_run_.SetAllocated(first_run, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.first_run)
}

// optional string markdown_description = 14 [json_name = "markdownDescription"];
inline bool Module::_internal_has_markdown_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Module::has_markdown_description() const {
  return _internal_has_markdown_description();
}
inline void Module::clear_markdown_description() {
  markdown_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Module::markdown_description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.markdown_description)
  return _internal_markdown_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_markdown_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 markdown_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.markdown_description)
}
inline std::string* Module::mutable_markdown_description() {
  std::string* _s = _internal_mutable_markdown_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.markdown_description)
  return _s;
}
inline const std::string& Module::_internal_markdown_description() const {
  return markdown_description_.Get();
}
inline void Module::_internal_set_markdown_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  markdown_description_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_markdown_description() {
  _has_bits_[0] |= 0x00000002u;
  return markdown_description_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_markdown_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.markdown_description)
  if (!_internal_has_markdown_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = markdown_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Module::set_allocated_markdown_description(std::string* markdown_description) {
  if (markdown_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  markdown_description_.SetAllocated(markdown_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.markdown_description)
}

// repeated .viam.app.v1.App apps = 15 [json_name = "apps"];
inline int Module::_internal_apps_size() const {
  return apps_.size();
}
inline int Module::apps_size() const {
  return _internal_apps_size();
}
inline void Module::clear_apps() {
  apps_.Clear();
}
inline ::viam::app::v1::App* Module::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
Module::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Module.apps)
  return &apps_;
}
inline const ::viam::app::v1::App& Module::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::viam::app::v1::App& Module::apps(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.apps)
  return _internal_apps(index);
}
inline ::viam::app::v1::App* Module::_internal_add_apps() {
  return apps_.Add();
}
inline ::viam::app::v1::App* Module::add_apps() {
  ::viam::app::v1::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:viam.app.v1.Module.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
Module::apps() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Module.apps)
  return apps_;
}

// -------------------------------------------------------------------

// VersionHistory

// string version = 1 [json_name = "version"];
inline void VersionHistory::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& VersionHistory::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionHistory::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.VersionHistory.version)
}
inline std::string* VersionHistory::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.version)
  return _s;
}
inline const std::string& VersionHistory::_internal_version() const {
  return version_.Get();
}
inline void VersionHistory::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionHistory::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionHistory::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.VersionHistory.version)
  return version_.Release();
}
inline void VersionHistory::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.VersionHistory.version)
}

// repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
inline int VersionHistory::_internal_files_size() const {
  return files_.size();
}
inline int VersionHistory::files_size() const {
  return _internal_files_size();
}
inline void VersionHistory::clear_files() {
  files_.Clear();
}
inline ::viam::app::v1::Uploads* VersionHistory::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
VersionHistory::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.VersionHistory.files)
  return &files_;
}
inline const ::viam::app::v1::Uploads& VersionHistory::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::viam::app::v1::Uploads& VersionHistory::files(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.files)
  return _internal_files(index);
}
inline ::viam::app::v1::Uploads* VersionHistory::_internal_add_files() {
  return files_.Add();
}
inline ::viam::app::v1::Uploads* VersionHistory::add_files() {
  ::viam::app::v1::Uploads* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:viam.app.v1.VersionHistory.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
VersionHistory::files() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.VersionHistory.files)
  return files_;
}

// repeated .viam.app.v1.Model models = 3 [json_name = "models"];
inline int VersionHistory::_internal_models_size() const {
  return models_.size();
}
inline int VersionHistory::models_size() const {
  return _internal_models_size();
}
inline void VersionHistory::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* VersionHistory::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
VersionHistory::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.VersionHistory.models)
  return &models_;
}
inline const ::viam::app::v1::Model& VersionHistory::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& VersionHistory::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* VersionHistory::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* VersionHistory::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.VersionHistory.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
VersionHistory::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.VersionHistory.models)
  return models_;
}

// string entrypoint = 4 [json_name = "entrypoint"];
inline void VersionHistory::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& VersionHistory::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionHistory::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.VersionHistory.entrypoint)
}
inline std::string* VersionHistory::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.entrypoint)
  return _s;
}
inline const std::string& VersionHistory::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void VersionHistory::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionHistory::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionHistory::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.VersionHistory.entrypoint)
  return entrypoint_.Release();
}
inline void VersionHistory::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.VersionHistory.entrypoint)
}

// optional string first_run = 5 [json_name = "firstRun"];
inline bool VersionHistory::_internal_has_first_run() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VersionHistory::has_first_run() const {
  return _internal_has_first_run();
}
inline void VersionHistory::clear_first_run() {
  first_run_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VersionHistory::first_run() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.first_run)
  return _internal_first_run();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionHistory::set_first_run(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 first_run_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.VersionHistory.first_run)
}
inline std::string* VersionHistory::mutable_first_run() {
  std::string* _s = _internal_mutable_first_run();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.first_run)
  return _s;
}
inline const std::string& VersionHistory::_internal_first_run() const {
  return first_run_.Get();
}
inline void VersionHistory::_internal_set_first_run(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  first_run_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionHistory::_internal_mutable_first_run() {
  _has_bits_[0] |= 0x00000001u;
  return first_run_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionHistory::release_first_run() {
  // @@protoc_insertion_point(field_release:viam.app.v1.VersionHistory.first_run)
  if (!_internal_has_first_run()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = first_run_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VersionHistory::set_allocated_first_run(std::string* first_run) {
  if (first_run != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_run_.SetAllocated(first_run, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_run_.IsDefault()) {
    first_run_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.VersionHistory.first_run)
}

// optional string markdown_description = 6 [json_name = "markdownDescription"];
inline bool VersionHistory::_internal_has_markdown_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VersionHistory::has_markdown_description() const {
  return _internal_has_markdown_description();
}
inline void VersionHistory::clear_markdown_description() {
  markdown_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VersionHistory::markdown_description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.markdown_description)
  return _internal_markdown_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionHistory::set_markdown_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 markdown_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.VersionHistory.markdown_description)
}
inline std::string* VersionHistory::mutable_markdown_description() {
  std::string* _s = _internal_mutable_markdown_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.markdown_description)
  return _s;
}
inline const std::string& VersionHistory::_internal_markdown_description() const {
  return markdown_description_.Get();
}
inline void VersionHistory::_internal_set_markdown_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  markdown_description_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionHistory::_internal_mutable_markdown_description() {
  _has_bits_[0] |= 0x00000002u;
  return markdown_description_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionHistory::release_markdown_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.VersionHistory.markdown_description)
  if (!_internal_has_markdown_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = markdown_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VersionHistory::set_allocated_markdown_description(std::string* markdown_description) {
  if (markdown_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  markdown_description_.SetAllocated(markdown_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (markdown_description_.IsDefault()) {
    markdown_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.VersionHistory.markdown_description)
}

// repeated .viam.app.v1.App apps = 7 [json_name = "apps"];
inline int VersionHistory::_internal_apps_size() const {
  return apps_.size();
}
inline int VersionHistory::apps_size() const {
  return _internal_apps_size();
}
inline void VersionHistory::clear_apps() {
  apps_.Clear();
}
inline ::viam::app::v1::App* VersionHistory::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >*
VersionHistory::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.VersionHistory.apps)
  return &apps_;
}
inline const ::viam::app::v1::App& VersionHistory::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::viam::app::v1::App& VersionHistory::apps(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.apps)
  return _internal_apps(index);
}
inline ::viam::app::v1::App* VersionHistory::_internal_add_apps() {
  return apps_.Add();
}
inline ::viam::app::v1::App* VersionHistory::add_apps() {
  ::viam::app::v1::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:viam.app.v1.VersionHistory.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::App >&
VersionHistory::apps() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.VersionHistory.apps)
  return apps_;
}

// -------------------------------------------------------------------

// Uploads

// string platform = 1 [json_name = "platform"];
inline void Uploads::clear_platform() {
  platform_.ClearToEmpty();
}
inline const std::string& Uploads::platform() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Uploads.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Uploads::set_platform(ArgT0&& arg0, ArgT... args) {
 
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Uploads.platform)
}
inline std::string* Uploads::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Uploads.platform)
  return _s;
}
inline const std::string& Uploads::_internal_platform() const {
  return platform_.Get();
}
inline void Uploads::_internal_set_platform(const std::string& value) {
  
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* Uploads::_internal_mutable_platform() {
  
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* Uploads::release_platform() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Uploads.platform)
  return platform_.Release();
}
inline void Uploads::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Uploads.platform)
}

// .google.protobuf.Timestamp uploaded_at = 2 [json_name = "uploadedAt"];
inline bool Uploads::_internal_has_uploaded_at() const {
  return this != internal_default_instance() && uploaded_at_ != nullptr;
}
inline bool Uploads::has_uploaded_at() const {
  return _internal_has_uploaded_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Uploads::_internal_uploaded_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = uploaded_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Uploads::uploaded_at() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Uploads.uploaded_at)
  return _internal_uploaded_at();
}
inline void Uploads::unsafe_arena_set_allocated_uploaded_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaded_at_);
  }
  uploaded_at_ = uploaded_at;
  if (uploaded_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Uploads.uploaded_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::release_uploaded_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = uploaded_at_;
  uploaded_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::unsafe_arena_release_uploaded_at() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Uploads.uploaded_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = uploaded_at_;
  uploaded_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::_internal_mutable_uploaded_at() {
  
  if (uploaded_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    uploaded_at_ = p;
  }
  return uploaded_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::mutable_uploaded_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_uploaded_at();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Uploads.uploaded_at)
  return _msg;
}
inline void Uploads::set_allocated_uploaded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaded_at_);
  }
  if (uploaded_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaded_at));
    if (message_arena != submessage_arena) {
      uploaded_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uploaded_at, submessage_arena);
    }
    
  } else {
    
  }
  uploaded_at_ = uploaded_at;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Uploads.uploaded_at)
}

// -------------------------------------------------------------------

// ListModulesRequest

// optional string organization_id = 1 [json_name = "organizationId"];
inline bool ListModulesRequest::_internal_has_organization_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListModulesRequest::has_organization_id() const {
  return _internal_has_organization_id();
}
inline void ListModulesRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListModulesRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListModulesRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListModulesRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListModulesRequest.organization_id)
}
inline std::string* ListModulesRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListModulesRequest.organization_id)
  return _s;
}
inline const std::string& ListModulesRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListModulesRequest::_internal_set_organization_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListModulesRequest::_internal_mutable_organization_id() {
  _has_bits_[0] |= 0x00000001u;
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListModulesRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListModulesRequest.organization_id)
  if (!_internal_has_organization_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = organization_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListModulesRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListModulesRequest.organization_id)
}

// optional bool include_markdown_documentation = 2 [json_name = "includeMarkdownDocumentation"];
inline bool ListModulesRequest::_internal_has_include_markdown_documentation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListModulesRequest::has_include_markdown_documentation() const {
  return _internal_has_include_markdown_documentation();
}
inline void ListModulesRequest::clear_include_markdown_documentation() {
  include_markdown_documentation_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ListModulesRequest::_internal_include_markdown_documentation() const {
  return include_markdown_documentation_;
}
inline bool ListModulesRequest::include_markdown_documentation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListModulesRequest.include_markdown_documentation)
  return _internal_include_markdown_documentation();
}
inline void ListModulesRequest::_internal_set_include_markdown_documentation(bool value) {
  _has_bits_[0] |= 0x00000002u;
  include_markdown_documentation_ = value;
}
inline void ListModulesRequest::set_include_markdown_documentation(bool value) {
  _internal_set_include_markdown_documentation(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListModulesRequest.include_markdown_documentation)
}

// -------------------------------------------------------------------

// ListModulesResponse

// repeated .viam.app.v1.Module modules = 1 [json_name = "modules"];
inline int ListModulesResponse::_internal_modules_size() const {
  return modules_.size();
}
inline int ListModulesResponse::modules_size() const {
  return _internal_modules_size();
}
inline void ListModulesResponse::clear_modules() {
  modules_.Clear();
}
inline ::viam::app::v1::Module* ListModulesResponse::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListModulesResponse.modules)
  return modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >*
ListModulesResponse::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListModulesResponse.modules)
  return &modules_;
}
inline const ::viam::app::v1::Module& ListModulesResponse::_internal_modules(int index) const {
  return modules_.Get(index);
}
inline const ::viam::app::v1::Module& ListModulesResponse::modules(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListModulesResponse.modules)
  return _internal_modules(index);
}
inline ::viam::app::v1::Module* ListModulesResponse::_internal_add_modules() {
  return modules_.Add();
}
inline ::viam::app::v1::Module* ListModulesResponse::add_modules() {
  ::viam::app::v1::Module* _add = _internal_add_modules();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListModulesResponse.modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >&
ListModulesResponse::modules() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListModulesResponse.modules)
  return modules_;
}

// -------------------------------------------------------------------

// GetUserIDByEmailRequest

// string email = 1 [json_name = "email"];
inline void GetUserIDByEmailRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& GetUserIDByEmailRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetUserIDByEmailRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserIDByEmailRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetUserIDByEmailRequest.email)
}
inline std::string* GetUserIDByEmailRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetUserIDByEmailRequest.email)
  return _s;
}
inline const std::string& GetUserIDByEmailRequest::_internal_email() const {
  return email_.Get();
}
inline void GetUserIDByEmailRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetUserIDByEmailRequest.email)
  return email_.Release();
}
inline void GetUserIDByEmailRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetUserIDByEmailRequest.email)
}

// -------------------------------------------------------------------

// GetUserIDByEmailResponse

// string user_id = 1 [json_name = "userId"];
inline void GetUserIDByEmailResponse::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetUserIDByEmailResponse::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetUserIDByEmailResponse.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserIDByEmailResponse::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetUserIDByEmailResponse.user_id)
}
inline std::string* GetUserIDByEmailResponse::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetUserIDByEmailResponse.user_id)
  return _s;
}
inline const std::string& GetUserIDByEmailResponse::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetUserIDByEmailResponse::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailResponse::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailResponse::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetUserIDByEmailResponse.user_id)
  return user_id_.Release();
}
inline void GetUserIDByEmailResponse::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetUserIDByEmailResponse.user_id)
}

// -------------------------------------------------------------------

// ListOrganizationsByUserRequest

// string user_id = 1 [json_name = "userId"];
inline void ListOrganizationsByUserRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ListOrganizationsByUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationsByUserRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOrganizationsByUserRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOrganizationsByUserRequest.user_id)
}
inline std::string* ListOrganizationsByUserRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationsByUserRequest.user_id)
  return _s;
}
inline const std::string& ListOrganizationsByUserRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ListOrganizationsByUserRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOrganizationsByUserRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOrganizationsByUserRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListOrganizationsByUserRequest.user_id)
  return user_id_.Release();
}
inline void ListOrganizationsByUserRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListOrganizationsByUserRequest.user_id)
}

// -------------------------------------------------------------------

// OrgDetails

// string org_id = 1 [json_name = "orgId"];
inline void OrgDetails::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& OrgDetails::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrgDetails.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrgDetails::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrgDetails.org_id)
}
inline std::string* OrgDetails::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrgDetails.org_id)
  return _s;
}
inline const std::string& OrgDetails::_internal_org_id() const {
  return org_id_.Get();
}
inline void OrgDetails::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrgDetails::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrgDetails::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrgDetails.org_id)
  return org_id_.Release();
}
inline void OrgDetails::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrgDetails.org_id)
}

// string org_name = 2 [json_name = "orgName"];
inline void OrgDetails::clear_org_name() {
  org_name_.ClearToEmpty();
}
inline const std::string& OrgDetails::org_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrgDetails.org_name)
  return _internal_org_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrgDetails::set_org_name(ArgT0&& arg0, ArgT... args) {
 
 org_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrgDetails.org_name)
}
inline std::string* OrgDetails::mutable_org_name() {
  std::string* _s = _internal_mutable_org_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrgDetails.org_name)
  return _s;
}
inline const std::string& OrgDetails::_internal_org_name() const {
  return org_name_.Get();
}
inline void OrgDetails::_internal_set_org_name(const std::string& value) {
  
  org_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OrgDetails::_internal_mutable_org_name() {
  
  return org_name_.Mutable(GetArenaForAllocation());
}
inline std::string* OrgDetails::release_org_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrgDetails.org_name)
  return org_name_.Release();
}
inline void OrgDetails::set_allocated_org_name(std::string* org_name) {
  if (org_name != nullptr) {
    
  } else {
    
  }
  org_name_.SetAllocated(org_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_name_.IsDefault()) {
    org_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrgDetails.org_name)
}

// optional string org_cid = 3 [json_name = "orgCid"];
inline bool OrgDetails::_internal_has_org_cid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrgDetails::has_org_cid() const {
  return _internal_has_org_cid();
}
inline void OrgDetails::clear_org_cid() {
  org_cid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OrgDetails::org_cid() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrgDetails.org_cid)
  return _internal_org_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrgDetails::set_org_cid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 org_cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrgDetails.org_cid)
}
inline std::string* OrgDetails::mutable_org_cid() {
  std::string* _s = _internal_mutable_org_cid();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrgDetails.org_cid)
  return _s;
}
inline const std::string& OrgDetails::_internal_org_cid() const {
  return org_cid_.Get();
}
inline void OrgDetails::_internal_set_org_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  org_cid_.Set(value, GetArenaForAllocation());
}
inline std::string* OrgDetails::_internal_mutable_org_cid() {
  _has_bits_[0] |= 0x00000001u;
  return org_cid_.Mutable(GetArenaForAllocation());
}
inline std::string* OrgDetails::release_org_cid() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrgDetails.org_cid)
  if (!_internal_has_org_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = org_cid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_cid_.IsDefault()) {
    org_cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrgDetails::set_allocated_org_cid(std::string* org_cid) {
  if (org_cid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  org_cid_.SetAllocated(org_cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_cid_.IsDefault()) {
    org_cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrgDetails.org_cid)
}

// optional string public_namespace = 4 [json_name = "publicNamespace"];
inline bool OrgDetails::_internal_has_public_namespace() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OrgDetails::has_public_namespace() const {
  return _internal_has_public_namespace();
}
inline void OrgDetails::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OrgDetails::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrgDetails.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrgDetails::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrgDetails.public_namespace)
}
inline std::string* OrgDetails::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrgDetails.public_namespace)
  return _s;
}
inline const std::string& OrgDetails::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void OrgDetails::_internal_set_public_namespace(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* OrgDetails::_internal_mutable_public_namespace() {
  _has_bits_[0] |= 0x00000002u;
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* OrgDetails::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrgDetails.public_namespace)
  if (!_internal_has_public_namespace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_namespace_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrgDetails::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrgDetails.public_namespace)
}

// optional string billing_tier = 5 [json_name = "billingTier"];
inline bool OrgDetails::_internal_has_billing_tier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OrgDetails::has_billing_tier() const {
  return _internal_has_billing_tier();
}
inline void OrgDetails::clear_billing_tier() {
  billing_tier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OrgDetails::billing_tier() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrgDetails.billing_tier)
  return _internal_billing_tier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrgDetails::set_billing_tier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 billing_tier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrgDetails.billing_tier)
}
inline std::string* OrgDetails::mutable_billing_tier() {
  std::string* _s = _internal_mutable_billing_tier();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrgDetails.billing_tier)
  return _s;
}
inline const std::string& OrgDetails::_internal_billing_tier() const {
  return billing_tier_.Get();
}
inline void OrgDetails::_internal_set_billing_tier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  billing_tier_.Set(value, GetArenaForAllocation());
}
inline std::string* OrgDetails::_internal_mutable_billing_tier() {
  _has_bits_[0] |= 0x00000004u;
  return billing_tier_.Mutable(GetArenaForAllocation());
}
inline std::string* OrgDetails::release_billing_tier() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrgDetails.billing_tier)
  if (!_internal_has_billing_tier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = billing_tier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (billing_tier_.IsDefault()) {
    billing_tier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrgDetails::set_allocated_billing_tier(std::string* billing_tier) {
  if (billing_tier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  billing_tier_.SetAllocated(billing_tier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (billing_tier_.IsDefault()) {
    billing_tier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrgDetails.billing_tier)
}

// -------------------------------------------------------------------

// ListOrganizationsByUserResponse

// repeated .viam.app.v1.OrgDetails orgs = 1 [json_name = "orgs"];
inline int ListOrganizationsByUserResponse::_internal_orgs_size() const {
  return orgs_.size();
}
inline int ListOrganizationsByUserResponse::orgs_size() const {
  return _internal_orgs_size();
}
inline void ListOrganizationsByUserResponse::clear_orgs() {
  orgs_.Clear();
}
inline ::viam::app::v1::OrgDetails* ListOrganizationsByUserResponse::mutable_orgs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return orgs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >*
ListOrganizationsByUserResponse::mutable_orgs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return &orgs_;
}
inline const ::viam::app::v1::OrgDetails& ListOrganizationsByUserResponse::_internal_orgs(int index) const {
  return orgs_.Get(index);
}
inline const ::viam::app::v1::OrgDetails& ListOrganizationsByUserResponse::orgs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return _internal_orgs(index);
}
inline ::viam::app::v1::OrgDetails* ListOrganizationsByUserResponse::_internal_add_orgs() {
  return orgs_.Add();
}
inline ::viam::app::v1::OrgDetails* ListOrganizationsByUserResponse::add_orgs() {
  ::viam::app::v1::OrgDetails* _add = _internal_add_orgs();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >&
ListOrganizationsByUserResponse::orgs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return orgs_;
}

// -------------------------------------------------------------------

// SearchOrganizationsRequest

// optional string org_id = 1 [json_name = "orgId"];
inline bool SearchOrganizationsRequest::_internal_has_org_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SearchOrganizationsRequest::has_org_id() const {
  return _internal_has_org_id();
}
inline void SearchOrganizationsRequest::clear_org_id() {
  org_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SearchOrganizationsRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SearchOrganizationsRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchOrganizationsRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SearchOrganizationsRequest.org_id)
}
inline std::string* SearchOrganizationsRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SearchOrganizationsRequest.org_id)
  return _s;
}
inline const std::string& SearchOrganizationsRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void SearchOrganizationsRequest::_internal_set_org_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::_internal_mutable_org_id() {
  _has_bits_[0] |= 0x00000001u;
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SearchOrganizationsRequest.org_id)
  if (!_internal_has_org_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = org_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchOrganizationsRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SearchOrganizationsRequest.org_id)
}

// optional string org_name = 2 [json_name = "orgName"];
inline bool SearchOrganizationsRequest::_internal_has_org_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SearchOrganizationsRequest::has_org_name() const {
  return _internal_has_org_name();
}
inline void SearchOrganizationsRequest::clear_org_name() {
  org_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SearchOrganizationsRequest::org_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SearchOrganizationsRequest.org_name)
  return _internal_org_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchOrganizationsRequest::set_org_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 org_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SearchOrganizationsRequest.org_name)
}
inline std::string* SearchOrganizationsRequest::mutable_org_name() {
  std::string* _s = _internal_mutable_org_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SearchOrganizationsRequest.org_name)
  return _s;
}
inline const std::string& SearchOrganizationsRequest::_internal_org_name() const {
  return org_name_.Get();
}
inline void SearchOrganizationsRequest::_internal_set_org_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  org_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::_internal_mutable_org_name() {
  _has_bits_[0] |= 0x00000002u;
  return org_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::release_org_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SearchOrganizationsRequest.org_name)
  if (!_internal_has_org_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = org_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_name_.IsDefault()) {
    org_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchOrganizationsRequest::set_allocated_org_name(std::string* org_name) {
  if (org_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  org_name_.SetAllocated(org_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_name_.IsDefault()) {
    org_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SearchOrganizationsRequest.org_name)
}

// optional string cid = 3 [json_name = "cid"];
inline bool SearchOrganizationsRequest::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SearchOrganizationsRequest::has_cid() const {
  return _internal_has_cid();
}
inline void SearchOrganizationsRequest::clear_cid() {
  cid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SearchOrganizationsRequest::cid() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SearchOrganizationsRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchOrganizationsRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SearchOrganizationsRequest.cid)
}
inline std::string* SearchOrganizationsRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SearchOrganizationsRequest.cid)
  return _s;
}
inline const std::string& SearchOrganizationsRequest::_internal_cid() const {
  return cid_.Get();
}
inline void SearchOrganizationsRequest::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000004u;
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::release_cid() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SearchOrganizationsRequest.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = cid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchOrganizationsRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SearchOrganizationsRequest.cid)
}

// optional string public_namespace = 4 [json_name = "publicNamespace"];
inline bool SearchOrganizationsRequest::_internal_has_public_namespace() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SearchOrganizationsRequest::has_public_namespace() const {
  return _internal_has_public_namespace();
}
inline void SearchOrganizationsRequest::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SearchOrganizationsRequest::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SearchOrganizationsRequest.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchOrganizationsRequest::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SearchOrganizationsRequest.public_namespace)
}
inline std::string* SearchOrganizationsRequest::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SearchOrganizationsRequest.public_namespace)
  return _s;
}
inline const std::string& SearchOrganizationsRequest::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void SearchOrganizationsRequest::_internal_set_public_namespace(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::_internal_mutable_public_namespace() {
  _has_bits_[0] |= 0x00000008u;
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchOrganizationsRequest::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SearchOrganizationsRequest.public_namespace)
  if (!_internal_has_public_namespace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = public_namespace_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchOrganizationsRequest::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SearchOrganizationsRequest.public_namespace)
}

// -------------------------------------------------------------------

// SearchOrganizationsResponse

// repeated .viam.app.v1.OrgDetails organizations = 1 [json_name = "organizations"];
inline int SearchOrganizationsResponse::_internal_organizations_size() const {
  return organizations_.size();
}
inline int SearchOrganizationsResponse::organizations_size() const {
  return _internal_organizations_size();
}
inline void SearchOrganizationsResponse::clear_organizations() {
  organizations_.Clear();
}
inline ::viam::app::v1::OrgDetails* SearchOrganizationsResponse::mutable_organizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SearchOrganizationsResponse.organizations)
  return organizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >*
SearchOrganizationsResponse::mutable_organizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.SearchOrganizationsResponse.organizations)
  return &organizations_;
}
inline const ::viam::app::v1::OrgDetails& SearchOrganizationsResponse::_internal_organizations(int index) const {
  return organizations_.Get(index);
}
inline const ::viam::app::v1::OrgDetails& SearchOrganizationsResponse::organizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SearchOrganizationsResponse.organizations)
  return _internal_organizations(index);
}
inline ::viam::app::v1::OrgDetails* SearchOrganizationsResponse::_internal_add_organizations() {
  return organizations_.Add();
}
inline ::viam::app::v1::OrgDetails* SearchOrganizationsResponse::add_organizations() {
  ::viam::app::v1::OrgDetails* _add = _internal_add_organizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.SearchOrganizationsResponse.organizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >&
SearchOrganizationsResponse::organizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.SearchOrganizationsResponse.organizations)
  return organizations_;
}

// -------------------------------------------------------------------

// CreateKeyRequest

// repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
inline int CreateKeyRequest::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int CreateKeyRequest::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void CreateKeyRequest::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* CreateKeyRequest::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyRequest.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
CreateKeyRequest::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CreateKeyRequest.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& CreateKeyRequest::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& CreateKeyRequest::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyRequest.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* CreateKeyRequest::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* CreateKeyRequest::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.CreateKeyRequest.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
CreateKeyRequest::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CreateKeyRequest.authorizations)
  return authorizations_;
}

// string name = 2 [json_name = "name"];
inline void CreateKeyRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyRequest.name)
}
inline std::string* CreateKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyRequest.name)
  return _s;
}
inline const std::string& CreateKeyRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateKeyRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyRequest.name)
  return name_.Release();
}
inline void CreateKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyRequest.name)
}

// -------------------------------------------------------------------

// CreateKeyResponse

// string key = 1 [json_name = "key"];
inline void CreateKeyResponse::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& CreateKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyResponse.key)
}
inline std::string* CreateKeyResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyResponse.key)
  return _s;
}
inline const std::string& CreateKeyResponse::_internal_key() const {
  return key_.Get();
}
inline void CreateKeyResponse::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyResponse.key)
  return key_.Release();
}
inline void CreateKeyResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyResponse.key)
}

// string id = 2 [json_name = "id"];
inline void CreateKeyResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateKeyResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyResponse.id)
}
inline std::string* CreateKeyResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyResponse.id)
  return _s;
}
inline const std::string& CreateKeyResponse::_internal_id() const {
  return id_.Get();
}
inline void CreateKeyResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyResponse.id)
  return id_.Release();
}
inline void CreateKeyResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyResponse.id)
}

// -------------------------------------------------------------------

// DeleteKeyRequest

// string id = 1 [json_name = "id"];
inline void DeleteKeyRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteKeyRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteKeyRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteKeyRequest.id)
}
inline std::string* DeleteKeyRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteKeyRequest.id)
  return _s;
}
inline const std::string& DeleteKeyRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteKeyRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteKeyRequest.id)
  return id_.Release();
}
inline void DeleteKeyRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteKeyRequest.id)
}

// -------------------------------------------------------------------

// DeleteKeyResponse

// -------------------------------------------------------------------

// RenameKeyRequest

// string id = 1 [json_name = "id"];
inline void RenameKeyRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RenameKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RenameKeyRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameKeyRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RenameKeyRequest.id)
}
inline std::string* RenameKeyRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RenameKeyRequest.id)
  return _s;
}
inline const std::string& RenameKeyRequest::_internal_id() const {
  return id_.Get();
}
inline void RenameKeyRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameKeyRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameKeyRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RenameKeyRequest.id)
  return id_.Release();
}
inline void RenameKeyRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RenameKeyRequest.id)
}

// string name = 2 [json_name = "name"];
inline void RenameKeyRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RenameKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RenameKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RenameKeyRequest.name)
}
inline std::string* RenameKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RenameKeyRequest.name)
  return _s;
}
inline const std::string& RenameKeyRequest::_internal_name() const {
  return name_.Get();
}
inline void RenameKeyRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameKeyRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RenameKeyRequest.name)
  return name_.Release();
}
inline void RenameKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RenameKeyRequest.name)
}

// -------------------------------------------------------------------

// RenameKeyResponse

// string id = 1 [json_name = "id"];
inline void RenameKeyResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RenameKeyResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RenameKeyResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameKeyResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RenameKeyResponse.id)
}
inline std::string* RenameKeyResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RenameKeyResponse.id)
  return _s;
}
inline const std::string& RenameKeyResponse::_internal_id() const {
  return id_.Get();
}
inline void RenameKeyResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameKeyResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameKeyResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RenameKeyResponse.id)
  return id_.Release();
}
inline void RenameKeyResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RenameKeyResponse.id)
}

// string name = 2 [json_name = "name"];
inline void RenameKeyResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RenameKeyResponse::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RenameKeyResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameKeyResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RenameKeyResponse.name)
}
inline std::string* RenameKeyResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RenameKeyResponse.name)
  return _s;
}
inline const std::string& RenameKeyResponse::_internal_name() const {
  return name_.Get();
}
inline void RenameKeyResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameKeyResponse::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameKeyResponse::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RenameKeyResponse.name)
  return name_.Release();
}
inline void RenameKeyResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RenameKeyResponse.name)
}

// -------------------------------------------------------------------

// AuthorizationDetails

// string authorization_type = 1 [json_name = "authorizationType"];
inline void AuthorizationDetails::clear_authorization_type() {
  authorization_type_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::authorization_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.authorization_type)
  return _internal_authorization_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_authorization_type(ArgT0&& arg0, ArgT... args) {
 
 authorization_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.authorization_type)
}
inline std::string* AuthorizationDetails::mutable_authorization_type() {
  std::string* _s = _internal_mutable_authorization_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.authorization_type)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_authorization_type() const {
  return authorization_type_.Get();
}
inline void AuthorizationDetails::_internal_set_authorization_type(const std::string& value) {
  
  authorization_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_authorization_type() {
  
  return authorization_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_authorization_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.authorization_type)
  return authorization_type_.Release();
}
inline void AuthorizationDetails::set_allocated_authorization_type(std::string* authorization_type) {
  if (authorization_type != nullptr) {
    
  } else {
    
  }
  authorization_type_.SetAllocated(authorization_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_type_.IsDefault()) {
    authorization_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.authorization_type)
}

// string authorization_id = 2 [json_name = "authorizationId"];
inline void AuthorizationDetails::clear_authorization_id() {
  authorization_id_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::authorization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.authorization_id)
  return _internal_authorization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_authorization_id(ArgT0&& arg0, ArgT... args) {
 
 authorization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.authorization_id)
}
inline std::string* AuthorizationDetails::mutable_authorization_id() {
  std::string* _s = _internal_mutable_authorization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.authorization_id)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_authorization_id() const {
  return authorization_id_.Get();
}
inline void AuthorizationDetails::_internal_set_authorization_id(const std::string& value) {
  
  authorization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_authorization_id() {
  
  return authorization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_authorization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.authorization_id)
  return authorization_id_.Release();
}
inline void AuthorizationDetails::set_allocated_authorization_id(std::string* authorization_id) {
  if (authorization_id != nullptr) {
    
  } else {
    
  }
  authorization_id_.SetAllocated(authorization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_id_.IsDefault()) {
    authorization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.authorization_id)
}

// string resource_type = 3 [json_name = "resourceType"];
inline void AuthorizationDetails::clear_resource_type() {
  resource_type_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::resource_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.resource_type)
}
inline std::string* AuthorizationDetails::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.resource_type)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_resource_type() const {
  return resource_type_.Get();
}
inline void AuthorizationDetails::_internal_set_resource_type(const std::string& value) {
  
  resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_resource_type() {
  
  return resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_resource_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.resource_type)
  return resource_type_.Release();
}
inline void AuthorizationDetails::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_type_.IsDefault()) {
    resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.resource_type)
}

// string resource_id = 4 [json_name = "resourceId"];
inline void AuthorizationDetails::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::resource_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.resource_id)
}
inline std::string* AuthorizationDetails::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.resource_id)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void AuthorizationDetails::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_resource_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.resource_id)
  return resource_id_.Release();
}
inline void AuthorizationDetails::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault()) {
    resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.resource_id)
}

// string org_id = 5 [json_name = "orgId"];
inline void AuthorizationDetails::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.org_id)
}
inline std::string* AuthorizationDetails::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.org_id)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_org_id() const {
  return org_id_.Get();
}
inline void AuthorizationDetails::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.org_id)
  return org_id_.Release();
}
inline void AuthorizationDetails::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.org_id)
}

// -------------------------------------------------------------------

// APIKeyWithAuthorizations

// .viam.app.v1.APIKey api_key = 1 [json_name = "apiKey"];
inline bool APIKeyWithAuthorizations::_internal_has_api_key() const {
  return this != internal_default_instance() && api_key_ != nullptr;
}
inline bool APIKeyWithAuthorizations::has_api_key() const {
  return _internal_has_api_key();
}
inline void APIKeyWithAuthorizations::clear_api_key() {
  if (GetArenaForAllocation() == nullptr && api_key_ != nullptr) {
    delete api_key_;
  }
  api_key_ = nullptr;
}
inline const ::viam::app::v1::APIKey& APIKeyWithAuthorizations::_internal_api_key() const {
  const ::viam::app::v1::APIKey* p = api_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::APIKey&>(
      ::viam::app::v1::_APIKey_default_instance_);
}
inline const ::viam::app::v1::APIKey& APIKeyWithAuthorizations::api_key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKeyWithAuthorizations.api_key)
  return _internal_api_key();
}
inline void APIKeyWithAuthorizations::unsafe_arena_set_allocated_api_key(
    ::viam::app::v1::APIKey* api_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_key_);
  }
  api_key_ = api_key;
  if (api_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.APIKeyWithAuthorizations.api_key)
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::release_api_key() {
  
  ::viam::app::v1::APIKey* temp = api_key_;
  api_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::unsafe_arena_release_api_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKeyWithAuthorizations.api_key)
  
  ::viam::app::v1::APIKey* temp = api_key_;
  api_key_ = nullptr;
  return temp;
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::_internal_mutable_api_key() {
  
  if (api_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::APIKey>(GetArenaForAllocation());
    api_key_ = p;
  }
  return api_key_;
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::mutable_api_key() {
  ::viam::app::v1::APIKey* _msg = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKeyWithAuthorizations.api_key)
  return _msg;
}
inline void APIKeyWithAuthorizations::set_allocated_api_key(::viam::app::v1::APIKey* api_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete api_key_;
  }
  if (api_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(api_key);
    if (message_arena != submessage_arena) {
      api_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_key, submessage_arena);
    }
    
  } else {
    
  }
  api_key_ = api_key;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKeyWithAuthorizations.api_key)
}

// repeated .viam.app.v1.AuthorizationDetails authorizations = 2 [json_name = "authorizations"];
inline int APIKeyWithAuthorizations::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int APIKeyWithAuthorizations::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void APIKeyWithAuthorizations::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::AuthorizationDetails* APIKeyWithAuthorizations::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >*
APIKeyWithAuthorizations::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::AuthorizationDetails& APIKeyWithAuthorizations::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::AuthorizationDetails& APIKeyWithAuthorizations::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::AuthorizationDetails* APIKeyWithAuthorizations::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::AuthorizationDetails* APIKeyWithAuthorizations::add_authorizations() {
  ::viam::app::v1::AuthorizationDetails* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >&
APIKeyWithAuthorizations::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return authorizations_;
}

// -------------------------------------------------------------------

// ListKeysRequest

// string org_id = 1 [json_name = "orgId"];
inline void ListKeysRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& ListKeysRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListKeysRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListKeysRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListKeysRequest.org_id)
}
inline std::string* ListKeysRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListKeysRequest.org_id)
  return _s;
}
inline const std::string& ListKeysRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void ListKeysRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListKeysRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListKeysRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListKeysRequest.org_id)
  return org_id_.Release();
}
inline void ListKeysRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListKeysRequest.org_id)
}

// -------------------------------------------------------------------

// ListKeysResponse

// repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
inline int ListKeysResponse::_internal_api_keys_size() const {
  return api_keys_.size();
}
inline int ListKeysResponse::api_keys_size() const {
  return _internal_api_keys_size();
}
inline void ListKeysResponse::clear_api_keys() {
  api_keys_.Clear();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* ListKeysResponse::mutable_api_keys(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListKeysResponse.api_keys)
  return api_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
ListKeysResponse::mutable_api_keys() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListKeysResponse.api_keys)
  return &api_keys_;
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& ListKeysResponse::_internal_api_keys(int index) const {
  return api_keys_.Get(index);
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& ListKeysResponse::api_keys(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListKeysResponse.api_keys)
  return _internal_api_keys(index);
}
inline ::viam::app::v1::APIKeyWithAuthorizations* ListKeysResponse::_internal_add_api_keys() {
  return api_keys_.Add();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* ListKeysResponse::add_api_keys() {
  ::viam::app::v1::APIKeyWithAuthorizations* _add = _internal_add_api_keys();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListKeysResponse.api_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
ListKeysResponse::api_keys() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListKeysResponse.api_keys)
  return api_keys_;
}

// -------------------------------------------------------------------

// RotateKeyRequest

// string id = 1 [json_name = "id"];
inline void RotateKeyRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RotateKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RotateKeyRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RotateKeyRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RotateKeyRequest.id)
}
inline std::string* RotateKeyRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RotateKeyRequest.id)
  return _s;
}
inline const std::string& RotateKeyRequest::_internal_id() const {
  return id_.Get();
}
inline void RotateKeyRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RotateKeyRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RotateKeyRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RotateKeyRequest.id)
  return id_.Release();
}
inline void RotateKeyRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RotateKeyRequest.id)
}

// -------------------------------------------------------------------

// RotateKeyResponse

// string id = 1 [json_name = "id"];
inline void RotateKeyResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RotateKeyResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RotateKeyResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RotateKeyResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RotateKeyResponse.id)
}
inline std::string* RotateKeyResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RotateKeyResponse.id)
  return _s;
}
inline const std::string& RotateKeyResponse::_internal_id() const {
  return id_.Get();
}
inline void RotateKeyResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RotateKeyResponse.id)
  return id_.Release();
}
inline void RotateKeyResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RotateKeyResponse.id)
}

// string key = 2 [json_name = "key"];
inline void RotateKeyResponse::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& RotateKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RotateKeyResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RotateKeyResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RotateKeyResponse.key)
}
inline std::string* RotateKeyResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RotateKeyResponse.key)
  return _s;
}
inline const std::string& RotateKeyResponse::_internal_key() const {
  return key_.Get();
}
inline void RotateKeyResponse::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RotateKeyResponse.key)
  return key_.Release();
}
inline void RotateKeyResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RotateKeyResponse.key)
}

// -------------------------------------------------------------------

// CreateKeyFromExistingKeyAuthorizationsRequest

// string id = 1 [json_name = "id"];
inline void CreateKeyFromExistingKeyAuthorizationsRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyFromExistingKeyAuthorizationsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
  return _s;
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsRequest::_internal_id() const {
  return id_.Get();
}
inline void CreateKeyFromExistingKeyAuthorizationsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
  return id_.Release();
}
inline void CreateKeyFromExistingKeyAuthorizationsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
}

// -------------------------------------------------------------------

// CreateKeyFromExistingKeyAuthorizationsResponse

// string id = 1 [json_name = "id"];
inline void CreateKeyFromExistingKeyAuthorizationsResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyFromExistingKeyAuthorizationsResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
  return _s;
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::_internal_id() const {
  return id_.Get();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
  return id_.Release();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
}

// string key = 2 [json_name = "key"];
inline void CreateKeyFromExistingKeyAuthorizationsResponse::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyFromExistingKeyAuthorizationsResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
  return _s;
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::_internal_key() const {
  return key_.Get();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
  return key_.Release();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
}

// -------------------------------------------------------------------

// GetAppContentRequest

// string public_namespace = 1 [json_name = "publicNamespace"];
inline void GetAppContentRequest::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& GetAppContentRequest::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppContentRequest.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppContentRequest::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppContentRequest.public_namespace)
}
inline std::string* GetAppContentRequest::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppContentRequest.public_namespace)
  return _s;
}
inline const std::string& GetAppContentRequest::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void GetAppContentRequest::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppContentRequest::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAppContentRequest::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetAppContentRequest.public_namespace)
  return public_namespace_.Release();
}
inline void GetAppContentRequest::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetAppContentRequest.public_namespace)
}

// string name = 2 [json_name = "name"];
inline void GetAppContentRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetAppContentRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppContentRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppContentRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppContentRequest.name)
}
inline std::string* GetAppContentRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppContentRequest.name)
  return _s;
}
inline const std::string& GetAppContentRequest::_internal_name() const {
  return name_.Get();
}
inline void GetAppContentRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppContentRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAppContentRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetAppContentRequest.name)
  return name_.Release();
}
inline void GetAppContentRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetAppContentRequest.name)
}

// -------------------------------------------------------------------

// GetAppContentResponse

// string blob_path = 1 [json_name = "blobPath"];
inline void GetAppContentResponse::clear_blob_path() {
  blob_path_.ClearToEmpty();
}
inline const std::string& GetAppContentResponse::blob_path() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppContentResponse.blob_path)
  return _internal_blob_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppContentResponse::set_blob_path(ArgT0&& arg0, ArgT... args) {
 
 blob_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppContentResponse.blob_path)
}
inline std::string* GetAppContentResponse::mutable_blob_path() {
  std::string* _s = _internal_mutable_blob_path();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppContentResponse.blob_path)
  return _s;
}
inline const std::string& GetAppContentResponse::_internal_blob_path() const {
  return blob_path_.Get();
}
inline void GetAppContentResponse::_internal_set_blob_path(const std::string& value) {
  
  blob_path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppContentResponse::_internal_mutable_blob_path() {
  
  return blob_path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAppContentResponse::release_blob_path() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetAppContentResponse.blob_path)
  return blob_path_.Release();
}
inline void GetAppContentResponse::set_allocated_blob_path(std::string* blob_path) {
  if (blob_path != nullptr) {
    
  } else {
    
  }
  blob_path_.SetAllocated(blob_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blob_path_.IsDefault()) {
    blob_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetAppContentResponse.blob_path)
}

// string entrypoint = 2 [json_name = "entrypoint"];
inline void GetAppContentResponse::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& GetAppContentResponse::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppContentResponse.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppContentResponse::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppContentResponse.entrypoint)
}
inline std::string* GetAppContentResponse::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppContentResponse.entrypoint)
  return _s;
}
inline const std::string& GetAppContentResponse::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void GetAppContentResponse::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppContentResponse::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAppContentResponse::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetAppContentResponse.entrypoint)
  return entrypoint_.Release();
}
inline void GetAppContentResponse::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetAppContentResponse.entrypoint)
}

// .viam.app.v1.AppType app_type = 3 [json_name = "appType"];
inline void GetAppContentResponse::clear_app_type() {
  app_type_ = 0;
}
inline ::viam::app::v1::AppType GetAppContentResponse::_internal_app_type() const {
  return static_cast< ::viam::app::v1::AppType >(app_type_);
}
inline ::viam::app::v1::AppType GetAppContentResponse::app_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppContentResponse.app_type)
  return _internal_app_type();
}
inline void GetAppContentResponse::_internal_set_app_type(::viam::app::v1::AppType value) {
  
  app_type_ = value;
}
inline void GetAppContentResponse::set_app_type(::viam::app::v1::AppType value) {
  _internal_set_app_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppContentResponse.app_type)
}

// -------------------------------------------------------------------

// OrganizationSetLogoRequest

// string org_id = 1 [json_name = "orgId"];
inline void OrganizationSetLogoRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& OrganizationSetLogoRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationSetLogoRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationSetLogoRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationSetLogoRequest.org_id)
}
inline std::string* OrganizationSetLogoRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationSetLogoRequest.org_id)
  return _s;
}
inline const std::string& OrganizationSetLogoRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void OrganizationSetLogoRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationSetLogoRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationSetLogoRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationSetLogoRequest.org_id)
  return org_id_.Release();
}
inline void OrganizationSetLogoRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationSetLogoRequest.org_id)
}

// bytes logo = 2 [json_name = "logo"];
inline void OrganizationSetLogoRequest::clear_logo() {
  logo_.ClearToEmpty();
}
inline const std::string& OrganizationSetLogoRequest::logo() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationSetLogoRequest.logo)
  return _internal_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationSetLogoRequest::set_logo(ArgT0&& arg0, ArgT... args) {
 
 logo_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationSetLogoRequest.logo)
}
inline std::string* OrganizationSetLogoRequest::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationSetLogoRequest.logo)
  return _s;
}
inline const std::string& OrganizationSetLogoRequest::_internal_logo() const {
  return logo_.Get();
}
inline void OrganizationSetLogoRequest::_internal_set_logo(const std::string& value) {
  
  logo_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationSetLogoRequest::_internal_mutable_logo() {
  
  return logo_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationSetLogoRequest::release_logo() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationSetLogoRequest.logo)
  return logo_.Release();
}
inline void OrganizationSetLogoRequest::set_allocated_logo(std::string* logo) {
  if (logo != nullptr) {
    
  } else {
    
  }
  logo_.SetAllocated(logo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logo_.IsDefault()) {
    logo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationSetLogoRequest.logo)
}

// -------------------------------------------------------------------

// OrganizationSetLogoResponse

// -------------------------------------------------------------------

// OrganizationGetLogoRequest

// string org_id = 1 [json_name = "orgId"];
inline void OrganizationGetLogoRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& OrganizationGetLogoRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationGetLogoRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationGetLogoRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationGetLogoRequest.org_id)
}
inline std::string* OrganizationGetLogoRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationGetLogoRequest.org_id)
  return _s;
}
inline const std::string& OrganizationGetLogoRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void OrganizationGetLogoRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationGetLogoRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationGetLogoRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationGetLogoRequest.org_id)
  return org_id_.Release();
}
inline void OrganizationGetLogoRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationGetLogoRequest.org_id)
}

// -------------------------------------------------------------------

// OrganizationGetLogoResponse

// string url = 1 [json_name = "url"];
inline void OrganizationGetLogoResponse::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& OrganizationGetLogoResponse::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationGetLogoResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationGetLogoResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationGetLogoResponse.url)
}
inline std::string* OrganizationGetLogoResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationGetLogoResponse.url)
  return _s;
}
inline const std::string& OrganizationGetLogoResponse::_internal_url() const {
  return url_.Get();
}
inline void OrganizationGetLogoResponse::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationGetLogoResponse::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationGetLogoResponse::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationGetLogoResponse.url)
  return url_.Release();
}
inline void OrganizationGetLogoResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationGetLogoResponse.url)
}

// -------------------------------------------------------------------

// EnableAuthServiceRequest

// string org_id = 1 [json_name = "orgId"];
inline void EnableAuthServiceRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& EnableAuthServiceRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.EnableAuthServiceRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnableAuthServiceRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.EnableAuthServiceRequest.org_id)
}
inline std::string* EnableAuthServiceRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.EnableAuthServiceRequest.org_id)
  return _s;
}
inline const std::string& EnableAuthServiceRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void EnableAuthServiceRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EnableAuthServiceRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EnableAuthServiceRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.EnableAuthServiceRequest.org_id)
  return org_id_.Release();
}
inline void EnableAuthServiceRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.EnableAuthServiceRequest.org_id)
}

// -------------------------------------------------------------------

// EnableAuthServiceResponse

// -------------------------------------------------------------------

// DisableAuthServiceRequest

// string org_id = 1 [json_name = "orgId"];
inline void DisableAuthServiceRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& DisableAuthServiceRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DisableAuthServiceRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisableAuthServiceRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DisableAuthServiceRequest.org_id)
}
inline std::string* DisableAuthServiceRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DisableAuthServiceRequest.org_id)
  return _s;
}
inline const std::string& DisableAuthServiceRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void DisableAuthServiceRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DisableAuthServiceRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DisableAuthServiceRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DisableAuthServiceRequest.org_id)
  return org_id_.Release();
}
inline void DisableAuthServiceRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DisableAuthServiceRequest.org_id)
}

// -------------------------------------------------------------------

// DisableAuthServiceResponse

// -------------------------------------------------------------------

// CreateOAuthAppRequest

// string org_id = 1 [json_name = "orgId"];
inline void CreateOAuthAppRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& CreateOAuthAppRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOAuthAppRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOAuthAppRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOAuthAppRequest.org_id)
}
inline std::string* CreateOAuthAppRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOAuthAppRequest.org_id)
  return _s;
}
inline const std::string& CreateOAuthAppRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void CreateOAuthAppRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOAuthAppRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOAuthAppRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOAuthAppRequest.org_id)
  return org_id_.Release();
}
inline void CreateOAuthAppRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOAuthAppRequest.org_id)
}

// string client_name = 2 [json_name = "clientName"];
inline void CreateOAuthAppRequest::clear_client_name() {
  client_name_.ClearToEmpty();
}
inline const std::string& CreateOAuthAppRequest::client_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOAuthAppRequest.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOAuthAppRequest::set_client_name(ArgT0&& arg0, ArgT... args) {
 
 client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOAuthAppRequest.client_name)
}
inline std::string* CreateOAuthAppRequest::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOAuthAppRequest.client_name)
  return _s;
}
inline const std::string& CreateOAuthAppRequest::_internal_client_name() const {
  return client_name_.Get();
}
inline void CreateOAuthAppRequest::_internal_set_client_name(const std::string& value) {
  
  client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOAuthAppRequest::_internal_mutable_client_name() {
  
  return client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOAuthAppRequest::release_client_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOAuthAppRequest.client_name)
  return client_name_.Release();
}
inline void CreateOAuthAppRequest::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_name_.IsDefault()) {
    client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOAuthAppRequest.client_name)
}

// .viam.app.v1.OAuthConfig oauth_config = 3 [json_name = "oauthConfig"];
inline bool CreateOAuthAppRequest::_internal_has_oauth_config() const {
  return this != internal_default_instance() && oauth_config_ != nullptr;
}
inline bool CreateOAuthAppRequest::has_oauth_config() const {
  return _internal_has_oauth_config();
}
inline void CreateOAuthAppRequest::clear_oauth_config() {
  if (GetArenaForAllocation() == nullptr && oauth_config_ != nullptr) {
    delete oauth_config_;
  }
  oauth_config_ = nullptr;
}
inline const ::viam::app::v1::OAuthConfig& CreateOAuthAppRequest::_internal_oauth_config() const {
  const ::viam::app::v1::OAuthConfig* p = oauth_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OAuthConfig&>(
      ::viam::app::v1::_OAuthConfig_default_instance_);
}
inline const ::viam::app::v1::OAuthConfig& CreateOAuthAppRequest::oauth_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOAuthAppRequest.oauth_config)
  return _internal_oauth_config();
}
inline void CreateOAuthAppRequest::unsafe_arena_set_allocated_oauth_config(
    ::viam::app::v1::OAuthConfig* oauth_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oauth_config_);
  }
  oauth_config_ = oauth_config;
  if (oauth_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateOAuthAppRequest.oauth_config)
}
inline ::viam::app::v1::OAuthConfig* CreateOAuthAppRequest::release_oauth_config() {
  
  ::viam::app::v1::OAuthConfig* temp = oauth_config_;
  oauth_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OAuthConfig* CreateOAuthAppRequest::unsafe_arena_release_oauth_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOAuthAppRequest.oauth_config)
  
  ::viam::app::v1::OAuthConfig* temp = oauth_config_;
  oauth_config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OAuthConfig* CreateOAuthAppRequest::_internal_mutable_oauth_config() {
  
  if (oauth_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OAuthConfig>(GetArenaForAllocation());
    oauth_config_ = p;
  }
  return oauth_config_;
}
inline ::viam::app::v1::OAuthConfig* CreateOAuthAppRequest::mutable_oauth_config() {
  ::viam::app::v1::OAuthConfig* _msg = _internal_mutable_oauth_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOAuthAppRequest.oauth_config)
  return _msg;
}
inline void CreateOAuthAppRequest::set_allocated_oauth_config(::viam::app::v1::OAuthConfig* oauth_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete oauth_config_;
  }
  if (oauth_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oauth_config);
    if (message_arena != submessage_arena) {
      oauth_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oauth_config, submessage_arena);
    }
    
  } else {
    
  }
  oauth_config_ = oauth_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOAuthAppRequest.oauth_config)
}

// -------------------------------------------------------------------

// CreateOAuthAppResponse

// string client_id = 1 [json_name = "clientId"];
inline void CreateOAuthAppResponse::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& CreateOAuthAppResponse::client_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOAuthAppResponse.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOAuthAppResponse::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOAuthAppResponse.client_id)
}
inline std::string* CreateOAuthAppResponse::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOAuthAppResponse.client_id)
  return _s;
}
inline const std::string& CreateOAuthAppResponse::_internal_client_id() const {
  return client_id_.Get();
}
inline void CreateOAuthAppResponse::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOAuthAppResponse::_internal_mutable_client_id() {
  
  return client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOAuthAppResponse::release_client_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOAuthAppResponse.client_id)
  return client_id_.Release();
}
inline void CreateOAuthAppResponse::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault()) {
    client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOAuthAppResponse.client_id)
}

// string client_secret = 2 [json_name = "clientSecret"];
inline void CreateOAuthAppResponse::clear_client_secret() {
  client_secret_.ClearToEmpty();
}
inline const std::string& CreateOAuthAppResponse::client_secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOAuthAppResponse.client_secret)
  return _internal_client_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOAuthAppResponse::set_client_secret(ArgT0&& arg0, ArgT... args) {
 
 client_secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOAuthAppResponse.client_secret)
}
inline std::string* CreateOAuthAppResponse::mutable_client_secret() {
  std::string* _s = _internal_mutable_client_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOAuthAppResponse.client_secret)
  return _s;
}
inline const std::string& CreateOAuthAppResponse::_internal_client_secret() const {
  return client_secret_.Get();
}
inline void CreateOAuthAppResponse::_internal_set_client_secret(const std::string& value) {
  
  client_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOAuthAppResponse::_internal_mutable_client_secret() {
  
  return client_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOAuthAppResponse::release_client_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOAuthAppResponse.client_secret)
  return client_secret_.Release();
}
inline void CreateOAuthAppResponse::set_allocated_client_secret(std::string* client_secret) {
  if (client_secret != nullptr) {
    
  } else {
    
  }
  client_secret_.SetAllocated(client_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_secret_.IsDefault()) {
    client_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOAuthAppResponse.client_secret)
}

// -------------------------------------------------------------------

// ReadOAuthAppRequest

// string org_id = 1 [json_name = "orgId"];
inline void ReadOAuthAppRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& ReadOAuthAppRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ReadOAuthAppRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadOAuthAppRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ReadOAuthAppRequest.org_id)
}
inline std::string* ReadOAuthAppRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ReadOAuthAppRequest.org_id)
  return _s;
}
inline const std::string& ReadOAuthAppRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void ReadOAuthAppRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadOAuthAppRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadOAuthAppRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ReadOAuthAppRequest.org_id)
  return org_id_.Release();
}
inline void ReadOAuthAppRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ReadOAuthAppRequest.org_id)
}

// string client_id = 2 [json_name = "clientId"];
inline void ReadOAuthAppRequest::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& ReadOAuthAppRequest::client_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ReadOAuthAppRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadOAuthAppRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ReadOAuthAppRequest.client_id)
}
inline std::string* ReadOAuthAppRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ReadOAuthAppRequest.client_id)
  return _s;
}
inline const std::string& ReadOAuthAppRequest::_internal_client_id() const {
  return client_id_.Get();
}
inline void ReadOAuthAppRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadOAuthAppRequest::_internal_mutable_client_id() {
  
  return client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadOAuthAppRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ReadOAuthAppRequest.client_id)
  return client_id_.Release();
}
inline void ReadOAuthAppRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault()) {
    client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ReadOAuthAppRequest.client_id)
}

// -------------------------------------------------------------------

// ReadOAuthAppResponse

// string client_name = 1 [json_name = "clientName"];
inline void ReadOAuthAppResponse::clear_client_name() {
  client_name_.ClearToEmpty();
}
inline const std::string& ReadOAuthAppResponse::client_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ReadOAuthAppResponse.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadOAuthAppResponse::set_client_name(ArgT0&& arg0, ArgT... args) {
 
 client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ReadOAuthAppResponse.client_name)
}
inline std::string* ReadOAuthAppResponse::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ReadOAuthAppResponse.client_name)
  return _s;
}
inline const std::string& ReadOAuthAppResponse::_internal_client_name() const {
  return client_name_.Get();
}
inline void ReadOAuthAppResponse::_internal_set_client_name(const std::string& value) {
  
  client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadOAuthAppResponse::_internal_mutable_client_name() {
  
  return client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadOAuthAppResponse::release_client_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ReadOAuthAppResponse.client_name)
  return client_name_.Release();
}
inline void ReadOAuthAppResponse::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_name_.IsDefault()) {
    client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ReadOAuthAppResponse.client_name)
}

// string client_secret = 2 [json_name = "clientSecret"];
inline void ReadOAuthAppResponse::clear_client_secret() {
  client_secret_.ClearToEmpty();
}
inline const std::string& ReadOAuthAppResponse::client_secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ReadOAuthAppResponse.client_secret)
  return _internal_client_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadOAuthAppResponse::set_client_secret(ArgT0&& arg0, ArgT... args) {
 
 client_secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ReadOAuthAppResponse.client_secret)
}
inline std::string* ReadOAuthAppResponse::mutable_client_secret() {
  std::string* _s = _internal_mutable_client_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ReadOAuthAppResponse.client_secret)
  return _s;
}
inline const std::string& ReadOAuthAppResponse::_internal_client_secret() const {
  return client_secret_.Get();
}
inline void ReadOAuthAppResponse::_internal_set_client_secret(const std::string& value) {
  
  client_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadOAuthAppResponse::_internal_mutable_client_secret() {
  
  return client_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadOAuthAppResponse::release_client_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ReadOAuthAppResponse.client_secret)
  return client_secret_.Release();
}
inline void ReadOAuthAppResponse::set_allocated_client_secret(std::string* client_secret) {
  if (client_secret != nullptr) {
    
  } else {
    
  }
  client_secret_.SetAllocated(client_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_secret_.IsDefault()) {
    client_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ReadOAuthAppResponse.client_secret)
}

// .viam.app.v1.OAuthConfig oauth_config = 3 [json_name = "oauthConfig"];
inline bool ReadOAuthAppResponse::_internal_has_oauth_config() const {
  return this != internal_default_instance() && oauth_config_ != nullptr;
}
inline bool ReadOAuthAppResponse::has_oauth_config() const {
  return _internal_has_oauth_config();
}
inline void ReadOAuthAppResponse::clear_oauth_config() {
  if (GetArenaForAllocation() == nullptr && oauth_config_ != nullptr) {
    delete oauth_config_;
  }
  oauth_config_ = nullptr;
}
inline const ::viam::app::v1::OAuthConfig& ReadOAuthAppResponse::_internal_oauth_config() const {
  const ::viam::app::v1::OAuthConfig* p = oauth_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OAuthConfig&>(
      ::viam::app::v1::_OAuthConfig_default_instance_);
}
inline const ::viam::app::v1::OAuthConfig& ReadOAuthAppResponse::oauth_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ReadOAuthAppResponse.oauth_config)
  return _internal_oauth_config();
}
inline void ReadOAuthAppResponse::unsafe_arena_set_allocated_oauth_config(
    ::viam::app::v1::OAuthConfig* oauth_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oauth_config_);
  }
  oauth_config_ = oauth_config;
  if (oauth_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ReadOAuthAppResponse.oauth_config)
}
inline ::viam::app::v1::OAuthConfig* ReadOAuthAppResponse::release_oauth_config() {
  
  ::viam::app::v1::OAuthConfig* temp = oauth_config_;
  oauth_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OAuthConfig* ReadOAuthAppResponse::unsafe_arena_release_oauth_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ReadOAuthAppResponse.oauth_config)
  
  ::viam::app::v1::OAuthConfig* temp = oauth_config_;
  oauth_config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OAuthConfig* ReadOAuthAppResponse::_internal_mutable_oauth_config() {
  
  if (oauth_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OAuthConfig>(GetArenaForAllocation());
    oauth_config_ = p;
  }
  return oauth_config_;
}
inline ::viam::app::v1::OAuthConfig* ReadOAuthAppResponse::mutable_oauth_config() {
  ::viam::app::v1::OAuthConfig* _msg = _internal_mutable_oauth_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ReadOAuthAppResponse.oauth_config)
  return _msg;
}
inline void ReadOAuthAppResponse::set_allocated_oauth_config(::viam::app::v1::OAuthConfig* oauth_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete oauth_config_;
  }
  if (oauth_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oauth_config);
    if (message_arena != submessage_arena) {
      oauth_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oauth_config, submessage_arena);
    }
    
  } else {
    
  }
  oauth_config_ = oauth_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ReadOAuthAppResponse.oauth_config)
}

// -------------------------------------------------------------------

// UpdateOAuthAppRequest

// string org_id = 1 [json_name = "orgId"];
inline void UpdateOAuthAppRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& UpdateOAuthAppRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOAuthAppRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOAuthAppRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOAuthAppRequest.org_id)
}
inline std::string* UpdateOAuthAppRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOAuthAppRequest.org_id)
  return _s;
}
inline const std::string& UpdateOAuthAppRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void UpdateOAuthAppRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOAuthAppRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOAuthAppRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOAuthAppRequest.org_id)
  return org_id_.Release();
}
inline void UpdateOAuthAppRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOAuthAppRequest.org_id)
}

// string client_id = 2 [json_name = "clientId"];
inline void UpdateOAuthAppRequest::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& UpdateOAuthAppRequest::client_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOAuthAppRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOAuthAppRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOAuthAppRequest.client_id)
}
inline std::string* UpdateOAuthAppRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOAuthAppRequest.client_id)
  return _s;
}
inline const std::string& UpdateOAuthAppRequest::_internal_client_id() const {
  return client_id_.Get();
}
inline void UpdateOAuthAppRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOAuthAppRequest::_internal_mutable_client_id() {
  
  return client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOAuthAppRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOAuthAppRequest.client_id)
  return client_id_.Release();
}
inline void UpdateOAuthAppRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault()) {
    client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOAuthAppRequest.client_id)
}

// string client_name = 3 [json_name = "clientName"];
inline void UpdateOAuthAppRequest::clear_client_name() {
  client_name_.ClearToEmpty();
}
inline const std::string& UpdateOAuthAppRequest::client_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOAuthAppRequest.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOAuthAppRequest::set_client_name(ArgT0&& arg0, ArgT... args) {
 
 client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOAuthAppRequest.client_name)
}
inline std::string* UpdateOAuthAppRequest::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOAuthAppRequest.client_name)
  return _s;
}
inline const std::string& UpdateOAuthAppRequest::_internal_client_name() const {
  return client_name_.Get();
}
inline void UpdateOAuthAppRequest::_internal_set_client_name(const std::string& value) {
  
  client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOAuthAppRequest::_internal_mutable_client_name() {
  
  return client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOAuthAppRequest::release_client_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOAuthAppRequest.client_name)
  return client_name_.Release();
}
inline void UpdateOAuthAppRequest::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_name_.IsDefault()) {
    client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOAuthAppRequest.client_name)
}

// .viam.app.v1.OAuthConfig oauth_config = 4 [json_name = "oauthConfig"];
inline bool UpdateOAuthAppRequest::_internal_has_oauth_config() const {
  return this != internal_default_instance() && oauth_config_ != nullptr;
}
inline bool UpdateOAuthAppRequest::has_oauth_config() const {
  return _internal_has_oauth_config();
}
inline void UpdateOAuthAppRequest::clear_oauth_config() {
  if (GetArenaForAllocation() == nullptr && oauth_config_ != nullptr) {
    delete oauth_config_;
  }
  oauth_config_ = nullptr;
}
inline const ::viam::app::v1::OAuthConfig& UpdateOAuthAppRequest::_internal_oauth_config() const {
  const ::viam::app::v1::OAuthConfig* p = oauth_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OAuthConfig&>(
      ::viam::app::v1::_OAuthConfig_default_instance_);
}
inline const ::viam::app::v1::OAuthConfig& UpdateOAuthAppRequest::oauth_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOAuthAppRequest.oauth_config)
  return _internal_oauth_config();
}
inline void UpdateOAuthAppRequest::unsafe_arena_set_allocated_oauth_config(
    ::viam::app::v1::OAuthConfig* oauth_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oauth_config_);
  }
  oauth_config_ = oauth_config;
  if (oauth_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOAuthAppRequest.oauth_config)
}
inline ::viam::app::v1::OAuthConfig* UpdateOAuthAppRequest::release_oauth_config() {
  
  ::viam::app::v1::OAuthConfig* temp = oauth_config_;
  oauth_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OAuthConfig* UpdateOAuthAppRequest::unsafe_arena_release_oauth_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOAuthAppRequest.oauth_config)
  
  ::viam::app::v1::OAuthConfig* temp = oauth_config_;
  oauth_config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OAuthConfig* UpdateOAuthAppRequest::_internal_mutable_oauth_config() {
  
  if (oauth_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OAuthConfig>(GetArenaForAllocation());
    oauth_config_ = p;
  }
  return oauth_config_;
}
inline ::viam::app::v1::OAuthConfig* UpdateOAuthAppRequest::mutable_oauth_config() {
  ::viam::app::v1::OAuthConfig* _msg = _internal_mutable_oauth_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOAuthAppRequest.oauth_config)
  return _msg;
}
inline void UpdateOAuthAppRequest::set_allocated_oauth_config(::viam::app::v1::OAuthConfig* oauth_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete oauth_config_;
  }
  if (oauth_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oauth_config);
    if (message_arena != submessage_arena) {
      oauth_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oauth_config, submessage_arena);
    }
    
  } else {
    
  }
  oauth_config_ = oauth_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOAuthAppRequest.oauth_config)
}

// -------------------------------------------------------------------

// UpdateOAuthAppResponse

// -------------------------------------------------------------------

// DeleteOAuthAppRequest

// string org_id = 1 [json_name = "orgId"];
inline void DeleteOAuthAppRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& DeleteOAuthAppRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOAuthAppRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOAuthAppRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOAuthAppRequest.org_id)
}
inline std::string* DeleteOAuthAppRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOAuthAppRequest.org_id)
  return _s;
}
inline const std::string& DeleteOAuthAppRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void DeleteOAuthAppRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOAuthAppRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOAuthAppRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOAuthAppRequest.org_id)
  return org_id_.Release();
}
inline void DeleteOAuthAppRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOAuthAppRequest.org_id)
}

// string client_id = 2 [json_name = "clientId"];
inline void DeleteOAuthAppRequest::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& DeleteOAuthAppRequest::client_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOAuthAppRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOAuthAppRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOAuthAppRequest.client_id)
}
inline std::string* DeleteOAuthAppRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOAuthAppRequest.client_id)
  return _s;
}
inline const std::string& DeleteOAuthAppRequest::_internal_client_id() const {
  return client_id_.Get();
}
inline void DeleteOAuthAppRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOAuthAppRequest::_internal_mutable_client_id() {
  
  return client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOAuthAppRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOAuthAppRequest.client_id)
  return client_id_.Release();
}
inline void DeleteOAuthAppRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault()) {
    client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOAuthAppRequest.client_id)
}

// -------------------------------------------------------------------

// DeleteOAuthAppResponse

// -------------------------------------------------------------------

// ListOAuthAppsRequest

// string org_id = 1 [json_name = "orgId"];
inline void ListOAuthAppsRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& ListOAuthAppsRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOAuthAppsRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOAuthAppsRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOAuthAppsRequest.org_id)
}
inline std::string* ListOAuthAppsRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOAuthAppsRequest.org_id)
  return _s;
}
inline const std::string& ListOAuthAppsRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void ListOAuthAppsRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOAuthAppsRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOAuthAppsRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListOAuthAppsRequest.org_id)
  return org_id_.Release();
}
inline void ListOAuthAppsRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListOAuthAppsRequest.org_id)
}

// -------------------------------------------------------------------

// ListOAuthAppsResponse

// repeated string client_ids = 1 [json_name = "clientIds"];
inline int ListOAuthAppsResponse::_internal_client_ids_size() const {
  return client_ids_.size();
}
inline int ListOAuthAppsResponse::client_ids_size() const {
  return _internal_client_ids_size();
}
inline void ListOAuthAppsResponse::clear_client_ids() {
  client_ids_.Clear();
}
inline std::string* ListOAuthAppsResponse::add_client_ids() {
  std::string* _s = _internal_add_client_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListOAuthAppsResponse.client_ids)
  return _s;
}
inline const std::string& ListOAuthAppsResponse::_internal_client_ids(int index) const {
  return client_ids_.Get(index);
}
inline const std::string& ListOAuthAppsResponse::client_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOAuthAppsResponse.client_ids)
  return _internal_client_ids(index);
}
inline std::string* ListOAuthAppsResponse::mutable_client_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOAuthAppsResponse.client_ids)
  return client_ids_.Mutable(index);
}
inline void ListOAuthAppsResponse::set_client_ids(int index, const std::string& value) {
  client_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline void ListOAuthAppsResponse::set_client_ids(int index, std::string&& value) {
  client_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline void ListOAuthAppsResponse::set_client_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline void ListOAuthAppsResponse::set_client_ids(int index, const char* value, size_t size) {
  client_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline std::string* ListOAuthAppsResponse::_internal_add_client_ids() {
  return client_ids_.Add();
}
inline void ListOAuthAppsResponse::add_client_ids(const std::string& value) {
  client_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline void ListOAuthAppsResponse::add_client_ids(std::string&& value) {
  client_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline void ListOAuthAppsResponse::add_client_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline void ListOAuthAppsResponse::add_client_ids(const char* value, size_t size) {
  client_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListOAuthAppsResponse.client_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListOAuthAppsResponse::client_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOAuthAppsResponse.client_ids)
  return client_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListOAuthAppsResponse::mutable_client_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOAuthAppsResponse.client_ids)
  return &client_ids_;
}

// -------------------------------------------------------------------

// OAuthConfig

// .viam.app.v1.ClientAuthentication client_authentication = 1 [json_name = "clientAuthentication"];
inline void OAuthConfig::clear_client_authentication() {
  client_authentication_ = 0;
}
inline ::viam::app::v1::ClientAuthentication OAuthConfig::_internal_client_authentication() const {
  return static_cast< ::viam::app::v1::ClientAuthentication >(client_authentication_);
}
inline ::viam::app::v1::ClientAuthentication OAuthConfig::client_authentication() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OAuthConfig.client_authentication)
  return _internal_client_authentication();
}
inline void OAuthConfig::_internal_set_client_authentication(::viam::app::v1::ClientAuthentication value) {
  
  client_authentication_ = value;
}
inline void OAuthConfig::set_client_authentication(::viam::app::v1::ClientAuthentication value) {
  _internal_set_client_authentication(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.client_authentication)
}

// .viam.app.v1.PKCE pkce = 2 [json_name = "pkce"];
inline void OAuthConfig::clear_pkce() {
  pkce_ = 0;
}
inline ::viam::app::v1::PKCE OAuthConfig::_internal_pkce() const {
  return static_cast< ::viam::app::v1::PKCE >(pkce_);
}
inline ::viam::app::v1::PKCE OAuthConfig::pkce() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OAuthConfig.pkce)
  return _internal_pkce();
}
inline void OAuthConfig::_internal_set_pkce(::viam::app::v1::PKCE value) {
  
  pkce_ = value;
}
inline void OAuthConfig::set_pkce(::viam::app::v1::PKCE value) {
  _internal_set_pkce(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.pkce)
}

// .viam.app.v1.URLValidation url_validation = 3 [json_name = "urlValidation"];
inline void OAuthConfig::clear_url_validation() {
  url_validation_ = 0;
}
inline ::viam::app::v1::URLValidation OAuthConfig::_internal_url_validation() const {
  return static_cast< ::viam::app::v1::URLValidation >(url_validation_);
}
inline ::viam::app::v1::URLValidation OAuthConfig::url_validation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OAuthConfig.url_validation)
  return _internal_url_validation();
}
inline void OAuthConfig::_internal_set_url_validation(::viam::app::v1::URLValidation value) {
  
  url_validation_ = value;
}
inline void OAuthConfig::set_url_validation(::viam::app::v1::URLValidation value) {
  _internal_set_url_validation(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.url_validation)
}

// repeated string origin_uris = 4 [json_name = "originUris"];
inline int OAuthConfig::_internal_origin_uris_size() const {
  return origin_uris_.size();
}
inline int OAuthConfig::origin_uris_size() const {
  return _internal_origin_uris_size();
}
inline void OAuthConfig::clear_origin_uris() {
  origin_uris_.Clear();
}
inline std::string* OAuthConfig::add_origin_uris() {
  std::string* _s = _internal_add_origin_uris();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.OAuthConfig.origin_uris)
  return _s;
}
inline const std::string& OAuthConfig::_internal_origin_uris(int index) const {
  return origin_uris_.Get(index);
}
inline const std::string& OAuthConfig::origin_uris(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OAuthConfig.origin_uris)
  return _internal_origin_uris(index);
}
inline std::string* OAuthConfig::mutable_origin_uris(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OAuthConfig.origin_uris)
  return origin_uris_.Mutable(index);
}
inline void OAuthConfig::set_origin_uris(int index, const std::string& value) {
  origin_uris_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.origin_uris)
}
inline void OAuthConfig::set_origin_uris(int index, std::string&& value) {
  origin_uris_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.origin_uris)
}
inline void OAuthConfig::set_origin_uris(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  origin_uris_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.OAuthConfig.origin_uris)
}
inline void OAuthConfig::set_origin_uris(int index, const char* value, size_t size) {
  origin_uris_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.OAuthConfig.origin_uris)
}
inline std::string* OAuthConfig::_internal_add_origin_uris() {
  return origin_uris_.Add();
}
inline void OAuthConfig::add_origin_uris(const std::string& value) {
  origin_uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.OAuthConfig.origin_uris)
}
inline void OAuthConfig::add_origin_uris(std::string&& value) {
  origin_uris_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.OAuthConfig.origin_uris)
}
inline void OAuthConfig::add_origin_uris(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  origin_uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.OAuthConfig.origin_uris)
}
inline void OAuthConfig::add_origin_uris(const char* value, size_t size) {
  origin_uris_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.OAuthConfig.origin_uris)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OAuthConfig::origin_uris() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.OAuthConfig.origin_uris)
  return origin_uris_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OAuthConfig::mutable_origin_uris() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.OAuthConfig.origin_uris)
  return &origin_uris_;
}

// repeated string redirect_uris = 5 [json_name = "redirectUris"];
inline int OAuthConfig::_internal_redirect_uris_size() const {
  return redirect_uris_.size();
}
inline int OAuthConfig::redirect_uris_size() const {
  return _internal_redirect_uris_size();
}
inline void OAuthConfig::clear_redirect_uris() {
  redirect_uris_.Clear();
}
inline std::string* OAuthConfig::add_redirect_uris() {
  std::string* _s = _internal_add_redirect_uris();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.OAuthConfig.redirect_uris)
  return _s;
}
inline const std::string& OAuthConfig::_internal_redirect_uris(int index) const {
  return redirect_uris_.Get(index);
}
inline const std::string& OAuthConfig::redirect_uris(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OAuthConfig.redirect_uris)
  return _internal_redirect_uris(index);
}
inline std::string* OAuthConfig::mutable_redirect_uris(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OAuthConfig.redirect_uris)
  return redirect_uris_.Mutable(index);
}
inline void OAuthConfig::set_redirect_uris(int index, const std::string& value) {
  redirect_uris_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.redirect_uris)
}
inline void OAuthConfig::set_redirect_uris(int index, std::string&& value) {
  redirect_uris_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.redirect_uris)
}
inline void OAuthConfig::set_redirect_uris(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  redirect_uris_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.OAuthConfig.redirect_uris)
}
inline void OAuthConfig::set_redirect_uris(int index, const char* value, size_t size) {
  redirect_uris_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.OAuthConfig.redirect_uris)
}
inline std::string* OAuthConfig::_internal_add_redirect_uris() {
  return redirect_uris_.Add();
}
inline void OAuthConfig::add_redirect_uris(const std::string& value) {
  redirect_uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.OAuthConfig.redirect_uris)
}
inline void OAuthConfig::add_redirect_uris(std::string&& value) {
  redirect_uris_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.OAuthConfig.redirect_uris)
}
inline void OAuthConfig::add_redirect_uris(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  redirect_uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.OAuthConfig.redirect_uris)
}
inline void OAuthConfig::add_redirect_uris(const char* value, size_t size) {
  redirect_uris_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.OAuthConfig.redirect_uris)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OAuthConfig::redirect_uris() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.OAuthConfig.redirect_uris)
  return redirect_uris_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OAuthConfig::mutable_redirect_uris() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.OAuthConfig.redirect_uris)
  return &redirect_uris_;
}

// string logout_uri = 6 [json_name = "logoutUri"];
inline void OAuthConfig::clear_logout_uri() {
  logout_uri_.ClearToEmpty();
}
inline const std::string& OAuthConfig::logout_uri() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OAuthConfig.logout_uri)
  return _internal_logout_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OAuthConfig::set_logout_uri(ArgT0&& arg0, ArgT... args) {
 
 logout_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.logout_uri)
}
inline std::string* OAuthConfig::mutable_logout_uri() {
  std::string* _s = _internal_mutable_logout_uri();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OAuthConfig.logout_uri)
  return _s;
}
inline const std::string& OAuthConfig::_internal_logout_uri() const {
  return logout_uri_.Get();
}
inline void OAuthConfig::_internal_set_logout_uri(const std::string& value) {
  
  logout_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* OAuthConfig::_internal_mutable_logout_uri() {
  
  return logout_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* OAuthConfig::release_logout_uri() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OAuthConfig.logout_uri)
  return logout_uri_.Release();
}
inline void OAuthConfig::set_allocated_logout_uri(std::string* logout_uri) {
  if (logout_uri != nullptr) {
    
  } else {
    
  }
  logout_uri_.SetAllocated(logout_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logout_uri_.IsDefault()) {
    logout_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OAuthConfig.logout_uri)
}

// repeated .viam.app.v1.EnabledGrant enabled_grants = 7 [json_name = "enabledGrants"];
inline int OAuthConfig::_internal_enabled_grants_size() const {
  return enabled_grants_.size();
}
inline int OAuthConfig::enabled_grants_size() const {
  return _internal_enabled_grants_size();
}
inline void OAuthConfig::clear_enabled_grants() {
  enabled_grants_.Clear();
}
inline ::viam::app::v1::EnabledGrant OAuthConfig::_internal_enabled_grants(int index) const {
  return static_cast< ::viam::app::v1::EnabledGrant >(enabled_grants_.Get(index));
}
inline ::viam::app::v1::EnabledGrant OAuthConfig::enabled_grants(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OAuthConfig.enabled_grants)
  return _internal_enabled_grants(index);
}
inline void OAuthConfig::set_enabled_grants(int index, ::viam::app::v1::EnabledGrant value) {
  enabled_grants_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OAuthConfig.enabled_grants)
}
inline void OAuthConfig::_internal_add_enabled_grants(::viam::app::v1::EnabledGrant value) {
  enabled_grants_.Add(value);
}
inline void OAuthConfig::add_enabled_grants(::viam::app::v1::EnabledGrant value) {
  _internal_add_enabled_grants(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.OAuthConfig.enabled_grants)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
OAuthConfig::enabled_grants() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.OAuthConfig.enabled_grants)
  return enabled_grants_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OAuthConfig::_internal_mutable_enabled_grants() {
  return &enabled_grants_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OAuthConfig::mutable_enabled_grants() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.OAuthConfig.enabled_grants)
  return _internal_mutable_enabled_grants();
}

// -------------------------------------------------------------------

// GetAppBrandingRequest

// string public_namespace = 1 [json_name = "publicNamespace"];
inline void GetAppBrandingRequest::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& GetAppBrandingRequest::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppBrandingRequest.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppBrandingRequest::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppBrandingRequest.public_namespace)
}
inline std::string* GetAppBrandingRequest::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppBrandingRequest.public_namespace)
  return _s;
}
inline const std::string& GetAppBrandingRequest::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void GetAppBrandingRequest::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppBrandingRequest::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAppBrandingRequest::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetAppBrandingRequest.public_namespace)
  return public_namespace_.Release();
}
inline void GetAppBrandingRequest::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetAppBrandingRequest.public_namespace)
}

// string name = 2 [json_name = "name"];
inline void GetAppBrandingRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetAppBrandingRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppBrandingRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppBrandingRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppBrandingRequest.name)
}
inline std::string* GetAppBrandingRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppBrandingRequest.name)
  return _s;
}
inline const std::string& GetAppBrandingRequest::_internal_name() const {
  return name_.Get();
}
inline void GetAppBrandingRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppBrandingRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAppBrandingRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetAppBrandingRequest.name)
  return name_.Release();
}
inline void GetAppBrandingRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetAppBrandingRequest.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TextOverrides

// map<string, string> fields = 1 [json_name = "fields"];
inline int TextOverrides::_internal_fields_size() const {
  return fields_.size();
}
inline int TextOverrides::fields_size() const {
  return _internal_fields_size();
}
inline void TextOverrides::clear_fields() {
  fields_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TextOverrides::_internal_fields() const {
  return fields_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TextOverrides::fields() const {
  // @@protoc_insertion_point(field_map:viam.app.v1.TextOverrides.fields)
  return _internal_fields();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TextOverrides::_internal_mutable_fields() {
  return fields_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TextOverrides::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.v1.TextOverrides.fields)
  return _internal_mutable_fields();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetAppBrandingResponse

// optional string logo_path = 1 [json_name = "logoPath"];
inline bool GetAppBrandingResponse::_internal_has_logo_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetAppBrandingResponse::has_logo_path() const {
  return _internal_has_logo_path();
}
inline void GetAppBrandingResponse::clear_logo_path() {
  logo_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetAppBrandingResponse::logo_path() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppBrandingResponse.logo_path)
  return _internal_logo_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAppBrandingResponse::set_logo_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 logo_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppBrandingResponse.logo_path)
}
inline std::string* GetAppBrandingResponse::mutable_logo_path() {
  std::string* _s = _internal_mutable_logo_path();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppBrandingResponse.logo_path)
  return _s;
}
inline const std::string& GetAppBrandingResponse::_internal_logo_path() const {
  return logo_path_.Get();
}
inline void GetAppBrandingResponse::_internal_set_logo_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  logo_path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppBrandingResponse::_internal_mutable_logo_path() {
  _has_bits_[0] |= 0x00000001u;
  return logo_path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAppBrandingResponse::release_logo_path() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetAppBrandingResponse.logo_path)
  if (!_internal_has_logo_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = logo_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logo_path_.IsDefault()) {
    logo_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetAppBrandingResponse::set_allocated_logo_path(std::string* logo_path) {
  if (logo_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  logo_path_.SetAllocated(logo_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (logo_path_.IsDefault()) {
    logo_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetAppBrandingResponse.logo_path)
}

// map<string, .viam.app.v1.TextOverrides> text_customizations = 2 [json_name = "textCustomizations"];
inline int GetAppBrandingResponse::_internal_text_customizations_size() const {
  return text_customizations_.size();
}
inline int GetAppBrandingResponse::text_customizations_size() const {
  return _internal_text_customizations_size();
}
inline void GetAppBrandingResponse::clear_text_customizations() {
  text_customizations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >&
GetAppBrandingResponse::_internal_text_customizations() const {
  return text_customizations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >&
GetAppBrandingResponse::text_customizations() const {
  // @@protoc_insertion_point(field_map:viam.app.v1.GetAppBrandingResponse.text_customizations)
  return _internal_text_customizations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >*
GetAppBrandingResponse::_internal_mutable_text_customizations() {
  return text_customizations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::viam::app::v1::TextOverrides >*
GetAppBrandingResponse::mutable_text_customizations() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.v1.GetAppBrandingResponse.text_customizations)
  return _internal_mutable_text_customizations();
}

// repeated string fragment_ids = 3 [json_name = "fragmentIds"];
inline int GetAppBrandingResponse::_internal_fragment_ids_size() const {
  return fragment_ids_.size();
}
inline int GetAppBrandingResponse::fragment_ids_size() const {
  return _internal_fragment_ids_size();
}
inline void GetAppBrandingResponse::clear_fragment_ids() {
  fragment_ids_.Clear();
}
inline std::string* GetAppBrandingResponse::add_fragment_ids() {
  std::string* _s = _internal_add_fragment_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.GetAppBrandingResponse.fragment_ids)
  return _s;
}
inline const std::string& GetAppBrandingResponse::_internal_fragment_ids(int index) const {
  return fragment_ids_.Get(index);
}
inline const std::string& GetAppBrandingResponse::fragment_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetAppBrandingResponse.fragment_ids)
  return _internal_fragment_ids(index);
}
inline std::string* GetAppBrandingResponse::mutable_fragment_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetAppBrandingResponse.fragment_ids)
  return fragment_ids_.Mutable(index);
}
inline void GetAppBrandingResponse::set_fragment_ids(int index, const std::string& value) {
  fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline void GetAppBrandingResponse::set_fragment_ids(int index, std::string&& value) {
  fragment_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline void GetAppBrandingResponse::set_fragment_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fragment_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline void GetAppBrandingResponse::set_fragment_ids(int index, const char* value, size_t size) {
  fragment_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline std::string* GetAppBrandingResponse::_internal_add_fragment_ids() {
  return fragment_ids_.Add();
}
inline void GetAppBrandingResponse::add_fragment_ids(const std::string& value) {
  fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline void GetAppBrandingResponse::add_fragment_ids(std::string&& value) {
  fragment_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline void GetAppBrandingResponse::add_fragment_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fragment_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline void GetAppBrandingResponse::add_fragment_ids(const char* value, size_t size) {
  fragment_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.GetAppBrandingResponse.fragment_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetAppBrandingResponse::fragment_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetAppBrandingResponse.fragment_ids)
  return fragment_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetAppBrandingResponse::mutable_fragment_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetAppBrandingResponse.fragment_ids)
  return &fragment_ids_;
}

// -------------------------------------------------------------------

// AppCustomizations

// .viam.app.v1.MachinePickerCustomizations machine_picker = 1 [json_name = "machinePicker"];
inline bool AppCustomizations::_internal_has_machine_picker() const {
  return this != internal_default_instance() && machine_picker_ != nullptr;
}
inline bool AppCustomizations::has_machine_picker() const {
  return _internal_has_machine_picker();
}
inline void AppCustomizations::clear_machine_picker() {
  if (GetArenaForAllocation() == nullptr && machine_picker_ != nullptr) {
    delete machine_picker_;
  }
  machine_picker_ = nullptr;
}
inline const ::viam::app::v1::MachinePickerCustomizations& AppCustomizations::_internal_machine_picker() const {
  const ::viam::app::v1::MachinePickerCustomizations* p = machine_picker_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::MachinePickerCustomizations&>(
      ::viam::app::v1::_MachinePickerCustomizations_default_instance_);
}
inline const ::viam::app::v1::MachinePickerCustomizations& AppCustomizations::machine_picker() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AppCustomizations.machine_picker)
  return _internal_machine_picker();
}
inline void AppCustomizations::unsafe_arena_set_allocated_machine_picker(
    ::viam::app::v1::MachinePickerCustomizations* machine_picker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(machine_picker_);
  }
  machine_picker_ = machine_picker;
  if (machine_picker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.AppCustomizations.machine_picker)
}
inline ::viam::app::v1::MachinePickerCustomizations* AppCustomizations::release_machine_picker() {
  
  ::viam::app::v1::MachinePickerCustomizations* temp = machine_picker_;
  machine_picker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::MachinePickerCustomizations* AppCustomizations::unsafe_arena_release_machine_picker() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AppCustomizations.machine_picker)
  
  ::viam::app::v1::MachinePickerCustomizations* temp = machine_picker_;
  machine_picker_ = nullptr;
  return temp;
}
inline ::viam::app::v1::MachinePickerCustomizations* AppCustomizations::_internal_mutable_machine_picker() {
  
  if (machine_picker_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::MachinePickerCustomizations>(GetArenaForAllocation());
    machine_picker_ = p;
  }
  return machine_picker_;
}
inline ::viam::app::v1::MachinePickerCustomizations* AppCustomizations::mutable_machine_picker() {
  ::viam::app::v1::MachinePickerCustomizations* _msg = _internal_mutable_machine_picker();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AppCustomizations.machine_picker)
  return _msg;
}
inline void AppCustomizations::set_allocated_machine_picker(::viam::app::v1::MachinePickerCustomizations* machine_picker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete machine_picker_;
  }
  if (machine_picker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(machine_picker);
    if (message_arena != submessage_arena) {
      machine_picker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, machine_picker, submessage_arena);
    }
    
  } else {
    
  }
  machine_picker_ = machine_picker;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AppCustomizations.machine_picker)
}

// -------------------------------------------------------------------

// MachinePickerCustomizations

// optional string heading = 1 [json_name = "heading"];
inline bool MachinePickerCustomizations::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MachinePickerCustomizations::has_heading() const {
  return _internal_has_heading();
}
inline void MachinePickerCustomizations::clear_heading() {
  heading_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MachinePickerCustomizations::heading() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MachinePickerCustomizations.heading)
  return _internal_heading();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MachinePickerCustomizations::set_heading(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 heading_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MachinePickerCustomizations.heading)
}
inline std::string* MachinePickerCustomizations::mutable_heading() {
  std::string* _s = _internal_mutable_heading();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MachinePickerCustomizations.heading)
  return _s;
}
inline const std::string& MachinePickerCustomizations::_internal_heading() const {
  return heading_.Get();
}
inline void MachinePickerCustomizations::_internal_set_heading(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  heading_.Set(value, GetArenaForAllocation());
}
inline std::string* MachinePickerCustomizations::_internal_mutable_heading() {
  _has_bits_[0] |= 0x00000001u;
  return heading_.Mutable(GetArenaForAllocation());
}
inline std::string* MachinePickerCustomizations::release_heading() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MachinePickerCustomizations.heading)
  if (!_internal_has_heading()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = heading_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (heading_.IsDefault()) {
    heading_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MachinePickerCustomizations::set_allocated_heading(std::string* heading) {
  if (heading != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  heading_.SetAllocated(heading, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (heading_.IsDefault()) {
    heading_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MachinePickerCustomizations.heading)
}

// optional string subheading = 2 [json_name = "subheading"];
inline bool MachinePickerCustomizations::_internal_has_subheading() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MachinePickerCustomizations::has_subheading() const {
  return _internal_has_subheading();
}
inline void MachinePickerCustomizations::clear_subheading() {
  subheading_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MachinePickerCustomizations::subheading() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MachinePickerCustomizations.subheading)
  return _internal_subheading();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MachinePickerCustomizations::set_subheading(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 subheading_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MachinePickerCustomizations.subheading)
}
inline std::string* MachinePickerCustomizations::mutable_subheading() {
  std::string* _s = _internal_mutable_subheading();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MachinePickerCustomizations.subheading)
  return _s;
}
inline const std::string& MachinePickerCustomizations::_internal_subheading() const {
  return subheading_.Get();
}
inline void MachinePickerCustomizations::_internal_set_subheading(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  subheading_.Set(value, GetArenaForAllocation());
}
inline std::string* MachinePickerCustomizations::_internal_mutable_subheading() {
  _has_bits_[0] |= 0x00000002u;
  return subheading_.Mutable(GetArenaForAllocation());
}
inline std::string* MachinePickerCustomizations::release_subheading() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MachinePickerCustomizations.subheading)
  if (!_internal_has_subheading()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = subheading_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subheading_.IsDefault()) {
    subheading_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MachinePickerCustomizations::set_allocated_subheading(std::string* subheading) {
  if (subheading != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subheading_.SetAllocated(subheading, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subheading_.IsDefault()) {
    subheading_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MachinePickerCustomizations.subheading)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::v1::SharedSecret_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::SharedSecret_State>() {
  return ::viam::app::v1::SharedSecret_State_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::OnlineState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::OnlineState>() {
  return ::viam::app::v1::OnlineState_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::AuthenticationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::AuthenticationType>() {
  return ::viam::app::v1::AuthenticationType_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::FragmentVisibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::FragmentVisibility>() {
  return ::viam::app::v1::FragmentVisibility_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::FragmentErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::FragmentErrorType>() {
  return ::viam::app::v1::FragmentErrorType_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::ModuleSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::ModuleSourceType>() {
  return ::viam::app::v1::ModuleSourceType_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::ModuleLanguage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::ModuleLanguage>() {
  return ::viam::app::v1::ModuleLanguage_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::RegistryItemStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::RegistryItemStatus>() {
  return ::viam::app::v1::RegistryItemStatus_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::Visibility>() {
  return ::viam::app::v1::Visibility_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::AppType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::AppType>() {
  return ::viam::app::v1::AppType_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::ClientAuthentication> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::ClientAuthentication>() {
  return ::viam::app::v1::ClientAuthentication_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::PKCE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::PKCE>() {
  return ::viam::app::v1::PKCE_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::URLValidation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::URLValidation>() {
  return ::viam::app::v1::URLValidation_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::EnabledGrant> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::EnabledGrant>() {
  return ::viam::app::v1::EnabledGrant_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto
