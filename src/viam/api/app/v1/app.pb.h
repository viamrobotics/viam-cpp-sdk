// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/v1/app.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "app/packages/v1/packages.pb.h"
#include "common/v1/common.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fv1_2fapp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fv1_2fapp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fv1_2fapp_2eproto;
namespace viam {
namespace app {
namespace v1 {
class APIKey;
struct APIKeyDefaultTypeInternal;
extern APIKeyDefaultTypeInternal _APIKey_default_instance_;
class APIKeyWithAuthorizations;
struct APIKeyWithAuthorizationsDefaultTypeInternal;
extern APIKeyWithAuthorizationsDefaultTypeInternal _APIKeyWithAuthorizations_default_instance_;
class AddRoleRequest;
struct AddRoleRequestDefaultTypeInternal;
extern AddRoleRequestDefaultTypeInternal _AddRoleRequest_default_instance_;
class AddRoleResponse;
struct AddRoleResponseDefaultTypeInternal;
extern AddRoleResponseDefaultTypeInternal _AddRoleResponse_default_instance_;
class Authorization;
struct AuthorizationDefaultTypeInternal;
extern AuthorizationDefaultTypeInternal _Authorization_default_instance_;
class AuthorizationDetails;
struct AuthorizationDetailsDefaultTypeInternal;
extern AuthorizationDetailsDefaultTypeInternal _AuthorizationDetails_default_instance_;
class AuthorizedPermissions;
struct AuthorizedPermissionsDefaultTypeInternal;
extern AuthorizedPermissionsDefaultTypeInternal _AuthorizedPermissions_default_instance_;
class ChangeRoleRequest;
struct ChangeRoleRequestDefaultTypeInternal;
extern ChangeRoleRequestDefaultTypeInternal _ChangeRoleRequest_default_instance_;
class ChangeRoleResponse;
struct ChangeRoleResponseDefaultTypeInternal;
extern ChangeRoleResponseDefaultTypeInternal _ChangeRoleResponse_default_instance_;
class CheckPermissionsRequest;
struct CheckPermissionsRequestDefaultTypeInternal;
extern CheckPermissionsRequestDefaultTypeInternal _CheckPermissionsRequest_default_instance_;
class CheckPermissionsResponse;
struct CheckPermissionsResponseDefaultTypeInternal;
extern CheckPermissionsResponseDefaultTypeInternal _CheckPermissionsResponse_default_instance_;
class CreateFragmentRequest;
struct CreateFragmentRequestDefaultTypeInternal;
extern CreateFragmentRequestDefaultTypeInternal _CreateFragmentRequest_default_instance_;
class CreateFragmentResponse;
struct CreateFragmentResponseDefaultTypeInternal;
extern CreateFragmentResponseDefaultTypeInternal _CreateFragmentResponse_default_instance_;
class CreateKeyFromExistingKeyAuthorizationsRequest;
struct CreateKeyFromExistingKeyAuthorizationsRequestDefaultTypeInternal;
extern CreateKeyFromExistingKeyAuthorizationsRequestDefaultTypeInternal _CreateKeyFromExistingKeyAuthorizationsRequest_default_instance_;
class CreateKeyFromExistingKeyAuthorizationsResponse;
struct CreateKeyFromExistingKeyAuthorizationsResponseDefaultTypeInternal;
extern CreateKeyFromExistingKeyAuthorizationsResponseDefaultTypeInternal _CreateKeyFromExistingKeyAuthorizationsResponse_default_instance_;
class CreateKeyRequest;
struct CreateKeyRequestDefaultTypeInternal;
extern CreateKeyRequestDefaultTypeInternal _CreateKeyRequest_default_instance_;
class CreateKeyResponse;
struct CreateKeyResponseDefaultTypeInternal;
extern CreateKeyResponseDefaultTypeInternal _CreateKeyResponse_default_instance_;
class CreateLocationRequest;
struct CreateLocationRequestDefaultTypeInternal;
extern CreateLocationRequestDefaultTypeInternal _CreateLocationRequest_default_instance_;
class CreateLocationResponse;
struct CreateLocationResponseDefaultTypeInternal;
extern CreateLocationResponseDefaultTypeInternal _CreateLocationResponse_default_instance_;
class CreateLocationSecretRequest;
struct CreateLocationSecretRequestDefaultTypeInternal;
extern CreateLocationSecretRequestDefaultTypeInternal _CreateLocationSecretRequest_default_instance_;
class CreateLocationSecretResponse;
struct CreateLocationSecretResponseDefaultTypeInternal;
extern CreateLocationSecretResponseDefaultTypeInternal _CreateLocationSecretResponse_default_instance_;
class CreateModuleRequest;
struct CreateModuleRequestDefaultTypeInternal;
extern CreateModuleRequestDefaultTypeInternal _CreateModuleRequest_default_instance_;
class CreateModuleResponse;
struct CreateModuleResponseDefaultTypeInternal;
extern CreateModuleResponseDefaultTypeInternal _CreateModuleResponse_default_instance_;
class CreateOrganizationInviteRequest;
struct CreateOrganizationInviteRequestDefaultTypeInternal;
extern CreateOrganizationInviteRequestDefaultTypeInternal _CreateOrganizationInviteRequest_default_instance_;
class CreateOrganizationInviteResponse;
struct CreateOrganizationInviteResponseDefaultTypeInternal;
extern CreateOrganizationInviteResponseDefaultTypeInternal _CreateOrganizationInviteResponse_default_instance_;
class CreateOrganizationRequest;
struct CreateOrganizationRequestDefaultTypeInternal;
extern CreateOrganizationRequestDefaultTypeInternal _CreateOrganizationRequest_default_instance_;
class CreateOrganizationResponse;
struct CreateOrganizationResponseDefaultTypeInternal;
extern CreateOrganizationResponseDefaultTypeInternal _CreateOrganizationResponse_default_instance_;
class CreateRegistryItemRequest;
struct CreateRegistryItemRequestDefaultTypeInternal;
extern CreateRegistryItemRequestDefaultTypeInternal _CreateRegistryItemRequest_default_instance_;
class CreateRegistryItemResponse;
struct CreateRegistryItemResponseDefaultTypeInternal;
extern CreateRegistryItemResponseDefaultTypeInternal _CreateRegistryItemResponse_default_instance_;
class CreateRobotPartSecretRequest;
struct CreateRobotPartSecretRequestDefaultTypeInternal;
extern CreateRobotPartSecretRequestDefaultTypeInternal _CreateRobotPartSecretRequest_default_instance_;
class CreateRobotPartSecretResponse;
struct CreateRobotPartSecretResponseDefaultTypeInternal;
extern CreateRobotPartSecretResponseDefaultTypeInternal _CreateRobotPartSecretResponse_default_instance_;
class DeleteFragmentRequest;
struct DeleteFragmentRequestDefaultTypeInternal;
extern DeleteFragmentRequestDefaultTypeInternal _DeleteFragmentRequest_default_instance_;
class DeleteFragmentResponse;
struct DeleteFragmentResponseDefaultTypeInternal;
extern DeleteFragmentResponseDefaultTypeInternal _DeleteFragmentResponse_default_instance_;
class DeleteKeyRequest;
struct DeleteKeyRequestDefaultTypeInternal;
extern DeleteKeyRequestDefaultTypeInternal _DeleteKeyRequest_default_instance_;
class DeleteKeyResponse;
struct DeleteKeyResponseDefaultTypeInternal;
extern DeleteKeyResponseDefaultTypeInternal _DeleteKeyResponse_default_instance_;
class DeleteLocationRequest;
struct DeleteLocationRequestDefaultTypeInternal;
extern DeleteLocationRequestDefaultTypeInternal _DeleteLocationRequest_default_instance_;
class DeleteLocationResponse;
struct DeleteLocationResponseDefaultTypeInternal;
extern DeleteLocationResponseDefaultTypeInternal _DeleteLocationResponse_default_instance_;
class DeleteLocationSecretRequest;
struct DeleteLocationSecretRequestDefaultTypeInternal;
extern DeleteLocationSecretRequestDefaultTypeInternal _DeleteLocationSecretRequest_default_instance_;
class DeleteLocationSecretResponse;
struct DeleteLocationSecretResponseDefaultTypeInternal;
extern DeleteLocationSecretResponseDefaultTypeInternal _DeleteLocationSecretResponse_default_instance_;
class DeleteOrganizationInviteRequest;
struct DeleteOrganizationInviteRequestDefaultTypeInternal;
extern DeleteOrganizationInviteRequestDefaultTypeInternal _DeleteOrganizationInviteRequest_default_instance_;
class DeleteOrganizationInviteResponse;
struct DeleteOrganizationInviteResponseDefaultTypeInternal;
extern DeleteOrganizationInviteResponseDefaultTypeInternal _DeleteOrganizationInviteResponse_default_instance_;
class DeleteOrganizationMemberRequest;
struct DeleteOrganizationMemberRequestDefaultTypeInternal;
extern DeleteOrganizationMemberRequestDefaultTypeInternal _DeleteOrganizationMemberRequest_default_instance_;
class DeleteOrganizationMemberResponse;
struct DeleteOrganizationMemberResponseDefaultTypeInternal;
extern DeleteOrganizationMemberResponseDefaultTypeInternal _DeleteOrganizationMemberResponse_default_instance_;
class DeleteOrganizationRequest;
struct DeleteOrganizationRequestDefaultTypeInternal;
extern DeleteOrganizationRequestDefaultTypeInternal _DeleteOrganizationRequest_default_instance_;
class DeleteOrganizationResponse;
struct DeleteOrganizationResponseDefaultTypeInternal;
extern DeleteOrganizationResponseDefaultTypeInternal _DeleteOrganizationResponse_default_instance_;
class DeleteRegistryItemRequest;
struct DeleteRegistryItemRequestDefaultTypeInternal;
extern DeleteRegistryItemRequestDefaultTypeInternal _DeleteRegistryItemRequest_default_instance_;
class DeleteRegistryItemResponse;
struct DeleteRegistryItemResponseDefaultTypeInternal;
extern DeleteRegistryItemResponseDefaultTypeInternal _DeleteRegistryItemResponse_default_instance_;
class DeleteRobotPartRequest;
struct DeleteRobotPartRequestDefaultTypeInternal;
extern DeleteRobotPartRequestDefaultTypeInternal _DeleteRobotPartRequest_default_instance_;
class DeleteRobotPartResponse;
struct DeleteRobotPartResponseDefaultTypeInternal;
extern DeleteRobotPartResponseDefaultTypeInternal _DeleteRobotPartResponse_default_instance_;
class DeleteRobotPartSecretRequest;
struct DeleteRobotPartSecretRequestDefaultTypeInternal;
extern DeleteRobotPartSecretRequestDefaultTypeInternal _DeleteRobotPartSecretRequest_default_instance_;
class DeleteRobotPartSecretResponse;
struct DeleteRobotPartSecretResponseDefaultTypeInternal;
extern DeleteRobotPartSecretResponseDefaultTypeInternal _DeleteRobotPartSecretResponse_default_instance_;
class DeleteRobotRequest;
struct DeleteRobotRequestDefaultTypeInternal;
extern DeleteRobotRequestDefaultTypeInternal _DeleteRobotRequest_default_instance_;
class DeleteRobotResponse;
struct DeleteRobotResponseDefaultTypeInternal;
extern DeleteRobotResponseDefaultTypeInternal _DeleteRobotResponse_default_instance_;
class Fragment;
struct FragmentDefaultTypeInternal;
extern FragmentDefaultTypeInternal _Fragment_default_instance_;
class GetFragmentRequest;
struct GetFragmentRequestDefaultTypeInternal;
extern GetFragmentRequestDefaultTypeInternal _GetFragmentRequest_default_instance_;
class GetFragmentResponse;
struct GetFragmentResponseDefaultTypeInternal;
extern GetFragmentResponseDefaultTypeInternal _GetFragmentResponse_default_instance_;
class GetLocationRequest;
struct GetLocationRequestDefaultTypeInternal;
extern GetLocationRequestDefaultTypeInternal _GetLocationRequest_default_instance_;
class GetLocationResponse;
struct GetLocationResponseDefaultTypeInternal;
extern GetLocationResponseDefaultTypeInternal _GetLocationResponse_default_instance_;
class GetModuleRequest;
struct GetModuleRequestDefaultTypeInternal;
extern GetModuleRequestDefaultTypeInternal _GetModuleRequest_default_instance_;
class GetModuleResponse;
struct GetModuleResponseDefaultTypeInternal;
extern GetModuleResponseDefaultTypeInternal _GetModuleResponse_default_instance_;
class GetOrganizationNamespaceAvailabilityRequest;
struct GetOrganizationNamespaceAvailabilityRequestDefaultTypeInternal;
extern GetOrganizationNamespaceAvailabilityRequestDefaultTypeInternal _GetOrganizationNamespaceAvailabilityRequest_default_instance_;
class GetOrganizationNamespaceAvailabilityResponse;
struct GetOrganizationNamespaceAvailabilityResponseDefaultTypeInternal;
extern GetOrganizationNamespaceAvailabilityResponseDefaultTypeInternal _GetOrganizationNamespaceAvailabilityResponse_default_instance_;
class GetOrganizationRequest;
struct GetOrganizationRequestDefaultTypeInternal;
extern GetOrganizationRequestDefaultTypeInternal _GetOrganizationRequest_default_instance_;
class GetOrganizationResponse;
struct GetOrganizationResponseDefaultTypeInternal;
extern GetOrganizationResponseDefaultTypeInternal _GetOrganizationResponse_default_instance_;
class GetOrganizationsWithAccessToLocationRequest;
struct GetOrganizationsWithAccessToLocationRequestDefaultTypeInternal;
extern GetOrganizationsWithAccessToLocationRequestDefaultTypeInternal _GetOrganizationsWithAccessToLocationRequest_default_instance_;
class GetOrganizationsWithAccessToLocationResponse;
struct GetOrganizationsWithAccessToLocationResponseDefaultTypeInternal;
extern GetOrganizationsWithAccessToLocationResponseDefaultTypeInternal _GetOrganizationsWithAccessToLocationResponse_default_instance_;
class GetRegistryItemRequest;
struct GetRegistryItemRequestDefaultTypeInternal;
extern GetRegistryItemRequestDefaultTypeInternal _GetRegistryItemRequest_default_instance_;
class GetRegistryItemResponse;
struct GetRegistryItemResponseDefaultTypeInternal;
extern GetRegistryItemResponseDefaultTypeInternal _GetRegistryItemResponse_default_instance_;
class GetRobotAPIKeysRequest;
struct GetRobotAPIKeysRequestDefaultTypeInternal;
extern GetRobotAPIKeysRequestDefaultTypeInternal _GetRobotAPIKeysRequest_default_instance_;
class GetRobotAPIKeysResponse;
struct GetRobotAPIKeysResponseDefaultTypeInternal;
extern GetRobotAPIKeysResponseDefaultTypeInternal _GetRobotAPIKeysResponse_default_instance_;
class GetRobotPartHistoryRequest;
struct GetRobotPartHistoryRequestDefaultTypeInternal;
extern GetRobotPartHistoryRequestDefaultTypeInternal _GetRobotPartHistoryRequest_default_instance_;
class GetRobotPartHistoryResponse;
struct GetRobotPartHistoryResponseDefaultTypeInternal;
extern GetRobotPartHistoryResponseDefaultTypeInternal _GetRobotPartHistoryResponse_default_instance_;
class GetRobotPartLogsRequest;
struct GetRobotPartLogsRequestDefaultTypeInternal;
extern GetRobotPartLogsRequestDefaultTypeInternal _GetRobotPartLogsRequest_default_instance_;
class GetRobotPartLogsResponse;
struct GetRobotPartLogsResponseDefaultTypeInternal;
extern GetRobotPartLogsResponseDefaultTypeInternal _GetRobotPartLogsResponse_default_instance_;
class GetRobotPartRequest;
struct GetRobotPartRequestDefaultTypeInternal;
extern GetRobotPartRequestDefaultTypeInternal _GetRobotPartRequest_default_instance_;
class GetRobotPartResponse;
struct GetRobotPartResponseDefaultTypeInternal;
extern GetRobotPartResponseDefaultTypeInternal _GetRobotPartResponse_default_instance_;
class GetRobotPartsRequest;
struct GetRobotPartsRequestDefaultTypeInternal;
extern GetRobotPartsRequestDefaultTypeInternal _GetRobotPartsRequest_default_instance_;
class GetRobotPartsResponse;
struct GetRobotPartsResponseDefaultTypeInternal;
extern GetRobotPartsResponseDefaultTypeInternal _GetRobotPartsResponse_default_instance_;
class GetRobotRequest;
struct GetRobotRequestDefaultTypeInternal;
extern GetRobotRequestDefaultTypeInternal _GetRobotRequest_default_instance_;
class GetRobotResponse;
struct GetRobotResponseDefaultTypeInternal;
extern GetRobotResponseDefaultTypeInternal _GetRobotResponse_default_instance_;
class GetRoverRentalRobotsRequest;
struct GetRoverRentalRobotsRequestDefaultTypeInternal;
extern GetRoverRentalRobotsRequestDefaultTypeInternal _GetRoverRentalRobotsRequest_default_instance_;
class GetRoverRentalRobotsResponse;
struct GetRoverRentalRobotsResponseDefaultTypeInternal;
extern GetRoverRentalRobotsResponseDefaultTypeInternal _GetRoverRentalRobotsResponse_default_instance_;
class GetUserIDByEmailRequest;
struct GetUserIDByEmailRequestDefaultTypeInternal;
extern GetUserIDByEmailRequestDefaultTypeInternal _GetUserIDByEmailRequest_default_instance_;
class GetUserIDByEmailResponse;
struct GetUserIDByEmailResponseDefaultTypeInternal;
extern GetUserIDByEmailResponseDefaultTypeInternal _GetUserIDByEmailResponse_default_instance_;
class ListAuthorizationsRequest;
struct ListAuthorizationsRequestDefaultTypeInternal;
extern ListAuthorizationsRequestDefaultTypeInternal _ListAuthorizationsRequest_default_instance_;
class ListAuthorizationsResponse;
struct ListAuthorizationsResponseDefaultTypeInternal;
extern ListAuthorizationsResponseDefaultTypeInternal _ListAuthorizationsResponse_default_instance_;
class ListFragmentsRequest;
struct ListFragmentsRequestDefaultTypeInternal;
extern ListFragmentsRequestDefaultTypeInternal _ListFragmentsRequest_default_instance_;
class ListFragmentsResponse;
struct ListFragmentsResponseDefaultTypeInternal;
extern ListFragmentsResponseDefaultTypeInternal _ListFragmentsResponse_default_instance_;
class ListKeysRequest;
struct ListKeysRequestDefaultTypeInternal;
extern ListKeysRequestDefaultTypeInternal _ListKeysRequest_default_instance_;
class ListKeysResponse;
struct ListKeysResponseDefaultTypeInternal;
extern ListKeysResponseDefaultTypeInternal _ListKeysResponse_default_instance_;
class ListLocationsRequest;
struct ListLocationsRequestDefaultTypeInternal;
extern ListLocationsRequestDefaultTypeInternal _ListLocationsRequest_default_instance_;
class ListLocationsResponse;
struct ListLocationsResponseDefaultTypeInternal;
extern ListLocationsResponseDefaultTypeInternal _ListLocationsResponse_default_instance_;
class ListModulesRequest;
struct ListModulesRequestDefaultTypeInternal;
extern ListModulesRequestDefaultTypeInternal _ListModulesRequest_default_instance_;
class ListModulesResponse;
struct ListModulesResponseDefaultTypeInternal;
extern ListModulesResponseDefaultTypeInternal _ListModulesResponse_default_instance_;
class ListOrganizationMembersRequest;
struct ListOrganizationMembersRequestDefaultTypeInternal;
extern ListOrganizationMembersRequestDefaultTypeInternal _ListOrganizationMembersRequest_default_instance_;
class ListOrganizationMembersResponse;
struct ListOrganizationMembersResponseDefaultTypeInternal;
extern ListOrganizationMembersResponseDefaultTypeInternal _ListOrganizationMembersResponse_default_instance_;
class ListOrganizationsByUserRequest;
struct ListOrganizationsByUserRequestDefaultTypeInternal;
extern ListOrganizationsByUserRequestDefaultTypeInternal _ListOrganizationsByUserRequest_default_instance_;
class ListOrganizationsByUserResponse;
struct ListOrganizationsByUserResponseDefaultTypeInternal;
extern ListOrganizationsByUserResponseDefaultTypeInternal _ListOrganizationsByUserResponse_default_instance_;
class ListOrganizationsRequest;
struct ListOrganizationsRequestDefaultTypeInternal;
extern ListOrganizationsRequestDefaultTypeInternal _ListOrganizationsRequest_default_instance_;
class ListOrganizationsResponse;
struct ListOrganizationsResponseDefaultTypeInternal;
extern ListOrganizationsResponseDefaultTypeInternal _ListOrganizationsResponse_default_instance_;
class ListRegistryItemsRequest;
struct ListRegistryItemsRequestDefaultTypeInternal;
extern ListRegistryItemsRequestDefaultTypeInternal _ListRegistryItemsRequest_default_instance_;
class ListRegistryItemsResponse;
struct ListRegistryItemsResponseDefaultTypeInternal;
extern ListRegistryItemsResponseDefaultTypeInternal _ListRegistryItemsResponse_default_instance_;
class ListRobotsRequest;
struct ListRobotsRequestDefaultTypeInternal;
extern ListRobotsRequestDefaultTypeInternal _ListRobotsRequest_default_instance_;
class ListRobotsResponse;
struct ListRobotsResponseDefaultTypeInternal;
extern ListRobotsResponseDefaultTypeInternal _ListRobotsResponse_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class LocationAuth;
struct LocationAuthDefaultTypeInternal;
extern LocationAuthDefaultTypeInternal _LocationAuth_default_instance_;
class LocationAuthRequest;
struct LocationAuthRequestDefaultTypeInternal;
extern LocationAuthRequestDefaultTypeInternal _LocationAuthRequest_default_instance_;
class LocationAuthResponse;
struct LocationAuthResponseDefaultTypeInternal;
extern LocationAuthResponseDefaultTypeInternal _LocationAuthResponse_default_instance_;
class LocationOrganization;
struct LocationOrganizationDefaultTypeInternal;
extern LocationOrganizationDefaultTypeInternal _LocationOrganization_default_instance_;
class MLModelMetadata;
struct MLModelMetadataDefaultTypeInternal;
extern MLModelMetadataDefaultTypeInternal _MLModelMetadata_default_instance_;
class MarkPartAsMainRequest;
struct MarkPartAsMainRequestDefaultTypeInternal;
extern MarkPartAsMainRequestDefaultTypeInternal _MarkPartAsMainRequest_default_instance_;
class MarkPartAsMainResponse;
struct MarkPartAsMainResponseDefaultTypeInternal;
extern MarkPartAsMainResponseDefaultTypeInternal _MarkPartAsMainResponse_default_instance_;
class MarkPartForRestartRequest;
struct MarkPartForRestartRequestDefaultTypeInternal;
extern MarkPartForRestartRequestDefaultTypeInternal _MarkPartForRestartRequest_default_instance_;
class MarkPartForRestartResponse;
struct MarkPartForRestartResponseDefaultTypeInternal;
extern MarkPartForRestartResponseDefaultTypeInternal _MarkPartForRestartResponse_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Module;
struct ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class ModuleFileInfo;
struct ModuleFileInfoDefaultTypeInternal;
extern ModuleFileInfoDefaultTypeInternal _ModuleFileInfo_default_instance_;
class ModuleMetadata;
struct ModuleMetadataDefaultTypeInternal;
extern ModuleMetadataDefaultTypeInternal _ModuleMetadata_default_instance_;
class ModuleVersion;
struct ModuleVersionDefaultTypeInternal;
extern ModuleVersionDefaultTypeInternal _ModuleVersion_default_instance_;
class NewRobotPartRequest;
struct NewRobotPartRequestDefaultTypeInternal;
extern NewRobotPartRequestDefaultTypeInternal _NewRobotPartRequest_default_instance_;
class NewRobotPartResponse;
struct NewRobotPartResponseDefaultTypeInternal;
extern NewRobotPartResponseDefaultTypeInternal _NewRobotPartResponse_default_instance_;
class NewRobotRequest;
struct NewRobotRequestDefaultTypeInternal;
extern NewRobotRequestDefaultTypeInternal _NewRobotRequest_default_instance_;
class NewRobotResponse;
struct NewRobotResponseDefaultTypeInternal;
extern NewRobotResponseDefaultTypeInternal _NewRobotResponse_default_instance_;
class OrgDetails;
struct OrgDetailsDefaultTypeInternal;
extern OrgDetailsDefaultTypeInternal _OrgDetails_default_instance_;
class Organization;
struct OrganizationDefaultTypeInternal;
extern OrganizationDefaultTypeInternal _Organization_default_instance_;
class OrganizationIdentity;
struct OrganizationIdentityDefaultTypeInternal;
extern OrganizationIdentityDefaultTypeInternal _OrganizationIdentity_default_instance_;
class OrganizationInvite;
struct OrganizationInviteDefaultTypeInternal;
extern OrganizationInviteDefaultTypeInternal _OrganizationInvite_default_instance_;
class OrganizationMember;
struct OrganizationMemberDefaultTypeInternal;
extern OrganizationMemberDefaultTypeInternal _OrganizationMember_default_instance_;
class RegistryItem;
struct RegistryItemDefaultTypeInternal;
extern RegistryItemDefaultTypeInternal _RegistryItem_default_instance_;
class RemoveRoleRequest;
struct RemoveRoleRequestDefaultTypeInternal;
extern RemoveRoleRequestDefaultTypeInternal _RemoveRoleRequest_default_instance_;
class RemoveRoleResponse;
struct RemoveRoleResponseDefaultTypeInternal;
extern RemoveRoleResponseDefaultTypeInternal _RemoveRoleResponse_default_instance_;
class ResendOrganizationInviteRequest;
struct ResendOrganizationInviteRequestDefaultTypeInternal;
extern ResendOrganizationInviteRequestDefaultTypeInternal _ResendOrganizationInviteRequest_default_instance_;
class ResendOrganizationInviteResponse;
struct ResendOrganizationInviteResponseDefaultTypeInternal;
extern ResendOrganizationInviteResponseDefaultTypeInternal _ResendOrganizationInviteResponse_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class RobotPart;
struct RobotPartDefaultTypeInternal;
extern RobotPartDefaultTypeInternal _RobotPart_default_instance_;
class RobotPartHistoryEntry;
struct RobotPartHistoryEntryDefaultTypeInternal;
extern RobotPartHistoryEntryDefaultTypeInternal _RobotPartHistoryEntry_default_instance_;
class RotateKeyRequest;
struct RotateKeyRequestDefaultTypeInternal;
extern RotateKeyRequestDefaultTypeInternal _RotateKeyRequest_default_instance_;
class RotateKeyResponse;
struct RotateKeyResponseDefaultTypeInternal;
extern RotateKeyResponseDefaultTypeInternal _RotateKeyResponse_default_instance_;
class RoverRentalRobot;
struct RoverRentalRobotDefaultTypeInternal;
extern RoverRentalRobotDefaultTypeInternal _RoverRentalRobot_default_instance_;
class ShareLocationRequest;
struct ShareLocationRequestDefaultTypeInternal;
extern ShareLocationRequestDefaultTypeInternal _ShareLocationRequest_default_instance_;
class ShareLocationResponse;
struct ShareLocationResponseDefaultTypeInternal;
extern ShareLocationResponseDefaultTypeInternal _ShareLocationResponse_default_instance_;
class SharedSecret;
struct SharedSecretDefaultTypeInternal;
extern SharedSecretDefaultTypeInternal _SharedSecret_default_instance_;
class StorageConfig;
struct StorageConfigDefaultTypeInternal;
extern StorageConfigDefaultTypeInternal _StorageConfig_default_instance_;
class TailRobotPartLogsRequest;
struct TailRobotPartLogsRequestDefaultTypeInternal;
extern TailRobotPartLogsRequestDefaultTypeInternal _TailRobotPartLogsRequest_default_instance_;
class TailRobotPartLogsResponse;
struct TailRobotPartLogsResponseDefaultTypeInternal;
extern TailRobotPartLogsResponseDefaultTypeInternal _TailRobotPartLogsResponse_default_instance_;
class UnshareLocationRequest;
struct UnshareLocationRequestDefaultTypeInternal;
extern UnshareLocationRequestDefaultTypeInternal _UnshareLocationRequest_default_instance_;
class UnshareLocationResponse;
struct UnshareLocationResponseDefaultTypeInternal;
extern UnshareLocationResponseDefaultTypeInternal _UnshareLocationResponse_default_instance_;
class UpdateFragmentRequest;
struct UpdateFragmentRequestDefaultTypeInternal;
extern UpdateFragmentRequestDefaultTypeInternal _UpdateFragmentRequest_default_instance_;
class UpdateFragmentResponse;
struct UpdateFragmentResponseDefaultTypeInternal;
extern UpdateFragmentResponseDefaultTypeInternal _UpdateFragmentResponse_default_instance_;
class UpdateLocationRequest;
struct UpdateLocationRequestDefaultTypeInternal;
extern UpdateLocationRequestDefaultTypeInternal _UpdateLocationRequest_default_instance_;
class UpdateLocationResponse;
struct UpdateLocationResponseDefaultTypeInternal;
extern UpdateLocationResponseDefaultTypeInternal _UpdateLocationResponse_default_instance_;
class UpdateModuleRequest;
struct UpdateModuleRequestDefaultTypeInternal;
extern UpdateModuleRequestDefaultTypeInternal _UpdateModuleRequest_default_instance_;
class UpdateModuleResponse;
struct UpdateModuleResponseDefaultTypeInternal;
extern UpdateModuleResponseDefaultTypeInternal _UpdateModuleResponse_default_instance_;
class UpdateOrganizationInviteAuthorizationsRequest;
struct UpdateOrganizationInviteAuthorizationsRequestDefaultTypeInternal;
extern UpdateOrganizationInviteAuthorizationsRequestDefaultTypeInternal _UpdateOrganizationInviteAuthorizationsRequest_default_instance_;
class UpdateOrganizationInviteAuthorizationsResponse;
struct UpdateOrganizationInviteAuthorizationsResponseDefaultTypeInternal;
extern UpdateOrganizationInviteAuthorizationsResponseDefaultTypeInternal _UpdateOrganizationInviteAuthorizationsResponse_default_instance_;
class UpdateOrganizationRequest;
struct UpdateOrganizationRequestDefaultTypeInternal;
extern UpdateOrganizationRequestDefaultTypeInternal _UpdateOrganizationRequest_default_instance_;
class UpdateOrganizationResponse;
struct UpdateOrganizationResponseDefaultTypeInternal;
extern UpdateOrganizationResponseDefaultTypeInternal _UpdateOrganizationResponse_default_instance_;
class UpdateRegistryItemRequest;
struct UpdateRegistryItemRequestDefaultTypeInternal;
extern UpdateRegistryItemRequestDefaultTypeInternal _UpdateRegistryItemRequest_default_instance_;
class UpdateRegistryItemResponse;
struct UpdateRegistryItemResponseDefaultTypeInternal;
extern UpdateRegistryItemResponseDefaultTypeInternal _UpdateRegistryItemResponse_default_instance_;
class UpdateRobotPartRequest;
struct UpdateRobotPartRequestDefaultTypeInternal;
extern UpdateRobotPartRequestDefaultTypeInternal _UpdateRobotPartRequest_default_instance_;
class UpdateRobotPartResponse;
struct UpdateRobotPartResponseDefaultTypeInternal;
extern UpdateRobotPartResponseDefaultTypeInternal _UpdateRobotPartResponse_default_instance_;
class UpdateRobotRequest;
struct UpdateRobotRequestDefaultTypeInternal;
extern UpdateRobotRequestDefaultTypeInternal _UpdateRobotRequest_default_instance_;
class UpdateRobotResponse;
struct UpdateRobotResponseDefaultTypeInternal;
extern UpdateRobotResponseDefaultTypeInternal _UpdateRobotResponse_default_instance_;
class UploadModuleFileRequest;
struct UploadModuleFileRequestDefaultTypeInternal;
extern UploadModuleFileRequestDefaultTypeInternal _UploadModuleFileRequest_default_instance_;
class UploadModuleFileResponse;
struct UploadModuleFileResponseDefaultTypeInternal;
extern UploadModuleFileResponseDefaultTypeInternal _UploadModuleFileResponse_default_instance_;
class Uploads;
struct UploadsDefaultTypeInternal;
extern UploadsDefaultTypeInternal _Uploads_default_instance_;
class VersionHistory;
struct VersionHistoryDefaultTypeInternal;
extern VersionHistoryDefaultTypeInternal _VersionHistory_default_instance_;
}  // namespace v1
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::v1::APIKey* Arena::CreateMaybeMessage<::viam::app::v1::APIKey>(Arena*);
template<> ::viam::app::v1::APIKeyWithAuthorizations* Arena::CreateMaybeMessage<::viam::app::v1::APIKeyWithAuthorizations>(Arena*);
template<> ::viam::app::v1::AddRoleRequest* Arena::CreateMaybeMessage<::viam::app::v1::AddRoleRequest>(Arena*);
template<> ::viam::app::v1::AddRoleResponse* Arena::CreateMaybeMessage<::viam::app::v1::AddRoleResponse>(Arena*);
template<> ::viam::app::v1::Authorization* Arena::CreateMaybeMessage<::viam::app::v1::Authorization>(Arena*);
template<> ::viam::app::v1::AuthorizationDetails* Arena::CreateMaybeMessage<::viam::app::v1::AuthorizationDetails>(Arena*);
template<> ::viam::app::v1::AuthorizedPermissions* Arena::CreateMaybeMessage<::viam::app::v1::AuthorizedPermissions>(Arena*);
template<> ::viam::app::v1::ChangeRoleRequest* Arena::CreateMaybeMessage<::viam::app::v1::ChangeRoleRequest>(Arena*);
template<> ::viam::app::v1::ChangeRoleResponse* Arena::CreateMaybeMessage<::viam::app::v1::ChangeRoleResponse>(Arena*);
template<> ::viam::app::v1::CheckPermissionsRequest* Arena::CreateMaybeMessage<::viam::app::v1::CheckPermissionsRequest>(Arena*);
template<> ::viam::app::v1::CheckPermissionsResponse* Arena::CreateMaybeMessage<::viam::app::v1::CheckPermissionsResponse>(Arena*);
template<> ::viam::app::v1::CreateFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateFragmentRequest>(Arena*);
template<> ::viam::app::v1::CreateFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateFragmentResponse>(Arena*);
template<> ::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsRequest>(Arena*);
template<> ::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyFromExistingKeyAuthorizationsResponse>(Arena*);
template<> ::viam::app::v1::CreateKeyRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyRequest>(Arena*);
template<> ::viam::app::v1::CreateKeyResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateKeyResponse>(Arena*);
template<> ::viam::app::v1::CreateLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationRequest>(Arena*);
template<> ::viam::app::v1::CreateLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationResponse>(Arena*);
template<> ::viam::app::v1::CreateLocationSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationSecretRequest>(Arena*);
template<> ::viam::app::v1::CreateLocationSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationSecretResponse>(Arena*);
template<> ::viam::app::v1::CreateModuleRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateModuleRequest>(Arena*);
template<> ::viam::app::v1::CreateModuleResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateModuleResponse>(Arena*);
template<> ::viam::app::v1::CreateOrganizationInviteRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationInviteRequest>(Arena*);
template<> ::viam::app::v1::CreateOrganizationInviteResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationInviteResponse>(Arena*);
template<> ::viam::app::v1::CreateOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationRequest>(Arena*);
template<> ::viam::app::v1::CreateOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateOrganizationResponse>(Arena*);
template<> ::viam::app::v1::CreateRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::CreateRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::CreateRobotPartSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateRobotPartSecretRequest>(Arena*);
template<> ::viam::app::v1::CreateRobotPartSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateRobotPartSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteFragmentRequest>(Arena*);
template<> ::viam::app::v1::DeleteFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteFragmentResponse>(Arena*);
template<> ::viam::app::v1::DeleteKeyRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteKeyRequest>(Arena*);
template<> ::viam::app::v1::DeleteKeyResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteKeyResponse>(Arena*);
template<> ::viam::app::v1::DeleteLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationRequest>(Arena*);
template<> ::viam::app::v1::DeleteLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationResponse>(Arena*);
template<> ::viam::app::v1::DeleteLocationSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationSecretRequest>(Arena*);
template<> ::viam::app::v1::DeleteLocationSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationInviteRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationInviteRequest>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationInviteResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationInviteResponse>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationMemberRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationMemberRequest>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationMemberResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationMemberResponse>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationRequest>(Arena*);
template<> ::viam::app::v1::DeleteOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteOrganizationResponse>(Arena*);
template<> ::viam::app::v1::DeleteRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::DeleteRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartSecretRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotResponse>(Arena*);
template<> ::viam::app::v1::Fragment* Arena::CreateMaybeMessage<::viam::app::v1::Fragment>(Arena*);
template<> ::viam::app::v1::GetFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentRequest>(Arena*);
template<> ::viam::app::v1::GetFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetFragmentResponse>(Arena*);
template<> ::viam::app::v1::GetLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetLocationRequest>(Arena*);
template<> ::viam::app::v1::GetLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetLocationResponse>(Arena*);
template<> ::viam::app::v1::GetModuleRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetModuleRequest>(Arena*);
template<> ::viam::app::v1::GetModuleResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetModuleResponse>(Arena*);
template<> ::viam::app::v1::GetOrganizationNamespaceAvailabilityRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationNamespaceAvailabilityRequest>(Arena*);
template<> ::viam::app::v1::GetOrganizationNamespaceAvailabilityResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationNamespaceAvailabilityResponse>(Arena*);
template<> ::viam::app::v1::GetOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationRequest>(Arena*);
template<> ::viam::app::v1::GetOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationResponse>(Arena*);
template<> ::viam::app::v1::GetOrganizationsWithAccessToLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationsWithAccessToLocationRequest>(Arena*);
template<> ::viam::app::v1::GetOrganizationsWithAccessToLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetOrganizationsWithAccessToLocationResponse>(Arena*);
template<> ::viam::app::v1::GetRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::GetRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::GetRobotAPIKeysRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotAPIKeysRequest>(Arena*);
template<> ::viam::app::v1::GetRobotAPIKeysResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotAPIKeysResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartHistoryRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartHistoryRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartHistoryResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartHistoryResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartLogsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartLogsRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartLogsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartLogsResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartsRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartsResponse>(Arena*);
template<> ::viam::app::v1::GetRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotRequest>(Arena*);
template<> ::viam::app::v1::GetRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotResponse>(Arena*);
template<> ::viam::app::v1::GetRoverRentalRobotsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRoverRentalRobotsRequest>(Arena*);
template<> ::viam::app::v1::GetRoverRentalRobotsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRoverRentalRobotsResponse>(Arena*);
template<> ::viam::app::v1::GetUserIDByEmailRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetUserIDByEmailRequest>(Arena*);
template<> ::viam::app::v1::GetUserIDByEmailResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetUserIDByEmailResponse>(Arena*);
template<> ::viam::app::v1::ListAuthorizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListAuthorizationsRequest>(Arena*);
template<> ::viam::app::v1::ListAuthorizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListAuthorizationsResponse>(Arena*);
template<> ::viam::app::v1::ListFragmentsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListFragmentsRequest>(Arena*);
template<> ::viam::app::v1::ListFragmentsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListFragmentsResponse>(Arena*);
template<> ::viam::app::v1::ListKeysRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListKeysRequest>(Arena*);
template<> ::viam::app::v1::ListKeysResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListKeysResponse>(Arena*);
template<> ::viam::app::v1::ListLocationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListLocationsRequest>(Arena*);
template<> ::viam::app::v1::ListLocationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListLocationsResponse>(Arena*);
template<> ::viam::app::v1::ListModulesRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListModulesRequest>(Arena*);
template<> ::viam::app::v1::ListModulesResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListModulesResponse>(Arena*);
template<> ::viam::app::v1::ListOrganizationMembersRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationMembersRequest>(Arena*);
template<> ::viam::app::v1::ListOrganizationMembersResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationMembersResponse>(Arena*);
template<> ::viam::app::v1::ListOrganizationsByUserRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsByUserRequest>(Arena*);
template<> ::viam::app::v1::ListOrganizationsByUserResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsByUserResponse>(Arena*);
template<> ::viam::app::v1::ListOrganizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsRequest>(Arena*);
template<> ::viam::app::v1::ListOrganizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsResponse>(Arena*);
template<> ::viam::app::v1::ListRegistryItemsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListRegistryItemsRequest>(Arena*);
template<> ::viam::app::v1::ListRegistryItemsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListRegistryItemsResponse>(Arena*);
template<> ::viam::app::v1::ListRobotsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsRequest>(Arena*);
template<> ::viam::app::v1::ListRobotsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListRobotsResponse>(Arena*);
template<> ::viam::app::v1::Location* Arena::CreateMaybeMessage<::viam::app::v1::Location>(Arena*);
template<> ::viam::app::v1::LocationAuth* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuth>(Arena*);
template<> ::viam::app::v1::LocationAuthRequest* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuthRequest>(Arena*);
template<> ::viam::app::v1::LocationAuthResponse* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuthResponse>(Arena*);
template<> ::viam::app::v1::LocationOrganization* Arena::CreateMaybeMessage<::viam::app::v1::LocationOrganization>(Arena*);
template<> ::viam::app::v1::MLModelMetadata* Arena::CreateMaybeMessage<::viam::app::v1::MLModelMetadata>(Arena*);
template<> ::viam::app::v1::MarkPartAsMainRequest* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartAsMainRequest>(Arena*);
template<> ::viam::app::v1::MarkPartAsMainResponse* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartAsMainResponse>(Arena*);
template<> ::viam::app::v1::MarkPartForRestartRequest* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartForRestartRequest>(Arena*);
template<> ::viam::app::v1::MarkPartForRestartResponse* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartForRestartResponse>(Arena*);
template<> ::viam::app::v1::Model* Arena::CreateMaybeMessage<::viam::app::v1::Model>(Arena*);
template<> ::viam::app::v1::Module* Arena::CreateMaybeMessage<::viam::app::v1::Module>(Arena*);
template<> ::viam::app::v1::ModuleFileInfo* Arena::CreateMaybeMessage<::viam::app::v1::ModuleFileInfo>(Arena*);
template<> ::viam::app::v1::ModuleMetadata* Arena::CreateMaybeMessage<::viam::app::v1::ModuleMetadata>(Arena*);
template<> ::viam::app::v1::ModuleVersion* Arena::CreateMaybeMessage<::viam::app::v1::ModuleVersion>(Arena*);
template<> ::viam::app::v1::NewRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotPartRequest>(Arena*);
template<> ::viam::app::v1::NewRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotPartResponse>(Arena*);
template<> ::viam::app::v1::NewRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotRequest>(Arena*);
template<> ::viam::app::v1::NewRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotResponse>(Arena*);
template<> ::viam::app::v1::OrgDetails* Arena::CreateMaybeMessage<::viam::app::v1::OrgDetails>(Arena*);
template<> ::viam::app::v1::Organization* Arena::CreateMaybeMessage<::viam::app::v1::Organization>(Arena*);
template<> ::viam::app::v1::OrganizationIdentity* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationIdentity>(Arena*);
template<> ::viam::app::v1::OrganizationInvite* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(Arena*);
template<> ::viam::app::v1::OrganizationMember* Arena::CreateMaybeMessage<::viam::app::v1::OrganizationMember>(Arena*);
template<> ::viam::app::v1::RegistryItem* Arena::CreateMaybeMessage<::viam::app::v1::RegistryItem>(Arena*);
template<> ::viam::app::v1::RemoveRoleRequest* Arena::CreateMaybeMessage<::viam::app::v1::RemoveRoleRequest>(Arena*);
template<> ::viam::app::v1::RemoveRoleResponse* Arena::CreateMaybeMessage<::viam::app::v1::RemoveRoleResponse>(Arena*);
template<> ::viam::app::v1::ResendOrganizationInviteRequest* Arena::CreateMaybeMessage<::viam::app::v1::ResendOrganizationInviteRequest>(Arena*);
template<> ::viam::app::v1::ResendOrganizationInviteResponse* Arena::CreateMaybeMessage<::viam::app::v1::ResendOrganizationInviteResponse>(Arena*);
template<> ::viam::app::v1::Robot* Arena::CreateMaybeMessage<::viam::app::v1::Robot>(Arena*);
template<> ::viam::app::v1::RobotPart* Arena::CreateMaybeMessage<::viam::app::v1::RobotPart>(Arena*);
template<> ::viam::app::v1::RobotPartHistoryEntry* Arena::CreateMaybeMessage<::viam::app::v1::RobotPartHistoryEntry>(Arena*);
template<> ::viam::app::v1::RotateKeyRequest* Arena::CreateMaybeMessage<::viam::app::v1::RotateKeyRequest>(Arena*);
template<> ::viam::app::v1::RotateKeyResponse* Arena::CreateMaybeMessage<::viam::app::v1::RotateKeyResponse>(Arena*);
template<> ::viam::app::v1::RoverRentalRobot* Arena::CreateMaybeMessage<::viam::app::v1::RoverRentalRobot>(Arena*);
template<> ::viam::app::v1::ShareLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::ShareLocationRequest>(Arena*);
template<> ::viam::app::v1::ShareLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::ShareLocationResponse>(Arena*);
template<> ::viam::app::v1::SharedSecret* Arena::CreateMaybeMessage<::viam::app::v1::SharedSecret>(Arena*);
template<> ::viam::app::v1::StorageConfig* Arena::CreateMaybeMessage<::viam::app::v1::StorageConfig>(Arena*);
template<> ::viam::app::v1::TailRobotPartLogsRequest* Arena::CreateMaybeMessage<::viam::app::v1::TailRobotPartLogsRequest>(Arena*);
template<> ::viam::app::v1::TailRobotPartLogsResponse* Arena::CreateMaybeMessage<::viam::app::v1::TailRobotPartLogsResponse>(Arena*);
template<> ::viam::app::v1::UnshareLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::UnshareLocationRequest>(Arena*);
template<> ::viam::app::v1::UnshareLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::UnshareLocationResponse>(Arena*);
template<> ::viam::app::v1::UpdateFragmentRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateFragmentRequest>(Arena*);
template<> ::viam::app::v1::UpdateFragmentResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateFragmentResponse>(Arena*);
template<> ::viam::app::v1::UpdateLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateLocationRequest>(Arena*);
template<> ::viam::app::v1::UpdateLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateLocationResponse>(Arena*);
template<> ::viam::app::v1::UpdateModuleRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateModuleRequest>(Arena*);
template<> ::viam::app::v1::UpdateModuleResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateModuleResponse>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationInviteAuthorizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationInviteAuthorizationsRequest>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationInviteAuthorizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationInviteAuthorizationsResponse>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationRequest>(Arena*);
template<> ::viam::app::v1::UpdateOrganizationResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateOrganizationResponse>(Arena*);
template<> ::viam::app::v1::UpdateRegistryItemRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRegistryItemRequest>(Arena*);
template<> ::viam::app::v1::UpdateRegistryItemResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRegistryItemResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotResponse>(Arena*);
template<> ::viam::app::v1::UploadModuleFileRequest* Arena::CreateMaybeMessage<::viam::app::v1::UploadModuleFileRequest>(Arena*);
template<> ::viam::app::v1::UploadModuleFileResponse* Arena::CreateMaybeMessage<::viam::app::v1::UploadModuleFileResponse>(Arena*);
template<> ::viam::app::v1::Uploads* Arena::CreateMaybeMessage<::viam::app::v1::Uploads>(Arena*);
template<> ::viam::app::v1::VersionHistory* Arena::CreateMaybeMessage<::viam::app::v1::VersionHistory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace v1 {

enum SharedSecret_State : int {
  SharedSecret_State_STATE_UNSPECIFIED = 0,
  SharedSecret_State_STATE_ENABLED = 1,
  SharedSecret_State_STATE_DISABLED = 2,
  SharedSecret_State_SharedSecret_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SharedSecret_State_SharedSecret_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SharedSecret_State_IsValid(int value);
constexpr SharedSecret_State SharedSecret_State_State_MIN = SharedSecret_State_STATE_UNSPECIFIED;
constexpr SharedSecret_State SharedSecret_State_State_MAX = SharedSecret_State_STATE_DISABLED;
constexpr int SharedSecret_State_State_ARRAYSIZE = SharedSecret_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SharedSecret_State_descriptor();
template<typename T>
inline const std::string& SharedSecret_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SharedSecret_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SharedSecret_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SharedSecret_State_descriptor(), enum_t_value);
}
inline bool SharedSecret_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharedSecret_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SharedSecret_State>(
    SharedSecret_State_descriptor(), name, value);
}
enum RegistryItemStatus : int {
  REGISTRY_ITEM_STATUS_UNSPECIFIED = 0,
  REGISTRY_ITEM_STATUS_PUBLISHED = 1,
  REGISTRY_ITEM_STATUS_IN_DEVELOPMENT = 2,
  RegistryItemStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegistryItemStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegistryItemStatus_IsValid(int value);
constexpr RegistryItemStatus RegistryItemStatus_MIN = REGISTRY_ITEM_STATUS_UNSPECIFIED;
constexpr RegistryItemStatus RegistryItemStatus_MAX = REGISTRY_ITEM_STATUS_IN_DEVELOPMENT;
constexpr int RegistryItemStatus_ARRAYSIZE = RegistryItemStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegistryItemStatus_descriptor();
template<typename T>
inline const std::string& RegistryItemStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegistryItemStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegistryItemStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegistryItemStatus_descriptor(), enum_t_value);
}
inline bool RegistryItemStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegistryItemStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegistryItemStatus>(
    RegistryItemStatus_descriptor(), name, value);
}
enum Visibility : int {
  VISIBILITY_UNSPECIFIED = 0,
  VISIBILITY_PRIVATE = 1,
  VISIBILITY_PUBLIC = 2,
  Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Visibility_IsValid(int value);
constexpr Visibility Visibility_MIN = VISIBILITY_UNSPECIFIED;
constexpr Visibility Visibility_MAX = VISIBILITY_PUBLIC;
constexpr int Visibility_ARRAYSIZE = Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Visibility_descriptor();
template<typename T>
inline const std::string& Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Visibility_descriptor(), enum_t_value);
}
inline bool Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Visibility>(
    Visibility_descriptor(), name, value);
}
// ===================================================================

class Robot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  explicit PROTOBUF_CONSTEXPR Robot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLocationFieldNumber = 3,
    kLastAccessFieldNumber = 4,
    kCreatedOnFieldNumber = 5,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 3 [json_name = "location", (.tagger.v1.tags) = "bson:\"location\" json:\"location\""];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // .google.protobuf.Timestamp last_access = 4 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // .google.protobuf.Timestamp created_on = 5 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RobotPart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotPart) */ {
 public:
  inline RobotPart() : RobotPart(nullptr) {}
  ~RobotPart() override;
  explicit PROTOBUF_CONSTEXPR RobotPart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotPart(const RobotPart& from);
  RobotPart(RobotPart&& from) noexcept
    : RobotPart() {
    *this = ::std::move(from);
  }

  inline RobotPart& operator=(const RobotPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPart& operator=(RobotPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotPart* internal_default_instance() {
    return reinterpret_cast<const RobotPart*>(
               &_RobotPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RobotPart& a, RobotPart& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotPart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotPart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotPart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotPart& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RobotPart";
  }
  protected:
  explicit RobotPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 14,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSecretFieldNumber = 3,
    kRobotFieldNumber = 4,
    kFqdnFieldNumber = 9,
    kDnsNameFieldNumber = 10,
    kLocalFqdnFieldNumber = 11,
    kLocationIdFieldNumber = 12,
    kRobotConfigFieldNumber = 5,
    kLastAccessFieldNumber = 6,
    kUserSuppliedInfoFieldNumber = 7,
    kCreatedOnFieldNumber = 13,
    kMainPartFieldNumber = 8,
  };
  // repeated .viam.app.v1.SharedSecret secrets = 14 [json_name = "secrets", (.tagger.v1.tags) = "bson:\"secrets\""];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  ::viam::app::v1::SharedSecret* mutable_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
      mutable_secrets();
  private:
  const ::viam::app::v1::SharedSecret& _internal_secrets(int index) const;
  ::viam::app::v1::SharedSecret* _internal_add_secrets();
  public:
  const ::viam::app::v1::SharedSecret& secrets(int index) const;
  ::viam::app::v1::SharedSecret* add_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
      secrets() const;

  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string secret = 3 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\" json:\"secret,omitempty\""];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string robot = 4 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
  void clear_robot();
  const std::string& robot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot();
  PROTOBUF_NODISCARD std::string* release_robot();
  void set_allocated_robot(std::string* robot);
  private:
  const std::string& _internal_robot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot(const std::string& value);
  std::string* _internal_mutable_robot();
  public:

  // string fqdn = 9 [json_name = "fqdn"];
  void clear_fqdn();
  const std::string& fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fqdn();
  PROTOBUF_NODISCARD std::string* release_fqdn();
  void set_allocated_fqdn(std::string* fqdn);
  private:
  const std::string& _internal_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fqdn(const std::string& value);
  std::string* _internal_mutable_fqdn();
  public:

  // string dns_name = 10 [json_name = "dnsName", (.tagger.v1.tags) = "bson:\"dns_name\" json:\"dns_name\""];
  void clear_dns_name();
  const std::string& dns_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dns_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dns_name();
  PROTOBUF_NODISCARD std::string* release_dns_name();
  void set_allocated_dns_name(std::string* dns_name);
  private:
  const std::string& _internal_dns_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns_name(const std::string& value);
  std::string* _internal_mutable_dns_name();
  public:

  // string local_fqdn = 11 [json_name = "localFqdn"];
  void clear_local_fqdn();
  const std::string& local_fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_fqdn();
  PROTOBUF_NODISCARD std::string* release_local_fqdn();
  void set_allocated_local_fqdn(std::string* local_fqdn);
  private:
  const std::string& _internal_local_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_fqdn(const std::string& value);
  std::string* _internal_mutable_local_fqdn();
  public:

  // string location_id = 12 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"-\""];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // .google.protobuf.Struct robot_config = 5 [json_name = "robotConfig", (.tagger.v1.tags) = "bson:\"config\" json:\"robot_config\""];
  bool has_robot_config() const;
  private:
  bool _internal_has_robot_config() const;
  public:
  void clear_robot_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& robot_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_robot_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_robot_config();
  void set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_robot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_robot_config();
  public:
  void unsafe_arena_set_allocated_robot_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_robot_config();

  // .google.protobuf.Timestamp last_access = 6 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // .google.protobuf.Struct user_supplied_info = 7 [json_name = "userSuppliedInfo", (.tagger.v1.tags) = "bson:\"user_supplied_info\" json:\"user_supplied_info\""];
  bool has_user_supplied_info() const;
  private:
  bool _internal_has_user_supplied_info() const;
  public:
  void clear_user_supplied_info();
  const ::PROTOBUF_NAMESPACE_ID::Struct& user_supplied_info() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_user_supplied_info();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_user_supplied_info();
  void set_allocated_user_supplied_info(::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_user_supplied_info() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_user_supplied_info();
  public:
  void unsafe_arena_set_allocated_user_supplied_info(
      ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_user_supplied_info();

  // .google.protobuf.Timestamp created_on = 13 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // bool main_part = 8 [json_name = "mainPart", (.tagger.v1.tags) = "bson:\"main_part\" json:\"main_part\""];
  void clear_main_part();
  bool main_part() const;
  void set_main_part(bool value);
  private:
  bool _internal_main_part() const;
  void _internal_set_main_part(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotPart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fqdn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dns_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_fqdn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* robot_config_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
  ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  bool main_part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RobotPartHistoryEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotPartHistoryEntry) */ {
 public:
  inline RobotPartHistoryEntry() : RobotPartHistoryEntry(nullptr) {}
  ~RobotPartHistoryEntry() override;
  explicit PROTOBUF_CONSTEXPR RobotPartHistoryEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotPartHistoryEntry(const RobotPartHistoryEntry& from);
  RobotPartHistoryEntry(RobotPartHistoryEntry&& from) noexcept
    : RobotPartHistoryEntry() {
    *this = ::std::move(from);
  }

  inline RobotPartHistoryEntry& operator=(const RobotPartHistoryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPartHistoryEntry& operator=(RobotPartHistoryEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotPartHistoryEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotPartHistoryEntry* internal_default_instance() {
    return reinterpret_cast<const RobotPartHistoryEntry*>(
               &_RobotPartHistoryEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotPartHistoryEntry& a, RobotPartHistoryEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPartHistoryEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPartHistoryEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotPartHistoryEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotPartHistoryEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotPartHistoryEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotPartHistoryEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPartHistoryEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RobotPartHistoryEntry";
  }
  protected:
  explicit RobotPartHistoryEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
    kRobotFieldNumber = 2,
    kWhenFieldNumber = 3,
    kOldFieldNumber = 4,
  };
  // string part = 1 [json_name = "part", (.tagger.v1.tags) = "bson:\"part\" json:\"part\""];
  void clear_part();
  const std::string& part() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part();
  PROTOBUF_NODISCARD std::string* release_part();
  void set_allocated_part(std::string* part);
  private:
  const std::string& _internal_part() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part(const std::string& value);
  std::string* _internal_mutable_part();
  public:

  // string robot = 2 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
  void clear_robot();
  const std::string& robot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot();
  PROTOBUF_NODISCARD std::string* release_robot();
  void set_allocated_robot(std::string* robot);
  private:
  const std::string& _internal_robot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot(const std::string& value);
  std::string* _internal_mutable_robot();
  public:

  // .google.protobuf.Timestamp when = 3 [json_name = "when", (.tagger.v1.tags) = "bson:\"when\" json:\"when\""];
  bool has_when() const;
  private:
  bool _internal_has_when() const;
  public:
  void clear_when();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& when() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_when();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_when();
  void set_allocated_when(::PROTOBUF_NAMESPACE_ID::Timestamp* when);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_when() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_when();
  public:
  void unsafe_arena_set_allocated_when(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* when);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_when();

  // .viam.app.v1.RobotPart old = 4 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
  bool has_old() const;
  private:
  bool _internal_has_old() const;
  public:
  void clear_old();
  const ::viam::app::v1::RobotPart& old() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_old();
  ::viam::app::v1::RobotPart* mutable_old();
  void set_allocated_old(::viam::app::v1::RobotPart* old);
  private:
  const ::viam::app::v1::RobotPart& _internal_old() const;
  ::viam::app::v1::RobotPart* _internal_mutable_old();
  public:
  void unsafe_arena_set_allocated_old(
      ::viam::app::v1::RobotPart* old);
  ::viam::app::v1::RobotPart* unsafe_arena_release_old();

  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotPartHistoryEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* when_;
  ::viam::app::v1::RobotPart* old_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsRequest) */ {
 public:
  inline ListOrganizationsRequest() : ListOrganizationsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsRequest(const ListOrganizationsRequest& from);
  ListOrganizationsRequest(ListOrganizationsRequest&& from) noexcept
    : ListOrganizationsRequest() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsRequest& operator=(const ListOrganizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsRequest& operator=(ListOrganizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsRequest*>(
               &_ListOrganizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListOrganizationsRequest& a, ListOrganizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListOrganizationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListOrganizationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsRequest";
  }
  protected:
  explicit ListOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Organization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Organization) */ {
 public:
  inline Organization() : Organization(nullptr) {}
  ~Organization() override;
  explicit PROTOBUF_CONSTEXPR Organization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Organization(const Organization& from);
  Organization(Organization&& from) noexcept
    : Organization() {
    *this = ::std::move(from);
  }

  inline Organization& operator=(const Organization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Organization& operator=(Organization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Organization& default_instance() {
    return *internal_default_instance();
  }
  static inline const Organization* internal_default_instance() {
    return reinterpret_cast<const Organization*>(
               &_Organization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Organization& a, Organization& b) {
    a.Swap(&b);
  }
  inline void Swap(Organization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Organization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Organization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Organization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Organization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Organization& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Organization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Organization";
  }
  protected:
  explicit Organization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPublicNamespaceFieldNumber = 4,
    kDefaultRegionFieldNumber = 5,
    kCidFieldNumber = 6,
    kCreatedOnFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string public_namespace = 4 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // string default_region = 5 [json_name = "defaultRegion"];
  void clear_default_region();
  const std::string& default_region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_region();
  PROTOBUF_NODISCARD std::string* release_default_region();
  void set_allocated_default_region(std::string* default_region);
  private:
  const std::string& _internal_default_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_region(const std::string& value);
  std::string* _internal_mutable_default_region();
  public:

  // optional string cid = 6 [json_name = "cid"];
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Organization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationMember) */ {
 public:
  inline OrganizationMember() : OrganizationMember(nullptr) {}
  ~OrganizationMember() override;
  explicit PROTOBUF_CONSTEXPR OrganizationMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationMember(const OrganizationMember& from);
  OrganizationMember(OrganizationMember&& from) noexcept
    : OrganizationMember() {
    *this = ::std::move(from);
  }

  inline OrganizationMember& operator=(const OrganizationMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationMember& operator=(OrganizationMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationMember* internal_default_instance() {
    return reinterpret_cast<const OrganizationMember*>(
               &_OrganizationMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OrganizationMember& a, OrganizationMember& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationMember& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationMember";
  }
  protected:
  explicit OrganizationMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailsFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kDateAddedFieldNumber = 3,
    kLastLoginFieldNumber = 4,
  };
  // repeated string emails = 2 [json_name = "emails"];
  int emails_size() const;
  private:
  int _internal_emails_size() const;
  public:
  void clear_emails();
  const std::string& emails(int index) const;
  std::string* mutable_emails(int index);
  void set_emails(int index, const std::string& value);
  void set_emails(int index, std::string&& value);
  void set_emails(int index, const char* value);
  void set_emails(int index, const char* value, size_t size);
  std::string* add_emails();
  void add_emails(const std::string& value);
  void add_emails(std::string&& value);
  void add_emails(const char* value);
  void add_emails(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& emails() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_emails();
  private:
  const std::string& _internal_emails(int index) const;
  std::string* _internal_add_emails();
  public:

  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .google.protobuf.Timestamp date_added = 3 [json_name = "dateAdded"];
  bool has_date_added() const;
  private:
  bool _internal_has_date_added() const;
  public:
  void clear_date_added();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& date_added() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_date_added();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_date_added();
  void set_allocated_date_added(::PROTOBUF_NAMESPACE_ID::Timestamp* date_added);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_date_added() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_date_added();
  public:
  void unsafe_arena_set_allocated_date_added(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* date_added);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_date_added();

  // optional .google.protobuf.Timestamp last_login = 4 [json_name = "lastLogin"];
  bool has_last_login() const;
  private:
  bool _internal_has_last_login() const;
  public:
  void clear_last_login();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_login() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_login();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_login();
  void set_allocated_last_login(::PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_login() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_login();
  public:
  void unsafe_arena_set_allocated_last_login(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_login();

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> emails_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* date_added_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_login_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsResponse) */ {
 public:
  inline ListOrganizationsResponse() : ListOrganizationsResponse(nullptr) {}
  ~ListOrganizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsResponse(const ListOrganizationsResponse& from);
  ListOrganizationsResponse(ListOrganizationsResponse&& from) noexcept
    : ListOrganizationsResponse() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsResponse& operator=(const ListOrganizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsResponse& operator=(ListOrganizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsResponse*>(
               &_ListOrganizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListOrganizationsResponse& a, ListOrganizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsResponse";
  }
  protected:
  explicit ListOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Organization organizations = 1 [json_name = "organizations"];
  int organizations_size() const;
  private:
  int _internal_organizations_size() const;
  public:
  void clear_organizations();
  ::viam::app::v1::Organization* mutable_organizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >*
      mutable_organizations();
  private:
  const ::viam::app::v1::Organization& _internal_organizations(int index) const;
  ::viam::app::v1::Organization* _internal_add_organizations();
  public:
  const ::viam::app::v1::Organization& organizations(int index) const;
  ::viam::app::v1::Organization* add_organizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >&
      organizations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization > organizations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationInvite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationInvite) */ {
 public:
  inline OrganizationInvite() : OrganizationInvite(nullptr) {}
  ~OrganizationInvite() override;
  explicit PROTOBUF_CONSTEXPR OrganizationInvite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationInvite(const OrganizationInvite& from);
  OrganizationInvite(OrganizationInvite&& from) noexcept
    : OrganizationInvite() {
    *this = ::std::move(from);
  }

  inline OrganizationInvite& operator=(const OrganizationInvite& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationInvite& operator=(OrganizationInvite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationInvite& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationInvite* internal_default_instance() {
    return reinterpret_cast<const OrganizationInvite*>(
               &_OrganizationInvite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OrganizationInvite& a, OrganizationInvite& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationInvite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationInvite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationInvite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationInvite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationInvite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationInvite& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationInvite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationInvite";
  }
  protected:
  explicit OrganizationInvite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 4,
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kCreatedOnFieldNumber = 3,
  };
  // repeated .viam.app.v1.Authorization authorizations = 4 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationInvite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationRequest) */ {
 public:
  inline CreateOrganizationRequest() : CreateOrganizationRequest(nullptr) {}
  ~CreateOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationRequest(const CreateOrganizationRequest& from);
  CreateOrganizationRequest(CreateOrganizationRequest&& from) noexcept
    : CreateOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationRequest& operator=(const CreateOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationRequest& operator=(CreateOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationRequest*>(
               &_CreateOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateOrganizationRequest& a, CreateOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationRequest";
  }
  protected:
  explicit CreateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationResponse) */ {
 public:
  inline CreateOrganizationResponse() : CreateOrganizationResponse(nullptr) {}
  ~CreateOrganizationResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationResponse(const CreateOrganizationResponse& from);
  CreateOrganizationResponse(CreateOrganizationResponse&& from) noexcept
    : CreateOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationResponse& operator=(const CreateOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationResponse& operator=(CreateOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationResponse*>(
               &_CreateOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateOrganizationResponse& a, CreateOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationResponse";
  }
  protected:
  explicit CreateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
  };
  // .viam.app.v1.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::viam::app::v1::Organization& organization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Organization* release_organization();
  ::viam::app::v1::Organization* mutable_organization();
  void set_allocated_organization(::viam::app::v1::Organization* organization);
  private:
  const ::viam::app::v1::Organization& _internal_organization() const;
  ::viam::app::v1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::viam::app::v1::Organization* organization);
  ::viam::app::v1::Organization* unsafe_arena_release_organization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Organization* organization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationRequest) */ {
 public:
  inline GetOrganizationRequest() : GetOrganizationRequest(nullptr) {}
  ~GetOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationRequest(const GetOrganizationRequest& from);
  GetOrganizationRequest(GetOrganizationRequest&& from) noexcept
    : GetOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationRequest& operator=(const GetOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationRequest& operator=(GetOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationRequest*>(
               &_GetOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetOrganizationRequest& a, GetOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationRequest";
  }
  protected:
  explicit GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationResponse) */ {
 public:
  inline GetOrganizationResponse() : GetOrganizationResponse(nullptr) {}
  ~GetOrganizationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationResponse(const GetOrganizationResponse& from);
  GetOrganizationResponse(GetOrganizationResponse&& from) noexcept
    : GetOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationResponse& operator=(const GetOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationResponse& operator=(GetOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationResponse*>(
               &_GetOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetOrganizationResponse& a, GetOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationResponse";
  }
  protected:
  explicit GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
  };
  // .viam.app.v1.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::viam::app::v1::Organization& organization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Organization* release_organization();
  ::viam::app::v1::Organization* mutable_organization();
  void set_allocated_organization(::viam::app::v1::Organization* organization);
  private:
  const ::viam::app::v1::Organization& _internal_organization() const;
  ::viam::app::v1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::viam::app::v1::Organization* organization);
  ::viam::app::v1::Organization* unsafe_arena_release_organization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Organization* organization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationNamespaceAvailabilityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest) */ {
 public:
  inline GetOrganizationNamespaceAvailabilityRequest() : GetOrganizationNamespaceAvailabilityRequest(nullptr) {}
  ~GetOrganizationNamespaceAvailabilityRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationNamespaceAvailabilityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationNamespaceAvailabilityRequest(const GetOrganizationNamespaceAvailabilityRequest& from);
  GetOrganizationNamespaceAvailabilityRequest(GetOrganizationNamespaceAvailabilityRequest&& from) noexcept
    : GetOrganizationNamespaceAvailabilityRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationNamespaceAvailabilityRequest& operator=(const GetOrganizationNamespaceAvailabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationNamespaceAvailabilityRequest& operator=(GetOrganizationNamespaceAvailabilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationNamespaceAvailabilityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationNamespaceAvailabilityRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationNamespaceAvailabilityRequest*>(
               &_GetOrganizationNamespaceAvailabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetOrganizationNamespaceAvailabilityRequest& a, GetOrganizationNamespaceAvailabilityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationNamespaceAvailabilityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationNamespaceAvailabilityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationNamespaceAvailabilityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationNamespaceAvailabilityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationNamespaceAvailabilityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationNamespaceAvailabilityRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationNamespaceAvailabilityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationNamespaceAvailabilityRequest";
  }
  protected:
  explicit GetOrganizationNamespaceAvailabilityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicNamespaceFieldNumber = 1,
  };
  // string public_namespace = 1 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationNamespaceAvailabilityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse) */ {
 public:
  inline GetOrganizationNamespaceAvailabilityResponse() : GetOrganizationNamespaceAvailabilityResponse(nullptr) {}
  ~GetOrganizationNamespaceAvailabilityResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationNamespaceAvailabilityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationNamespaceAvailabilityResponse(const GetOrganizationNamespaceAvailabilityResponse& from);
  GetOrganizationNamespaceAvailabilityResponse(GetOrganizationNamespaceAvailabilityResponse&& from) noexcept
    : GetOrganizationNamespaceAvailabilityResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationNamespaceAvailabilityResponse& operator=(const GetOrganizationNamespaceAvailabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationNamespaceAvailabilityResponse& operator=(GetOrganizationNamespaceAvailabilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationNamespaceAvailabilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationNamespaceAvailabilityResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationNamespaceAvailabilityResponse*>(
               &_GetOrganizationNamespaceAvailabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetOrganizationNamespaceAvailabilityResponse& a, GetOrganizationNamespaceAvailabilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationNamespaceAvailabilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationNamespaceAvailabilityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationNamespaceAvailabilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationNamespaceAvailabilityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationNamespaceAvailabilityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationNamespaceAvailabilityResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationNamespaceAvailabilityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationNamespaceAvailabilityResponse";
  }
  protected:
  explicit GetOrganizationNamespaceAvailabilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableFieldNumber = 1,
  };
  // bool available = 1 [json_name = "available"];
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool available_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationRequest) */ {
 public:
  inline UpdateOrganizationRequest() : UpdateOrganizationRequest(nullptr) {}
  ~UpdateOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationRequest(const UpdateOrganizationRequest& from);
  UpdateOrganizationRequest(UpdateOrganizationRequest&& from) noexcept
    : UpdateOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationRequest& operator=(const UpdateOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationRequest& operator=(UpdateOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationRequest*>(
               &_UpdateOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateOrganizationRequest& a, UpdateOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationRequest";
  }
  protected:
  explicit UpdateOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPublicNamespaceFieldNumber = 3,
    kRegionFieldNumber = 4,
    kCidFieldNumber = 5,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string public_namespace = 3 [json_name = "publicNamespace"];
  bool has_public_namespace() const;
  private:
  bool _internal_has_public_namespace() const;
  public:
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // optional string region = 4 [json_name = "region"];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional string cid = 5 [json_name = "cid"];
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationResponse) */ {
 public:
  inline UpdateOrganizationResponse() : UpdateOrganizationResponse(nullptr) {}
  ~UpdateOrganizationResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationResponse(const UpdateOrganizationResponse& from);
  UpdateOrganizationResponse(UpdateOrganizationResponse&& from) noexcept
    : UpdateOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationResponse& operator=(const UpdateOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationResponse& operator=(UpdateOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationResponse*>(
               &_UpdateOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateOrganizationResponse& a, UpdateOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationResponse";
  }
  protected:
  explicit UpdateOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
  };
  // .viam.app.v1.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::viam::app::v1::Organization& organization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Organization* release_organization();
  ::viam::app::v1::Organization* mutable_organization();
  void set_allocated_organization(::viam::app::v1::Organization* organization);
  private:
  const ::viam::app::v1::Organization& _internal_organization() const;
  ::viam::app::v1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::viam::app::v1::Organization* organization);
  ::viam::app::v1::Organization* unsafe_arena_release_organization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Organization* organization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationRequest) */ {
 public:
  inline DeleteOrganizationRequest() : DeleteOrganizationRequest(nullptr) {}
  ~DeleteOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationRequest(const DeleteOrganizationRequest& from);
  DeleteOrganizationRequest(DeleteOrganizationRequest&& from) noexcept
    : DeleteOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationRequest& operator=(const DeleteOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationRequest& operator=(DeleteOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationRequest*>(
               &_DeleteOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeleteOrganizationRequest& a, DeleteOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationRequest";
  }
  protected:
  explicit DeleteOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationResponse) */ {
 public:
  inline DeleteOrganizationResponse() : DeleteOrganizationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationResponse(const DeleteOrganizationResponse& from);
  DeleteOrganizationResponse(DeleteOrganizationResponse&& from) noexcept
    : DeleteOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationResponse& operator=(const DeleteOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationResponse& operator=(DeleteOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationResponse*>(
               &_DeleteOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteOrganizationResponse& a, DeleteOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteOrganizationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteOrganizationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationResponse";
  }
  protected:
  explicit DeleteOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationMembersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationMembersRequest) */ {
 public:
  inline ListOrganizationMembersRequest() : ListOrganizationMembersRequest(nullptr) {}
  ~ListOrganizationMembersRequest() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationMembersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationMembersRequest(const ListOrganizationMembersRequest& from);
  ListOrganizationMembersRequest(ListOrganizationMembersRequest&& from) noexcept
    : ListOrganizationMembersRequest() {
    *this = ::std::move(from);
  }

  inline ListOrganizationMembersRequest& operator=(const ListOrganizationMembersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationMembersRequest& operator=(ListOrganizationMembersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationMembersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationMembersRequest* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationMembersRequest*>(
               &_ListOrganizationMembersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListOrganizationMembersRequest& a, ListOrganizationMembersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationMembersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationMembersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationMembersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationMembersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationMembersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationMembersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationMembersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationMembersRequest";
  }
  protected:
  explicit ListOrganizationMembersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationMembersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationMembersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationMembersResponse) */ {
 public:
  inline ListOrganizationMembersResponse() : ListOrganizationMembersResponse(nullptr) {}
  ~ListOrganizationMembersResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationMembersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationMembersResponse(const ListOrganizationMembersResponse& from);
  ListOrganizationMembersResponse(ListOrganizationMembersResponse&& from) noexcept
    : ListOrganizationMembersResponse() {
    *this = ::std::move(from);
  }

  inline ListOrganizationMembersResponse& operator=(const ListOrganizationMembersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationMembersResponse& operator=(ListOrganizationMembersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationMembersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationMembersResponse* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationMembersResponse*>(
               &_ListOrganizationMembersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListOrganizationMembersResponse& a, ListOrganizationMembersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationMembersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationMembersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationMembersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationMembersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationMembersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationMembersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationMembersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationMembersResponse";
  }
  protected:
  explicit ListOrganizationMembersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kInvitesFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // repeated .viam.app.v1.OrganizationMember members = 2 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::viam::app::v1::OrganizationMember* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >*
      mutable_members();
  private:
  const ::viam::app::v1::OrganizationMember& _internal_members(int index) const;
  ::viam::app::v1::OrganizationMember* _internal_add_members();
  public:
  const ::viam::app::v1::OrganizationMember& members(int index) const;
  ::viam::app::v1::OrganizationMember* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >&
      members() const;

  // repeated .viam.app.v1.OrganizationInvite invites = 3 [json_name = "invites"];
  int invites_size() const;
  private:
  int _internal_invites_size() const;
  public:
  void clear_invites();
  ::viam::app::v1::OrganizationInvite* mutable_invites(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >*
      mutable_invites();
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invites(int index) const;
  ::viam::app::v1::OrganizationInvite* _internal_add_invites();
  public:
  const ::viam::app::v1::OrganizationInvite& invites(int index) const;
  ::viam::app::v1::OrganizationInvite* add_invites();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >&
      invites() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationMembersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember > members_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite > invites_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationInviteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationInviteRequest) */ {
 public:
  inline CreateOrganizationInviteRequest() : CreateOrganizationInviteRequest(nullptr) {}
  ~CreateOrganizationInviteRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationInviteRequest(const CreateOrganizationInviteRequest& from);
  CreateOrganizationInviteRequest(CreateOrganizationInviteRequest&& from) noexcept
    : CreateOrganizationInviteRequest() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationInviteRequest& operator=(const CreateOrganizationInviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationInviteRequest& operator=(CreateOrganizationInviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationInviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationInviteRequest* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationInviteRequest*>(
               &_CreateOrganizationInviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateOrganizationInviteRequest& a, CreateOrganizationInviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationInviteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationInviteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationInviteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationInviteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationInviteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationInviteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationInviteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationInviteRequest";
  }
  protected:
  explicit CreateOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kSendEmailInviteFieldNumber = 4,
  };
  // repeated .viam.app.v1.Authorization authorizations = 3 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // optional bool send_email_invite = 4 [json_name = "sendEmailInvite"];
  bool has_send_email_invite() const;
  private:
  bool _internal_has_send_email_invite() const;
  public:
  void clear_send_email_invite();
  bool send_email_invite() const;
  void set_send_email_invite(bool value);
  private:
  bool _internal_send_email_invite() const;
  void _internal_set_send_email_invite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationInviteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  bool send_email_invite_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateOrganizationInviteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateOrganizationInviteResponse) */ {
 public:
  inline CreateOrganizationInviteResponse() : CreateOrganizationInviteResponse(nullptr) {}
  ~CreateOrganizationInviteResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOrganizationInviteResponse(const CreateOrganizationInviteResponse& from);
  CreateOrganizationInviteResponse(CreateOrganizationInviteResponse&& from) noexcept
    : CreateOrganizationInviteResponse() {
    *this = ::std::move(from);
  }

  inline CreateOrganizationInviteResponse& operator=(const CreateOrganizationInviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOrganizationInviteResponse& operator=(CreateOrganizationInviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOrganizationInviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOrganizationInviteResponse* internal_default_instance() {
    return reinterpret_cast<const CreateOrganizationInviteResponse*>(
               &_CreateOrganizationInviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateOrganizationInviteResponse& a, CreateOrganizationInviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOrganizationInviteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOrganizationInviteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOrganizationInviteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOrganizationInviteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOrganizationInviteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateOrganizationInviteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOrganizationInviteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateOrganizationInviteResponse";
  }
  protected:
  explicit CreateOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteFieldNumber = 1,
  };
  // .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
  bool has_invite() const;
  private:
  bool _internal_has_invite() const;
  public:
  void clear_invite();
  const ::viam::app::v1::OrganizationInvite& invite() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OrganizationInvite* release_invite();
  ::viam::app::v1::OrganizationInvite* mutable_invite();
  void set_allocated_invite(::viam::app::v1::OrganizationInvite* invite);
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invite() const;
  ::viam::app::v1::OrganizationInvite* _internal_mutable_invite();
  public:
  void unsafe_arena_set_allocated_invite(
      ::viam::app::v1::OrganizationInvite* invite);
  ::viam::app::v1::OrganizationInvite* unsafe_arena_release_invite();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateOrganizationInviteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::OrganizationInvite* invite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationInviteAuthorizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest) */ {
 public:
  inline UpdateOrganizationInviteAuthorizationsRequest() : UpdateOrganizationInviteAuthorizationsRequest(nullptr) {}
  ~UpdateOrganizationInviteAuthorizationsRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationInviteAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationInviteAuthorizationsRequest(const UpdateOrganizationInviteAuthorizationsRequest& from);
  UpdateOrganizationInviteAuthorizationsRequest(UpdateOrganizationInviteAuthorizationsRequest&& from) noexcept
    : UpdateOrganizationInviteAuthorizationsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationInviteAuthorizationsRequest& operator=(const UpdateOrganizationInviteAuthorizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationInviteAuthorizationsRequest& operator=(UpdateOrganizationInviteAuthorizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationInviteAuthorizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationInviteAuthorizationsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationInviteAuthorizationsRequest*>(
               &_UpdateOrganizationInviteAuthorizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UpdateOrganizationInviteAuthorizationsRequest& a, UpdateOrganizationInviteAuthorizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationInviteAuthorizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationInviteAuthorizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationInviteAuthorizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationInviteAuthorizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationInviteAuthorizationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationInviteAuthorizationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationInviteAuthorizationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest";
  }
  protected:
  explicit UpdateOrganizationInviteAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddAuthorizationsFieldNumber = 3,
    kRemoveAuthorizationsFieldNumber = 4,
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
  };
  // repeated .viam.app.v1.Authorization add_authorizations = 3 [json_name = "addAuthorizations"];
  int add_authorizations_size() const;
  private:
  int _internal_add_authorizations_size() const;
  public:
  void clear_add_authorizations();
  ::viam::app::v1::Authorization* mutable_add_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_add_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_add_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& add_authorizations(int index) const;
  ::viam::app::v1::Authorization* add_add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      add_authorizations() const;

  // repeated .viam.app.v1.Authorization remove_authorizations = 4 [json_name = "removeAuthorizations"];
  int remove_authorizations_size() const;
  private:
  int _internal_remove_authorizations_size() const;
  public:
  void clear_remove_authorizations();
  ::viam::app::v1::Authorization* mutable_remove_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_remove_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_remove_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_remove_authorizations();
  public:
  const ::viam::app::v1::Authorization& remove_authorizations(int index) const;
  ::viam::app::v1::Authorization* add_remove_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      remove_authorizations() const;

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > add_authorizations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > remove_authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrganizationInviteAuthorizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse) */ {
 public:
  inline UpdateOrganizationInviteAuthorizationsResponse() : UpdateOrganizationInviteAuthorizationsResponse(nullptr) {}
  ~UpdateOrganizationInviteAuthorizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrganizationInviteAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrganizationInviteAuthorizationsResponse(const UpdateOrganizationInviteAuthorizationsResponse& from);
  UpdateOrganizationInviteAuthorizationsResponse(UpdateOrganizationInviteAuthorizationsResponse&& from) noexcept
    : UpdateOrganizationInviteAuthorizationsResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOrganizationInviteAuthorizationsResponse& operator=(const UpdateOrganizationInviteAuthorizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrganizationInviteAuthorizationsResponse& operator=(UpdateOrganizationInviteAuthorizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrganizationInviteAuthorizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrganizationInviteAuthorizationsResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOrganizationInviteAuthorizationsResponse*>(
               &_UpdateOrganizationInviteAuthorizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UpdateOrganizationInviteAuthorizationsResponse& a, UpdateOrganizationInviteAuthorizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrganizationInviteAuthorizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrganizationInviteAuthorizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrganizationInviteAuthorizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrganizationInviteAuthorizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrganizationInviteAuthorizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateOrganizationInviteAuthorizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrganizationInviteAuthorizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse";
  }
  protected:
  explicit UpdateOrganizationInviteAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteFieldNumber = 1,
  };
  // .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
  bool has_invite() const;
  private:
  bool _internal_has_invite() const;
  public:
  void clear_invite();
  const ::viam::app::v1::OrganizationInvite& invite() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OrganizationInvite* release_invite();
  ::viam::app::v1::OrganizationInvite* mutable_invite();
  void set_allocated_invite(::viam::app::v1::OrganizationInvite* invite);
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invite() const;
  ::viam::app::v1::OrganizationInvite* _internal_mutable_invite();
  public:
  void unsafe_arena_set_allocated_invite(
      ::viam::app::v1::OrganizationInvite* invite);
  ::viam::app::v1::OrganizationInvite* unsafe_arena_release_invite();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::OrganizationInvite* invite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationInviteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationInviteRequest) */ {
 public:
  inline DeleteOrganizationInviteRequest() : DeleteOrganizationInviteRequest(nullptr) {}
  ~DeleteOrganizationInviteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationInviteRequest(const DeleteOrganizationInviteRequest& from);
  DeleteOrganizationInviteRequest(DeleteOrganizationInviteRequest&& from) noexcept
    : DeleteOrganizationInviteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationInviteRequest& operator=(const DeleteOrganizationInviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationInviteRequest& operator=(DeleteOrganizationInviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationInviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationInviteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationInviteRequest*>(
               &_DeleteOrganizationInviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DeleteOrganizationInviteRequest& a, DeleteOrganizationInviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationInviteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationInviteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationInviteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationInviteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOrganizationInviteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteOrganizationInviteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOrganizationInviteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationInviteRequest";
  }
  protected:
  explicit DeleteOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationInviteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationInviteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationInviteResponse) */ {
 public:
  inline DeleteOrganizationInviteResponse() : DeleteOrganizationInviteResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationInviteResponse(const DeleteOrganizationInviteResponse& from);
  DeleteOrganizationInviteResponse(DeleteOrganizationInviteResponse&& from) noexcept
    : DeleteOrganizationInviteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationInviteResponse& operator=(const DeleteOrganizationInviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationInviteResponse& operator=(DeleteOrganizationInviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationInviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationInviteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationInviteResponse*>(
               &_DeleteOrganizationInviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeleteOrganizationInviteResponse& a, DeleteOrganizationInviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationInviteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationInviteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationInviteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationInviteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteOrganizationInviteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteOrganizationInviteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationInviteResponse";
  }
  protected:
  explicit DeleteOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationInviteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ResendOrganizationInviteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ResendOrganizationInviteRequest) */ {
 public:
  inline ResendOrganizationInviteRequest() : ResendOrganizationInviteRequest(nullptr) {}
  ~ResendOrganizationInviteRequest() override;
  explicit PROTOBUF_CONSTEXPR ResendOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResendOrganizationInviteRequest(const ResendOrganizationInviteRequest& from);
  ResendOrganizationInviteRequest(ResendOrganizationInviteRequest&& from) noexcept
    : ResendOrganizationInviteRequest() {
    *this = ::std::move(from);
  }

  inline ResendOrganizationInviteRequest& operator=(const ResendOrganizationInviteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResendOrganizationInviteRequest& operator=(ResendOrganizationInviteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResendOrganizationInviteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResendOrganizationInviteRequest* internal_default_instance() {
    return reinterpret_cast<const ResendOrganizationInviteRequest*>(
               &_ResendOrganizationInviteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResendOrganizationInviteRequest& a, ResendOrganizationInviteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResendOrganizationInviteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResendOrganizationInviteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResendOrganizationInviteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResendOrganizationInviteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResendOrganizationInviteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResendOrganizationInviteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResendOrganizationInviteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ResendOrganizationInviteRequest";
  }
  protected:
  explicit ResendOrganizationInviteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kEmailFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ResendOrganizationInviteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ResendOrganizationInviteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ResendOrganizationInviteResponse) */ {
 public:
  inline ResendOrganizationInviteResponse() : ResendOrganizationInviteResponse(nullptr) {}
  ~ResendOrganizationInviteResponse() override;
  explicit PROTOBUF_CONSTEXPR ResendOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResendOrganizationInviteResponse(const ResendOrganizationInviteResponse& from);
  ResendOrganizationInviteResponse(ResendOrganizationInviteResponse&& from) noexcept
    : ResendOrganizationInviteResponse() {
    *this = ::std::move(from);
  }

  inline ResendOrganizationInviteResponse& operator=(const ResendOrganizationInviteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResendOrganizationInviteResponse& operator=(ResendOrganizationInviteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResendOrganizationInviteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResendOrganizationInviteResponse* internal_default_instance() {
    return reinterpret_cast<const ResendOrganizationInviteResponse*>(
               &_ResendOrganizationInviteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ResendOrganizationInviteResponse& a, ResendOrganizationInviteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResendOrganizationInviteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResendOrganizationInviteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResendOrganizationInviteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResendOrganizationInviteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResendOrganizationInviteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResendOrganizationInviteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResendOrganizationInviteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ResendOrganizationInviteResponse";
  }
  protected:
  explicit ResendOrganizationInviteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteFieldNumber = 1,
  };
  // .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
  bool has_invite() const;
  private:
  bool _internal_has_invite() const;
  public:
  void clear_invite();
  const ::viam::app::v1::OrganizationInvite& invite() const;
  PROTOBUF_NODISCARD ::viam::app::v1::OrganizationInvite* release_invite();
  ::viam::app::v1::OrganizationInvite* mutable_invite();
  void set_allocated_invite(::viam::app::v1::OrganizationInvite* invite);
  private:
  const ::viam::app::v1::OrganizationInvite& _internal_invite() const;
  ::viam::app::v1::OrganizationInvite* _internal_mutable_invite();
  public:
  void unsafe_arena_set_allocated_invite(
      ::viam::app::v1::OrganizationInvite* invite);
  ::viam::app::v1::OrganizationInvite* unsafe_arena_release_invite();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ResendOrganizationInviteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::OrganizationInvite* invite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationMemberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationMemberRequest) */ {
 public:
  inline DeleteOrganizationMemberRequest() : DeleteOrganizationMemberRequest(nullptr) {}
  ~DeleteOrganizationMemberRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationMemberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationMemberRequest(const DeleteOrganizationMemberRequest& from);
  DeleteOrganizationMemberRequest(DeleteOrganizationMemberRequest&& from) noexcept
    : DeleteOrganizationMemberRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationMemberRequest& operator=(const DeleteOrganizationMemberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationMemberRequest& operator=(DeleteOrganizationMemberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationMemberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationMemberRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationMemberRequest*>(
               &_DeleteOrganizationMemberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DeleteOrganizationMemberRequest& a, DeleteOrganizationMemberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationMemberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationMemberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationMemberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationMemberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOrganizationMemberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteOrganizationMemberRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOrganizationMemberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationMemberRequest";
  }
  protected:
  explicit DeleteOrganizationMemberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string user_id = 2 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationMemberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteOrganizationMemberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteOrganizationMemberResponse) */ {
 public:
  inline DeleteOrganizationMemberResponse() : DeleteOrganizationMemberResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteOrganizationMemberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOrganizationMemberResponse(const DeleteOrganizationMemberResponse& from);
  DeleteOrganizationMemberResponse(DeleteOrganizationMemberResponse&& from) noexcept
    : DeleteOrganizationMemberResponse() {
    *this = ::std::move(from);
  }

  inline DeleteOrganizationMemberResponse& operator=(const DeleteOrganizationMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOrganizationMemberResponse& operator=(DeleteOrganizationMemberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOrganizationMemberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOrganizationMemberResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteOrganizationMemberResponse*>(
               &_DeleteOrganizationMemberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeleteOrganizationMemberResponse& a, DeleteOrganizationMemberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOrganizationMemberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOrganizationMemberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOrganizationMemberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOrganizationMemberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteOrganizationMemberResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteOrganizationMemberResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteOrganizationMemberResponse";
  }
  protected:
  explicit DeleteOrganizationMemberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteOrganizationMemberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrganizationIdentity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrganizationIdentity) */ {
 public:
  inline OrganizationIdentity() : OrganizationIdentity(nullptr) {}
  ~OrganizationIdentity() override;
  explicit PROTOBUF_CONSTEXPR OrganizationIdentity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationIdentity(const OrganizationIdentity& from);
  OrganizationIdentity(OrganizationIdentity&& from) noexcept
    : OrganizationIdentity() {
    *this = ::std::move(from);
  }

  inline OrganizationIdentity& operator=(const OrganizationIdentity& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationIdentity& operator=(OrganizationIdentity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationIdentity& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationIdentity* internal_default_instance() {
    return reinterpret_cast<const OrganizationIdentity*>(
               &_OrganizationIdentity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(OrganizationIdentity& a, OrganizationIdentity& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationIdentity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationIdentity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationIdentity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationIdentity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationIdentity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrganizationIdentity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationIdentity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrganizationIdentity";
  }
  protected:
  explicit OrganizationIdentity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrganizationIdentity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationOrganization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationOrganization) */ {
 public:
  inline LocationOrganization() : LocationOrganization(nullptr) {}
  ~LocationOrganization() override;
  explicit PROTOBUF_CONSTEXPR LocationOrganization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationOrganization(const LocationOrganization& from);
  LocationOrganization(LocationOrganization&& from) noexcept
    : LocationOrganization() {
    *this = ::std::move(from);
  }

  inline LocationOrganization& operator=(const LocationOrganization& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationOrganization& operator=(LocationOrganization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationOrganization& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationOrganization* internal_default_instance() {
    return reinterpret_cast<const LocationOrganization*>(
               &_LocationOrganization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LocationOrganization& a, LocationOrganization& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationOrganization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationOrganization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationOrganization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationOrganization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationOrganization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationOrganization& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationOrganization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationOrganization";
  }
  protected:
  explicit LocationOrganization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kPrimaryFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // bool primary = 2 [json_name = "primary"];
  void clear_primary();
  bool primary() const;
  void set_primary(bool value);
  private:
  bool _internal_primary() const;
  void _internal_set_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationOrganization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  bool primary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuth) */ {
 public:
  inline LocationAuth() : LocationAuth(nullptr) {}
  ~LocationAuth() override;
  explicit PROTOBUF_CONSTEXPR LocationAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuth(const LocationAuth& from);
  LocationAuth(LocationAuth&& from) noexcept
    : LocationAuth() {
    *this = ::std::move(from);
  }

  inline LocationAuth& operator=(const LocationAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuth& operator=(LocationAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuth* internal_default_instance() {
    return reinterpret_cast<const LocationAuth*>(
               &_LocationAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LocationAuth& a, LocationAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuth";
  }
  protected:
  explicit LocationAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kSecretFieldNumber = 1,
    kLocationIdFieldNumber = 2,
  };
  // repeated .viam.app.v1.SharedSecret secrets = 3 [json_name = "secrets"];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  ::viam::app::v1::SharedSecret* mutable_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
      mutable_secrets();
  private:
  const ::viam::app::v1::SharedSecret& _internal_secrets(int index) const;
  ::viam::app::v1::SharedSecret* _internal_add_secrets();
  public:
  const ::viam::app::v1::SharedSecret& secrets(int index) const;
  ::viam::app::v1::SharedSecret* add_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
      secrets() const;

  // string secret = 1 [json_name = "secret", deprecated = true];
  PROTOBUF_DEPRECATED void clear_secret();
  PROTOBUF_DEPRECATED const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_secret(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_secret();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_secret();
  PROTOBUF_DEPRECATED void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string location_id = 2 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class StorageConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.StorageConfig) */ {
 public:
  inline StorageConfig() : StorageConfig(nullptr) {}
  ~StorageConfig() override;
  explicit PROTOBUF_CONSTEXPR StorageConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageConfig(const StorageConfig& from);
  StorageConfig(StorageConfig&& from) noexcept
    : StorageConfig() {
    *this = ::std::move(from);
  }

  inline StorageConfig& operator=(const StorageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageConfig& operator=(StorageConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageConfig* internal_default_instance() {
    return reinterpret_cast<const StorageConfig*>(
               &_StorageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(StorageConfig& a, StorageConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StorageConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.StorageConfig";
  }
  protected:
  explicit StorageConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
  };
  // string region = 1 [json_name = "region"];
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.StorageConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Location& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationsFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kParentLocationIdFieldNumber = 4,
    kCreatedOnFieldNumber = 3,
    kAuthFieldNumber = 5,
    kConfigFieldNumber = 8,
    kRobotCountFieldNumber = 7,
  };
  // repeated .viam.app.v1.LocationOrganization organizations = 6 [json_name = "organizations"];
  int organizations_size() const;
  private:
  int _internal_organizations_size() const;
  public:
  void clear_organizations();
  ::viam::app::v1::LocationOrganization* mutable_organizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >*
      mutable_organizations();
  private:
  const ::viam::app::v1::LocationOrganization& _internal_organizations(int index) const;
  ::viam::app::v1::LocationOrganization* _internal_add_organizations();
  public:
  const ::viam::app::v1::LocationOrganization& organizations(int index) const;
  ::viam::app::v1::LocationOrganization* add_organizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >&
      organizations() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string parent_location_id = 4 [json_name = "parentLocationId"];
  void clear_parent_location_id();
  const std::string& parent_location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_location_id();
  PROTOBUF_NODISCARD std::string* release_parent_location_id();
  void set_allocated_parent_location_id(std::string* parent_location_id);
  private:
  const std::string& _internal_parent_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_location_id(const std::string& value);
  std::string* _internal_mutable_parent_location_id();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .viam.app.v1.LocationAuth auth = 5 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // .viam.app.v1.StorageConfig config = 8 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::viam::app::v1::StorageConfig& config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::StorageConfig* release_config();
  ::viam::app::v1::StorageConfig* mutable_config();
  void set_allocated_config(::viam::app::v1::StorageConfig* config);
  private:
  const ::viam::app::v1::StorageConfig& _internal_config() const;
  ::viam::app::v1::StorageConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::viam::app::v1::StorageConfig* config);
  ::viam::app::v1::StorageConfig* unsafe_arena_release_config();

  // int32 robot_count = 7 [json_name = "robotCount"];
  void clear_robot_count();
  int32_t robot_count() const;
  void set_robot_count(int32_t value);
  private:
  int32_t _internal_robot_count() const;
  void _internal_set_robot_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization > organizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_location_id_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  ::viam::app::v1::LocationAuth* auth_;
  ::viam::app::v1::StorageConfig* config_;
  int32_t robot_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class SharedSecret final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SharedSecret) */ {
 public:
  inline SharedSecret() : SharedSecret(nullptr) {}
  ~SharedSecret() override;
  explicit PROTOBUF_CONSTEXPR SharedSecret(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharedSecret(const SharedSecret& from);
  SharedSecret(SharedSecret&& from) noexcept
    : SharedSecret() {
    *this = ::std::move(from);
  }

  inline SharedSecret& operator=(const SharedSecret& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedSecret& operator=(SharedSecret&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SharedSecret& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedSecret* internal_default_instance() {
    return reinterpret_cast<const SharedSecret*>(
               &_SharedSecret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SharedSecret& a, SharedSecret& b) {
    a.Swap(&b);
  }
  inline void Swap(SharedSecret* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedSecret* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedSecret* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharedSecret>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SharedSecret& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SharedSecret& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SharedSecret* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SharedSecret";
  }
  protected:
  explicit SharedSecret(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SharedSecret_State State;
  static constexpr State STATE_UNSPECIFIED =
    SharedSecret_State_STATE_UNSPECIFIED;
  static constexpr State STATE_ENABLED =
    SharedSecret_State_STATE_ENABLED;
  static constexpr State STATE_DISABLED =
    SharedSecret_State_STATE_DISABLED;
  static inline bool State_IsValid(int value) {
    return SharedSecret_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SharedSecret_State_State_MIN;
  static constexpr State State_MAX =
    SharedSecret_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SharedSecret_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SharedSecret_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SharedSecret_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SharedSecret_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSecretFieldNumber = 2,
    kCreatedOnFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"id\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string secret = 2 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\""];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .viam.app.v1.SharedSecret.State state = 4 [json_name = "state", (.tagger.v1.tags) = "bson:\"state\""];
  void clear_state();
  ::viam::app::v1::SharedSecret_State state() const;
  void set_state(::viam::app::v1::SharedSecret_State value);
  private:
  ::viam::app::v1::SharedSecret_State _internal_state() const;
  void _internal_set_state(::viam::app::v1::SharedSecret_State value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.SharedSecret)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationRequest) */ {
 public:
  inline CreateLocationRequest() : CreateLocationRequest(nullptr) {}
  ~CreateLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationRequest(const CreateLocationRequest& from);
  CreateLocationRequest(CreateLocationRequest&& from) noexcept
    : CreateLocationRequest() {
    *this = ::std::move(from);
  }

  inline CreateLocationRequest& operator=(const CreateLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationRequest& operator=(CreateLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateLocationRequest*>(
               &_CreateLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CreateLocationRequest& a, CreateLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationRequest";
  }
  protected:
  explicit CreateLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kParentLocationIdFieldNumber = 3,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string parent_location_id = 3 [json_name = "parentLocationId"];
  bool has_parent_location_id() const;
  private:
  bool _internal_has_parent_location_id() const;
  public:
  void clear_parent_location_id();
  const std::string& parent_location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_location_id();
  PROTOBUF_NODISCARD std::string* release_parent_location_id();
  void set_allocated_parent_location_id(std::string* parent_location_id);
  private:
  const std::string& _internal_parent_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_location_id(const std::string& value);
  std::string* _internal_mutable_parent_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_location_id_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationResponse) */ {
 public:
  inline CreateLocationResponse() : CreateLocationResponse(nullptr) {}
  ~CreateLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationResponse(const CreateLocationResponse& from);
  CreateLocationResponse(CreateLocationResponse&& from) noexcept
    : CreateLocationResponse() {
    *this = ::std::move(from);
  }

  inline CreateLocationResponse& operator=(const CreateLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationResponse& operator=(CreateLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateLocationResponse*>(
               &_CreateLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CreateLocationResponse& a, CreateLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationResponse";
  }
  protected:
  explicit CreateLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // .viam.app.v1.Location location = 1 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::viam::app::v1::Location& location() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Location* release_location();
  ::viam::app::v1::Location* mutable_location();
  void set_allocated_location(::viam::app::v1::Location* location);
  private:
  const ::viam::app::v1::Location& _internal_location() const;
  ::viam::app::v1::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::viam::app::v1::Location* location);
  ::viam::app::v1::Location* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Location* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetLocationRequest) */ {
 public:
  inline GetLocationRequest() : GetLocationRequest(nullptr) {}
  ~GetLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocationRequest(const GetLocationRequest& from);
  GetLocationRequest(GetLocationRequest&& from) noexcept
    : GetLocationRequest() {
    *this = ::std::move(from);
  }

  inline GetLocationRequest& operator=(const GetLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocationRequest& operator=(GetLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocationRequest* internal_default_instance() {
    return reinterpret_cast<const GetLocationRequest*>(
               &_GetLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetLocationRequest& a, GetLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetLocationRequest";
  }
  protected:
  explicit GetLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetLocationResponse) */ {
 public:
  inline GetLocationResponse() : GetLocationResponse(nullptr) {}
  ~GetLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLocationResponse(const GetLocationResponse& from);
  GetLocationResponse(GetLocationResponse&& from) noexcept
    : GetLocationResponse() {
    *this = ::std::move(from);
  }

  inline GetLocationResponse& operator=(const GetLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocationResponse& operator=(GetLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLocationResponse* internal_default_instance() {
    return reinterpret_cast<const GetLocationResponse*>(
               &_GetLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetLocationResponse& a, GetLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetLocationResponse";
  }
  protected:
  explicit GetLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // .viam.app.v1.Location location = 1 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::viam::app::v1::Location& location() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Location* release_location();
  ::viam::app::v1::Location* mutable_location();
  void set_allocated_location(::viam::app::v1::Location* location);
  private:
  const ::viam::app::v1::Location& _internal_location() const;
  ::viam::app::v1::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::viam::app::v1::Location* location);
  ::viam::app::v1::Location* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Location* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateLocationRequest) */ {
 public:
  inline UpdateLocationRequest() : UpdateLocationRequest(nullptr) {}
  ~UpdateLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocationRequest(const UpdateLocationRequest& from);
  UpdateLocationRequest(UpdateLocationRequest&& from) noexcept
    : UpdateLocationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateLocationRequest& operator=(const UpdateLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocationRequest& operator=(UpdateLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateLocationRequest*>(
               &_UpdateLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(UpdateLocationRequest& a, UpdateLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateLocationRequest";
  }
  protected:
  explicit UpdateLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kParentLocationIdFieldNumber = 3,
    kRegionFieldNumber = 4,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string parent_location_id = 3 [json_name = "parentLocationId"];
  bool has_parent_location_id() const;
  private:
  bool _internal_has_parent_location_id() const;
  public:
  void clear_parent_location_id();
  const std::string& parent_location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_location_id();
  PROTOBUF_NODISCARD std::string* release_parent_location_id();
  void set_allocated_parent_location_id(std::string* parent_location_id);
  private:
  const std::string& _internal_parent_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_location_id(const std::string& value);
  std::string* _internal_mutable_parent_location_id();
  public:

  // optional string region = 4 [json_name = "region"];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateLocationResponse) */ {
 public:
  inline UpdateLocationResponse() : UpdateLocationResponse(nullptr) {}
  ~UpdateLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocationResponse(const UpdateLocationResponse& from);
  UpdateLocationResponse(UpdateLocationResponse&& from) noexcept
    : UpdateLocationResponse() {
    *this = ::std::move(from);
  }

  inline UpdateLocationResponse& operator=(const UpdateLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocationResponse& operator=(UpdateLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocationResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateLocationResponse*>(
               &_UpdateLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(UpdateLocationResponse& a, UpdateLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateLocationResponse";
  }
  protected:
  explicit UpdateLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // .viam.app.v1.Location location = 1 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::viam::app::v1::Location& location() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Location* release_location();
  ::viam::app::v1::Location* mutable_location();
  void set_allocated_location(::viam::app::v1::Location* location);
  private:
  const ::viam::app::v1::Location& _internal_location() const;
  ::viam::app::v1::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::viam::app::v1::Location* location);
  ::viam::app::v1::Location* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Location* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationRequest) */ {
 public:
  inline DeleteLocationRequest() : DeleteLocationRequest(nullptr) {}
  ~DeleteLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationRequest(const DeleteLocationRequest& from);
  DeleteLocationRequest(DeleteLocationRequest&& from) noexcept
    : DeleteLocationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteLocationRequest& operator=(const DeleteLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationRequest& operator=(DeleteLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationRequest*>(
               &_DeleteLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DeleteLocationRequest& a, DeleteLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationRequest";
  }
  protected:
  explicit DeleteLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationResponse) */ {
 public:
  inline DeleteLocationResponse() : DeleteLocationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationResponse(const DeleteLocationResponse& from);
  DeleteLocationResponse(DeleteLocationResponse&& from) noexcept
    : DeleteLocationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteLocationResponse& operator=(const DeleteLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationResponse& operator=(DeleteLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationResponse*>(
               &_DeleteLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DeleteLocationResponse& a, DeleteLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationResponse";
  }
  protected:
  explicit DeleteLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationsWithAccessToLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationsWithAccessToLocationRequest) */ {
 public:
  inline GetOrganizationsWithAccessToLocationRequest() : GetOrganizationsWithAccessToLocationRequest(nullptr) {}
  ~GetOrganizationsWithAccessToLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationsWithAccessToLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationsWithAccessToLocationRequest(const GetOrganizationsWithAccessToLocationRequest& from);
  GetOrganizationsWithAccessToLocationRequest(GetOrganizationsWithAccessToLocationRequest&& from) noexcept
    : GetOrganizationsWithAccessToLocationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationsWithAccessToLocationRequest& operator=(const GetOrganizationsWithAccessToLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationsWithAccessToLocationRequest& operator=(GetOrganizationsWithAccessToLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationsWithAccessToLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationsWithAccessToLocationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationsWithAccessToLocationRequest*>(
               &_GetOrganizationsWithAccessToLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(GetOrganizationsWithAccessToLocationRequest& a, GetOrganizationsWithAccessToLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationsWithAccessToLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationsWithAccessToLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationsWithAccessToLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationsWithAccessToLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationsWithAccessToLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationsWithAccessToLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationsWithAccessToLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationsWithAccessToLocationRequest";
  }
  protected:
  explicit GetOrganizationsWithAccessToLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationsWithAccessToLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationsWithAccessToLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetOrganizationsWithAccessToLocationResponse) */ {
 public:
  inline GetOrganizationsWithAccessToLocationResponse() : GetOrganizationsWithAccessToLocationResponse(nullptr) {}
  ~GetOrganizationsWithAccessToLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationsWithAccessToLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationsWithAccessToLocationResponse(const GetOrganizationsWithAccessToLocationResponse& from);
  GetOrganizationsWithAccessToLocationResponse(GetOrganizationsWithAccessToLocationResponse&& from) noexcept
    : GetOrganizationsWithAccessToLocationResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationsWithAccessToLocationResponse& operator=(const GetOrganizationsWithAccessToLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationsWithAccessToLocationResponse& operator=(GetOrganizationsWithAccessToLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationsWithAccessToLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationsWithAccessToLocationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationsWithAccessToLocationResponse*>(
               &_GetOrganizationsWithAccessToLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(GetOrganizationsWithAccessToLocationResponse& a, GetOrganizationsWithAccessToLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationsWithAccessToLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationsWithAccessToLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationsWithAccessToLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationsWithAccessToLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationsWithAccessToLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationsWithAccessToLocationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationsWithAccessToLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetOrganizationsWithAccessToLocationResponse";
  }
  protected:
  explicit GetOrganizationsWithAccessToLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdentitiesFieldNumber = 1,
  };
  // repeated .viam.app.v1.OrganizationIdentity organization_identities = 1 [json_name = "organizationIdentities"];
  int organization_identities_size() const;
  private:
  int _internal_organization_identities_size() const;
  public:
  void clear_organization_identities();
  ::viam::app::v1::OrganizationIdentity* mutable_organization_identities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >*
      mutable_organization_identities();
  private:
  const ::viam::app::v1::OrganizationIdentity& _internal_organization_identities(int index) const;
  ::viam::app::v1::OrganizationIdentity* _internal_add_organization_identities();
  public:
  const ::viam::app::v1::OrganizationIdentity& organization_identities(int index) const;
  ::viam::app::v1::OrganizationIdentity* add_organization_identities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >&
      organization_identities() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetOrganizationsWithAccessToLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity > organization_identities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListLocationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListLocationsRequest) */ {
 public:
  inline ListLocationsRequest() : ListLocationsRequest(nullptr) {}
  ~ListLocationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListLocationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocationsRequest(const ListLocationsRequest& from);
  ListLocationsRequest(ListLocationsRequest&& from) noexcept
    : ListLocationsRequest() {
    *this = ::std::move(from);
  }

  inline ListLocationsRequest& operator=(const ListLocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocationsRequest& operator=(ListLocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListLocationsRequest*>(
               &_ListLocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ListLocationsRequest& a, ListLocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListLocationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListLocationsRequest";
  }
  protected:
  explicit ListLocationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListLocationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ShareLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ShareLocationRequest) */ {
 public:
  inline ShareLocationRequest() : ShareLocationRequest(nullptr) {}
  ~ShareLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR ShareLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareLocationRequest(const ShareLocationRequest& from);
  ShareLocationRequest(ShareLocationRequest&& from) noexcept
    : ShareLocationRequest() {
    *this = ::std::move(from);
  }

  inline ShareLocationRequest& operator=(const ShareLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareLocationRequest& operator=(ShareLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareLocationRequest* internal_default_instance() {
    return reinterpret_cast<const ShareLocationRequest*>(
               &_ShareLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ShareLocationRequest& a, ShareLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShareLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ShareLocationRequest";
  }
  protected:
  explicit ShareLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ShareLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ShareLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.ShareLocationResponse) */ {
 public:
  inline ShareLocationResponse() : ShareLocationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShareLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareLocationResponse(const ShareLocationResponse& from);
  ShareLocationResponse(ShareLocationResponse&& from) noexcept
    : ShareLocationResponse() {
    *this = ::std::move(from);
  }

  inline ShareLocationResponse& operator=(const ShareLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareLocationResponse& operator=(ShareLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareLocationResponse* internal_default_instance() {
    return reinterpret_cast<const ShareLocationResponse*>(
               &_ShareLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ShareLocationResponse& a, ShareLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ShareLocationResponse";
  }
  protected:
  explicit ShareLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.ShareLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UnshareLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UnshareLocationRequest) */ {
 public:
  inline UnshareLocationRequest() : UnshareLocationRequest(nullptr) {}
  ~UnshareLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR UnshareLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnshareLocationRequest(const UnshareLocationRequest& from);
  UnshareLocationRequest(UnshareLocationRequest&& from) noexcept
    : UnshareLocationRequest() {
    *this = ::std::move(from);
  }

  inline UnshareLocationRequest& operator=(const UnshareLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnshareLocationRequest& operator=(UnshareLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnshareLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnshareLocationRequest* internal_default_instance() {
    return reinterpret_cast<const UnshareLocationRequest*>(
               &_UnshareLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(UnshareLocationRequest& a, UnshareLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnshareLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnshareLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnshareLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnshareLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnshareLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnshareLocationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnshareLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UnshareLocationRequest";
  }
  protected:
  explicit UnshareLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UnshareLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UnshareLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UnshareLocationResponse) */ {
 public:
  inline UnshareLocationResponse() : UnshareLocationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UnshareLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnshareLocationResponse(const UnshareLocationResponse& from);
  UnshareLocationResponse(UnshareLocationResponse&& from) noexcept
    : UnshareLocationResponse() {
    *this = ::std::move(from);
  }

  inline UnshareLocationResponse& operator=(const UnshareLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnshareLocationResponse& operator=(UnshareLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnshareLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnshareLocationResponse* internal_default_instance() {
    return reinterpret_cast<const UnshareLocationResponse*>(
               &_UnshareLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(UnshareLocationResponse& a, UnshareLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnshareLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnshareLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnshareLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnshareLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UnshareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UnshareLocationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UnshareLocationResponse";
  }
  protected:
  explicit UnshareLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UnshareLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListLocationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListLocationsResponse) */ {
 public:
  inline ListLocationsResponse() : ListLocationsResponse(nullptr) {}
  ~ListLocationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListLocationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocationsResponse(const ListLocationsResponse& from);
  ListLocationsResponse(ListLocationsResponse&& from) noexcept
    : ListLocationsResponse() {
    *this = ::std::move(from);
  }

  inline ListLocationsResponse& operator=(const ListLocationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocationsResponse& operator=(ListLocationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListLocationsResponse*>(
               &_ListLocationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ListLocationsResponse& a, ListLocationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListLocationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListLocationsResponse";
  }
  protected:
  explicit ListLocationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Location locations = 1 [json_name = "locations"];
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  ::viam::app::v1::Location* mutable_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >*
      mutable_locations();
  private:
  const ::viam::app::v1::Location& _internal_locations(int index) const;
  ::viam::app::v1::Location* _internal_add_locations();
  public:
  const ::viam::app::v1::Location& locations(int index) const;
  ::viam::app::v1::Location* add_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >&
      locations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListLocationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location > locations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationSecretRequest) */ {
 public:
  inline CreateLocationSecretRequest() : CreateLocationSecretRequest(nullptr) {}
  ~CreateLocationSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationSecretRequest(const CreateLocationSecretRequest& from);
  CreateLocationSecretRequest(CreateLocationSecretRequest&& from) noexcept
    : CreateLocationSecretRequest() {
    *this = ::std::move(from);
  }

  inline CreateLocationSecretRequest& operator=(const CreateLocationSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationSecretRequest& operator=(CreateLocationSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationSecretRequest* internal_default_instance() {
    return reinterpret_cast<const CreateLocationSecretRequest*>(
               &_CreateLocationSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CreateLocationSecretRequest& a, CreateLocationSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationSecretRequest";
  }
  protected:
  explicit CreateLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationSecretResponse) */ {
 public:
  inline CreateLocationSecretResponse() : CreateLocationSecretResponse(nullptr) {}
  ~CreateLocationSecretResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationSecretResponse(const CreateLocationSecretResponse& from);
  CreateLocationSecretResponse(CreateLocationSecretResponse&& from) noexcept
    : CreateLocationSecretResponse() {
    *this = ::std::move(from);
  }

  inline CreateLocationSecretResponse& operator=(const CreateLocationSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationSecretResponse& operator=(CreateLocationSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationSecretResponse* internal_default_instance() {
    return reinterpret_cast<const CreateLocationSecretResponse*>(
               &_CreateLocationSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CreateLocationSecretResponse& a, CreateLocationSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationSecretResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateLocationSecretResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationSecretResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationSecretResponse";
  }
  protected:
  explicit CreateLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
  };
  // .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::LocationAuth* auth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationSecretRequest) */ {
 public:
  inline DeleteLocationSecretRequest() : DeleteLocationSecretRequest(nullptr) {}
  ~DeleteLocationSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationSecretRequest(const DeleteLocationSecretRequest& from);
  DeleteLocationSecretRequest(DeleteLocationSecretRequest&& from) noexcept
    : DeleteLocationSecretRequest() {
    *this = ::std::move(from);
  }

  inline DeleteLocationSecretRequest& operator=(const DeleteLocationSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationSecretRequest& operator=(DeleteLocationSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationSecretRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationSecretRequest*>(
               &_DeleteLocationSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(DeleteLocationSecretRequest& a, DeleteLocationSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteLocationSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteLocationSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteLocationSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationSecretRequest";
  }
  protected:
  explicit DeleteLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kSecretIdFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string secret_id = 2 [json_name = "secretId"];
  void clear_secret_id();
  const std::string& secret_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* secret_id);
  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(const std::string& value);
  std::string* _internal_mutable_secret_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationSecretResponse) */ {
 public:
  inline DeleteLocationSecretResponse() : DeleteLocationSecretResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationSecretResponse(const DeleteLocationSecretResponse& from);
  DeleteLocationSecretResponse(DeleteLocationSecretResponse&& from) noexcept
    : DeleteLocationSecretResponse() {
    *this = ::std::move(from);
  }

  inline DeleteLocationSecretResponse& operator=(const DeleteLocationSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationSecretResponse& operator=(DeleteLocationSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationSecretResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationSecretResponse*>(
               &_DeleteLocationSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DeleteLocationSecretResponse& a, DeleteLocationSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteLocationSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteLocationSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationSecretResponse";
  }
  protected:
  explicit DeleteLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuthRequest) */ {
 public:
  inline LocationAuthRequest() : LocationAuthRequest(nullptr) {}
  ~LocationAuthRequest() override;
  explicit PROTOBUF_CONSTEXPR LocationAuthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuthRequest(const LocationAuthRequest& from);
  LocationAuthRequest(LocationAuthRequest&& from) noexcept
    : LocationAuthRequest() {
    *this = ::std::move(from);
  }

  inline LocationAuthRequest& operator=(const LocationAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuthRequest& operator=(LocationAuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuthRequest* internal_default_instance() {
    return reinterpret_cast<const LocationAuthRequest*>(
               &_LocationAuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(LocationAuthRequest& a, LocationAuthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuthRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationAuthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuthRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuthRequest";
  }
  protected:
  explicit LocationAuthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuthResponse) */ {
 public:
  inline LocationAuthResponse() : LocationAuthResponse(nullptr) {}
  ~LocationAuthResponse() override;
  explicit PROTOBUF_CONSTEXPR LocationAuthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuthResponse(const LocationAuthResponse& from);
  LocationAuthResponse(LocationAuthResponse&& from) noexcept
    : LocationAuthResponse() {
    *this = ::std::move(from);
  }

  inline LocationAuthResponse& operator=(const LocationAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuthResponse& operator=(LocationAuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuthResponse* internal_default_instance() {
    return reinterpret_cast<const LocationAuthResponse*>(
               &_LocationAuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(LocationAuthResponse& a, LocationAuthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationAuthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuthResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuthResponse";
  }
  protected:
  explicit LocationAuthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
  };
  // .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::LocationAuth* auth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotRequest) */ {
 public:
  inline GetRobotRequest() : GetRobotRequest(nullptr) {}
  ~GetRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotRequest(const GetRobotRequest& from);
  GetRobotRequest(GetRobotRequest&& from) noexcept
    : GetRobotRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotRequest& operator=(const GetRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotRequest& operator=(GetRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotRequest*>(
               &_GetRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(GetRobotRequest& a, GetRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotRequest";
  }
  protected:
  explicit GetRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRoverRentalRobotsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRoverRentalRobotsRequest) */ {
 public:
  inline GetRoverRentalRobotsRequest() : GetRoverRentalRobotsRequest(nullptr) {}
  ~GetRoverRentalRobotsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRoverRentalRobotsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoverRentalRobotsRequest(const GetRoverRentalRobotsRequest& from);
  GetRoverRentalRobotsRequest(GetRoverRentalRobotsRequest&& from) noexcept
    : GetRoverRentalRobotsRequest() {
    *this = ::std::move(from);
  }

  inline GetRoverRentalRobotsRequest& operator=(const GetRoverRentalRobotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoverRentalRobotsRequest& operator=(GetRoverRentalRobotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoverRentalRobotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoverRentalRobotsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRoverRentalRobotsRequest*>(
               &_GetRoverRentalRobotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(GetRoverRentalRobotsRequest& a, GetRoverRentalRobotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoverRentalRobotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoverRentalRobotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoverRentalRobotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoverRentalRobotsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoverRentalRobotsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRoverRentalRobotsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoverRentalRobotsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRoverRentalRobotsRequest";
  }
  protected:
  explicit GetRoverRentalRobotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRoverRentalRobotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RoverRentalRobot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RoverRentalRobot) */ {
 public:
  inline RoverRentalRobot() : RoverRentalRobot(nullptr) {}
  ~RoverRentalRobot() override;
  explicit PROTOBUF_CONSTEXPR RoverRentalRobot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoverRentalRobot(const RoverRentalRobot& from);
  RoverRentalRobot(RoverRentalRobot&& from) noexcept
    : RoverRentalRobot() {
    *this = ::std::move(from);
  }

  inline RoverRentalRobot& operator=(const RoverRentalRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoverRentalRobot& operator=(RoverRentalRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoverRentalRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoverRentalRobot* internal_default_instance() {
    return reinterpret_cast<const RoverRentalRobot*>(
               &_RoverRentalRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(RoverRentalRobot& a, RoverRentalRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(RoverRentalRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoverRentalRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoverRentalRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoverRentalRobot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoverRentalRobot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoverRentalRobot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoverRentalRobot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RoverRentalRobot";
  }
  protected:
  explicit RoverRentalRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
    kLocationIdFieldNumber = 2,
    kRobotNameFieldNumber = 3,
    kRobotMainPartIdFieldNumber = 4,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string location_id = 2 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string robot_name = 3 [json_name = "robotName"];
  void clear_robot_name();
  const std::string& robot_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_name();
  PROTOBUF_NODISCARD std::string* release_robot_name();
  void set_allocated_robot_name(std::string* robot_name);
  private:
  const std::string& _internal_robot_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_name(const std::string& value);
  std::string* _internal_mutable_robot_name();
  public:

  // string robot_main_part_id = 4 [json_name = "robotMainPartId"];
  void clear_robot_main_part_id();
  const std::string& robot_main_part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_main_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_main_part_id();
  PROTOBUF_NODISCARD std::string* release_robot_main_part_id();
  void set_allocated_robot_main_part_id(std::string* robot_main_part_id);
  private:
  const std::string& _internal_robot_main_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_main_part_id(const std::string& value);
  std::string* _internal_mutable_robot_main_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RoverRentalRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_main_part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRoverRentalRobotsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRoverRentalRobotsResponse) */ {
 public:
  inline GetRoverRentalRobotsResponse() : GetRoverRentalRobotsResponse(nullptr) {}
  ~GetRoverRentalRobotsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRoverRentalRobotsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoverRentalRobotsResponse(const GetRoverRentalRobotsResponse& from);
  GetRoverRentalRobotsResponse(GetRoverRentalRobotsResponse&& from) noexcept
    : GetRoverRentalRobotsResponse() {
    *this = ::std::move(from);
  }

  inline GetRoverRentalRobotsResponse& operator=(const GetRoverRentalRobotsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoverRentalRobotsResponse& operator=(GetRoverRentalRobotsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoverRentalRobotsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoverRentalRobotsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRoverRentalRobotsResponse*>(
               &_GetRoverRentalRobotsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(GetRoverRentalRobotsResponse& a, GetRoverRentalRobotsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoverRentalRobotsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoverRentalRobotsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoverRentalRobotsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoverRentalRobotsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoverRentalRobotsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRoverRentalRobotsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoverRentalRobotsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRoverRentalRobotsResponse";
  }
  protected:
  explicit GetRoverRentalRobotsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
  };
  // repeated .viam.app.v1.RoverRentalRobot robots = 1 [json_name = "robots"];
  int robots_size() const;
  private:
  int _internal_robots_size() const;
  public:
  void clear_robots();
  ::viam::app::v1::RoverRentalRobot* mutable_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >*
      mutable_robots();
  private:
  const ::viam::app::v1::RoverRentalRobot& _internal_robots(int index) const;
  ::viam::app::v1::RoverRentalRobot* _internal_add_robots();
  public:
  const ::viam::app::v1::RoverRentalRobot& robots(int index) const;
  ::viam::app::v1::RoverRentalRobot* add_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >&
      robots() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRoverRentalRobotsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot > robots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotResponse) */ {
 public:
  inline GetRobotResponse() : GetRobotResponse(nullptr) {}
  ~GetRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotResponse(const GetRobotResponse& from);
  GetRobotResponse(GetRobotResponse&& from) noexcept
    : GetRobotResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotResponse& operator=(const GetRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotResponse& operator=(GetRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotResponse*>(
               &_GetRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(GetRobotResponse& a, GetRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotResponse";
  }
  protected:
  explicit GetRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // .viam.app.v1.Robot robot = 1 [json_name = "robot"];
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::viam::app::v1::Robot& robot() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Robot* release_robot();
  ::viam::app::v1::Robot* mutable_robot();
  void set_allocated_robot(::viam::app::v1::Robot* robot);
  private:
  const ::viam::app::v1::Robot& _internal_robot() const;
  ::viam::app::v1::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::viam::app::v1::Robot* robot);
  ::viam::app::v1::Robot* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Robot* robot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartsRequest) */ {
 public:
  inline GetRobotPartsRequest() : GetRobotPartsRequest(nullptr) {}
  ~GetRobotPartsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartsRequest(const GetRobotPartsRequest& from);
  GetRobotPartsRequest(GetRobotPartsRequest&& from) noexcept
    : GetRobotPartsRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartsRequest& operator=(const GetRobotPartsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartsRequest& operator=(GetRobotPartsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartsRequest*>(
               &_GetRobotPartsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(GetRobotPartsRequest& a, GetRobotPartsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartsRequest";
  }
  protected:
  explicit GetRobotPartsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartsResponse) */ {
 public:
  inline GetRobotPartsResponse() : GetRobotPartsResponse(nullptr) {}
  ~GetRobotPartsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartsResponse(const GetRobotPartsResponse& from);
  GetRobotPartsResponse(GetRobotPartsResponse&& from) noexcept
    : GetRobotPartsResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartsResponse& operator=(const GetRobotPartsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartsResponse& operator=(GetRobotPartsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartsResponse*>(
               &_GetRobotPartsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(GetRobotPartsResponse& a, GetRobotPartsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartsResponse";
  }
  protected:
  explicit GetRobotPartsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 1,
  };
  // repeated .viam.app.v1.RobotPart parts = 1 [json_name = "parts"];
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::viam::app::v1::RobotPart* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >*
      mutable_parts();
  private:
  const ::viam::app::v1::RobotPart& _internal_parts(int index) const;
  ::viam::app::v1::RobotPart* _internal_add_parts();
  public:
  const ::viam::app::v1::RobotPart& parts(int index) const;
  ::viam::app::v1::RobotPart* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >&
      parts() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart > parts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartRequest) */ {
 public:
  inline GetRobotPartRequest() : GetRobotPartRequest(nullptr) {}
  ~GetRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartRequest(const GetRobotPartRequest& from);
  GetRobotPartRequest(GetRobotPartRequest&& from) noexcept
    : GetRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartRequest& operator=(const GetRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartRequest& operator=(GetRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartRequest*>(
               &_GetRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(GetRobotPartRequest& a, GetRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartRequest";
  }
  protected:
  explicit GetRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartResponse) */ {
 public:
  inline GetRobotPartResponse() : GetRobotPartResponse(nullptr) {}
  ~GetRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartResponse(const GetRobotPartResponse& from);
  GetRobotPartResponse(GetRobotPartResponse&& from) noexcept
    : GetRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartResponse& operator=(const GetRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartResponse& operator=(GetRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartResponse*>(
               &_GetRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(GetRobotPartResponse& a, GetRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartResponse";
  }
  protected:
  explicit GetRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigJsonFieldNumber = 2,
    kPartFieldNumber = 1,
  };
  // string config_json = 2 [json_name = "configJson"];
  void clear_config_json();
  const std::string& config_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_json();
  PROTOBUF_NODISCARD std::string* release_config_json();
  void set_allocated_config_json(std::string* config_json);
  private:
  const std::string& _internal_config_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_json(const std::string& value);
  std::string* _internal_mutable_config_json();
  public:

  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_json_;
  ::viam::app::v1::RobotPart* part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartLogsRequest) */ {
 public:
  inline GetRobotPartLogsRequest() : GetRobotPartLogsRequest(nullptr) {}
  ~GetRobotPartLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartLogsRequest(const GetRobotPartLogsRequest& from);
  GetRobotPartLogsRequest(GetRobotPartLogsRequest&& from) noexcept
    : GetRobotPartLogsRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartLogsRequest& operator=(const GetRobotPartLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartLogsRequest& operator=(GetRobotPartLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartLogsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartLogsRequest*>(
               &_GetRobotPartLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(GetRobotPartLogsRequest& a, GetRobotPartLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartLogsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartLogsRequest";
  }
  protected:
  explicit GetRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelsFieldNumber = 5,
    kIdFieldNumber = 1,
    kFilterFieldNumber = 3,
    kPageTokenFieldNumber = 4,
    kErrorsOnlyFieldNumber = 2,
  };
  // repeated string levels = 5 [json_name = "levels"];
  int levels_size() const;
  private:
  int _internal_levels_size() const;
  public:
  void clear_levels();
  const std::string& levels(int index) const;
  std::string* mutable_levels(int index);
  void set_levels(int index, const std::string& value);
  void set_levels(int index, std::string&& value);
  void set_levels(int index, const char* value);
  void set_levels(int index, const char* value, size_t size);
  std::string* add_levels();
  void add_levels(const std::string& value);
  void add_levels(std::string&& value);
  void add_levels(const char* value);
  void add_levels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& levels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_levels();
  private:
  const std::string& _internal_levels(int index) const;
  std::string* _internal_add_levels();
  public:

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string filter = 3 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // optional string page_token = 4 [json_name = "pageToken"];
  bool has_page_token() const;
  private:
  bool _internal_has_page_token() const;
  public:
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // bool errors_only = 2 [json_name = "errorsOnly", deprecated = true];
  PROTOBUF_DEPRECATED void clear_errors_only();
  PROTOBUF_DEPRECATED bool errors_only() const;
  PROTOBUF_DEPRECATED void set_errors_only(bool value);
  private:
  bool _internal_errors_only() const;
  void _internal_set_errors_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> levels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  bool errors_only_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartLogsResponse) */ {
 public:
  inline GetRobotPartLogsResponse() : GetRobotPartLogsResponse(nullptr) {}
  ~GetRobotPartLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartLogsResponse(const GetRobotPartLogsResponse& from);
  GetRobotPartLogsResponse(GetRobotPartLogsResponse&& from) noexcept
    : GetRobotPartLogsResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartLogsResponse& operator=(const GetRobotPartLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartLogsResponse& operator=(GetRobotPartLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartLogsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartLogsResponse*>(
               &_GetRobotPartLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(GetRobotPartLogsResponse& a, GetRobotPartLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartLogsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartLogsResponse";
  }
  protected:
  explicit GetRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::common::v1::LogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
      mutable_logs();
  private:
  const ::viam::common::v1::LogEntry& _internal_logs(int index) const;
  ::viam::common::v1::LogEntry* _internal_add_logs();
  public:
  const ::viam::common::v1::LogEntry& logs(int index) const;
  ::viam::common::v1::LogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
      logs() const;

  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry > logs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TailRobotPartLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TailRobotPartLogsRequest) */ {
 public:
  inline TailRobotPartLogsRequest() : TailRobotPartLogsRequest(nullptr) {}
  ~TailRobotPartLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR TailRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailRobotPartLogsRequest(const TailRobotPartLogsRequest& from);
  TailRobotPartLogsRequest(TailRobotPartLogsRequest&& from) noexcept
    : TailRobotPartLogsRequest() {
    *this = ::std::move(from);
  }

  inline TailRobotPartLogsRequest& operator=(const TailRobotPartLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailRobotPartLogsRequest& operator=(TailRobotPartLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailRobotPartLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailRobotPartLogsRequest* internal_default_instance() {
    return reinterpret_cast<const TailRobotPartLogsRequest*>(
               &_TailRobotPartLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(TailRobotPartLogsRequest& a, TailRobotPartLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TailRobotPartLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailRobotPartLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailRobotPartLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailRobotPartLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailRobotPartLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TailRobotPartLogsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailRobotPartLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TailRobotPartLogsRequest";
  }
  protected:
  explicit TailRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kFilterFieldNumber = 3,
    kErrorsOnlyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string filter = 3 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // bool errors_only = 2 [json_name = "errorsOnly"];
  void clear_errors_only();
  bool errors_only() const;
  void set_errors_only(bool value);
  private:
  bool _internal_errors_only() const;
  void _internal_set_errors_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.TailRobotPartLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  bool errors_only_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TailRobotPartLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TailRobotPartLogsResponse) */ {
 public:
  inline TailRobotPartLogsResponse() : TailRobotPartLogsResponse(nullptr) {}
  ~TailRobotPartLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR TailRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailRobotPartLogsResponse(const TailRobotPartLogsResponse& from);
  TailRobotPartLogsResponse(TailRobotPartLogsResponse&& from) noexcept
    : TailRobotPartLogsResponse() {
    *this = ::std::move(from);
  }

  inline TailRobotPartLogsResponse& operator=(const TailRobotPartLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailRobotPartLogsResponse& operator=(TailRobotPartLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailRobotPartLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailRobotPartLogsResponse* internal_default_instance() {
    return reinterpret_cast<const TailRobotPartLogsResponse*>(
               &_TailRobotPartLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(TailRobotPartLogsResponse& a, TailRobotPartLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TailRobotPartLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailRobotPartLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailRobotPartLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailRobotPartLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailRobotPartLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TailRobotPartLogsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailRobotPartLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TailRobotPartLogsResponse";
  }
  protected:
  explicit TailRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
  };
  // repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::common::v1::LogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
      mutable_logs();
  private:
  const ::viam::common::v1::LogEntry& _internal_logs(int index) const;
  ::viam::common::v1::LogEntry* _internal_add_logs();
  public:
  const ::viam::common::v1::LogEntry& logs(int index) const;
  ::viam::common::v1::LogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
      logs() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.TailRobotPartLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry > logs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartHistoryRequest) */ {
 public:
  inline GetRobotPartHistoryRequest() : GetRobotPartHistoryRequest(nullptr) {}
  ~GetRobotPartHistoryRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartHistoryRequest(const GetRobotPartHistoryRequest& from);
  GetRobotPartHistoryRequest(GetRobotPartHistoryRequest&& from) noexcept
    : GetRobotPartHistoryRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartHistoryRequest& operator=(const GetRobotPartHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartHistoryRequest& operator=(GetRobotPartHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartHistoryRequest*>(
               &_GetRobotPartHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(GetRobotPartHistoryRequest& a, GetRobotPartHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartHistoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartHistoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartHistoryRequest";
  }
  protected:
  explicit GetRobotPartHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartHistoryResponse) */ {
 public:
  inline GetRobotPartHistoryResponse() : GetRobotPartHistoryResponse(nullptr) {}
  ~GetRobotPartHistoryResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartHistoryResponse(const GetRobotPartHistoryResponse& from);
  GetRobotPartHistoryResponse(GetRobotPartHistoryResponse&& from) noexcept
    : GetRobotPartHistoryResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartHistoryResponse& operator=(const GetRobotPartHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartHistoryResponse& operator=(GetRobotPartHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartHistoryResponse*>(
               &_GetRobotPartHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(GetRobotPartHistoryResponse& a, GetRobotPartHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartHistoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotPartHistoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartHistoryResponse";
  }
  protected:
  explicit GetRobotPartHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
  };
  // repeated .viam.app.v1.RobotPartHistoryEntry history = 1 [json_name = "history"];
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::viam::app::v1::RobotPartHistoryEntry* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >*
      mutable_history();
  private:
  const ::viam::app::v1::RobotPartHistoryEntry& _internal_history(int index) const;
  ::viam::app::v1::RobotPartHistoryEntry* _internal_add_history();
  public:
  const ::viam::app::v1::RobotPartHistoryEntry& history(int index) const;
  ::viam::app::v1::RobotPartHistoryEntry* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >&
      history() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry > history_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartRequest) */ {
 public:
  inline UpdateRobotPartRequest() : UpdateRobotPartRequest(nullptr) {}
  ~UpdateRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartRequest(const UpdateRobotPartRequest& from);
  UpdateRobotPartRequest(UpdateRobotPartRequest&& from) noexcept
    : UpdateRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartRequest& operator=(const UpdateRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartRequest& operator=(UpdateRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartRequest*>(
               &_UpdateRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(UpdateRobotPartRequest& a, UpdateRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartRequest";
  }
  protected:
  explicit UpdateRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kRobotConfigFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct robot_config = 3 [json_name = "robotConfig"];
  bool has_robot_config() const;
  private:
  bool _internal_has_robot_config() const;
  public:
  void clear_robot_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& robot_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_robot_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_robot_config();
  void set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_robot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_robot_config();
  public:
  void unsafe_arena_set_allocated_robot_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_robot_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* robot_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartResponse) */ {
 public:
  inline UpdateRobotPartResponse() : UpdateRobotPartResponse(nullptr) {}
  ~UpdateRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartResponse(const UpdateRobotPartResponse& from);
  UpdateRobotPartResponse(UpdateRobotPartResponse&& from) noexcept
    : UpdateRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartResponse& operator=(const UpdateRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartResponse& operator=(UpdateRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartResponse*>(
               &_UpdateRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(UpdateRobotPartResponse& a, UpdateRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotPartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartResponse";
  }
  protected:
  explicit UpdateRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RobotPart* part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotPartRequest) */ {
 public:
  inline NewRobotPartRequest() : NewRobotPartRequest(nullptr) {}
  ~NewRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR NewRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotPartRequest(const NewRobotPartRequest& from);
  NewRobotPartRequest(NewRobotPartRequest&& from) noexcept
    : NewRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline NewRobotPartRequest& operator=(const NewRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotPartRequest& operator=(NewRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const NewRobotPartRequest*>(
               &_NewRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(NewRobotPartRequest& a, NewRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotPartRequest";
  }
  protected:
  explicit NewRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
    kPartNameFieldNumber = 2,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string part_name = 2 [json_name = "partName"];
  void clear_part_name();
  const std::string& part_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_name();
  PROTOBUF_NODISCARD std::string* release_part_name();
  void set_allocated_part_name(std::string* part_name);
  private:
  const std::string& _internal_part_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_name(const std::string& value);
  std::string* _internal_mutable_part_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotPartResponse) */ {
 public:
  inline NewRobotPartResponse() : NewRobotPartResponse(nullptr) {}
  ~NewRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR NewRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotPartResponse(const NewRobotPartResponse& from);
  NewRobotPartResponse(NewRobotPartResponse&& from) noexcept
    : NewRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline NewRobotPartResponse& operator=(const NewRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotPartResponse& operator=(NewRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const NewRobotPartResponse*>(
               &_NewRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(NewRobotPartResponse& a, NewRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotPartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotPartResponse";
  }
  protected:
  explicit NewRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartRequest) */ {
 public:
  inline DeleteRobotPartRequest() : DeleteRobotPartRequest(nullptr) {}
  ~DeleteRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartRequest(const DeleteRobotPartRequest& from);
  DeleteRobotPartRequest(DeleteRobotPartRequest&& from) noexcept
    : DeleteRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartRequest& operator=(const DeleteRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartRequest& operator=(DeleteRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartRequest*>(
               &_DeleteRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(DeleteRobotPartRequest& a, DeleteRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRobotPartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartRequest";
  }
  protected:
  explicit DeleteRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotAPIKeysRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotAPIKeysRequest) */ {
 public:
  inline GetRobotAPIKeysRequest() : GetRobotAPIKeysRequest(nullptr) {}
  ~GetRobotAPIKeysRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotAPIKeysRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotAPIKeysRequest(const GetRobotAPIKeysRequest& from);
  GetRobotAPIKeysRequest(GetRobotAPIKeysRequest&& from) noexcept
    : GetRobotAPIKeysRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotAPIKeysRequest& operator=(const GetRobotAPIKeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotAPIKeysRequest& operator=(GetRobotAPIKeysRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotAPIKeysRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotAPIKeysRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotAPIKeysRequest*>(
               &_GetRobotAPIKeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(GetRobotAPIKeysRequest& a, GetRobotAPIKeysRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotAPIKeysRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotAPIKeysRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotAPIKeysRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotAPIKeysRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotAPIKeysRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotAPIKeysRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotAPIKeysRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotAPIKeysRequest";
  }
  protected:
  explicit GetRobotAPIKeysRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotAPIKeysRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class APIKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.APIKey) */ {
 public:
  inline APIKey() : APIKey(nullptr) {}
  ~APIKey() override;
  explicit PROTOBUF_CONSTEXPR APIKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIKey(const APIKey& from);
  APIKey(APIKey&& from) noexcept
    : APIKey() {
    *this = ::std::move(from);
  }

  inline APIKey& operator=(const APIKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIKey& operator=(APIKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIKey* internal_default_instance() {
    return reinterpret_cast<const APIKey*>(
               &_APIKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(APIKey& a, APIKey& b) {
    a.Swap(&b);
  }
  inline void Swap(APIKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const APIKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.APIKey";
  }
  protected:
  explicit APIKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kNameFieldNumber = 3,
    kCreatedOnFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string key = 2 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_on = 4 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.APIKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotAPIKeysResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotAPIKeysResponse) */ {
 public:
  inline GetRobotAPIKeysResponse() : GetRobotAPIKeysResponse(nullptr) {}
  ~GetRobotAPIKeysResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotAPIKeysResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotAPIKeysResponse(const GetRobotAPIKeysResponse& from);
  GetRobotAPIKeysResponse(GetRobotAPIKeysResponse&& from) noexcept
    : GetRobotAPIKeysResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotAPIKeysResponse& operator=(const GetRobotAPIKeysResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotAPIKeysResponse& operator=(GetRobotAPIKeysResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotAPIKeysResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotAPIKeysResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotAPIKeysResponse*>(
               &_GetRobotAPIKeysResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(GetRobotAPIKeysResponse& a, GetRobotAPIKeysResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotAPIKeysResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotAPIKeysResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotAPIKeysResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotAPIKeysResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotAPIKeysResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRobotAPIKeysResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotAPIKeysResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotAPIKeysResponse";
  }
  protected:
  explicit GetRobotAPIKeysResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeysFieldNumber = 1,
  };
  // repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
  int api_keys_size() const;
  private:
  int _internal_api_keys_size() const;
  public:
  void clear_api_keys();
  ::viam::app::v1::APIKeyWithAuthorizations* mutable_api_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
      mutable_api_keys();
  private:
  const ::viam::app::v1::APIKeyWithAuthorizations& _internal_api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* _internal_add_api_keys();
  public:
  const ::viam::app::v1::APIKeyWithAuthorizations& api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* add_api_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
      api_keys() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotAPIKeysResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations > api_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartResponse) */ {
 public:
  inline DeleteRobotPartResponse() : DeleteRobotPartResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartResponse(const DeleteRobotPartResponse& from);
  DeleteRobotPartResponse(DeleteRobotPartResponse&& from) noexcept
    : DeleteRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartResponse& operator=(const DeleteRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartResponse& operator=(DeleteRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartResponse*>(
               &_DeleteRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(DeleteRobotPartResponse& a, DeleteRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotPartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotPartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartResponse";
  }
  protected:
  explicit DeleteRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Fragment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Fragment) */ {
 public:
  inline Fragment() : Fragment(nullptr) {}
  ~Fragment() override;
  explicit PROTOBUF_CONSTEXPR Fragment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fragment(const Fragment& from);
  Fragment(Fragment&& from) noexcept
    : Fragment() {
    *this = ::std::move(from);
  }

  inline Fragment& operator=(const Fragment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fragment& operator=(Fragment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fragment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fragment* internal_default_instance() {
    return reinterpret_cast<const Fragment*>(
               &_Fragment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(Fragment& a, Fragment& b) {
    a.Swap(&b);
  }
  inline void Swap(Fragment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fragment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fragment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fragment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fragment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Fragment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fragment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Fragment";
  }
  protected:
  explicit Fragment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kOrganizationOwnerFieldNumber = 4,
    kOrganizationNameFieldNumber = 7,
    kFragmentFieldNumber = 3,
    kCreatedOnFieldNumber = 6,
    kPublicFieldNumber = 5,
    kOnlyUsedByOwnerFieldNumber = 11,
    kRobotPartCountFieldNumber = 9,
    kOrganizationCountFieldNumber = 10,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string organization_owner = 4 [json_name = "organizationOwner", (.tagger.v1.tags) = "bson:\"organization_owner\" json:\"owner\""];
  void clear_organization_owner();
  const std::string& organization_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_owner();
  PROTOBUF_NODISCARD std::string* release_organization_owner();
  void set_allocated_organization_owner(std::string* organization_owner);
  private:
  const std::string& _internal_organization_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_owner(const std::string& value);
  std::string* _internal_mutable_organization_owner();
  public:

  // string organization_name = 7 [json_name = "organizationName"];
  void clear_organization_name();
  const std::string& organization_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_name();
  PROTOBUF_NODISCARD std::string* release_organization_name();
  void set_allocated_organization_name(std::string* organization_name);
  private:
  const std::string& _internal_organization_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_name(const std::string& value);
  std::string* _internal_mutable_organization_name();
  public:

  // .google.protobuf.Struct fragment = 3 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::PROTOBUF_NAMESPACE_ID::Struct& fragment() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_fragment();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_fragment();
  void set_allocated_fragment(::PROTOBUF_NAMESPACE_ID::Struct* fragment);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_fragment() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::PROTOBUF_NAMESPACE_ID::Struct* fragment);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_fragment();

  // .google.protobuf.Timestamp created_on = 6 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // bool public = 5 [json_name = "public", (.tagger.v1.tags) = "bson:\"public\" json:\"public\""];
  void clear_public_();
  bool public_() const;
  void set_public_(bool value);
  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);
  public:

  // bool only_used_by_owner = 11 [json_name = "onlyUsedByOwner"];
  void clear_only_used_by_owner();
  bool only_used_by_owner() const;
  void set_only_used_by_owner(bool value);
  private:
  bool _internal_only_used_by_owner() const;
  void _internal_set_only_used_by_owner(bool value);
  public:

  // int32 robot_part_count = 9 [json_name = "robotPartCount"];
  void clear_robot_part_count();
  int32_t robot_part_count() const;
  void set_robot_part_count(int32_t value);
  private:
  int32_t _internal_robot_part_count() const;
  void _internal_set_robot_part_count(int32_t value);
  public:

  // int32 organization_count = 10 [json_name = "organizationCount"];
  void clear_organization_count();
  int32_t organization_count() const;
  void set_organization_count(int32_t value);
  private:
  int32_t _internal_organization_count() const;
  void _internal_set_organization_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Fragment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* fragment_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  bool public__;
  bool only_used_by_owner_;
  int32_t robot_part_count_;
  int32_t organization_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListFragmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListFragmentsRequest) */ {
 public:
  inline ListFragmentsRequest() : ListFragmentsRequest(nullptr) {}
  ~ListFragmentsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListFragmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFragmentsRequest(const ListFragmentsRequest& from);
  ListFragmentsRequest(ListFragmentsRequest&& from) noexcept
    : ListFragmentsRequest() {
    *this = ::std::move(from);
  }

  inline ListFragmentsRequest& operator=(const ListFragmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFragmentsRequest& operator=(ListFragmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFragmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFragmentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListFragmentsRequest*>(
               &_ListFragmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(ListFragmentsRequest& a, ListFragmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFragmentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFragmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFragmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFragmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFragmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListFragmentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFragmentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListFragmentsRequest";
  }
  protected:
  explicit ListFragmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kShowPublicFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // bool show_public = 2 [json_name = "showPublic"];
  void clear_show_public();
  bool show_public() const;
  void set_show_public(bool value);
  private:
  bool _internal_show_public() const;
  void _internal_set_show_public(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListFragmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  bool show_public_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListFragmentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListFragmentsResponse) */ {
 public:
  inline ListFragmentsResponse() : ListFragmentsResponse(nullptr) {}
  ~ListFragmentsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListFragmentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFragmentsResponse(const ListFragmentsResponse& from);
  ListFragmentsResponse(ListFragmentsResponse&& from) noexcept
    : ListFragmentsResponse() {
    *this = ::std::move(from);
  }

  inline ListFragmentsResponse& operator=(const ListFragmentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFragmentsResponse& operator=(ListFragmentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFragmentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFragmentsResponse* internal_default_instance() {
    return reinterpret_cast<const ListFragmentsResponse*>(
               &_ListFragmentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(ListFragmentsResponse& a, ListFragmentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFragmentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFragmentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFragmentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFragmentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFragmentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListFragmentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFragmentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListFragmentsResponse";
  }
  protected:
  explicit ListFragmentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;
  public:
  void clear_fragments();
  ::viam::app::v1::Fragment* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
      mutable_fragments();
  private:
  const ::viam::app::v1::Fragment& _internal_fragments(int index) const;
  ::viam::app::v1::Fragment* _internal_add_fragments();
  public:
  const ::viam::app::v1::Fragment& fragments(int index) const;
  ::viam::app::v1::Fragment* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
      fragments() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListFragmentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment > fragments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentRequest) */ {
 public:
  inline GetFragmentRequest() : GetFragmentRequest(nullptr) {}
  ~GetFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentRequest(const GetFragmentRequest& from);
  GetFragmentRequest(GetFragmentRequest&& from) noexcept
    : GetFragmentRequest() {
    *this = ::std::move(from);
  }

  inline GetFragmentRequest& operator=(const GetFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentRequest& operator=(GetFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const GetFragmentRequest*>(
               &_GetFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(GetFragmentRequest& a, GetFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentRequest";
  }
  protected:
  explicit GetFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetFragmentResponse) */ {
 public:
  inline GetFragmentResponse() : GetFragmentResponse(nullptr) {}
  ~GetFragmentResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFragmentResponse(const GetFragmentResponse& from);
  GetFragmentResponse(GetFragmentResponse&& from) noexcept
    : GetFragmentResponse() {
    *this = ::std::move(from);
  }

  inline GetFragmentResponse& operator=(const GetFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFragmentResponse& operator=(GetFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const GetFragmentResponse*>(
               &_GetFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(GetFragmentResponse& a, GetFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFragmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFragmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFragmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetFragmentResponse";
  }
  protected:
  explicit GetFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 1,
  };
  // .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::viam::app::v1::Fragment& fragment() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Fragment* release_fragment();
  ::viam::app::v1::Fragment* mutable_fragment();
  void set_allocated_fragment(::viam::app::v1::Fragment* fragment);
  private:
  const ::viam::app::v1::Fragment& _internal_fragment() const;
  ::viam::app::v1::Fragment* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::viam::app::v1::Fragment* fragment);
  ::viam::app::v1::Fragment* unsafe_arena_release_fragment();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Fragment* fragment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateFragmentRequest) */ {
 public:
  inline CreateFragmentRequest() : CreateFragmentRequest(nullptr) {}
  ~CreateFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFragmentRequest(const CreateFragmentRequest& from);
  CreateFragmentRequest(CreateFragmentRequest&& from) noexcept
    : CreateFragmentRequest() {
    *this = ::std::move(from);
  }

  inline CreateFragmentRequest& operator=(const CreateFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFragmentRequest& operator=(CreateFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const CreateFragmentRequest*>(
               &_CreateFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(CreateFragmentRequest& a, CreateFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateFragmentRequest";
  }
  protected:
  explicit CreateFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kOrganizationIdFieldNumber = 3,
    kConfigFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string organization_id = 3 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // .google.protobuf.Struct config = 2 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_config();
  void set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::Struct* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateFragmentResponse) */ {
 public:
  inline CreateFragmentResponse() : CreateFragmentResponse(nullptr) {}
  ~CreateFragmentResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFragmentResponse(const CreateFragmentResponse& from);
  CreateFragmentResponse(CreateFragmentResponse&& from) noexcept
    : CreateFragmentResponse() {
    *this = ::std::move(from);
  }

  inline CreateFragmentResponse& operator=(const CreateFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFragmentResponse& operator=(CreateFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const CreateFragmentResponse*>(
               &_CreateFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(CreateFragmentResponse& a, CreateFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFragmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateFragmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFragmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateFragmentResponse";
  }
  protected:
  explicit CreateFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 1,
  };
  // .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::viam::app::v1::Fragment& fragment() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Fragment* release_fragment();
  ::viam::app::v1::Fragment* mutable_fragment();
  void set_allocated_fragment(::viam::app::v1::Fragment* fragment);
  private:
  const ::viam::app::v1::Fragment& _internal_fragment() const;
  ::viam::app::v1::Fragment* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::viam::app::v1::Fragment* fragment);
  ::viam::app::v1::Fragment* unsafe_arena_release_fragment();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Fragment* fragment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateFragmentRequest) */ {
 public:
  inline UpdateFragmentRequest() : UpdateFragmentRequest(nullptr) {}
  ~UpdateFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFragmentRequest(const UpdateFragmentRequest& from);
  UpdateFragmentRequest(UpdateFragmentRequest&& from) noexcept
    : UpdateFragmentRequest() {
    *this = ::std::move(from);
  }

  inline UpdateFragmentRequest& operator=(const UpdateFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFragmentRequest& operator=(UpdateFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateFragmentRequest*>(
               &_UpdateFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(UpdateFragmentRequest& a, UpdateFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateFragmentRequest";
  }
  protected:
  explicit UpdateFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kConfigFieldNumber = 3,
    kPublicFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct config = 3 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_config();
  void set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_config();

  // optional bool public = 4 [json_name = "public"];
  bool has_public_() const;
  private:
  bool _internal_has_public_() const;
  public:
  void clear_public_();
  bool public_() const;
  void set_public_(bool value);
  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Struct* config_;
  bool public__;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateFragmentResponse) */ {
 public:
  inline UpdateFragmentResponse() : UpdateFragmentResponse(nullptr) {}
  ~UpdateFragmentResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFragmentResponse(const UpdateFragmentResponse& from);
  UpdateFragmentResponse(UpdateFragmentResponse&& from) noexcept
    : UpdateFragmentResponse() {
    *this = ::std::move(from);
  }

  inline UpdateFragmentResponse& operator=(const UpdateFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFragmentResponse& operator=(UpdateFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateFragmentResponse*>(
               &_UpdateFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(UpdateFragmentResponse& a, UpdateFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateFragmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateFragmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFragmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateFragmentResponse";
  }
  protected:
  explicit UpdateFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 1,
  };
  // .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::viam::app::v1::Fragment& fragment() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Fragment* release_fragment();
  ::viam::app::v1::Fragment* mutable_fragment();
  void set_allocated_fragment(::viam::app::v1::Fragment* fragment);
  private:
  const ::viam::app::v1::Fragment& _internal_fragment() const;
  ::viam::app::v1::Fragment* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::viam::app::v1::Fragment* fragment);
  ::viam::app::v1::Fragment* unsafe_arena_release_fragment();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Fragment* fragment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteFragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteFragmentRequest) */ {
 public:
  inline DeleteFragmentRequest() : DeleteFragmentRequest(nullptr) {}
  ~DeleteFragmentRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFragmentRequest(const DeleteFragmentRequest& from);
  DeleteFragmentRequest(DeleteFragmentRequest&& from) noexcept
    : DeleteFragmentRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFragmentRequest& operator=(const DeleteFragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFragmentRequest& operator=(DeleteFragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFragmentRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFragmentRequest*>(
               &_DeleteFragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(DeleteFragmentRequest& a, DeleteFragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFragmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFragmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFragmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFragmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteFragmentRequest";
  }
  protected:
  explicit DeleteFragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteFragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteFragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteFragmentResponse) */ {
 public:
  inline DeleteFragmentResponse() : DeleteFragmentResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteFragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFragmentResponse(const DeleteFragmentResponse& from);
  DeleteFragmentResponse(DeleteFragmentResponse&& from) noexcept
    : DeleteFragmentResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFragmentResponse& operator=(const DeleteFragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFragmentResponse& operator=(DeleteFragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFragmentResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFragmentResponse*>(
               &_DeleteFragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(DeleteFragmentResponse& a, DeleteFragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFragmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteFragmentResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteFragmentResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteFragmentResponse";
  }
  protected:
  explicit DeleteFragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteFragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsRequest) */ {
 public:
  inline ListRobotsRequest() : ListRobotsRequest(nullptr) {}
  ~ListRobotsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsRequest(const ListRobotsRequest& from);
  ListRobotsRequest(ListRobotsRequest&& from) noexcept
    : ListRobotsRequest() {
    *this = ::std::move(from);
  }

  inline ListRobotsRequest& operator=(const ListRobotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsRequest& operator=(ListRobotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRobotsRequest*>(
               &_ListRobotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(ListRobotsRequest& a, ListRobotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsRequest";
  }
  protected:
  explicit ListRobotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRobotsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRobotsResponse) */ {
 public:
  inline ListRobotsResponse() : ListRobotsResponse(nullptr) {}
  ~ListRobotsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRobotsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRobotsResponse(const ListRobotsResponse& from);
  ListRobotsResponse(ListRobotsResponse&& from) noexcept
    : ListRobotsResponse() {
    *this = ::std::move(from);
  }

  inline ListRobotsResponse& operator=(const ListRobotsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRobotsResponse& operator=(ListRobotsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRobotsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRobotsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRobotsResponse*>(
               &_ListRobotsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(ListRobotsResponse& a, ListRobotsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRobotsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRobotsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRobotsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRobotsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRobotsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRobotsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRobotsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRobotsResponse";
  }
  protected:
  explicit ListRobotsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
  int robots_size() const;
  private:
  int _internal_robots_size() const;
  public:
  void clear_robots();
  ::viam::app::v1::Robot* mutable_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
      mutable_robots();
  private:
  const ::viam::app::v1::Robot& _internal_robots(int index) const;
  ::viam::app::v1::Robot* _internal_add_robots();
  public:
  const ::viam::app::v1::Robot& robots(int index) const;
  ::viam::app::v1::Robot* add_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
      robots() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRobotsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot > robots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotRequest) */ {
 public:
  inline NewRobotRequest() : NewRobotRequest(nullptr) {}
  ~NewRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR NewRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotRequest(const NewRobotRequest& from);
  NewRobotRequest(NewRobotRequest&& from) noexcept
    : NewRobotRequest() {
    *this = ::std::move(from);
  }

  inline NewRobotRequest& operator=(const NewRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotRequest& operator=(NewRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotRequest* internal_default_instance() {
    return reinterpret_cast<const NewRobotRequest*>(
               &_NewRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(NewRobotRequest& a, NewRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotRequest";
  }
  protected:
  explicit NewRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 2 [json_name = "location"];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotResponse) */ {
 public:
  inline NewRobotResponse() : NewRobotResponse(nullptr) {}
  ~NewRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR NewRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotResponse(const NewRobotResponse& from);
  NewRobotResponse(NewRobotResponse&& from) noexcept
    : NewRobotResponse() {
    *this = ::std::move(from);
  }

  inline NewRobotResponse& operator=(const NewRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotResponse& operator=(NewRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotResponse* internal_default_instance() {
    return reinterpret_cast<const NewRobotResponse*>(
               &_NewRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(NewRobotResponse& a, NewRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewRobotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotResponse";
  }
  protected:
  explicit NewRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotRequest) */ {
 public:
  inline UpdateRobotRequest() : UpdateRobotRequest(nullptr) {}
  ~UpdateRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotRequest(const UpdateRobotRequest& from);
  UpdateRobotRequest(UpdateRobotRequest&& from) noexcept
    : UpdateRobotRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotRequest& operator=(const UpdateRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotRequest& operator=(UpdateRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotRequest*>(
               &_UpdateRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(UpdateRobotRequest& a, UpdateRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotRequest";
  }
  protected:
  explicit UpdateRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLocationFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 3 [json_name = "location"];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotResponse) */ {
 public:
  inline UpdateRobotResponse() : UpdateRobotResponse(nullptr) {}
  ~UpdateRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotResponse(const UpdateRobotResponse& from);
  UpdateRobotResponse(UpdateRobotResponse&& from) noexcept
    : UpdateRobotResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotResponse& operator=(const UpdateRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotResponse& operator=(UpdateRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotResponse*>(
               &_UpdateRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(UpdateRobotResponse& a, UpdateRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRobotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotResponse";
  }
  protected:
  explicit UpdateRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // .viam.app.v1.Robot robot = 1 [json_name = "robot"];
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::viam::app::v1::Robot& robot() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Robot* release_robot();
  ::viam::app::v1::Robot* mutable_robot();
  void set_allocated_robot(::viam::app::v1::Robot* robot);
  private:
  const ::viam::app::v1::Robot& _internal_robot() const;
  ::viam::app::v1::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::viam::app::v1::Robot* robot);
  ::viam::app::v1::Robot* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Robot* robot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotRequest) */ {
 public:
  inline DeleteRobotRequest() : DeleteRobotRequest(nullptr) {}
  ~DeleteRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotRequest(const DeleteRobotRequest& from);
  DeleteRobotRequest(DeleteRobotRequest&& from) noexcept
    : DeleteRobotRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotRequest& operator=(const DeleteRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotRequest& operator=(DeleteRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotRequest*>(
               &_DeleteRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(DeleteRobotRequest& a, DeleteRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRobotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotRequest";
  }
  protected:
  explicit DeleteRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotResponse) */ {
 public:
  inline DeleteRobotResponse() : DeleteRobotResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotResponse(const DeleteRobotResponse& from);
  DeleteRobotResponse(DeleteRobotResponse&& from) noexcept
    : DeleteRobotResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotResponse& operator=(const DeleteRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotResponse& operator=(DeleteRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotResponse*>(
               &_DeleteRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(DeleteRobotResponse& a, DeleteRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotResponse";
  }
  protected:
  explicit DeleteRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartAsMainRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartAsMainRequest) */ {
 public:
  inline MarkPartAsMainRequest() : MarkPartAsMainRequest(nullptr) {}
  ~MarkPartAsMainRequest() override;
  explicit PROTOBUF_CONSTEXPR MarkPartAsMainRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartAsMainRequest(const MarkPartAsMainRequest& from);
  MarkPartAsMainRequest(MarkPartAsMainRequest&& from) noexcept
    : MarkPartAsMainRequest() {
    *this = ::std::move(from);
  }

  inline MarkPartAsMainRequest& operator=(const MarkPartAsMainRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartAsMainRequest& operator=(MarkPartAsMainRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartAsMainRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartAsMainRequest* internal_default_instance() {
    return reinterpret_cast<const MarkPartAsMainRequest*>(
               &_MarkPartAsMainRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(MarkPartAsMainRequest& a, MarkPartAsMainRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartAsMainRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartAsMainRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartAsMainRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartAsMainRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkPartAsMainRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarkPartAsMainRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkPartAsMainRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartAsMainRequest";
  }
  protected:
  explicit MarkPartAsMainRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartAsMainRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartAsMainResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartAsMainResponse) */ {
 public:
  inline MarkPartAsMainResponse() : MarkPartAsMainResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MarkPartAsMainResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartAsMainResponse(const MarkPartAsMainResponse& from);
  MarkPartAsMainResponse(MarkPartAsMainResponse&& from) noexcept
    : MarkPartAsMainResponse() {
    *this = ::std::move(from);
  }

  inline MarkPartAsMainResponse& operator=(const MarkPartAsMainResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartAsMainResponse& operator=(MarkPartAsMainResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartAsMainResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartAsMainResponse* internal_default_instance() {
    return reinterpret_cast<const MarkPartAsMainResponse*>(
               &_MarkPartAsMainResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(MarkPartAsMainResponse& a, MarkPartAsMainResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartAsMainResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartAsMainResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartAsMainResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartAsMainResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MarkPartAsMainResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MarkPartAsMainResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartAsMainResponse";
  }
  protected:
  explicit MarkPartAsMainResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartAsMainResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartForRestartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartForRestartRequest) */ {
 public:
  inline MarkPartForRestartRequest() : MarkPartForRestartRequest(nullptr) {}
  ~MarkPartForRestartRequest() override;
  explicit PROTOBUF_CONSTEXPR MarkPartForRestartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartForRestartRequest(const MarkPartForRestartRequest& from);
  MarkPartForRestartRequest(MarkPartForRestartRequest&& from) noexcept
    : MarkPartForRestartRequest() {
    *this = ::std::move(from);
  }

  inline MarkPartForRestartRequest& operator=(const MarkPartForRestartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartForRestartRequest& operator=(MarkPartForRestartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartForRestartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartForRestartRequest* internal_default_instance() {
    return reinterpret_cast<const MarkPartForRestartRequest*>(
               &_MarkPartForRestartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(MarkPartForRestartRequest& a, MarkPartForRestartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartForRestartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartForRestartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartForRestartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartForRestartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkPartForRestartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarkPartForRestartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkPartForRestartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartForRestartRequest";
  }
  protected:
  explicit MarkPartForRestartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartForRestartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartForRestartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartForRestartResponse) */ {
 public:
  inline MarkPartForRestartResponse() : MarkPartForRestartResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MarkPartForRestartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartForRestartResponse(const MarkPartForRestartResponse& from);
  MarkPartForRestartResponse(MarkPartForRestartResponse&& from) noexcept
    : MarkPartForRestartResponse() {
    *this = ::std::move(from);
  }

  inline MarkPartForRestartResponse& operator=(const MarkPartForRestartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartForRestartResponse& operator=(MarkPartForRestartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartForRestartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartForRestartResponse* internal_default_instance() {
    return reinterpret_cast<const MarkPartForRestartResponse*>(
               &_MarkPartForRestartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(MarkPartForRestartResponse& a, MarkPartForRestartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartForRestartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartForRestartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartForRestartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartForRestartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MarkPartForRestartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MarkPartForRestartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartForRestartResponse";
  }
  protected:
  explicit MarkPartForRestartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartForRestartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRobotPartSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRobotPartSecretRequest) */ {
 public:
  inline CreateRobotPartSecretRequest() : CreateRobotPartSecretRequest(nullptr) {}
  ~CreateRobotPartSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRobotPartSecretRequest(const CreateRobotPartSecretRequest& from);
  CreateRobotPartSecretRequest(CreateRobotPartSecretRequest&& from) noexcept
    : CreateRobotPartSecretRequest() {
    *this = ::std::move(from);
  }

  inline CreateRobotPartSecretRequest& operator=(const CreateRobotPartSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRobotPartSecretRequest& operator=(CreateRobotPartSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRobotPartSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRobotPartSecretRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRobotPartSecretRequest*>(
               &_CreateRobotPartSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(CreateRobotPartSecretRequest& a, CreateRobotPartSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRobotPartSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRobotPartSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRobotPartSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRobotPartSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRobotPartSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRobotPartSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRobotPartSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRobotPartSecretRequest";
  }
  protected:
  explicit CreateRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRobotPartSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRobotPartSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRobotPartSecretResponse) */ {
 public:
  inline CreateRobotPartSecretResponse() : CreateRobotPartSecretResponse(nullptr) {}
  ~CreateRobotPartSecretResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRobotPartSecretResponse(const CreateRobotPartSecretResponse& from);
  CreateRobotPartSecretResponse(CreateRobotPartSecretResponse&& from) noexcept
    : CreateRobotPartSecretResponse() {
    *this = ::std::move(from);
  }

  inline CreateRobotPartSecretResponse& operator=(const CreateRobotPartSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRobotPartSecretResponse& operator=(CreateRobotPartSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRobotPartSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRobotPartSecretResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRobotPartSecretResponse*>(
               &_CreateRobotPartSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(CreateRobotPartSecretResponse& a, CreateRobotPartSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRobotPartSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRobotPartSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRobotPartSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRobotPartSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRobotPartSecretResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRobotPartSecretResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRobotPartSecretResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRobotPartSecretResponse";
  }
  protected:
  explicit CreateRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRobotPartSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RobotPart* part_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartSecretRequest) */ {
 public:
  inline DeleteRobotPartSecretRequest() : DeleteRobotPartSecretRequest(nullptr) {}
  ~DeleteRobotPartSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartSecretRequest(const DeleteRobotPartSecretRequest& from);
  DeleteRobotPartSecretRequest(DeleteRobotPartSecretRequest&& from) noexcept
    : DeleteRobotPartSecretRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartSecretRequest& operator=(const DeleteRobotPartSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartSecretRequest& operator=(DeleteRobotPartSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartSecretRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartSecretRequest*>(
               &_DeleteRobotPartSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(DeleteRobotPartSecretRequest& a, DeleteRobotPartSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotPartSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRobotPartSecretRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotPartSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartSecretRequest";
  }
  protected:
  explicit DeleteRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
    kSecretIdFieldNumber = 2,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string secret_id = 2 [json_name = "secretId"];
  void clear_secret_id();
  const std::string& secret_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* secret_id);
  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(const std::string& value);
  std::string* _internal_mutable_secret_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartSecretResponse) */ {
 public:
  inline DeleteRobotPartSecretResponse() : DeleteRobotPartSecretResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartSecretResponse(const DeleteRobotPartSecretResponse& from);
  DeleteRobotPartSecretResponse(DeleteRobotPartSecretResponse&& from) noexcept
    : DeleteRobotPartSecretResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartSecretResponse& operator=(const DeleteRobotPartSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartSecretResponse& operator=(DeleteRobotPartSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartSecretResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartSecretResponse*>(
               &_DeleteRobotPartSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(DeleteRobotPartSecretResponse& a, DeleteRobotPartSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotPartSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotPartSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartSecretResponse";
  }
  protected:
  explicit DeleteRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Authorization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Authorization) */ {
 public:
  inline Authorization() : Authorization(nullptr) {}
  ~Authorization() override;
  explicit PROTOBUF_CONSTEXPR Authorization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Authorization(const Authorization& from);
  Authorization(Authorization&& from) noexcept
    : Authorization() {
    *this = ::std::move(from);
  }

  inline Authorization& operator=(const Authorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Authorization& operator=(Authorization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Authorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const Authorization* internal_default_instance() {
    return reinterpret_cast<const Authorization*>(
               &_Authorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(Authorization& a, Authorization& b) {
    a.Swap(&b);
  }
  inline void Swap(Authorization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Authorization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Authorization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Authorization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Authorization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Authorization& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authorization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Authorization";
  }
  protected:
  explicit Authorization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationTypeFieldNumber = 1,
    kAuthorizationIdFieldNumber = 2,
    kResourceTypeFieldNumber = 3,
    kResourceIdFieldNumber = 4,
    kIdentityIdFieldNumber = 5,
    kOrganizationIdFieldNumber = 6,
    kIdentityTypeFieldNumber = 7,
  };
  // string authorization_type = 1 [json_name = "authorizationType"];
  void clear_authorization_type();
  const std::string& authorization_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_type();
  PROTOBUF_NODISCARD std::string* release_authorization_type();
  void set_allocated_authorization_type(std::string* authorization_type);
  private:
  const std::string& _internal_authorization_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_type(const std::string& value);
  std::string* _internal_mutable_authorization_type();
  public:

  // string authorization_id = 2 [json_name = "authorizationId"];
  void clear_authorization_id();
  const std::string& authorization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_id();
  PROTOBUF_NODISCARD std::string* release_authorization_id();
  void set_allocated_authorization_id(std::string* authorization_id);
  private:
  const std::string& _internal_authorization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_id(const std::string& value);
  std::string* _internal_mutable_authorization_id();
  public:

  // string resource_type = 3 [json_name = "resourceType"];
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string resource_id = 4 [json_name = "resourceId"];
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string identity_id = 5 [json_name = "identityId"];
  void clear_identity_id();
  const std::string& identity_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity_id();
  PROTOBUF_NODISCARD std::string* release_identity_id();
  void set_allocated_identity_id(std::string* identity_id);
  private:
  const std::string& _internal_identity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_id(const std::string& value);
  std::string* _internal_mutable_identity_id();
  public:

  // string organization_id = 6 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string identity_type = 7 [json_name = "identityType"];
  void clear_identity_type();
  const std::string& identity_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity_type();
  PROTOBUF_NODISCARD std::string* release_identity_type();
  void set_allocated_identity_type(std::string* identity_type);
  private:
  const std::string& _internal_identity_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_type(const std::string& value);
  std::string* _internal_mutable_identity_type();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Authorization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AddRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AddRoleRequest) */ {
 public:
  inline AddRoleRequest() : AddRoleRequest(nullptr) {}
  ~AddRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR AddRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRoleRequest(const AddRoleRequest& from);
  AddRoleRequest(AddRoleRequest&& from) noexcept
    : AddRoleRequest() {
    *this = ::std::move(from);
  }

  inline AddRoleRequest& operator=(const AddRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRoleRequest& operator=(AddRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRoleRequest* internal_default_instance() {
    return reinterpret_cast<const AddRoleRequest*>(
               &_AddRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(AddRoleRequest& a, AddRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddRoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AddRoleRequest";
  }
  protected:
  explicit AddRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationFieldNumber = 1,
  };
  // .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
  bool has_authorization() const;
  private:
  bool _internal_has_authorization() const;
  public:
  void clear_authorization();
  const ::viam::app::v1::Authorization& authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_authorization();
  ::viam::app::v1::Authorization* mutable_authorization();
  void set_allocated_authorization(::viam::app::v1::Authorization* authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_authorization();
  public:
  void unsafe_arena_set_allocated_authorization(
      ::viam::app::v1::Authorization* authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_authorization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.AddRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Authorization* authorization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AddRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.AddRoleResponse) */ {
 public:
  inline AddRoleResponse() : AddRoleResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRoleResponse(const AddRoleResponse& from);
  AddRoleResponse(AddRoleResponse&& from) noexcept
    : AddRoleResponse() {
    *this = ::std::move(from);
  }

  inline AddRoleResponse& operator=(const AddRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRoleResponse& operator=(AddRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRoleResponse* internal_default_instance() {
    return reinterpret_cast<const AddRoleResponse*>(
               &_AddRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(AddRoleResponse& a, AddRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AddRoleResponse";
  }
  protected:
  explicit AddRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.AddRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RemoveRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoveRoleRequest) */ {
 public:
  inline RemoveRoleRequest() : RemoveRoleRequest(nullptr) {}
  ~RemoveRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRoleRequest(const RemoveRoleRequest& from);
  RemoveRoleRequest(RemoveRoleRequest&& from) noexcept
    : RemoveRoleRequest() {
    *this = ::std::move(from);
  }

  inline RemoveRoleRequest& operator=(const RemoveRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRoleRequest& operator=(RemoveRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRoleRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveRoleRequest*>(
               &_RemoveRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(RemoveRoleRequest& a, RemoveRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveRoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RemoveRoleRequest";
  }
  protected:
  explicit RemoveRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationFieldNumber = 1,
  };
  // .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
  bool has_authorization() const;
  private:
  bool _internal_has_authorization() const;
  public:
  void clear_authorization();
  const ::viam::app::v1::Authorization& authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_authorization();
  ::viam::app::v1::Authorization* mutable_authorization();
  void set_allocated_authorization(::viam::app::v1::Authorization* authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_authorization();
  public:
  void unsafe_arena_set_allocated_authorization(
      ::viam::app::v1::Authorization* authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_authorization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoveRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Authorization* authorization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RemoveRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoveRoleResponse) */ {
 public:
  inline RemoveRoleResponse() : RemoveRoleResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RemoveRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRoleResponse(const RemoveRoleResponse& from);
  RemoveRoleResponse(RemoveRoleResponse&& from) noexcept
    : RemoveRoleResponse() {
    *this = ::std::move(from);
  }

  inline RemoveRoleResponse& operator=(const RemoveRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRoleResponse& operator=(RemoveRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRoleResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveRoleResponse*>(
               &_RemoveRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(RemoveRoleResponse& a, RemoveRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RemoveRoleResponse";
  }
  protected:
  explicit RemoveRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoveRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ChangeRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ChangeRoleRequest) */ {
 public:
  inline ChangeRoleRequest() : ChangeRoleRequest(nullptr) {}
  ~ChangeRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR ChangeRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeRoleRequest(const ChangeRoleRequest& from);
  ChangeRoleRequest(ChangeRoleRequest&& from) noexcept
    : ChangeRoleRequest() {
    *this = ::std::move(from);
  }

  inline ChangeRoleRequest& operator=(const ChangeRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeRoleRequest& operator=(ChangeRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeRoleRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeRoleRequest*>(
               &_ChangeRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(ChangeRoleRequest& a, ChangeRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeRoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ChangeRoleRequest";
  }
  protected:
  explicit ChangeRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldAuthorizationFieldNumber = 1,
    kNewAuthorizationFieldNumber = 2,
  };
  // .viam.app.v1.Authorization old_authorization = 1 [json_name = "oldAuthorization"];
  bool has_old_authorization() const;
  private:
  bool _internal_has_old_authorization() const;
  public:
  void clear_old_authorization();
  const ::viam::app::v1::Authorization& old_authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_old_authorization();
  ::viam::app::v1::Authorization* mutable_old_authorization();
  void set_allocated_old_authorization(::viam::app::v1::Authorization* old_authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_old_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_old_authorization();
  public:
  void unsafe_arena_set_allocated_old_authorization(
      ::viam::app::v1::Authorization* old_authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_old_authorization();

  // .viam.app.v1.Authorization new_authorization = 2 [json_name = "newAuthorization"];
  bool has_new_authorization() const;
  private:
  bool _internal_has_new_authorization() const;
  public:
  void clear_new_authorization();
  const ::viam::app::v1::Authorization& new_authorization() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Authorization* release_new_authorization();
  ::viam::app::v1::Authorization* mutable_new_authorization();
  void set_allocated_new_authorization(::viam::app::v1::Authorization* new_authorization);
  private:
  const ::viam::app::v1::Authorization& _internal_new_authorization() const;
  ::viam::app::v1::Authorization* _internal_mutable_new_authorization();
  public:
  void unsafe_arena_set_allocated_new_authorization(
      ::viam::app::v1::Authorization* new_authorization);
  ::viam::app::v1::Authorization* unsafe_arena_release_new_authorization();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ChangeRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Authorization* old_authorization_;
  ::viam::app::v1::Authorization* new_authorization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ChangeRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.ChangeRoleResponse) */ {
 public:
  inline ChangeRoleResponse() : ChangeRoleResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ChangeRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeRoleResponse(const ChangeRoleResponse& from);
  ChangeRoleResponse(ChangeRoleResponse&& from) noexcept
    : ChangeRoleResponse() {
    *this = ::std::move(from);
  }

  inline ChangeRoleResponse& operator=(const ChangeRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeRoleResponse& operator=(ChangeRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeRoleResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeRoleResponse*>(
               &_ChangeRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(ChangeRoleResponse& a, ChangeRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeRoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChangeRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChangeRoleResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ChangeRoleResponse";
  }
  protected:
  explicit ChangeRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.ChangeRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListAuthorizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListAuthorizationsRequest) */ {
 public:
  inline ListAuthorizationsRequest() : ListAuthorizationsRequest(nullptr) {}
  ~ListAuthorizationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAuthorizationsRequest(const ListAuthorizationsRequest& from);
  ListAuthorizationsRequest(ListAuthorizationsRequest&& from) noexcept
    : ListAuthorizationsRequest() {
    *this = ::std::move(from);
  }

  inline ListAuthorizationsRequest& operator=(const ListAuthorizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAuthorizationsRequest& operator=(ListAuthorizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAuthorizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAuthorizationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAuthorizationsRequest*>(
               &_ListAuthorizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(ListAuthorizationsRequest& a, ListAuthorizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAuthorizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAuthorizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAuthorizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAuthorizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAuthorizationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAuthorizationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAuthorizationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListAuthorizationsRequest";
  }
  protected:
  explicit ListAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceIdsFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // repeated string resource_ids = 2 [json_name = "resourceIds"];
  int resource_ids_size() const;
  private:
  int _internal_resource_ids_size() const;
  public:
  void clear_resource_ids();
  const std::string& resource_ids(int index) const;
  std::string* mutable_resource_ids(int index);
  void set_resource_ids(int index, const std::string& value);
  void set_resource_ids(int index, std::string&& value);
  void set_resource_ids(int index, const char* value);
  void set_resource_ids(int index, const char* value, size_t size);
  std::string* add_resource_ids();
  void add_resource_ids(const std::string& value);
  void add_resource_ids(std::string&& value);
  void add_resource_ids(const char* value);
  void add_resource_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& resource_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_resource_ids();
  private:
  const std::string& _internal_resource_ids(int index) const;
  std::string* _internal_add_resource_ids();
  public:

  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListAuthorizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> resource_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListAuthorizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListAuthorizationsResponse) */ {
 public:
  inline ListAuthorizationsResponse() : ListAuthorizationsResponse(nullptr) {}
  ~ListAuthorizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAuthorizationsResponse(const ListAuthorizationsResponse& from);
  ListAuthorizationsResponse(ListAuthorizationsResponse&& from) noexcept
    : ListAuthorizationsResponse() {
    *this = ::std::move(from);
  }

  inline ListAuthorizationsResponse& operator=(const ListAuthorizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAuthorizationsResponse& operator=(ListAuthorizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAuthorizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAuthorizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAuthorizationsResponse*>(
               &_ListAuthorizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(ListAuthorizationsResponse& a, ListAuthorizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAuthorizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAuthorizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAuthorizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAuthorizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAuthorizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAuthorizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAuthorizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListAuthorizationsResponse";
  }
  protected:
  explicit ListAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListAuthorizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CheckPermissionsRequest) */ {
 public:
  inline CheckPermissionsRequest() : CheckPermissionsRequest(nullptr) {}
  ~CheckPermissionsRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckPermissionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckPermissionsRequest(const CheckPermissionsRequest& from);
  CheckPermissionsRequest(CheckPermissionsRequest&& from) noexcept
    : CheckPermissionsRequest() {
    *this = ::std::move(from);
  }

  inline CheckPermissionsRequest& operator=(const CheckPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionsRequest& operator=(CheckPermissionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermissionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionsRequest*>(
               &_CheckPermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(CheckPermissionsRequest& a, CheckPermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermissionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermissionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckPermissionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckPermissionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CheckPermissionsRequest";
  }
  protected:
  explicit CheckPermissionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .viam.app.v1.AuthorizedPermissions permissions = 1 [json_name = "permissions"];
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::viam::app::v1::AuthorizedPermissions* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
      mutable_permissions();
  private:
  const ::viam::app::v1::AuthorizedPermissions& _internal_permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* _internal_add_permissions();
  public:
  const ::viam::app::v1::AuthorizedPermissions& permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
      permissions() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.CheckPermissionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions > permissions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AuthorizedPermissions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthorizedPermissions) */ {
 public:
  inline AuthorizedPermissions() : AuthorizedPermissions(nullptr) {}
  ~AuthorizedPermissions() override;
  explicit PROTOBUF_CONSTEXPR AuthorizedPermissions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizedPermissions(const AuthorizedPermissions& from);
  AuthorizedPermissions(AuthorizedPermissions&& from) noexcept
    : AuthorizedPermissions() {
    *this = ::std::move(from);
  }

  inline AuthorizedPermissions& operator=(const AuthorizedPermissions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizedPermissions& operator=(AuthorizedPermissions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizedPermissions& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizedPermissions* internal_default_instance() {
    return reinterpret_cast<const AuthorizedPermissions*>(
               &_AuthorizedPermissions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(AuthorizedPermissions& a, AuthorizedPermissions& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizedPermissions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizedPermissions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizedPermissions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizedPermissions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizedPermissions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthorizedPermissions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizedPermissions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AuthorizedPermissions";
  }
  protected:
  explicit AuthorizedPermissions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 3,
    kResourceTypeFieldNumber = 1,
    kResourceIdFieldNumber = 2,
  };
  // repeated string permissions = 3 [json_name = "permissions"];
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  const std::string& permissions(int index) const;
  std::string* mutable_permissions(int index);
  void set_permissions(int index, const std::string& value);
  void set_permissions(int index, std::string&& value);
  void set_permissions(int index, const char* value);
  void set_permissions(int index, const char* value, size_t size);
  std::string* add_permissions();
  void add_permissions(const std::string& value);
  void add_permissions(std::string&& value);
  void add_permissions(const char* value);
  void add_permissions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_permissions();
  private:
  const std::string& _internal_permissions(int index) const;
  std::string* _internal_add_permissions();
  public:

  // string resource_type = 1 [json_name = "resourceType"];
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string resource_id = 2 [json_name = "resourceId"];
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthorizedPermissions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CheckPermissionsResponse) */ {
 public:
  inline CheckPermissionsResponse() : CheckPermissionsResponse(nullptr) {}
  ~CheckPermissionsResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckPermissionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckPermissionsResponse(const CheckPermissionsResponse& from);
  CheckPermissionsResponse(CheckPermissionsResponse&& from) noexcept
    : CheckPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline CheckPermissionsResponse& operator=(const CheckPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionsResponse& operator=(CheckPermissionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionsResponse*>(
               &_CheckPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(CheckPermissionsResponse& a, CheckPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermissionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermissionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckPermissionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckPermissionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CheckPermissionsResponse";
  }
  protected:
  explicit CheckPermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizedPermissionsFieldNumber = 1,
  };
  // repeated .viam.app.v1.AuthorizedPermissions authorized_permissions = 1 [json_name = "authorizedPermissions"];
  int authorized_permissions_size() const;
  private:
  int _internal_authorized_permissions_size() const;
  public:
  void clear_authorized_permissions();
  ::viam::app::v1::AuthorizedPermissions* mutable_authorized_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
      mutable_authorized_permissions();
  private:
  const ::viam::app::v1::AuthorizedPermissions& _internal_authorized_permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* _internal_add_authorized_permissions();
  public:
  const ::viam::app::v1::AuthorizedPermissions& authorized_permissions(int index) const;
  ::viam::app::v1::AuthorizedPermissions* add_authorized_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
      authorized_permissions() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.CheckPermissionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions > authorized_permissions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ModuleVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleVersion) */ {
 public:
  inline ModuleVersion() : ModuleVersion(nullptr) {}
  ~ModuleVersion() override;
  explicit PROTOBUF_CONSTEXPR ModuleVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleVersion(const ModuleVersion& from);
  ModuleVersion(ModuleVersion&& from) noexcept
    : ModuleVersion() {
    *this = ::std::move(from);
  }

  inline ModuleVersion& operator=(const ModuleVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleVersion& operator=(ModuleVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleVersion* internal_default_instance() {
    return reinterpret_cast<const ModuleVersion*>(
               &_ModuleVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(ModuleVersion& a, ModuleVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ModuleVersion";
  }
  protected:
  explicit ModuleVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 2,
    kModelsFieldNumber = 3,
    kVersionFieldNumber = 1,
    kEntrypointFieldNumber = 4,
  };
  // repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::viam::app::v1::Uploads* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
      mutable_files();
  private:
  const ::viam::app::v1::Uploads& _internal_files(int index) const;
  ::viam::app::v1::Uploads* _internal_add_files();
  public:
  const ::viam::app::v1::Uploads& files(int index) const;
  ::viam::app::v1::Uploads* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
      files() const;

  // repeated .viam.app.v1.Model models = 3 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // string version = 1 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string entrypoint = 4 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ModuleMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleMetadata) */ {
 public:
  inline ModuleMetadata() : ModuleMetadata(nullptr) {}
  ~ModuleMetadata() override;
  explicit PROTOBUF_CONSTEXPR ModuleMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleMetadata(const ModuleMetadata& from);
  ModuleMetadata(ModuleMetadata&& from) noexcept
    : ModuleMetadata() {
    *this = ::std::move(from);
  }

  inline ModuleMetadata& operator=(const ModuleMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleMetadata& operator=(ModuleMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleMetadata* internal_default_instance() {
    return reinterpret_cast<const ModuleMetadata*>(
               &_ModuleMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(ModuleMetadata& a, ModuleMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ModuleMetadata";
  }
  protected:
  explicit ModuleMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
    kVersionsFieldNumber = 2,
    kEntrypointFieldNumber = 3,
  };
  // repeated .viam.app.v1.Model models = 1 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // repeated .viam.app.v1.ModuleVersion versions = 2 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  ::viam::app::v1::ModuleVersion* mutable_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >*
      mutable_versions();
  private:
  const ::viam::app::v1::ModuleVersion& _internal_versions(int index) const;
  ::viam::app::v1::ModuleVersion* _internal_add_versions();
  public:
  const ::viam::app::v1::ModuleVersion& versions(int index) const;
  ::viam::app::v1::ModuleVersion* add_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >&
      versions() const;

  // string entrypoint = 3 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion > versions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MLModelMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MLModelMetadata) */ {
 public:
  inline MLModelMetadata() : MLModelMetadata(nullptr) {}
  ~MLModelMetadata() override;
  explicit PROTOBUF_CONSTEXPR MLModelMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MLModelMetadata(const MLModelMetadata& from);
  MLModelMetadata(MLModelMetadata&& from) noexcept
    : MLModelMetadata() {
    *this = ::std::move(from);
  }

  inline MLModelMetadata& operator=(const MLModelMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLModelMetadata& operator=(MLModelMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLModelMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLModelMetadata* internal_default_instance() {
    return reinterpret_cast<const MLModelMetadata*>(
               &_MLModelMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(MLModelMetadata& a, MLModelMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MLModelMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLModelMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLModelMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLModelMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MLModelMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MLModelMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLModelMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MLModelMetadata";
  }
  protected:
  explicit MLModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 1,
  };
  // repeated string versions = 1 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MLModelMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RegistryItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RegistryItem) */ {
 public:
  inline RegistryItem() : RegistryItem(nullptr) {}
  ~RegistryItem() override;
  explicit PROTOBUF_CONSTEXPR RegistryItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistryItem(const RegistryItem& from);
  RegistryItem(RegistryItem&& from) noexcept
    : RegistryItem() {
    *this = ::std::move(from);
  }

  inline RegistryItem& operator=(const RegistryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistryItem& operator=(RegistryItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistryItem& default_instance() {
    return *internal_default_instance();
  }
  enum MetadataCase {
    kModuleMetadata = 11,
    kMlModelMetadata = 12,
    METADATA_NOT_SET = 0,
  };

  static inline const RegistryItem* internal_default_instance() {
    return reinterpret_cast<const RegistryItem*>(
               &_RegistryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(RegistryItem& a, RegistryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistryItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistryItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistryItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistryItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistryItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegistryItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistryItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RegistryItem";
  }
  protected:
  explicit RegistryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
    kPublicNamespaceFieldNumber = 3,
    kNameFieldNumber = 4,
    kUrlFieldNumber = 7,
    kDescriptionFieldNumber = 8,
    kCreatedAtFieldNumber = 15,
    kUpdatedAtFieldNumber = 16,
    kTypeFieldNumber = 5,
    kVisibilityFieldNumber = 6,
    kTotalRobotUsageFieldNumber = 9,
    kTotalOrganizationUsageFieldNumber = 10,
    kTotalExternalRobotUsageFieldNumber = 13,
    kTotalExternalOrganizationUsageFieldNumber = 14,
    kModuleMetadataFieldNumber = 11,
    kMlModelMetadataFieldNumber = 12,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string public_namespace = 3 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // string name = 4 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 7 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 8 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Timestamp created_at = 15 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 16 [json_name = "updatedAt"];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .viam.app.packages.v1.PackageType type = 5 [json_name = "type"];
  void clear_type();
  ::viam::app::packages::v1::PackageType type() const;
  void set_type(::viam::app::packages::v1::PackageType value);
  private:
  ::viam::app::packages::v1::PackageType _internal_type() const;
  void _internal_set_type(::viam::app::packages::v1::PackageType value);
  public:

  // .viam.app.v1.Visibility visibility = 6 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // int64 total_robot_usage = 9 [json_name = "totalRobotUsage"];
  void clear_total_robot_usage();
  int64_t total_robot_usage() const;
  void set_total_robot_usage(int64_t value);
  private:
  int64_t _internal_total_robot_usage() const;
  void _internal_set_total_robot_usage(int64_t value);
  public:

  // int64 total_organization_usage = 10 [json_name = "totalOrganizationUsage"];
  void clear_total_organization_usage();
  int64_t total_organization_usage() const;
  void set_total_organization_usage(int64_t value);
  private:
  int64_t _internal_total_organization_usage() const;
  void _internal_set_total_organization_usage(int64_t value);
  public:

  // int64 total_external_robot_usage = 13 [json_name = "totalExternalRobotUsage"];
  void clear_total_external_robot_usage();
  int64_t total_external_robot_usage() const;
  void set_total_external_robot_usage(int64_t value);
  private:
  int64_t _internal_total_external_robot_usage() const;
  void _internal_set_total_external_robot_usage(int64_t value);
  public:

  // int64 total_external_organization_usage = 14 [json_name = "totalExternalOrganizationUsage"];
  void clear_total_external_organization_usage();
  int64_t total_external_organization_usage() const;
  void set_total_external_organization_usage(int64_t value);
  private:
  int64_t _internal_total_external_organization_usage() const;
  void _internal_set_total_external_organization_usage(int64_t value);
  public:

  // .viam.app.v1.ModuleMetadata module_metadata = 11 [json_name = "moduleMetadata"];
  bool has_module_metadata() const;
  private:
  bool _internal_has_module_metadata() const;
  public:
  void clear_module_metadata();
  const ::viam::app::v1::ModuleMetadata& module_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ModuleMetadata* release_module_metadata();
  ::viam::app::v1::ModuleMetadata* mutable_module_metadata();
  void set_allocated_module_metadata(::viam::app::v1::ModuleMetadata* module_metadata);
  private:
  const ::viam::app::v1::ModuleMetadata& _internal_module_metadata() const;
  ::viam::app::v1::ModuleMetadata* _internal_mutable_module_metadata();
  public:
  void unsafe_arena_set_allocated_module_metadata(
      ::viam::app::v1::ModuleMetadata* module_metadata);
  ::viam::app::v1::ModuleMetadata* unsafe_arena_release_module_metadata();

  // .viam.app.v1.MLModelMetadata ml_model_metadata = 12 [json_name = "mlModelMetadata"];
  bool has_ml_model_metadata() const;
  private:
  bool _internal_has_ml_model_metadata() const;
  public:
  void clear_ml_model_metadata();
  const ::viam::app::v1::MLModelMetadata& ml_model_metadata() const;
  PROTOBUF_NODISCARD ::viam::app::v1::MLModelMetadata* release_ml_model_metadata();
  ::viam::app::v1::MLModelMetadata* mutable_ml_model_metadata();
  void set_allocated_ml_model_metadata(::viam::app::v1::MLModelMetadata* ml_model_metadata);
  private:
  const ::viam::app::v1::MLModelMetadata& _internal_ml_model_metadata() const;
  ::viam::app::v1::MLModelMetadata* _internal_mutable_ml_model_metadata();
  public:
  void unsafe_arena_set_allocated_ml_model_metadata(
      ::viam::app::v1::MLModelMetadata* ml_model_metadata);
  ::viam::app::v1::MLModelMetadata* unsafe_arena_release_ml_model_metadata();

  void clear_metadata();
  MetadataCase metadata_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.RegistryItem)
 private:
  class _Internal;
  void set_has_module_metadata();
  void set_has_ml_model_metadata();

  inline bool has_metadata() const;
  inline void clear_has_metadata();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  int type_;
  int visibility_;
  int64_t total_robot_usage_;
  int64_t total_organization_usage_;
  int64_t total_external_robot_usage_;
  int64_t total_external_organization_usage_;
  union MetadataUnion {
    constexpr MetadataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::viam::app::v1::ModuleMetadata* module_metadata_;
    ::viam::app::v1::MLModelMetadata* ml_model_metadata_;
  } metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRegistryItemRequest) */ {
 public:
  inline GetRegistryItemRequest() : GetRegistryItemRequest(nullptr) {}
  ~GetRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegistryItemRequest(const GetRegistryItemRequest& from);
  GetRegistryItemRequest(GetRegistryItemRequest&& from) noexcept
    : GetRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline GetRegistryItemRequest& operator=(const GetRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegistryItemRequest& operator=(GetRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegistryItemRequest*>(
               &_GetRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(GetRegistryItemRequest& a, GetRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRegistryItemRequest";
  }
  protected:
  explicit GetRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRegistryItemResponse) */ {
 public:
  inline GetRegistryItemResponse() : GetRegistryItemResponse(nullptr) {}
  ~GetRegistryItemResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegistryItemResponse(const GetRegistryItemResponse& from);
  GetRegistryItemResponse(GetRegistryItemResponse&& from) noexcept
    : GetRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline GetRegistryItemResponse& operator=(const GetRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegistryItemResponse& operator=(GetRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const GetRegistryItemResponse*>(
               &_GetRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(GetRegistryItemResponse& a, GetRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegistryItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRegistryItemResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegistryItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRegistryItemResponse";
  }
  protected:
  explicit GetRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .viam.app.v1.RegistryItem item = 1 [json_name = "item"];
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::viam::app::v1::RegistryItem& item() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RegistryItem* release_item();
  ::viam::app::v1::RegistryItem* mutable_item();
  void set_allocated_item(::viam::app::v1::RegistryItem* item);
  private:
  const ::viam::app::v1::RegistryItem& _internal_item() const;
  ::viam::app::v1::RegistryItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::viam::app::v1::RegistryItem* item);
  ::viam::app::v1::RegistryItem* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RegistryItem* item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRegistryItemRequest) */ {
 public:
  inline CreateRegistryItemRequest() : CreateRegistryItemRequest(nullptr) {}
  ~CreateRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRegistryItemRequest(const CreateRegistryItemRequest& from);
  CreateRegistryItemRequest(CreateRegistryItemRequest&& from) noexcept
    : CreateRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline CreateRegistryItemRequest& operator=(const CreateRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRegistryItemRequest& operator=(CreateRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRegistryItemRequest*>(
               &_CreateRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(CreateRegistryItemRequest& a, CreateRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRegistryItemRequest";
  }
  protected:
  explicit CreateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .viam.app.packages.v1.PackageType type = 3 [json_name = "type"];
  void clear_type();
  ::viam::app::packages::v1::PackageType type() const;
  void set_type(::viam::app::packages::v1::PackageType value);
  private:
  ::viam::app::packages::v1::PackageType _internal_type() const;
  void _internal_set_type(::viam::app::packages::v1::PackageType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRegistryItemResponse) */ {
 public:
  inline CreateRegistryItemResponse() : CreateRegistryItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRegistryItemResponse(const CreateRegistryItemResponse& from);
  CreateRegistryItemResponse(CreateRegistryItemResponse&& from) noexcept
    : CreateRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline CreateRegistryItemResponse& operator=(const CreateRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRegistryItemResponse& operator=(CreateRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRegistryItemResponse*>(
               &_CreateRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(CreateRegistryItemResponse& a, CreateRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRegistryItemResponse";
  }
  protected:
  explicit CreateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRegistryItemRequest) */ {
 public:
  inline UpdateRegistryItemRequest() : UpdateRegistryItemRequest(nullptr) {}
  ~UpdateRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRegistryItemRequest(const UpdateRegistryItemRequest& from);
  UpdateRegistryItemRequest(UpdateRegistryItemRequest&& from) noexcept
    : UpdateRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRegistryItemRequest& operator=(const UpdateRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRegistryItemRequest& operator=(UpdateRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRegistryItemRequest*>(
               &_UpdateRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(UpdateRegistryItemRequest& a, UpdateRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRegistryItemRequest";
  }
  protected:
  explicit UpdateRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kDescriptionFieldNumber = 3,
    kTypeFieldNumber = 2,
    kVisibilityFieldNumber = 4,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string description = 3 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .viam.app.packages.v1.PackageType type = 2 [json_name = "type"];
  void clear_type();
  ::viam::app::packages::v1::PackageType type() const;
  void set_type(::viam::app::packages::v1::PackageType value);
  private:
  ::viam::app::packages::v1::PackageType _internal_type() const;
  void _internal_set_type(::viam::app::packages::v1::PackageType value);
  public:

  // .viam.app.v1.Visibility visibility = 4 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int type_;
  int visibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRegistryItemResponse) */ {
 public:
  inline UpdateRegistryItemResponse() : UpdateRegistryItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRegistryItemResponse(const UpdateRegistryItemResponse& from);
  UpdateRegistryItemResponse(UpdateRegistryItemResponse&& from) noexcept
    : UpdateRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRegistryItemResponse& operator=(const UpdateRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRegistryItemResponse& operator=(UpdateRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRegistryItemResponse*>(
               &_UpdateRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(UpdateRegistryItemResponse& a, UpdateRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRegistryItemResponse";
  }
  protected:
  explicit UpdateRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRegistryItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRegistryItemsRequest) */ {
 public:
  inline ListRegistryItemsRequest() : ListRegistryItemsRequest(nullptr) {}
  ~ListRegistryItemsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRegistryItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRegistryItemsRequest(const ListRegistryItemsRequest& from);
  ListRegistryItemsRequest(ListRegistryItemsRequest&& from) noexcept
    : ListRegistryItemsRequest() {
    *this = ::std::move(from);
  }

  inline ListRegistryItemsRequest& operator=(const ListRegistryItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRegistryItemsRequest& operator=(ListRegistryItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRegistryItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRegistryItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRegistryItemsRequest*>(
               &_ListRegistryItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(ListRegistryItemsRequest& a, ListRegistryItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRegistryItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRegistryItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRegistryItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRegistryItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRegistryItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRegistryItemsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRegistryItemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRegistryItemsRequest";
  }
  protected:
  explicit ListRegistryItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 2,
    kVisibilitiesFieldNumber = 3,
    kPlatformsFieldNumber = 4,
    kStatusesFieldNumber = 5,
    kOrganizationIdFieldNumber = 1,
    kSearchTermFieldNumber = 6,
    kPageTokenFieldNumber = 7,
  };
  // repeated .viam.app.packages.v1.PackageType types = 2 [json_name = "types"];
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  ::viam::app::packages::v1::PackageType _internal_types(int index) const;
  void _internal_add_types(::viam::app::packages::v1::PackageType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_types();
  public:
  ::viam::app::packages::v1::PackageType types(int index) const;
  void set_types(int index, ::viam::app::packages::v1::PackageType value);
  void add_types(::viam::app::packages::v1::PackageType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_types();

  // repeated .viam.app.v1.Visibility visibilities = 3 [json_name = "visibilities"];
  int visibilities_size() const;
  private:
  int _internal_visibilities_size() const;
  public:
  void clear_visibilities();
  private:
  ::viam::app::v1::Visibility _internal_visibilities(int index) const;
  void _internal_add_visibilities(::viam::app::v1::Visibility value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_visibilities();
  public:
  ::viam::app::v1::Visibility visibilities(int index) const;
  void set_visibilities(int index, ::viam::app::v1::Visibility value);
  void add_visibilities(::viam::app::v1::Visibility value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& visibilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_visibilities();

  // repeated string platforms = 4 [json_name = "platforms"];
  int platforms_size() const;
  private:
  int _internal_platforms_size() const;
  public:
  void clear_platforms();
  const std::string& platforms(int index) const;
  std::string* mutable_platforms(int index);
  void set_platforms(int index, const std::string& value);
  void set_platforms(int index, std::string&& value);
  void set_platforms(int index, const char* value);
  void set_platforms(int index, const char* value, size_t size);
  std::string* add_platforms();
  void add_platforms(const std::string& value);
  void add_platforms(std::string&& value);
  void add_platforms(const char* value);
  void add_platforms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& platforms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_platforms();
  private:
  const std::string& _internal_platforms(int index) const;
  std::string* _internal_add_platforms();
  public:

  // repeated .viam.app.v1.RegistryItemStatus statuses = 5 [json_name = "statuses"];
  int statuses_size() const;
  private:
  int _internal_statuses_size() const;
  public:
  void clear_statuses();
  private:
  ::viam::app::v1::RegistryItemStatus _internal_statuses(int index) const;
  void _internal_add_statuses(::viam::app::v1::RegistryItemStatus value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_statuses();
  public:
  ::viam::app::v1::RegistryItemStatus statuses(int index) const;
  void set_statuses(int index, ::viam::app::v1::RegistryItemStatus value);
  void add_statuses(::viam::app::v1::RegistryItemStatus value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& statuses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_statuses();

  // optional string organization_id = 1 [json_name = "organizationId"];
  bool has_organization_id() const;
  private:
  bool _internal_has_organization_id() const;
  public:
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // optional string search_term = 6 [json_name = "searchTerm"];
  bool has_search_term() const;
  private:
  bool _internal_has_search_term() const;
  public:
  void clear_search_term();
  const std::string& search_term() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_term(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_term();
  PROTOBUF_NODISCARD std::string* release_search_term();
  void set_allocated_search_term(std::string* search_term);
  private:
  const std::string& _internal_search_term() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_term(const std::string& value);
  std::string* _internal_mutable_search_term();
  public:

  // optional string page_token = 7 [json_name = "pageToken"];
  bool has_page_token() const;
  private:
  bool _internal_has_page_token() const;
  public:
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRegistryItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> types_;
  mutable std::atomic<int> _types_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> visibilities_;
  mutable std::atomic<int> _visibilities_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> platforms_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> statuses_;
  mutable std::atomic<int> _statuses_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_term_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListRegistryItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListRegistryItemsResponse) */ {
 public:
  inline ListRegistryItemsResponse() : ListRegistryItemsResponse(nullptr) {}
  ~ListRegistryItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRegistryItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRegistryItemsResponse(const ListRegistryItemsResponse& from);
  ListRegistryItemsResponse(ListRegistryItemsResponse&& from) noexcept
    : ListRegistryItemsResponse() {
    *this = ::std::move(from);
  }

  inline ListRegistryItemsResponse& operator=(const ListRegistryItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRegistryItemsResponse& operator=(ListRegistryItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRegistryItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRegistryItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRegistryItemsResponse*>(
               &_ListRegistryItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(ListRegistryItemsResponse& a, ListRegistryItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRegistryItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRegistryItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRegistryItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRegistryItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRegistryItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRegistryItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRegistryItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListRegistryItemsResponse";
  }
  protected:
  explicit ListRegistryItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .viam.app.v1.RegistryItem items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::viam::app::v1::RegistryItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >*
      mutable_items();
  private:
  const ::viam::app::v1::RegistryItem& _internal_items(int index) const;
  ::viam::app::v1::RegistryItem* _internal_add_items();
  public:
  const ::viam::app::v1::RegistryItem& items(int index) const;
  ::viam::app::v1::RegistryItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListRegistryItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRegistryItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRegistryItemRequest) */ {
 public:
  inline DeleteRegistryItemRequest() : DeleteRegistryItemRequest(nullptr) {}
  ~DeleteRegistryItemRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRegistryItemRequest(const DeleteRegistryItemRequest& from);
  DeleteRegistryItemRequest(DeleteRegistryItemRequest&& from) noexcept
    : DeleteRegistryItemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRegistryItemRequest& operator=(const DeleteRegistryItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRegistryItemRequest& operator=(DeleteRegistryItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRegistryItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRegistryItemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRegistryItemRequest*>(
               &_DeleteRegistryItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(DeleteRegistryItemRequest& a, DeleteRegistryItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRegistryItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRegistryItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRegistryItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRegistryItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRegistryItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRegistryItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRegistryItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRegistryItemRequest";
  }
  protected:
  explicit DeleteRegistryItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRegistryItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRegistryItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRegistryItemResponse) */ {
 public:
  inline DeleteRegistryItemResponse() : DeleteRegistryItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRegistryItemResponse(const DeleteRegistryItemResponse& from);
  DeleteRegistryItemResponse(DeleteRegistryItemResponse&& from) noexcept
    : DeleteRegistryItemResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRegistryItemResponse& operator=(const DeleteRegistryItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRegistryItemResponse& operator=(DeleteRegistryItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRegistryItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRegistryItemResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRegistryItemResponse*>(
               &_DeleteRegistryItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(DeleteRegistryItemResponse& a, DeleteRegistryItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRegistryItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRegistryItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRegistryItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRegistryItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRegistryItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRegistryItemResponse";
  }
  protected:
  explicit DeleteRegistryItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRegistryItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateModuleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateModuleRequest) */ {
 public:
  inline CreateModuleRequest() : CreateModuleRequest(nullptr) {}
  ~CreateModuleRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateModuleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateModuleRequest(const CreateModuleRequest& from);
  CreateModuleRequest(CreateModuleRequest&& from) noexcept
    : CreateModuleRequest() {
    *this = ::std::move(from);
  }

  inline CreateModuleRequest& operator=(const CreateModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModuleRequest& operator=(CreateModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateModuleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateModuleRequest*>(
               &_CreateModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(CreateModuleRequest& a, CreateModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModuleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateModuleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateModuleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateModuleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateModuleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateModuleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateModuleRequest";
  }
  protected:
  explicit CreateModuleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateModuleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateModuleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateModuleResponse) */ {
 public:
  inline CreateModuleResponse() : CreateModuleResponse(nullptr) {}
  ~CreateModuleResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateModuleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateModuleResponse(const CreateModuleResponse& from);
  CreateModuleResponse(CreateModuleResponse&& from) noexcept
    : CreateModuleResponse() {
    *this = ::std::move(from);
  }

  inline CreateModuleResponse& operator=(const CreateModuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModuleResponse& operator=(CreateModuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateModuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateModuleResponse* internal_default_instance() {
    return reinterpret_cast<const CreateModuleResponse*>(
               &_CreateModuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(CreateModuleResponse& a, CreateModuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModuleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateModuleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateModuleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateModuleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateModuleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateModuleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateModuleResponse";
  }
  protected:
  explicit CreateModuleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleIdFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string url = 2 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateModuleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateModuleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateModuleRequest) */ {
 public:
  inline UpdateModuleRequest() : UpdateModuleRequest(nullptr) {}
  ~UpdateModuleRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateModuleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateModuleRequest(const UpdateModuleRequest& from);
  UpdateModuleRequest(UpdateModuleRequest&& from) noexcept
    : UpdateModuleRequest() {
    *this = ::std::move(from);
  }

  inline UpdateModuleRequest& operator=(const UpdateModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateModuleRequest& operator=(UpdateModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateModuleRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateModuleRequest*>(
               &_UpdateModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(UpdateModuleRequest& a, UpdateModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateModuleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateModuleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateModuleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateModuleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateModuleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateModuleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateModuleRequest";
  }
  protected:
  explicit UpdateModuleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 5,
    kModuleIdFieldNumber = 1,
    kUrlFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kEntrypointFieldNumber = 6,
    kVisibilityFieldNumber = 2,
  };
  // repeated .viam.app.v1.Model models = 5 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string url = 3 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 4 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string entrypoint = 6 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // .viam.app.v1.Visibility visibility = 2 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateModuleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  int visibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateModuleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateModuleResponse) */ {
 public:
  inline UpdateModuleResponse() : UpdateModuleResponse(nullptr) {}
  ~UpdateModuleResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateModuleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateModuleResponse(const UpdateModuleResponse& from);
  UpdateModuleResponse(UpdateModuleResponse&& from) noexcept
    : UpdateModuleResponse() {
    *this = ::std::move(from);
  }

  inline UpdateModuleResponse& operator=(const UpdateModuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateModuleResponse& operator=(UpdateModuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateModuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateModuleResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateModuleResponse*>(
               &_UpdateModuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(UpdateModuleResponse& a, UpdateModuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateModuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateModuleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateModuleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateModuleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateModuleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateModuleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateModuleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateModuleResponse";
  }
  protected:
  explicit UpdateModuleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateModuleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Model& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string api = 1 [json_name = "api"];
  void clear_api();
  const std::string& api() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api();
  PROTOBUF_NODISCARD std::string* release_api();
  void set_allocated_api(std::string* api);
  private:
  const std::string& _internal_api() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api(const std::string& value);
  std::string* _internal_mutable_api();
  public:

  // string model = 2 [json_name = "model"];
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ModuleFileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleFileInfo) */ {
 public:
  inline ModuleFileInfo() : ModuleFileInfo(nullptr) {}
  ~ModuleFileInfo() override;
  explicit PROTOBUF_CONSTEXPR ModuleFileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleFileInfo(const ModuleFileInfo& from);
  ModuleFileInfo(ModuleFileInfo&& from) noexcept
    : ModuleFileInfo() {
    *this = ::std::move(from);
  }

  inline ModuleFileInfo& operator=(const ModuleFileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleFileInfo& operator=(ModuleFileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleFileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleFileInfo* internal_default_instance() {
    return reinterpret_cast<const ModuleFileInfo*>(
               &_ModuleFileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(ModuleFileInfo& a, ModuleFileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleFileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleFileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleFileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleFileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleFileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleFileInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleFileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ModuleFileInfo";
  }
  protected:
  explicit ModuleFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPlatformFieldNumber = 3,
  };
  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string version = 2 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string platform = 3 [json_name = "platform"];
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleFileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UploadModuleFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UploadModuleFileRequest) */ {
 public:
  inline UploadModuleFileRequest() : UploadModuleFileRequest(nullptr) {}
  ~UploadModuleFileRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadModuleFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadModuleFileRequest(const UploadModuleFileRequest& from);
  UploadModuleFileRequest(UploadModuleFileRequest&& from) noexcept
    : UploadModuleFileRequest() {
    *this = ::std::move(from);
  }

  inline UploadModuleFileRequest& operator=(const UploadModuleFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadModuleFileRequest& operator=(UploadModuleFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadModuleFileRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ModuleFileCase {
    kModuleFileInfo = 1,
    kFile = 2,
    MODULE_FILE_NOT_SET = 0,
  };

  static inline const UploadModuleFileRequest* internal_default_instance() {
    return reinterpret_cast<const UploadModuleFileRequest*>(
               &_UploadModuleFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(UploadModuleFileRequest& a, UploadModuleFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadModuleFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadModuleFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadModuleFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadModuleFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadModuleFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadModuleFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadModuleFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UploadModuleFileRequest";
  }
  protected:
  explicit UploadModuleFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFileInfoFieldNumber = 1,
    kFileFieldNumber = 2,
  };
  // .viam.app.v1.ModuleFileInfo module_file_info = 1 [json_name = "moduleFileInfo"];
  bool has_module_file_info() const;
  private:
  bool _internal_has_module_file_info() const;
  public:
  void clear_module_file_info();
  const ::viam::app::v1::ModuleFileInfo& module_file_info() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ModuleFileInfo* release_module_file_info();
  ::viam::app::v1::ModuleFileInfo* mutable_module_file_info();
  void set_allocated_module_file_info(::viam::app::v1::ModuleFileInfo* module_file_info);
  private:
  const ::viam::app::v1::ModuleFileInfo& _internal_module_file_info() const;
  ::viam::app::v1::ModuleFileInfo* _internal_mutable_module_file_info();
  public:
  void unsafe_arena_set_allocated_module_file_info(
      ::viam::app::v1::ModuleFileInfo* module_file_info);
  ::viam::app::v1::ModuleFileInfo* unsafe_arena_release_module_file_info();

  // bytes file = 2 [json_name = "file"];
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_NODISCARD std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  void clear_module_file();
  ModuleFileCase module_file_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.UploadModuleFileRequest)
 private:
  class _Internal;
  void set_has_module_file_info();
  void set_has_file();

  inline bool has_module_file() const;
  inline void clear_has_module_file();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ModuleFileUnion {
    constexpr ModuleFileUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::viam::app::v1::ModuleFileInfo* module_file_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  } module_file_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UploadModuleFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UploadModuleFileResponse) */ {
 public:
  inline UploadModuleFileResponse() : UploadModuleFileResponse(nullptr) {}
  ~UploadModuleFileResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadModuleFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadModuleFileResponse(const UploadModuleFileResponse& from);
  UploadModuleFileResponse(UploadModuleFileResponse&& from) noexcept
    : UploadModuleFileResponse() {
    *this = ::std::move(from);
  }

  inline UploadModuleFileResponse& operator=(const UploadModuleFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadModuleFileResponse& operator=(UploadModuleFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadModuleFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadModuleFileResponse* internal_default_instance() {
    return reinterpret_cast<const UploadModuleFileResponse*>(
               &_UploadModuleFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(UploadModuleFileResponse& a, UploadModuleFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadModuleFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadModuleFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadModuleFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadModuleFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadModuleFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadModuleFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadModuleFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UploadModuleFileResponse";
  }
  protected:
  explicit UploadModuleFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UploadModuleFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetModuleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetModuleRequest) */ {
 public:
  inline GetModuleRequest() : GetModuleRequest(nullptr) {}
  ~GetModuleRequest() override;
  explicit PROTOBUF_CONSTEXPR GetModuleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModuleRequest(const GetModuleRequest& from);
  GetModuleRequest(GetModuleRequest&& from) noexcept
    : GetModuleRequest() {
    *this = ::std::move(from);
  }

  inline GetModuleRequest& operator=(const GetModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleRequest& operator=(GetModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleRequest* internal_default_instance() {
    return reinterpret_cast<const GetModuleRequest*>(
               &_GetModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(GetModuleRequest& a, GetModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModuleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModuleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModuleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetModuleRequest";
  }
  protected:
  explicit GetModuleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleIdFieldNumber = 1,
  };
  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetModuleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetModuleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetModuleResponse) */ {
 public:
  inline GetModuleResponse() : GetModuleResponse(nullptr) {}
  ~GetModuleResponse() override;
  explicit PROTOBUF_CONSTEXPR GetModuleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModuleResponse(const GetModuleResponse& from);
  GetModuleResponse(GetModuleResponse&& from) noexcept
    : GetModuleResponse() {
    *this = ::std::move(from);
  }

  inline GetModuleResponse& operator=(const GetModuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleResponse& operator=(GetModuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleResponse* internal_default_instance() {
    return reinterpret_cast<const GetModuleResponse*>(
               &_GetModuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(GetModuleResponse& a, GetModuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModuleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModuleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModuleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetModuleResponse";
  }
  protected:
  explicit GetModuleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFieldNumber = 1,
  };
  // .viam.app.v1.Module module = 1 [json_name = "module"];
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::viam::app::v1::Module& module() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Module* release_module();
  ::viam::app::v1::Module* mutable_module();
  void set_allocated_module(::viam::app::v1::Module* module);
  private:
  const ::viam::app::v1::Module& _internal_module() const;
  ::viam::app::v1::Module* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::viam::app::v1::Module* module);
  ::viam::app::v1::Module* unsafe_arena_release_module();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetModuleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::Module* module_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Module final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Module) */ {
 public:
  inline Module() : Module(nullptr) {}
  ~Module() override;
  explicit PROTOBUF_CONSTEXPR Module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Module(const Module& from);
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Module& operator=(Module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Module& default_instance() {
    return *internal_default_instance();
  }
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }
  inline void Swap(Module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Module>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Module& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Module& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Module* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Module";
  }
  protected:
  explicit Module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 4,
    kModelsFieldNumber = 7,
    kModuleIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kUrlFieldNumber = 5,
    kDescriptionFieldNumber = 6,
    kOrganizationIdFieldNumber = 10,
    kEntrypointFieldNumber = 11,
    kPublicNamespaceFieldNumber = 12,
    kTotalRobotUsageFieldNumber = 8,
    kTotalOrganizationUsageFieldNumber = 9,
    kVisibilityFieldNumber = 3,
  };
  // repeated .viam.app.v1.VersionHistory versions = 4 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  ::viam::app::v1::VersionHistory* mutable_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >*
      mutable_versions();
  private:
  const ::viam::app::v1::VersionHistory& _internal_versions(int index) const;
  ::viam::app::v1::VersionHistory* _internal_add_versions();
  public:
  const ::viam::app::v1::VersionHistory& versions(int index) const;
  ::viam::app::v1::VersionHistory* add_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >&
      versions() const;

  // repeated .viam.app.v1.Model models = 7 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // string module_id = 1 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 5 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string description = 6 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string organization_id = 10 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string entrypoint = 11 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // string public_namespace = 12 [json_name = "publicNamespace"];
  void clear_public_namespace();
  const std::string& public_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_namespace();
  PROTOBUF_NODISCARD std::string* release_public_namespace();
  void set_allocated_public_namespace(std::string* public_namespace);
  private:
  const std::string& _internal_public_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_namespace(const std::string& value);
  std::string* _internal_mutable_public_namespace();
  public:

  // int64 total_robot_usage = 8 [json_name = "totalRobotUsage"];
  void clear_total_robot_usage();
  int64_t total_robot_usage() const;
  void set_total_robot_usage(int64_t value);
  private:
  int64_t _internal_total_robot_usage() const;
  void _internal_set_total_robot_usage(int64_t value);
  public:

  // int64 total_organization_usage = 9 [json_name = "totalOrganizationUsage"];
  void clear_total_organization_usage();
  int64_t total_organization_usage() const;
  void set_total_organization_usage(int64_t value);
  private:
  int64_t _internal_total_organization_usage() const;
  void _internal_set_total_organization_usage(int64_t value);
  public:

  // .viam.app.v1.Visibility visibility = 3 [json_name = "visibility"];
  void clear_visibility();
  ::viam::app::v1::Visibility visibility() const;
  void set_visibility(::viam::app::v1::Visibility value);
  private:
  ::viam::app::v1::Visibility _internal_visibility() const;
  void _internal_set_visibility(::viam::app::v1::Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory > versions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_namespace_;
  int64_t total_robot_usage_;
  int64_t total_organization_usage_;
  int visibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class VersionHistory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.VersionHistory) */ {
 public:
  inline VersionHistory() : VersionHistory(nullptr) {}
  ~VersionHistory() override;
  explicit PROTOBUF_CONSTEXPR VersionHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionHistory(const VersionHistory& from);
  VersionHistory(VersionHistory&& from) noexcept
    : VersionHistory() {
    *this = ::std::move(from);
  }

  inline VersionHistory& operator=(const VersionHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionHistory& operator=(VersionHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionHistory* internal_default_instance() {
    return reinterpret_cast<const VersionHistory*>(
               &_VersionHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(VersionHistory& a, VersionHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionHistory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionHistory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionHistory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VersionHistory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionHistory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.VersionHistory";
  }
  protected:
  explicit VersionHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 2,
    kModelsFieldNumber = 3,
    kVersionFieldNumber = 1,
    kEntrypointFieldNumber = 4,
  };
  // repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::viam::app::v1::Uploads* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
      mutable_files();
  private:
  const ::viam::app::v1::Uploads& _internal_files(int index) const;
  ::viam::app::v1::Uploads* _internal_add_files();
  public:
  const ::viam::app::v1::Uploads& files(int index) const;
  ::viam::app::v1::Uploads* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
      files() const;

  // repeated .viam.app.v1.Model models = 3 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::viam::app::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
      mutable_models();
  private:
  const ::viam::app::v1::Model& _internal_models(int index) const;
  ::viam::app::v1::Model* _internal_add_models();
  public:
  const ::viam::app::v1::Model& models(int index) const;
  ::viam::app::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
      models() const;

  // string version = 1 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string entrypoint = 4 [json_name = "entrypoint"];
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_NODISCARD std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.VersionHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model > models_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Uploads final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Uploads) */ {
 public:
  inline Uploads() : Uploads(nullptr) {}
  ~Uploads() override;
  explicit PROTOBUF_CONSTEXPR Uploads(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uploads(const Uploads& from);
  Uploads(Uploads&& from) noexcept
    : Uploads() {
    *this = ::std::move(from);
  }

  inline Uploads& operator=(const Uploads& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uploads& operator=(Uploads&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uploads& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uploads* internal_default_instance() {
    return reinterpret_cast<const Uploads*>(
               &_Uploads_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(Uploads& a, Uploads& b) {
    a.Swap(&b);
  }
  inline void Swap(Uploads* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uploads* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uploads* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uploads>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uploads& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Uploads& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uploads* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Uploads";
  }
  protected:
  explicit Uploads(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformFieldNumber = 1,
    kUploadedAtFieldNumber = 2,
  };
  // string platform = 1 [json_name = "platform"];
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // .google.protobuf.Timestamp uploaded_at = 2 [json_name = "uploadedAt"];
  bool has_uploaded_at() const;
  private:
  bool _internal_has_uploaded_at() const;
  public:
  void clear_uploaded_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& uploaded_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_uploaded_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_uploaded_at();
  void set_allocated_uploaded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_uploaded_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_uploaded_at();
  public:
  void unsafe_arena_set_allocated_uploaded_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_uploaded_at();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Uploads)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListModulesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListModulesRequest) */ {
 public:
  inline ListModulesRequest() : ListModulesRequest(nullptr) {}
  ~ListModulesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListModulesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListModulesRequest(const ListModulesRequest& from);
  ListModulesRequest(ListModulesRequest&& from) noexcept
    : ListModulesRequest() {
    *this = ::std::move(from);
  }

  inline ListModulesRequest& operator=(const ListModulesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModulesRequest& operator=(ListModulesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModulesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModulesRequest* internal_default_instance() {
    return reinterpret_cast<const ListModulesRequest*>(
               &_ListModulesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(ListModulesRequest& a, ListModulesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModulesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModulesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModulesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModulesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListModulesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListModulesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListModulesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListModulesRequest";
  }
  protected:
  explicit ListModulesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // optional string organization_id = 1 [json_name = "organizationId"];
  bool has_organization_id() const;
  private:
  bool _internal_has_organization_id() const;
  public:
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListModulesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListModulesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListModulesResponse) */ {
 public:
  inline ListModulesResponse() : ListModulesResponse(nullptr) {}
  ~ListModulesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListModulesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListModulesResponse(const ListModulesResponse& from);
  ListModulesResponse(ListModulesResponse&& from) noexcept
    : ListModulesResponse() {
    *this = ::std::move(from);
  }

  inline ListModulesResponse& operator=(const ListModulesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModulesResponse& operator=(ListModulesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModulesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModulesResponse* internal_default_instance() {
    return reinterpret_cast<const ListModulesResponse*>(
               &_ListModulesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(ListModulesResponse& a, ListModulesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModulesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModulesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModulesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModulesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListModulesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListModulesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListModulesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListModulesResponse";
  }
  protected:
  explicit ListModulesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 1,
  };
  // repeated .viam.app.v1.Module modules = 1 [json_name = "modules"];
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  ::viam::app::v1::Module* mutable_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >*
      mutable_modules();
  private:
  const ::viam::app::v1::Module& _internal_modules(int index) const;
  ::viam::app::v1::Module* _internal_add_modules();
  public:
  const ::viam::app::v1::Module& modules(int index) const;
  ::viam::app::v1::Module* add_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >&
      modules() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListModulesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module > modules_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDByEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetUserIDByEmailRequest) */ {
 public:
  inline GetUserIDByEmailRequest() : GetUserIDByEmailRequest(nullptr) {}
  ~GetUserIDByEmailRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserIDByEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDByEmailRequest(const GetUserIDByEmailRequest& from);
  GetUserIDByEmailRequest(GetUserIDByEmailRequest&& from) noexcept
    : GetUserIDByEmailRequest() {
    *this = ::std::move(from);
  }

  inline GetUserIDByEmailRequest& operator=(const GetUserIDByEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDByEmailRequest& operator=(GetUserIDByEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDByEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDByEmailRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserIDByEmailRequest*>(
               &_GetUserIDByEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(GetUserIDByEmailRequest& a, GetUserIDByEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDByEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDByEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDByEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDByEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDByEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserIDByEmailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDByEmailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetUserIDByEmailRequest";
  }
  protected:
  explicit GetUserIDByEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetUserIDByEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDByEmailResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetUserIDByEmailResponse) */ {
 public:
  inline GetUserIDByEmailResponse() : GetUserIDByEmailResponse(nullptr) {}
  ~GetUserIDByEmailResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserIDByEmailResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDByEmailResponse(const GetUserIDByEmailResponse& from);
  GetUserIDByEmailResponse(GetUserIDByEmailResponse&& from) noexcept
    : GetUserIDByEmailResponse() {
    *this = ::std::move(from);
  }

  inline GetUserIDByEmailResponse& operator=(const GetUserIDByEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDByEmailResponse& operator=(GetUserIDByEmailResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDByEmailResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDByEmailResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserIDByEmailResponse*>(
               &_GetUserIDByEmailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(GetUserIDByEmailResponse& a, GetUserIDByEmailResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDByEmailResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDByEmailResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDByEmailResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDByEmailResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDByEmailResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserIDByEmailResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDByEmailResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetUserIDByEmailResponse";
  }
  protected:
  explicit GetUserIDByEmailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetUserIDByEmailResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsByUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsByUserRequest) */ {
 public:
  inline ListOrganizationsByUserRequest() : ListOrganizationsByUserRequest(nullptr) {}
  ~ListOrganizationsByUserRequest() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationsByUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsByUserRequest(const ListOrganizationsByUserRequest& from);
  ListOrganizationsByUserRequest(ListOrganizationsByUserRequest&& from) noexcept
    : ListOrganizationsByUserRequest() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsByUserRequest& operator=(const ListOrganizationsByUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsByUserRequest& operator=(ListOrganizationsByUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsByUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsByUserRequest* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsByUserRequest*>(
               &_ListOrganizationsByUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(ListOrganizationsByUserRequest& a, ListOrganizationsByUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsByUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsByUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsByUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsByUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationsByUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationsByUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationsByUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsByUserRequest";
  }
  protected:
  explicit ListOrganizationsByUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsByUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class OrgDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.OrgDetails) */ {
 public:
  inline OrgDetails() : OrgDetails(nullptr) {}
  ~OrgDetails() override;
  explicit PROTOBUF_CONSTEXPR OrgDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrgDetails(const OrgDetails& from);
  OrgDetails(OrgDetails&& from) noexcept
    : OrgDetails() {
    *this = ::std::move(from);
  }

  inline OrgDetails& operator=(const OrgDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrgDetails& operator=(OrgDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrgDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrgDetails* internal_default_instance() {
    return reinterpret_cast<const OrgDetails*>(
               &_OrgDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(OrgDetails& a, OrgDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(OrgDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrgDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrgDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrgDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrgDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrgDetails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrgDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.OrgDetails";
  }
  protected:
  explicit OrgDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
    kOrgNameFieldNumber = 2,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string org_name = 2 [json_name = "orgName"];
  void clear_org_name();
  const std::string& org_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_name();
  PROTOBUF_NODISCARD std::string* release_org_name();
  void set_allocated_org_name(std::string* org_name);
  private:
  const std::string& _internal_org_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_name(const std::string& value);
  std::string* _internal_mutable_org_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.OrgDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsByUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsByUserResponse) */ {
 public:
  inline ListOrganizationsByUserResponse() : ListOrganizationsByUserResponse(nullptr) {}
  ~ListOrganizationsByUserResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationsByUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsByUserResponse(const ListOrganizationsByUserResponse& from);
  ListOrganizationsByUserResponse(ListOrganizationsByUserResponse&& from) noexcept
    : ListOrganizationsByUserResponse() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsByUserResponse& operator=(const ListOrganizationsByUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsByUserResponse& operator=(ListOrganizationsByUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsByUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsByUserResponse* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsByUserResponse*>(
               &_ListOrganizationsByUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(ListOrganizationsByUserResponse& a, ListOrganizationsByUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsByUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsByUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsByUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsByUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationsByUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOrganizationsByUserResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationsByUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsByUserResponse";
  }
  protected:
  explicit ListOrganizationsByUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgsFieldNumber = 1,
  };
  // repeated .viam.app.v1.OrgDetails orgs = 1 [json_name = "orgs"];
  int orgs_size() const;
  private:
  int _internal_orgs_size() const;
  public:
  void clear_orgs();
  ::viam::app::v1::OrgDetails* mutable_orgs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >*
      mutable_orgs();
  private:
  const ::viam::app::v1::OrgDetails& _internal_orgs(int index) const;
  ::viam::app::v1::OrgDetails* _internal_add_orgs();
  public:
  const ::viam::app::v1::OrgDetails& orgs(int index) const;
  ::viam::app::v1::OrgDetails* add_orgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >&
      orgs() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsByUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails > orgs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyRequest) */ {
 public:
  inline CreateKeyRequest() : CreateKeyRequest(nullptr) {}
  ~CreateKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyRequest(const CreateKeyRequest& from);
  CreateKeyRequest(CreateKeyRequest&& from) noexcept
    : CreateKeyRequest() {
    *this = ::std::move(from);
  }

  inline CreateKeyRequest& operator=(const CreateKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyRequest& operator=(CreateKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyRequest* internal_default_instance() {
    return reinterpret_cast<const CreateKeyRequest*>(
               &_CreateKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(CreateKeyRequest& a, CreateKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyRequest";
  }
  protected:
  explicit CreateKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::Authorization* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::Authorization& _internal_authorizations(int index) const;
  ::viam::app::v1::Authorization* _internal_add_authorizations();
  public:
  const ::viam::app::v1::Authorization& authorizations(int index) const;
  ::viam::app::v1::Authorization* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
      authorizations() const;

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization > authorizations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyResponse) */ {
 public:
  inline CreateKeyResponse() : CreateKeyResponse(nullptr) {}
  ~CreateKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyResponse(const CreateKeyResponse& from);
  CreateKeyResponse(CreateKeyResponse&& from) noexcept
    : CreateKeyResponse() {
    *this = ::std::move(from);
  }

  inline CreateKeyResponse& operator=(const CreateKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyResponse& operator=(CreateKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyResponse* internal_default_instance() {
    return reinterpret_cast<const CreateKeyResponse*>(
               &_CreateKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    156;

  friend void swap(CreateKeyResponse& a, CreateKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyResponse";
  }
  protected:
  explicit CreateKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string id = 2 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteKeyRequest) */ {
 public:
  inline DeleteKeyRequest() : DeleteKeyRequest(nullptr) {}
  ~DeleteKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteKeyRequest(const DeleteKeyRequest& from);
  DeleteKeyRequest(DeleteKeyRequest&& from) noexcept
    : DeleteKeyRequest() {
    *this = ::std::move(from);
  }

  inline DeleteKeyRequest& operator=(const DeleteKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyRequest& operator=(DeleteKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyRequest*>(
               &_DeleteKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    157;

  friend void swap(DeleteKeyRequest& a, DeleteKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteKeyRequest";
  }
  protected:
  explicit DeleteKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteKeyResponse) */ {
 public:
  inline DeleteKeyResponse() : DeleteKeyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteKeyResponse(const DeleteKeyResponse& from);
  DeleteKeyResponse(DeleteKeyResponse&& from) noexcept
    : DeleteKeyResponse() {
    *this = ::std::move(from);
  }

  inline DeleteKeyResponse& operator=(const DeleteKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyResponse& operator=(DeleteKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyResponse*>(
               &_DeleteKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    158;

  friend void swap(DeleteKeyResponse& a, DeleteKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteKeyResponse";
  }
  protected:
  explicit DeleteKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class AuthorizationDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthorizationDetails) */ {
 public:
  inline AuthorizationDetails() : AuthorizationDetails(nullptr) {}
  ~AuthorizationDetails() override;
  explicit PROTOBUF_CONSTEXPR AuthorizationDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizationDetails(const AuthorizationDetails& from);
  AuthorizationDetails(AuthorizationDetails&& from) noexcept
    : AuthorizationDetails() {
    *this = ::std::move(from);
  }

  inline AuthorizationDetails& operator=(const AuthorizationDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizationDetails& operator=(AuthorizationDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizationDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizationDetails* internal_default_instance() {
    return reinterpret_cast<const AuthorizationDetails*>(
               &_AuthorizationDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    159;

  friend void swap(AuthorizationDetails& a, AuthorizationDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizationDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizationDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizationDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizationDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizationDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthorizationDetails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizationDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AuthorizationDetails";
  }
  protected:
  explicit AuthorizationDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationTypeFieldNumber = 1,
    kAuthorizationIdFieldNumber = 2,
    kResourceTypeFieldNumber = 3,
    kResourceIdFieldNumber = 4,
    kOrgIdFieldNumber = 5,
  };
  // string authorization_type = 1 [json_name = "authorizationType"];
  void clear_authorization_type();
  const std::string& authorization_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_type();
  PROTOBUF_NODISCARD std::string* release_authorization_type();
  void set_allocated_authorization_type(std::string* authorization_type);
  private:
  const std::string& _internal_authorization_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_type(const std::string& value);
  std::string* _internal_mutable_authorization_type();
  public:

  // string authorization_id = 2 [json_name = "authorizationId"];
  void clear_authorization_id();
  const std::string& authorization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_id();
  PROTOBUF_NODISCARD std::string* release_authorization_id();
  void set_allocated_authorization_id(std::string* authorization_id);
  private:
  const std::string& _internal_authorization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_id(const std::string& value);
  std::string* _internal_mutable_authorization_id();
  public:

  // string resource_type = 3 [json_name = "resourceType"];
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string resource_id = 4 [json_name = "resourceId"];
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string org_id = 5 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthorizationDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class APIKeyWithAuthorizations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.APIKeyWithAuthorizations) */ {
 public:
  inline APIKeyWithAuthorizations() : APIKeyWithAuthorizations(nullptr) {}
  ~APIKeyWithAuthorizations() override;
  explicit PROTOBUF_CONSTEXPR APIKeyWithAuthorizations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIKeyWithAuthorizations(const APIKeyWithAuthorizations& from);
  APIKeyWithAuthorizations(APIKeyWithAuthorizations&& from) noexcept
    : APIKeyWithAuthorizations() {
    *this = ::std::move(from);
  }

  inline APIKeyWithAuthorizations& operator=(const APIKeyWithAuthorizations& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIKeyWithAuthorizations& operator=(APIKeyWithAuthorizations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIKeyWithAuthorizations& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIKeyWithAuthorizations* internal_default_instance() {
    return reinterpret_cast<const APIKeyWithAuthorizations*>(
               &_APIKeyWithAuthorizations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    160;

  friend void swap(APIKeyWithAuthorizations& a, APIKeyWithAuthorizations& b) {
    a.Swap(&b);
  }
  inline void Swap(APIKeyWithAuthorizations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIKeyWithAuthorizations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIKeyWithAuthorizations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIKeyWithAuthorizations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIKeyWithAuthorizations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const APIKeyWithAuthorizations& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIKeyWithAuthorizations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.APIKeyWithAuthorizations";
  }
  protected:
  explicit APIKeyWithAuthorizations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationsFieldNumber = 2,
    kApiKeyFieldNumber = 1,
  };
  // repeated .viam.app.v1.AuthorizationDetails authorizations = 2 [json_name = "authorizations"];
  int authorizations_size() const;
  private:
  int _internal_authorizations_size() const;
  public:
  void clear_authorizations();
  ::viam::app::v1::AuthorizationDetails* mutable_authorizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >*
      mutable_authorizations();
  private:
  const ::viam::app::v1::AuthorizationDetails& _internal_authorizations(int index) const;
  ::viam::app::v1::AuthorizationDetails* _internal_add_authorizations();
  public:
  const ::viam::app::v1::AuthorizationDetails& authorizations(int index) const;
  ::viam::app::v1::AuthorizationDetails* add_authorizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >&
      authorizations() const;

  // .viam.app.v1.APIKey api_key = 1 [json_name = "apiKey"];
  bool has_api_key() const;
  private:
  bool _internal_has_api_key() const;
  public:
  void clear_api_key();
  const ::viam::app::v1::APIKey& api_key() const;
  PROTOBUF_NODISCARD ::viam::app::v1::APIKey* release_api_key();
  ::viam::app::v1::APIKey* mutable_api_key();
  void set_allocated_api_key(::viam::app::v1::APIKey* api_key);
  private:
  const ::viam::app::v1::APIKey& _internal_api_key() const;
  ::viam::app::v1::APIKey* _internal_mutable_api_key();
  public:
  void unsafe_arena_set_allocated_api_key(
      ::viam::app::v1::APIKey* api_key);
  ::viam::app::v1::APIKey* unsafe_arena_release_api_key();

  // @@protoc_insertion_point(class_scope:viam.app.v1.APIKeyWithAuthorizations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails > authorizations_;
  ::viam::app::v1::APIKey* api_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListKeysRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListKeysRequest) */ {
 public:
  inline ListKeysRequest() : ListKeysRequest(nullptr) {}
  ~ListKeysRequest() override;
  explicit PROTOBUF_CONSTEXPR ListKeysRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListKeysRequest(const ListKeysRequest& from);
  ListKeysRequest(ListKeysRequest&& from) noexcept
    : ListKeysRequest() {
    *this = ::std::move(from);
  }

  inline ListKeysRequest& operator=(const ListKeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListKeysRequest& operator=(ListKeysRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListKeysRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListKeysRequest* internal_default_instance() {
    return reinterpret_cast<const ListKeysRequest*>(
               &_ListKeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    161;

  friend void swap(ListKeysRequest& a, ListKeysRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListKeysRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListKeysRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListKeysRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListKeysRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListKeysRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListKeysRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListKeysRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListKeysRequest";
  }
  protected:
  explicit ListKeysRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgIdFieldNumber = 1,
  };
  // string org_id = 1 [json_name = "orgId"];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListKeysRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListKeysResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListKeysResponse) */ {
 public:
  inline ListKeysResponse() : ListKeysResponse(nullptr) {}
  ~ListKeysResponse() override;
  explicit PROTOBUF_CONSTEXPR ListKeysResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListKeysResponse(const ListKeysResponse& from);
  ListKeysResponse(ListKeysResponse&& from) noexcept
    : ListKeysResponse() {
    *this = ::std::move(from);
  }

  inline ListKeysResponse& operator=(const ListKeysResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListKeysResponse& operator=(ListKeysResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListKeysResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListKeysResponse* internal_default_instance() {
    return reinterpret_cast<const ListKeysResponse*>(
               &_ListKeysResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    162;

  friend void swap(ListKeysResponse& a, ListKeysResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListKeysResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListKeysResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListKeysResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListKeysResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListKeysResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListKeysResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListKeysResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListKeysResponse";
  }
  protected:
  explicit ListKeysResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeysFieldNumber = 1,
  };
  // repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
  int api_keys_size() const;
  private:
  int _internal_api_keys_size() const;
  public:
  void clear_api_keys();
  ::viam::app::v1::APIKeyWithAuthorizations* mutable_api_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
      mutable_api_keys();
  private:
  const ::viam::app::v1::APIKeyWithAuthorizations& _internal_api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* _internal_add_api_keys();
  public:
  const ::viam::app::v1::APIKeyWithAuthorizations& api_keys(int index) const;
  ::viam::app::v1::APIKeyWithAuthorizations* add_api_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
      api_keys() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListKeysResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations > api_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RotateKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RotateKeyRequest) */ {
 public:
  inline RotateKeyRequest() : RotateKeyRequest(nullptr) {}
  ~RotateKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR RotateKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotateKeyRequest(const RotateKeyRequest& from);
  RotateKeyRequest(RotateKeyRequest&& from) noexcept
    : RotateKeyRequest() {
    *this = ::std::move(from);
  }

  inline RotateKeyRequest& operator=(const RotateKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateKeyRequest& operator=(RotateKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotateKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotateKeyRequest* internal_default_instance() {
    return reinterpret_cast<const RotateKeyRequest*>(
               &_RotateKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    163;

  friend void swap(RotateKeyRequest& a, RotateKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RotateKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotateKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotateKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotateKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotateKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RotateKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RotateKeyRequest";
  }
  protected:
  explicit RotateKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RotateKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RotateKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RotateKeyResponse) */ {
 public:
  inline RotateKeyResponse() : RotateKeyResponse(nullptr) {}
  ~RotateKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR RotateKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotateKeyResponse(const RotateKeyResponse& from);
  RotateKeyResponse(RotateKeyResponse&& from) noexcept
    : RotateKeyResponse() {
    *this = ::std::move(from);
  }

  inline RotateKeyResponse& operator=(const RotateKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateKeyResponse& operator=(RotateKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotateKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotateKeyResponse* internal_default_instance() {
    return reinterpret_cast<const RotateKeyResponse*>(
               &_RotateKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    164;

  friend void swap(RotateKeyResponse& a, RotateKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RotateKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotateKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotateKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotateKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotateKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RotateKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RotateKeyResponse";
  }
  protected:
  explicit RotateKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string key = 2 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RotateKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyFromExistingKeyAuthorizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest) */ {
 public:
  inline CreateKeyFromExistingKeyAuthorizationsRequest() : CreateKeyFromExistingKeyAuthorizationsRequest(nullptr) {}
  ~CreateKeyFromExistingKeyAuthorizationsRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyFromExistingKeyAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyFromExistingKeyAuthorizationsRequest(const CreateKeyFromExistingKeyAuthorizationsRequest& from);
  CreateKeyFromExistingKeyAuthorizationsRequest(CreateKeyFromExistingKeyAuthorizationsRequest&& from) noexcept
    : CreateKeyFromExistingKeyAuthorizationsRequest() {
    *this = ::std::move(from);
  }

  inline CreateKeyFromExistingKeyAuthorizationsRequest& operator=(const CreateKeyFromExistingKeyAuthorizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyFromExistingKeyAuthorizationsRequest& operator=(CreateKeyFromExistingKeyAuthorizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyFromExistingKeyAuthorizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyFromExistingKeyAuthorizationsRequest* internal_default_instance() {
    return reinterpret_cast<const CreateKeyFromExistingKeyAuthorizationsRequest*>(
               &_CreateKeyFromExistingKeyAuthorizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    165;

  friend void swap(CreateKeyFromExistingKeyAuthorizationsRequest& a, CreateKeyFromExistingKeyAuthorizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyFromExistingKeyAuthorizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyFromExistingKeyAuthorizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyFromExistingKeyAuthorizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyFromExistingKeyAuthorizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyFromExistingKeyAuthorizationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyFromExistingKeyAuthorizationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyFromExistingKeyAuthorizationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest";
  }
  protected:
  explicit CreateKeyFromExistingKeyAuthorizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyFromExistingKeyAuthorizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse) */ {
 public:
  inline CreateKeyFromExistingKeyAuthorizationsResponse() : CreateKeyFromExistingKeyAuthorizationsResponse(nullptr) {}
  ~CreateKeyFromExistingKeyAuthorizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateKeyFromExistingKeyAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyFromExistingKeyAuthorizationsResponse(const CreateKeyFromExistingKeyAuthorizationsResponse& from);
  CreateKeyFromExistingKeyAuthorizationsResponse(CreateKeyFromExistingKeyAuthorizationsResponse&& from) noexcept
    : CreateKeyFromExistingKeyAuthorizationsResponse() {
    *this = ::std::move(from);
  }

  inline CreateKeyFromExistingKeyAuthorizationsResponse& operator=(const CreateKeyFromExistingKeyAuthorizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyFromExistingKeyAuthorizationsResponse& operator=(CreateKeyFromExistingKeyAuthorizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyFromExistingKeyAuthorizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyFromExistingKeyAuthorizationsResponse* internal_default_instance() {
    return reinterpret_cast<const CreateKeyFromExistingKeyAuthorizationsResponse*>(
               &_CreateKeyFromExistingKeyAuthorizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    166;

  friend void swap(CreateKeyFromExistingKeyAuthorizationsResponse& a, CreateKeyFromExistingKeyAuthorizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyFromExistingKeyAuthorizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyFromExistingKeyAuthorizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateKeyFromExistingKeyAuthorizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateKeyFromExistingKeyAuthorizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyFromExistingKeyAuthorizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyFromExistingKeyAuthorizationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyFromExistingKeyAuthorizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse";
  }
  protected:
  explicit CreateKeyFromExistingKeyAuthorizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string key = 2 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Robot

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void Robot::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Robot::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.id)
}
inline std::string* Robot::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.id)
  return _s;
}
inline const std::string& Robot::_internal_id() const {
  return id_.Get();
}
inline void Robot::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.id)
  return id_.Release();
}
inline void Robot::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void Robot::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Robot::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.name)
}
inline std::string* Robot::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.name)
  return _s;
}
inline const std::string& Robot::_internal_name() const {
  return name_.Get();
}
inline void Robot::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.name)
  return name_.Release();
}
inline void Robot::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.name)
}

// string location = 3 [json_name = "location", (.tagger.v1.tags) = "bson:\"location\" json:\"location\""];
inline void Robot::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& Robot::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.location)
}
inline std::string* Robot::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.location)
  return _s;
}
inline const std::string& Robot::_internal_location() const {
  return location_.Get();
}
inline void Robot::_internal_set_location(const std::string& value) {
  
  location_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_location() {
  
  return location_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.location)
  return location_.Release();
}
inline void Robot::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault()) {
    location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.location)
}

// .google.protobuf.Timestamp last_access = 4 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
inline bool Robot::_internal_has_last_access() const {
  return this != internal_default_instance() && last_access_ != nullptr;
}
inline bool Robot::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.last_access)
  return _internal_last_access();
}
inline void Robot::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  last_access_ = last_access;
  if (last_access) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Robot.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::release_last_access() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.last_access)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::_internal_mutable_last_access() {
  
  if (last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_access_ = p;
  }
  return last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.last_access)
  return _msg;
}
inline void Robot::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    
  } else {
    
  }
  last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.last_access)
}

// .google.protobuf.Timestamp created_on = 5 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool Robot::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Robot::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.created_on)
  return _internal_created_on();
}
inline void Robot::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Robot.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.created_on)
  return _msg;
}
inline void Robot::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.created_on)
}

// -------------------------------------------------------------------

// RobotPart

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void RobotPart::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RobotPart::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.id)
}
inline std::string* RobotPart::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.id)
  return _s;
}
inline const std::string& RobotPart::_internal_id() const {
  return id_.Get();
}
inline void RobotPart::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.id)
  return id_.Release();
}
inline void RobotPart::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void RobotPart::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RobotPart::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.name)
}
inline std::string* RobotPart::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.name)
  return _s;
}
inline const std::string& RobotPart::_internal_name() const {
  return name_.Get();
}
inline void RobotPart::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.name)
  return name_.Release();
}
inline void RobotPart::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.name)
}

// string dns_name = 10 [json_name = "dnsName", (.tagger.v1.tags) = "bson:\"dns_name\" json:\"dns_name\""];
inline void RobotPart::clear_dns_name() {
  dns_name_.ClearToEmpty();
}
inline const std::string& RobotPart::dns_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.dns_name)
  return _internal_dns_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_dns_name(ArgT0&& arg0, ArgT... args) {
 
 dns_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.dns_name)
}
inline std::string* RobotPart::mutable_dns_name() {
  std::string* _s = _internal_mutable_dns_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.dns_name)
  return _s;
}
inline const std::string& RobotPart::_internal_dns_name() const {
  return dns_name_.Get();
}
inline void RobotPart::_internal_set_dns_name(const std::string& value) {
  
  dns_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_dns_name() {
  
  return dns_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_dns_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.dns_name)
  return dns_name_.Release();
}
inline void RobotPart::set_allocated_dns_name(std::string* dns_name) {
  if (dns_name != nullptr) {
    
  } else {
    
  }
  dns_name_.SetAllocated(dns_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dns_name_.IsDefault()) {
    dns_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.dns_name)
}

// string secret = 3 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\" json:\"secret,omitempty\""];
inline void RobotPart::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& RobotPart::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.secret)
}
inline std::string* RobotPart::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.secret)
  return _s;
}
inline const std::string& RobotPart::_internal_secret() const {
  return secret_.Get();
}
inline void RobotPart::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.secret)
  return secret_.Release();
}
inline void RobotPart::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.secret)
}

// string robot = 4 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
inline void RobotPart::clear_robot() {
  robot_.ClearToEmpty();
}
inline const std::string& RobotPart::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.robot)
  return _internal_robot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_robot(ArgT0&& arg0, ArgT... args) {
 
 robot_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.robot)
}
inline std::string* RobotPart::mutable_robot() {
  std::string* _s = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.robot)
  return _s;
}
inline const std::string& RobotPart::_internal_robot() const {
  return robot_.Get();
}
inline void RobotPart::_internal_set_robot(const std::string& value) {
  
  robot_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_robot() {
  
  return robot_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.robot)
  return robot_.Release();
}
inline void RobotPart::set_allocated_robot(std::string* robot) {
  if (robot != nullptr) {
    
  } else {
    
  }
  robot_.SetAllocated(robot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_.IsDefault()) {
    robot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.robot)
}

// string location_id = 12 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"-\""];
inline void RobotPart::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& RobotPart::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.location_id)
}
inline std::string* RobotPart::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.location_id)
  return _s;
}
inline const std::string& RobotPart::_internal_location_id() const {
  return location_id_.Get();
}
inline void RobotPart::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.location_id)
  return location_id_.Release();
}
inline void RobotPart::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.location_id)
}

// .google.protobuf.Struct robot_config = 5 [json_name = "robotConfig", (.tagger.v1.tags) = "bson:\"config\" json:\"robot_config\""];
inline bool RobotPart::_internal_has_robot_config() const {
  return this != internal_default_instance() && robot_config_ != nullptr;
}
inline bool RobotPart::has_robot_config() const {
  return _internal_has_robot_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::_internal_robot_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = robot_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::robot_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.robot_config)
  return _internal_robot_config();
}
inline void RobotPart::unsafe_arena_set_allocated_robot_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  robot_config_ = robot_config;
  if (robot_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.robot_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::release_robot_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::unsafe_arena_release_robot_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.robot_config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::_internal_mutable_robot_config() {
  
  if (robot_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    robot_config_ = p;
  }
  return robot_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::mutable_robot_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_robot_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.robot_config)
  return _msg;
}
inline void RobotPart::set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  if (robot_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config));
    if (message_arena != submessage_arena) {
      robot_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_config, submessage_arena);
    }
    
  } else {
    
  }
  robot_config_ = robot_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.robot_config)
}

// .google.protobuf.Timestamp last_access = 6 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
inline bool RobotPart::_internal_has_last_access() const {
  return this != internal_default_instance() && last_access_ != nullptr;
}
inline bool RobotPart::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.last_access)
  return _internal_last_access();
}
inline void RobotPart::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  last_access_ = last_access;
  if (last_access) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::release_last_access() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.last_access)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_access_;
  last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::_internal_mutable_last_access() {
  
  if (last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_access_ = p;
  }
  return last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.last_access)
  return _msg;
}
inline void RobotPart::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    
  } else {
    
  }
  last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.last_access)
}

// .google.protobuf.Struct user_supplied_info = 7 [json_name = "userSuppliedInfo", (.tagger.v1.tags) = "bson:\"user_supplied_info\" json:\"user_supplied_info\""];
inline bool RobotPart::_internal_has_user_supplied_info() const {
  return this != internal_default_instance() && user_supplied_info_ != nullptr;
}
inline bool RobotPart::has_user_supplied_info() const {
  return _internal_has_user_supplied_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::_internal_user_supplied_info() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = user_supplied_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::user_supplied_info() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.user_supplied_info)
  return _internal_user_supplied_info();
}
inline void RobotPart::unsafe_arena_set_allocated_user_supplied_info(
    ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_supplied_info_);
  }
  user_supplied_info_ = user_supplied_info;
  if (user_supplied_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.user_supplied_info)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::release_user_supplied_info() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = user_supplied_info_;
  user_supplied_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::unsafe_arena_release_user_supplied_info() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.user_supplied_info)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = user_supplied_info_;
  user_supplied_info_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::_internal_mutable_user_supplied_info() {
  
  if (user_supplied_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    user_supplied_info_ = p;
  }
  return user_supplied_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::mutable_user_supplied_info() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_user_supplied_info();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.user_supplied_info)
  return _msg;
}
inline void RobotPart::set_allocated_user_supplied_info(::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_supplied_info_);
  }
  if (user_supplied_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_supplied_info));
    if (message_arena != submessage_arena) {
      user_supplied_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_supplied_info, submessage_arena);
    }
    
  } else {
    
  }
  user_supplied_info_ = user_supplied_info;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.user_supplied_info)
}

// bool main_part = 8 [json_name = "mainPart", (.tagger.v1.tags) = "bson:\"main_part\" json:\"main_part\""];
inline void RobotPart::clear_main_part() {
  main_part_ = false;
}
inline bool RobotPart::_internal_main_part() const {
  return main_part_;
}
inline bool RobotPart::main_part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.main_part)
  return _internal_main_part();
}
inline void RobotPart::_internal_set_main_part(bool value) {
  
  main_part_ = value;
}
inline void RobotPart::set_main_part(bool value) {
  _internal_set_main_part(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.main_part)
}

// string fqdn = 9 [json_name = "fqdn"];
inline void RobotPart::clear_fqdn() {
  fqdn_.ClearToEmpty();
}
inline const std::string& RobotPart::fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.fqdn)
  return _internal_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_fqdn(ArgT0&& arg0, ArgT... args) {
 
 fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.fqdn)
}
inline std::string* RobotPart::mutable_fqdn() {
  std::string* _s = _internal_mutable_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.fqdn)
  return _s;
}
inline const std::string& RobotPart::_internal_fqdn() const {
  return fqdn_.Get();
}
inline void RobotPart::_internal_set_fqdn(const std::string& value) {
  
  fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_fqdn() {
  
  return fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.fqdn)
  return fqdn_.Release();
}
inline void RobotPart::set_allocated_fqdn(std::string* fqdn) {
  if (fqdn != nullptr) {
    
  } else {
    
  }
  fqdn_.SetAllocated(fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fqdn_.IsDefault()) {
    fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.fqdn)
}

// string local_fqdn = 11 [json_name = "localFqdn"];
inline void RobotPart::clear_local_fqdn() {
  local_fqdn_.ClearToEmpty();
}
inline const std::string& RobotPart::local_fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.local_fqdn)
  return _internal_local_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_local_fqdn(ArgT0&& arg0, ArgT... args) {
 
 local_fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.local_fqdn)
}
inline std::string* RobotPart::mutable_local_fqdn() {
  std::string* _s = _internal_mutable_local_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.local_fqdn)
  return _s;
}
inline const std::string& RobotPart::_internal_local_fqdn() const {
  return local_fqdn_.Get();
}
inline void RobotPart::_internal_set_local_fqdn(const std::string& value) {
  
  local_fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_local_fqdn() {
  
  return local_fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_local_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.local_fqdn)
  return local_fqdn_.Release();
}
inline void RobotPart::set_allocated_local_fqdn(std::string* local_fqdn) {
  if (local_fqdn != nullptr) {
    
  } else {
    
  }
  local_fqdn_.SetAllocated(local_fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (local_fqdn_.IsDefault()) {
    local_fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.local_fqdn)
}

// .google.protobuf.Timestamp created_on = 13 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool RobotPart::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool RobotPart::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.created_on)
  return _internal_created_on();
}
inline void RobotPart::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.created_on)
  return _msg;
}
inline void RobotPart::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.created_on)
}

// repeated .viam.app.v1.SharedSecret secrets = 14 [json_name = "secrets", (.tagger.v1.tags) = "bson:\"secrets\""];
inline int RobotPart::_internal_secrets_size() const {
  return secrets_.size();
}
inline int RobotPart::secrets_size() const {
  return _internal_secrets_size();
}
inline void RobotPart::clear_secrets() {
  secrets_.Clear();
}
inline ::viam::app::v1::SharedSecret* RobotPart::mutable_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.secrets)
  return secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
RobotPart::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotPart.secrets)
  return &secrets_;
}
inline const ::viam::app::v1::SharedSecret& RobotPart::_internal_secrets(int index) const {
  return secrets_.Get(index);
}
inline const ::viam::app::v1::SharedSecret& RobotPart::secrets(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.secrets)
  return _internal_secrets(index);
}
inline ::viam::app::v1::SharedSecret* RobotPart::_internal_add_secrets() {
  return secrets_.Add();
}
inline ::viam::app::v1::SharedSecret* RobotPart::add_secrets() {
  ::viam::app::v1::SharedSecret* _add = _internal_add_secrets();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotPart.secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
RobotPart::secrets() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotPart.secrets)
  return secrets_;
}

// -------------------------------------------------------------------

// RobotPartHistoryEntry

// string part = 1 [json_name = "part", (.tagger.v1.tags) = "bson:\"part\" json:\"part\""];
inline void RobotPartHistoryEntry::clear_part() {
  part_.ClearToEmpty();
}
inline const std::string& RobotPartHistoryEntry::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.part)
  return _internal_part();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPartHistoryEntry::set_part(ArgT0&& arg0, ArgT... args) {
 
 part_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPartHistoryEntry.part)
}
inline std::string* RobotPartHistoryEntry::mutable_part() {
  std::string* _s = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.part)
  return _s;
}
inline const std::string& RobotPartHistoryEntry::_internal_part() const {
  return part_.Get();
}
inline void RobotPartHistoryEntry::_internal_set_part(const std::string& value) {
  
  part_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::_internal_mutable_part() {
  
  return part_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.part)
  return part_.Release();
}
inline void RobotPartHistoryEntry::set_allocated_part(std::string* part) {
  if (part != nullptr) {
    
  } else {
    
  }
  part_.SetAllocated(part, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_.IsDefault()) {
    part_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.part)
}

// string robot = 2 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
inline void RobotPartHistoryEntry::clear_robot() {
  robot_.ClearToEmpty();
}
inline const std::string& RobotPartHistoryEntry::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.robot)
  return _internal_robot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPartHistoryEntry::set_robot(ArgT0&& arg0, ArgT... args) {
 
 robot_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPartHistoryEntry.robot)
}
inline std::string* RobotPartHistoryEntry::mutable_robot() {
  std::string* _s = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.robot)
  return _s;
}
inline const std::string& RobotPartHistoryEntry::_internal_robot() const {
  return robot_.Get();
}
inline void RobotPartHistoryEntry::_internal_set_robot(const std::string& value) {
  
  robot_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::_internal_mutable_robot() {
  
  return robot_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.robot)
  return robot_.Release();
}
inline void RobotPartHistoryEntry::set_allocated_robot(std::string* robot) {
  if (robot != nullptr) {
    
  } else {
    
  }
  robot_.SetAllocated(robot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_.IsDefault()) {
    robot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.robot)
}

// .google.protobuf.Timestamp when = 3 [json_name = "when", (.tagger.v1.tags) = "bson:\"when\" json:\"when\""];
inline bool RobotPartHistoryEntry::_internal_has_when() const {
  return this != internal_default_instance() && when_ != nullptr;
}
inline bool RobotPartHistoryEntry::has_when() const {
  return _internal_has_when();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPartHistoryEntry::_internal_when() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = when_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPartHistoryEntry::when() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.when)
  return _internal_when();
}
inline void RobotPartHistoryEntry::unsafe_arena_set_allocated_when(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* when) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(when_);
  }
  when_ = when;
  if (when) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPartHistoryEntry.when)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::release_when() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = when_;
  when_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::unsafe_arena_release_when() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.when)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = when_;
  when_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::_internal_mutable_when() {
  
  if (when_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    when_ = p;
  }
  return when_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::mutable_when() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_when();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.when)
  return _msg;
}
inline void RobotPartHistoryEntry::set_allocated_when(::PROTOBUF_NAMESPACE_ID::Timestamp* when) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(when_);
  }
  if (when) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(when));
    if (message_arena != submessage_arena) {
      when = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, when, submessage_arena);
    }
    
  } else {
    
  }
  when_ = when;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.when)
}

// .viam.app.v1.RobotPart old = 4 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
inline bool RobotPartHistoryEntry::_internal_has_old() const {
  return this != internal_default_instance() && old_ != nullptr;
}
inline bool RobotPartHistoryEntry::has_old() const {
  return _internal_has_old();
}
inline void RobotPartHistoryEntry::clear_old() {
  if (GetArenaForAllocation() == nullptr && old_ != nullptr) {
    delete old_;
  }
  old_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& RobotPartHistoryEntry::_internal_old() const {
  const ::viam::app::v1::RobotPart* p = old_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& RobotPartHistoryEntry::old() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.old)
  return _internal_old();
}
inline void RobotPartHistoryEntry::unsafe_arena_set_allocated_old(
    ::viam::app::v1::RobotPart* old) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_);
  }
  old_ = old;
  if (old) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPartHistoryEntry.old)
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::release_old() {
  
  ::viam::app::v1::RobotPart* temp = old_;
  old_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::unsafe_arena_release_old() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.old)
  
  ::viam::app::v1::RobotPart* temp = old_;
  old_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::_internal_mutable_old() {
  
  if (old_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    old_ = p;
  }
  return old_;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::mutable_old() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_old();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.old)
  return _msg;
}
inline void RobotPartHistoryEntry::set_allocated_old(::viam::app::v1::RobotPart* old) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete old_;
  }
  if (old) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old);
    if (message_arena != submessage_arena) {
      old = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old, submessage_arena);
    }
    
  } else {
    
  }
  old_ = old;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.old)
}

// -------------------------------------------------------------------

// ListOrganizationsRequest

// -------------------------------------------------------------------

// Organization

// string id = 1 [json_name = "id"];
inline void Organization::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Organization::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.id)
}
inline std::string* Organization::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.id)
  return _s;
}
inline const std::string& Organization::_internal_id() const {
  return id_.Get();
}
inline void Organization::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.id)
  return id_.Release();
}
inline void Organization::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.id)
}

// string name = 2 [json_name = "name"];
inline void Organization::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Organization::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.name)
}
inline std::string* Organization::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.name)
  return _s;
}
inline const std::string& Organization::_internal_name() const {
  return name_.Get();
}
inline void Organization::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.name)
  return name_.Release();
}
inline void Organization::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.name)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool Organization::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Organization::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Organization::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Organization::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.created_on)
  return _internal_created_on();
}
inline void Organization::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Organization.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.created_on)
  return _msg;
}
inline void Organization::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.created_on)
}

// string public_namespace = 4 [json_name = "publicNamespace"];
inline void Organization::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& Organization::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.public_namespace)
}
inline std::string* Organization::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.public_namespace)
  return _s;
}
inline const std::string& Organization::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void Organization::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.public_namespace)
  return public_namespace_.Release();
}
inline void Organization::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.public_namespace)
}

// string default_region = 5 [json_name = "defaultRegion"];
inline void Organization::clear_default_region() {
  default_region_.ClearToEmpty();
}
inline const std::string& Organization::default_region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.default_region)
  return _internal_default_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_default_region(ArgT0&& arg0, ArgT... args) {
 
 default_region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.default_region)
}
inline std::string* Organization::mutable_default_region() {
  std::string* _s = _internal_mutable_default_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.default_region)
  return _s;
}
inline const std::string& Organization::_internal_default_region() const {
  return default_region_.Get();
}
inline void Organization::_internal_set_default_region(const std::string& value) {
  
  default_region_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_default_region() {
  
  return default_region_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_default_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.default_region)
  return default_region_.Release();
}
inline void Organization::set_allocated_default_region(std::string* default_region) {
  if (default_region != nullptr) {
    
  } else {
    
  }
  default_region_.SetAllocated(default_region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_region_.IsDefault()) {
    default_region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.default_region)
}

// optional string cid = 6 [json_name = "cid"];
inline bool Organization::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Organization::has_cid() const {
  return _internal_has_cid();
}
inline void Organization::clear_cid() {
  cid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Organization::cid() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_cid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.cid)
}
inline std::string* Organization::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.cid)
  return _s;
}
inline const std::string& Organization::_internal_cid() const {
  return cid_.Get();
}
inline void Organization::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000001u;
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_cid() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Organization::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.cid)
}

// -------------------------------------------------------------------

// OrganizationMember

// string user_id = 1 [json_name = "userId"];
inline void OrganizationMember::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& OrganizationMember::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationMember::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationMember.user_id)
}
inline std::string* OrganizationMember::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.user_id)
  return _s;
}
inline const std::string& OrganizationMember::_internal_user_id() const {
  return user_id_.Get();
}
inline void OrganizationMember::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationMember::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationMember::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationMember.user_id)
  return user_id_.Release();
}
inline void OrganizationMember::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationMember.user_id)
}

// repeated string emails = 2 [json_name = "emails"];
inline int OrganizationMember::_internal_emails_size() const {
  return emails_.size();
}
inline int OrganizationMember::emails_size() const {
  return _internal_emails_size();
}
inline void OrganizationMember::clear_emails() {
  emails_.Clear();
}
inline std::string* OrganizationMember::add_emails() {
  std::string* _s = _internal_add_emails();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.OrganizationMember.emails)
  return _s;
}
inline const std::string& OrganizationMember::_internal_emails(int index) const {
  return emails_.Get(index);
}
inline const std::string& OrganizationMember::emails(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.emails)
  return _internal_emails(index);
}
inline std::string* OrganizationMember::mutable_emails(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.emails)
  return emails_.Mutable(index);
}
inline void OrganizationMember::set_emails(int index, const std::string& value) {
  emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::set_emails(int index, std::string&& value) {
  emails_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::set_emails(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::set_emails(int index, const char* value, size_t size) {
  emails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.OrganizationMember.emails)
}
inline std::string* OrganizationMember::_internal_add_emails() {
  return emails_.Add();
}
inline void OrganizationMember::add_emails(const std::string& value) {
  emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::add_emails(std::string&& value) {
  emails_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::add_emails(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.OrganizationMember.emails)
}
inline void OrganizationMember::add_emails(const char* value, size_t size) {
  emails_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.OrganizationMember.emails)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrganizationMember::emails() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.OrganizationMember.emails)
  return emails_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrganizationMember::mutable_emails() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.OrganizationMember.emails)
  return &emails_;
}

// .google.protobuf.Timestamp date_added = 3 [json_name = "dateAdded"];
inline bool OrganizationMember::_internal_has_date_added() const {
  return this != internal_default_instance() && date_added_ != nullptr;
}
inline bool OrganizationMember::has_date_added() const {
  return _internal_has_date_added();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::_internal_date_added() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = date_added_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::date_added() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.date_added)
  return _internal_date_added();
}
inline void OrganizationMember::unsafe_arena_set_allocated_date_added(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* date_added) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_added_);
  }
  date_added_ = date_added;
  if (date_added) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.OrganizationMember.date_added)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::release_date_added() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = date_added_;
  date_added_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::unsafe_arena_release_date_added() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationMember.date_added)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = date_added_;
  date_added_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::_internal_mutable_date_added() {
  
  if (date_added_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    date_added_ = p;
  }
  return date_added_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::mutable_date_added() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_date_added();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.date_added)
  return _msg;
}
inline void OrganizationMember::set_allocated_date_added(::PROTOBUF_NAMESPACE_ID::Timestamp* date_added) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_added_);
  }
  if (date_added) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_added));
    if (message_arena != submessage_arena) {
      date_added = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_added, submessage_arena);
    }
    
  } else {
    
  }
  date_added_ = date_added;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationMember.date_added)
}

// optional .google.protobuf.Timestamp last_login = 4 [json_name = "lastLogin"];
inline bool OrganizationMember::_internal_has_last_login() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || last_login_ != nullptr);
  return value;
}
inline bool OrganizationMember::has_last_login() const {
  return _internal_has_last_login();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::_internal_last_login() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_login_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationMember::last_login() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationMember.last_login)
  return _internal_last_login();
}
inline void OrganizationMember::unsafe_arena_set_allocated_last_login(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  last_login_ = last_login;
  if (last_login) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.OrganizationMember.last_login)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::release_last_login() {
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_login_;
  last_login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::unsafe_arena_release_last_login() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationMember.last_login)
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_login_;
  last_login_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::_internal_mutable_last_login() {
  _has_bits_[0] |= 0x00000001u;
  if (last_login_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_login_ = p;
  }
  return last_login_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationMember::mutable_last_login() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_login();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationMember.last_login)
  return _msg;
}
inline void OrganizationMember::set_allocated_last_login(::PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  if (last_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login));
    if (message_arena != submessage_arena) {
      last_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_login, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_login_ = last_login;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationMember.last_login)
}

// -------------------------------------------------------------------

// ListOrganizationsResponse

// repeated .viam.app.v1.Organization organizations = 1 [json_name = "organizations"];
inline int ListOrganizationsResponse::_internal_organizations_size() const {
  return organizations_.size();
}
inline int ListOrganizationsResponse::organizations_size() const {
  return _internal_organizations_size();
}
inline void ListOrganizationsResponse::clear_organizations() {
  organizations_.Clear();
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::mutable_organizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationsResponse.organizations)
  return organizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >*
ListOrganizationsResponse::mutable_organizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationsResponse.organizations)
  return &organizations_;
}
inline const ::viam::app::v1::Organization& ListOrganizationsResponse::_internal_organizations(int index) const {
  return organizations_.Get(index);
}
inline const ::viam::app::v1::Organization& ListOrganizationsResponse::organizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationsResponse.organizations)
  return _internal_organizations(index);
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::_internal_add_organizations() {
  return organizations_.Add();
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::add_organizations() {
  ::viam::app::v1::Organization* _add = _internal_add_organizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationsResponse.organizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >&
ListOrganizationsResponse::organizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationsResponse.organizations)
  return organizations_;
}

// -------------------------------------------------------------------

// OrganizationInvite

// string organization_id = 1 [json_name = "organizationId"];
inline void OrganizationInvite::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& OrganizationInvite::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationInvite::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationInvite.organization_id)
}
inline std::string* OrganizationInvite::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.organization_id)
  return _s;
}
inline const std::string& OrganizationInvite::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void OrganizationInvite::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationInvite::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationInvite::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationInvite.organization_id)
  return organization_id_.Release();
}
inline void OrganizationInvite::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationInvite.organization_id)
}

// string email = 2 [json_name = "email"];
inline void OrganizationInvite::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& OrganizationInvite::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationInvite::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationInvite.email)
}
inline std::string* OrganizationInvite::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.email)
  return _s;
}
inline const std::string& OrganizationInvite::_internal_email() const {
  return email_.Get();
}
inline void OrganizationInvite::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationInvite::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationInvite::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationInvite.email)
  return email_.Release();
}
inline void OrganizationInvite::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationInvite.email)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool OrganizationInvite::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool OrganizationInvite::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationInvite::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OrganizationInvite::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.created_on)
  return _internal_created_on();
}
inline void OrganizationInvite::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.OrganizationInvite.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationInvite.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OrganizationInvite::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.created_on)
  return _msg;
}
inline void OrganizationInvite::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationInvite.created_on)
}

// repeated .viam.app.v1.Authorization authorizations = 4 [json_name = "authorizations"];
inline int OrganizationInvite::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int OrganizationInvite::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void OrganizationInvite::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* OrganizationInvite::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationInvite.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
OrganizationInvite::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.OrganizationInvite.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& OrganizationInvite::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& OrganizationInvite::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationInvite.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* OrganizationInvite::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* OrganizationInvite::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.OrganizationInvite.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
OrganizationInvite::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.OrganizationInvite.authorizations)
  return authorizations_;
}

// -------------------------------------------------------------------

// CreateOrganizationRequest

// string name = 1 [json_name = "name"];
inline void CreateOrganizationRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateOrganizationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOrganizationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationRequest.name)
}
inline std::string* CreateOrganizationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationRequest.name)
  return _s;
}
inline const std::string& CreateOrganizationRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateOrganizationRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOrganizationRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOrganizationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationRequest.name)
  return name_.Release();
}
inline void CreateOrganizationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationRequest.name)
}

// -------------------------------------------------------------------

// CreateOrganizationResponse

// .viam.app.v1.Organization organization = 1 [json_name = "organization"];
inline bool CreateOrganizationResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool CreateOrganizationResponse::has_organization() const {
  return _internal_has_organization();
}
inline void CreateOrganizationResponse::clear_organization() {
  if (GetArenaForAllocation() == nullptr && organization_ != nullptr) {
    delete organization_;
  }
  organization_ = nullptr;
}
inline const ::viam::app::v1::Organization& CreateOrganizationResponse::_internal_organization() const {
  const ::viam::app::v1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Organization&>(
      ::viam::app::v1::_Organization_default_instance_);
}
inline const ::viam::app::v1::Organization& CreateOrganizationResponse::organization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationResponse.organization)
  return _internal_organization();
}
inline void CreateOrganizationResponse::unsafe_arena_set_allocated_organization(
    ::viam::app::v1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateOrganizationResponse.organization)
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::release_organization() {
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationResponse.organization)
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::viam::app::v1::Organization* CreateOrganizationResponse::mutable_organization() {
  ::viam::app::v1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationResponse.organization)
  return _msg;
}
inline void CreateOrganizationResponse::set_allocated_organization(::viam::app::v1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationResponse.organization)
}

// -------------------------------------------------------------------

// GetOrganizationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetOrganizationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& GetOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationRequest.organization_id)
}
inline std::string* GetOrganizationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationRequest.organization_id)
  return _s;
}
inline const std::string& GetOrganizationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void GetOrganizationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationRequest.organization_id)
  return organization_id_.Release();
}
inline void GetOrganizationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// GetOrganizationResponse

// .viam.app.v1.Organization organization = 1 [json_name = "organization"];
inline bool GetOrganizationResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool GetOrganizationResponse::has_organization() const {
  return _internal_has_organization();
}
inline void GetOrganizationResponse::clear_organization() {
  if (GetArenaForAllocation() == nullptr && organization_ != nullptr) {
    delete organization_;
  }
  organization_ = nullptr;
}
inline const ::viam::app::v1::Organization& GetOrganizationResponse::_internal_organization() const {
  const ::viam::app::v1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Organization&>(
      ::viam::app::v1::_Organization_default_instance_);
}
inline const ::viam::app::v1::Organization& GetOrganizationResponse::organization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationResponse.organization)
  return _internal_organization();
}
inline void GetOrganizationResponse::unsafe_arena_set_allocated_organization(
    ::viam::app::v1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetOrganizationResponse.organization)
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::release_organization() {
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationResponse.organization)
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::viam::app::v1::Organization* GetOrganizationResponse::mutable_organization() {
  ::viam::app::v1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationResponse.organization)
  return _msg;
}
inline void GetOrganizationResponse::set_allocated_organization(::viam::app::v1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationResponse.organization)
}

// -------------------------------------------------------------------

// GetOrganizationNamespaceAvailabilityRequest

// string public_namespace = 1 [json_name = "publicNamespace"];
inline void GetOrganizationNamespaceAvailabilityRequest::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& GetOrganizationNamespaceAvailabilityRequest::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationNamespaceAvailabilityRequest::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
  return _s;
}
inline const std::string& GetOrganizationNamespaceAvailabilityRequest::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void GetOrganizationNamespaceAvailabilityRequest::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationNamespaceAvailabilityRequest::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
  return public_namespace_.Release();
}
inline void GetOrganizationNamespaceAvailabilityRequest::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationNamespaceAvailabilityRequest.public_namespace)
}

// -------------------------------------------------------------------

// GetOrganizationNamespaceAvailabilityResponse

// bool available = 1 [json_name = "available"];
inline void GetOrganizationNamespaceAvailabilityResponse::clear_available() {
  available_ = false;
}
inline bool GetOrganizationNamespaceAvailabilityResponse::_internal_available() const {
  return available_;
}
inline bool GetOrganizationNamespaceAvailabilityResponse::available() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse.available)
  return _internal_available();
}
inline void GetOrganizationNamespaceAvailabilityResponse::_internal_set_available(bool value) {
  
  available_ = value;
}
inline void GetOrganizationNamespaceAvailabilityResponse::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationNamespaceAvailabilityResponse.available)
}

// -------------------------------------------------------------------

// UpdateOrganizationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void UpdateOrganizationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.organization_id)
}
inline std::string* UpdateOrganizationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.organization_id)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.organization_id)
  return organization_id_.Release();
}
inline void UpdateOrganizationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.organization_id)
}

// optional string name = 2 [json_name = "name"];
inline bool UpdateOrganizationRequest::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_name() const {
  return _internal_has_name();
}
inline void UpdateOrganizationRequest::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateOrganizationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.name)
}
inline std::string* UpdateOrganizationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.name)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.name)
}

// optional string public_namespace = 3 [json_name = "publicNamespace"];
inline bool UpdateOrganizationRequest::_internal_has_public_namespace() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_public_namespace() const {
  return _internal_has_public_namespace();
}
inline void UpdateOrganizationRequest::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateOrganizationRequest::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.public_namespace)
}
inline std::string* UpdateOrganizationRequest::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.public_namespace)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_public_namespace(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_public_namespace() {
  _has_bits_[0] |= 0x00000002u;
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.public_namespace)
  if (!_internal_has_public_namespace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_namespace_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.public_namespace)
}

// optional string region = 4 [json_name = "region"];
inline bool UpdateOrganizationRequest::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_region() const {
  return _internal_has_region();
}
inline void UpdateOrganizationRequest::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UpdateOrganizationRequest::region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.region)
}
inline std::string* UpdateOrganizationRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.region)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_region() const {
  return region_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000004u;
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.region)
}

// optional string cid = 5 [json_name = "cid"];
inline bool UpdateOrganizationRequest::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdateOrganizationRequest::has_cid() const {
  return _internal_has_cid();
}
inline void UpdateOrganizationRequest::clear_cid() {
  cid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UpdateOrganizationRequest::cid() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationRequest.cid)
}
inline std::string* UpdateOrganizationRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationRequest.cid)
  return _s;
}
inline const std::string& UpdateOrganizationRequest::_internal_cid() const {
  return cid_.Get();
}
inline void UpdateOrganizationRequest::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  cid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000008u;
  return cid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationRequest::release_cid() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationRequest.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = cid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOrganizationRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cid_.IsDefault()) {
    cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationRequest.cid)
}

// -------------------------------------------------------------------

// UpdateOrganizationResponse

// .viam.app.v1.Organization organization = 1 [json_name = "organization"];
inline bool UpdateOrganizationResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool UpdateOrganizationResponse::has_organization() const {
  return _internal_has_organization();
}
inline void UpdateOrganizationResponse::clear_organization() {
  if (GetArenaForAllocation() == nullptr && organization_ != nullptr) {
    delete organization_;
  }
  organization_ = nullptr;
}
inline const ::viam::app::v1::Organization& UpdateOrganizationResponse::_internal_organization() const {
  const ::viam::app::v1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Organization&>(
      ::viam::app::v1::_Organization_default_instance_);
}
inline const ::viam::app::v1::Organization& UpdateOrganizationResponse::organization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationResponse.organization)
  return _internal_organization();
}
inline void UpdateOrganizationResponse::unsafe_arena_set_allocated_organization(
    ::viam::app::v1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOrganizationResponse.organization)
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::release_organization() {
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationResponse.organization)
  
  ::viam::app::v1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::viam::app::v1::Organization* UpdateOrganizationResponse::mutable_organization() {
  ::viam::app::v1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationResponse.organization)
  return _msg;
}
inline void UpdateOrganizationResponse::set_allocated_organization(::viam::app::v1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationResponse.organization)
}

// -------------------------------------------------------------------

// DeleteOrganizationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void DeleteOrganizationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationRequest.organization_id)
}
inline std::string* DeleteOrganizationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationRequest.organization_id)
  return _s;
}
inline const std::string& DeleteOrganizationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void DeleteOrganizationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationRequest.organization_id)
  return organization_id_.Release();
}
inline void DeleteOrganizationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// DeleteOrganizationResponse

// -------------------------------------------------------------------

// ListOrganizationMembersRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListOrganizationMembersRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListOrganizationMembersRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOrganizationMembersRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOrganizationMembersRequest.organization_id)
}
inline std::string* ListOrganizationMembersRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersRequest.organization_id)
  return _s;
}
inline const std::string& ListOrganizationMembersRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListOrganizationMembersRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListOrganizationMembersRequest.organization_id)
  return organization_id_.Release();
}
inline void ListOrganizationMembersRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListOrganizationMembersRequest.organization_id)
}

// -------------------------------------------------------------------

// ListOrganizationMembersResponse

// string organization_id = 1 [json_name = "organizationId"];
inline void ListOrganizationMembersResponse::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListOrganizationMembersResponse::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersResponse.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOrganizationMembersResponse::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOrganizationMembersResponse.organization_id)
}
inline std::string* ListOrganizationMembersResponse::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersResponse.organization_id)
  return _s;
}
inline const std::string& ListOrganizationMembersResponse::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListOrganizationMembersResponse::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersResponse::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOrganizationMembersResponse::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListOrganizationMembersResponse.organization_id)
  return organization_id_.Release();
}
inline void ListOrganizationMembersResponse::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListOrganizationMembersResponse.organization_id)
}

// repeated .viam.app.v1.OrganizationMember members = 2 [json_name = "members"];
inline int ListOrganizationMembersResponse::_internal_members_size() const {
  return members_.size();
}
inline int ListOrganizationMembersResponse::members_size() const {
  return _internal_members_size();
}
inline void ListOrganizationMembersResponse::clear_members() {
  members_.Clear();
}
inline ::viam::app::v1::OrganizationMember* ListOrganizationMembersResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersResponse.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >*
ListOrganizationMembersResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationMembersResponse.members)
  return &members_;
}
inline const ::viam::app::v1::OrganizationMember& ListOrganizationMembersResponse::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::viam::app::v1::OrganizationMember& ListOrganizationMembersResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersResponse.members)
  return _internal_members(index);
}
inline ::viam::app::v1::OrganizationMember* ListOrganizationMembersResponse::_internal_add_members() {
  return members_.Add();
}
inline ::viam::app::v1::OrganizationMember* ListOrganizationMembersResponse::add_members() {
  ::viam::app::v1::OrganizationMember* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationMembersResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationMember >&
ListOrganizationMembersResponse::members() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationMembersResponse.members)
  return members_;
}

// repeated .viam.app.v1.OrganizationInvite invites = 3 [json_name = "invites"];
inline int ListOrganizationMembersResponse::_internal_invites_size() const {
  return invites_.size();
}
inline int ListOrganizationMembersResponse::invites_size() const {
  return _internal_invites_size();
}
inline void ListOrganizationMembersResponse::clear_invites() {
  invites_.Clear();
}
inline ::viam::app::v1::OrganizationInvite* ListOrganizationMembersResponse::mutable_invites(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationMembersResponse.invites)
  return invites_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >*
ListOrganizationMembersResponse::mutable_invites() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationMembersResponse.invites)
  return &invites_;
}
inline const ::viam::app::v1::OrganizationInvite& ListOrganizationMembersResponse::_internal_invites(int index) const {
  return invites_.Get(index);
}
inline const ::viam::app::v1::OrganizationInvite& ListOrganizationMembersResponse::invites(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationMembersResponse.invites)
  return _internal_invites(index);
}
inline ::viam::app::v1::OrganizationInvite* ListOrganizationMembersResponse::_internal_add_invites() {
  return invites_.Add();
}
inline ::viam::app::v1::OrganizationInvite* ListOrganizationMembersResponse::add_invites() {
  ::viam::app::v1::OrganizationInvite* _add = _internal_add_invites();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationMembersResponse.invites)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationInvite >&
ListOrganizationMembersResponse::invites() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationMembersResponse.invites)
  return invites_;
}

// -------------------------------------------------------------------

// CreateOrganizationInviteRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateOrganizationInviteRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateOrganizationInviteRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOrganizationInviteRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
}
inline std::string* CreateOrganizationInviteRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
  return _s;
}
inline const std::string& CreateOrganizationInviteRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateOrganizationInviteRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateOrganizationInviteRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationInviteRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void CreateOrganizationInviteRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& CreateOrganizationInviteRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOrganizationInviteRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationInviteRequest.email)
}
inline std::string* CreateOrganizationInviteRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteRequest.email)
  return _s;
}
inline const std::string& CreateOrganizationInviteRequest::_internal_email() const {
  return email_.Get();
}
inline void CreateOrganizationInviteRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOrganizationInviteRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationInviteRequest.email)
  return email_.Release();
}
inline void CreateOrganizationInviteRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationInviteRequest.email)
}

// repeated .viam.app.v1.Authorization authorizations = 3 [json_name = "authorizations"];
inline int CreateOrganizationInviteRequest::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int CreateOrganizationInviteRequest::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void CreateOrganizationInviteRequest::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* CreateOrganizationInviteRequest::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
CreateOrganizationInviteRequest::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& CreateOrganizationInviteRequest::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& CreateOrganizationInviteRequest::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* CreateOrganizationInviteRequest::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* CreateOrganizationInviteRequest::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
CreateOrganizationInviteRequest::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CreateOrganizationInviteRequest.authorizations)
  return authorizations_;
}

// optional bool send_email_invite = 4 [json_name = "sendEmailInvite"];
inline bool CreateOrganizationInviteRequest::_internal_has_send_email_invite() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateOrganizationInviteRequest::has_send_email_invite() const {
  return _internal_has_send_email_invite();
}
inline void CreateOrganizationInviteRequest::clear_send_email_invite() {
  send_email_invite_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CreateOrganizationInviteRequest::_internal_send_email_invite() const {
  return send_email_invite_;
}
inline bool CreateOrganizationInviteRequest::send_email_invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteRequest.send_email_invite)
  return _internal_send_email_invite();
}
inline void CreateOrganizationInviteRequest::_internal_set_send_email_invite(bool value) {
  _has_bits_[0] |= 0x00000001u;
  send_email_invite_ = value;
}
inline void CreateOrganizationInviteRequest::set_send_email_invite(bool value) {
  _internal_set_send_email_invite(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateOrganizationInviteRequest.send_email_invite)
}

// -------------------------------------------------------------------

// CreateOrganizationInviteResponse

// .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
inline bool CreateOrganizationInviteResponse::_internal_has_invite() const {
  return this != internal_default_instance() && invite_ != nullptr;
}
inline bool CreateOrganizationInviteResponse::has_invite() const {
  return _internal_has_invite();
}
inline void CreateOrganizationInviteResponse::clear_invite() {
  if (GetArenaForAllocation() == nullptr && invite_ != nullptr) {
    delete invite_;
  }
  invite_ = nullptr;
}
inline const ::viam::app::v1::OrganizationInvite& CreateOrganizationInviteResponse::_internal_invite() const {
  const ::viam::app::v1::OrganizationInvite* p = invite_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OrganizationInvite&>(
      ::viam::app::v1::_OrganizationInvite_default_instance_);
}
inline const ::viam::app::v1::OrganizationInvite& CreateOrganizationInviteResponse::invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateOrganizationInviteResponse.invite)
  return _internal_invite();
}
inline void CreateOrganizationInviteResponse::unsafe_arena_set_allocated_invite(
    ::viam::app::v1::OrganizationInvite* invite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invite_);
  }
  invite_ = invite;
  if (invite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateOrganizationInviteResponse.invite)
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::release_invite() {
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::unsafe_arena_release_invite() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateOrganizationInviteResponse.invite)
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::_internal_mutable_invite() {
  
  if (invite_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(GetArenaForAllocation());
    invite_ = p;
  }
  return invite_;
}
inline ::viam::app::v1::OrganizationInvite* CreateOrganizationInviteResponse::mutable_invite() {
  ::viam::app::v1::OrganizationInvite* _msg = _internal_mutable_invite();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateOrganizationInviteResponse.invite)
  return _msg;
}
inline void CreateOrganizationInviteResponse::set_allocated_invite(::viam::app::v1::OrganizationInvite* invite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invite_;
  }
  if (invite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invite);
    if (message_arena != submessage_arena) {
      invite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invite, submessage_arena);
    }
    
  } else {
    
  }
  invite_ = invite;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateOrganizationInviteResponse.invite)
}

// -------------------------------------------------------------------

// UpdateOrganizationInviteAuthorizationsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationInviteAuthorizationsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
  return _s;
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
  return organization_id_.Release();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrganizationInviteAuthorizationsRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
  return _s;
}
inline const std::string& UpdateOrganizationInviteAuthorizationsRequest::_internal_email() const {
  return email_.Get();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrganizationInviteAuthorizationsRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
  return email_.Release();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.email)
}

// repeated .viam.app.v1.Authorization add_authorizations = 3 [json_name = "addAuthorizations"];
inline int UpdateOrganizationInviteAuthorizationsRequest::_internal_add_authorizations_size() const {
  return add_authorizations_.size();
}
inline int UpdateOrganizationInviteAuthorizationsRequest::add_authorizations_size() const {
  return _internal_add_authorizations_size();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_add_authorizations() {
  add_authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::mutable_add_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return add_authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
UpdateOrganizationInviteAuthorizationsRequest::mutable_add_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return &add_authorizations_;
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::_internal_add_authorizations(int index) const {
  return add_authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::add_authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return _internal_add_authorizations(index);
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::_internal_add_add_authorizations() {
  return add_authorizations_.Add();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::add_add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
UpdateOrganizationInviteAuthorizationsRequest::add_authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.add_authorizations)
  return add_authorizations_;
}

// repeated .viam.app.v1.Authorization remove_authorizations = 4 [json_name = "removeAuthorizations"];
inline int UpdateOrganizationInviteAuthorizationsRequest::_internal_remove_authorizations_size() const {
  return remove_authorizations_.size();
}
inline int UpdateOrganizationInviteAuthorizationsRequest::remove_authorizations_size() const {
  return _internal_remove_authorizations_size();
}
inline void UpdateOrganizationInviteAuthorizationsRequest::clear_remove_authorizations() {
  remove_authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::mutable_remove_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return remove_authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
UpdateOrganizationInviteAuthorizationsRequest::mutable_remove_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return &remove_authorizations_;
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::_internal_remove_authorizations(int index) const {
  return remove_authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& UpdateOrganizationInviteAuthorizationsRequest::remove_authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return _internal_remove_authorizations(index);
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::_internal_add_remove_authorizations() {
  return remove_authorizations_.Add();
}
inline ::viam::app::v1::Authorization* UpdateOrganizationInviteAuthorizationsRequest::add_remove_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_remove_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
UpdateOrganizationInviteAuthorizationsRequest::remove_authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateOrganizationInviteAuthorizationsRequest.remove_authorizations)
  return remove_authorizations_;
}

// -------------------------------------------------------------------

// UpdateOrganizationInviteAuthorizationsResponse

// .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
inline bool UpdateOrganizationInviteAuthorizationsResponse::_internal_has_invite() const {
  return this != internal_default_instance() && invite_ != nullptr;
}
inline bool UpdateOrganizationInviteAuthorizationsResponse::has_invite() const {
  return _internal_has_invite();
}
inline void UpdateOrganizationInviteAuthorizationsResponse::clear_invite() {
  if (GetArenaForAllocation() == nullptr && invite_ != nullptr) {
    delete invite_;
  }
  invite_ = nullptr;
}
inline const ::viam::app::v1::OrganizationInvite& UpdateOrganizationInviteAuthorizationsResponse::_internal_invite() const {
  const ::viam::app::v1::OrganizationInvite* p = invite_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OrganizationInvite&>(
      ::viam::app::v1::_OrganizationInvite_default_instance_);
}
inline const ::viam::app::v1::OrganizationInvite& UpdateOrganizationInviteAuthorizationsResponse::invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
  return _internal_invite();
}
inline void UpdateOrganizationInviteAuthorizationsResponse::unsafe_arena_set_allocated_invite(
    ::viam::app::v1::OrganizationInvite* invite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invite_);
  }
  invite_ = invite;
  if (invite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::release_invite() {
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::unsafe_arena_release_invite() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::_internal_mutable_invite() {
  
  if (invite_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(GetArenaForAllocation());
    invite_ = p;
  }
  return invite_;
}
inline ::viam::app::v1::OrganizationInvite* UpdateOrganizationInviteAuthorizationsResponse::mutable_invite() {
  ::viam::app::v1::OrganizationInvite* _msg = _internal_mutable_invite();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
  return _msg;
}
inline void UpdateOrganizationInviteAuthorizationsResponse::set_allocated_invite(::viam::app::v1::OrganizationInvite* invite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invite_;
  }
  if (invite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invite);
    if (message_arena != submessage_arena) {
      invite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invite, submessage_arena);
    }
    
  } else {
    
  }
  invite_ = invite;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateOrganizationInviteAuthorizationsResponse.invite)
}

// -------------------------------------------------------------------

// DeleteOrganizationInviteRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void DeleteOrganizationInviteRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationInviteRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationInviteRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
}
inline std::string* DeleteOrganizationInviteRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
  return _s;
}
inline const std::string& DeleteOrganizationInviteRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void DeleteOrganizationInviteRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
  return organization_id_.Release();
}
inline void DeleteOrganizationInviteRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationInviteRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void DeleteOrganizationInviteRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationInviteRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationInviteRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationInviteRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationInviteRequest.email)
}
inline std::string* DeleteOrganizationInviteRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationInviteRequest.email)
  return _s;
}
inline const std::string& DeleteOrganizationInviteRequest::_internal_email() const {
  return email_.Get();
}
inline void DeleteOrganizationInviteRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationInviteRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationInviteRequest.email)
  return email_.Release();
}
inline void DeleteOrganizationInviteRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationInviteRequest.email)
}

// -------------------------------------------------------------------

// DeleteOrganizationInviteResponse

// -------------------------------------------------------------------

// ResendOrganizationInviteRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ResendOrganizationInviteRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ResendOrganizationInviteRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResendOrganizationInviteRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
}
inline std::string* ResendOrganizationInviteRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
  return _s;
}
inline const std::string& ResendOrganizationInviteRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ResendOrganizationInviteRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
  return organization_id_.Release();
}
inline void ResendOrganizationInviteRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResendOrganizationInviteRequest.organization_id)
}

// string email = 2 [json_name = "email"];
inline void ResendOrganizationInviteRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& ResendOrganizationInviteRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResendOrganizationInviteRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResendOrganizationInviteRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResendOrganizationInviteRequest.email)
}
inline std::string* ResendOrganizationInviteRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResendOrganizationInviteRequest.email)
  return _s;
}
inline const std::string& ResendOrganizationInviteRequest::_internal_email() const {
  return email_.Get();
}
inline void ResendOrganizationInviteRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* ResendOrganizationInviteRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResendOrganizationInviteRequest.email)
  return email_.Release();
}
inline void ResendOrganizationInviteRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResendOrganizationInviteRequest.email)
}

// -------------------------------------------------------------------

// ResendOrganizationInviteResponse

// .viam.app.v1.OrganizationInvite invite = 1 [json_name = "invite"];
inline bool ResendOrganizationInviteResponse::_internal_has_invite() const {
  return this != internal_default_instance() && invite_ != nullptr;
}
inline bool ResendOrganizationInviteResponse::has_invite() const {
  return _internal_has_invite();
}
inline void ResendOrganizationInviteResponse::clear_invite() {
  if (GetArenaForAllocation() == nullptr && invite_ != nullptr) {
    delete invite_;
  }
  invite_ = nullptr;
}
inline const ::viam::app::v1::OrganizationInvite& ResendOrganizationInviteResponse::_internal_invite() const {
  const ::viam::app::v1::OrganizationInvite* p = invite_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::OrganizationInvite&>(
      ::viam::app::v1::_OrganizationInvite_default_instance_);
}
inline const ::viam::app::v1::OrganizationInvite& ResendOrganizationInviteResponse::invite() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResendOrganizationInviteResponse.invite)
  return _internal_invite();
}
inline void ResendOrganizationInviteResponse::unsafe_arena_set_allocated_invite(
    ::viam::app::v1::OrganizationInvite* invite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invite_);
  }
  invite_ = invite;
  if (invite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ResendOrganizationInviteResponse.invite)
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::release_invite() {
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::unsafe_arena_release_invite() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResendOrganizationInviteResponse.invite)
  
  ::viam::app::v1::OrganizationInvite* temp = invite_;
  invite_ = nullptr;
  return temp;
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::_internal_mutable_invite() {
  
  if (invite_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::OrganizationInvite>(GetArenaForAllocation());
    invite_ = p;
  }
  return invite_;
}
inline ::viam::app::v1::OrganizationInvite* ResendOrganizationInviteResponse::mutable_invite() {
  ::viam::app::v1::OrganizationInvite* _msg = _internal_mutable_invite();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResendOrganizationInviteResponse.invite)
  return _msg;
}
inline void ResendOrganizationInviteResponse::set_allocated_invite(::viam::app::v1::OrganizationInvite* invite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invite_;
  }
  if (invite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invite);
    if (message_arena != submessage_arena) {
      invite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invite, submessage_arena);
    }
    
  } else {
    
  }
  invite_ = invite;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResendOrganizationInviteResponse.invite)
}

// -------------------------------------------------------------------

// DeleteOrganizationMemberRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void DeleteOrganizationMemberRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationMemberRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationMemberRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
}
inline std::string* DeleteOrganizationMemberRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
  return _s;
}
inline const std::string& DeleteOrganizationMemberRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void DeleteOrganizationMemberRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
  return organization_id_.Release();
}
inline void DeleteOrganizationMemberRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationMemberRequest.organization_id)
}

// string user_id = 2 [json_name = "userId"];
inline void DeleteOrganizationMemberRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DeleteOrganizationMemberRequest::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOrganizationMemberRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
}
inline std::string* DeleteOrganizationMemberRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
  return _s;
}
inline const std::string& DeleteOrganizationMemberRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DeleteOrganizationMemberRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOrganizationMemberRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
  return user_id_.Release();
}
inline void DeleteOrganizationMemberRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteOrganizationMemberRequest.user_id)
}

// -------------------------------------------------------------------

// DeleteOrganizationMemberResponse

// -------------------------------------------------------------------

// OrganizationIdentity

// string id = 1 [json_name = "id"];
inline void OrganizationIdentity::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& OrganizationIdentity::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationIdentity.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationIdentity::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationIdentity.id)
}
inline std::string* OrganizationIdentity::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationIdentity.id)
  return _s;
}
inline const std::string& OrganizationIdentity::_internal_id() const {
  return id_.Get();
}
inline void OrganizationIdentity::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationIdentity.id)
  return id_.Release();
}
inline void OrganizationIdentity::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationIdentity.id)
}

// string name = 2 [json_name = "name"];
inline void OrganizationIdentity::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& OrganizationIdentity::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrganizationIdentity.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationIdentity::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrganizationIdentity.name)
}
inline std::string* OrganizationIdentity::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrganizationIdentity.name)
  return _s;
}
inline const std::string& OrganizationIdentity::_internal_name() const {
  return name_.Get();
}
inline void OrganizationIdentity::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationIdentity::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrganizationIdentity.name)
  return name_.Release();
}
inline void OrganizationIdentity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrganizationIdentity.name)
}

// -------------------------------------------------------------------

// LocationOrganization

// string organization_id = 1 [json_name = "organizationId"];
inline void LocationOrganization::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& LocationOrganization::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationOrganization.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationOrganization::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationOrganization.organization_id)
}
inline std::string* LocationOrganization::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationOrganization.organization_id)
  return _s;
}
inline const std::string& LocationOrganization::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void LocationOrganization::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationOrganization::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationOrganization::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationOrganization.organization_id)
  return organization_id_.Release();
}
inline void LocationOrganization::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationOrganization.organization_id)
}

// bool primary = 2 [json_name = "primary"];
inline void LocationOrganization::clear_primary() {
  primary_ = false;
}
inline bool LocationOrganization::_internal_primary() const {
  return primary_;
}
inline bool LocationOrganization::primary() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationOrganization.primary)
  return _internal_primary();
}
inline void LocationOrganization::_internal_set_primary(bool value) {
  
  primary_ = value;
}
inline void LocationOrganization::set_primary(bool value) {
  _internal_set_primary(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationOrganization.primary)
}

// -------------------------------------------------------------------

// LocationAuth

// string secret = 1 [json_name = "secret", deprecated = true];
inline void LocationAuth::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& LocationAuth::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuth::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuth.secret)
}
inline std::string* LocationAuth::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.secret)
  return _s;
}
inline const std::string& LocationAuth::_internal_secret() const {
  return secret_.Get();
}
inline void LocationAuth::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuth::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuth::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuth.secret)
  return secret_.Release();
}
inline void LocationAuth::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuth.secret)
}

// string location_id = 2 [json_name = "locationId"];
inline void LocationAuth::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& LocationAuth::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuth::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuth.location_id)
}
inline std::string* LocationAuth::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.location_id)
  return _s;
}
inline const std::string& LocationAuth::_internal_location_id() const {
  return location_id_.Get();
}
inline void LocationAuth::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuth::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuth::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuth.location_id)
  return location_id_.Release();
}
inline void LocationAuth::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuth.location_id)
}

// repeated .viam.app.v1.SharedSecret secrets = 3 [json_name = "secrets"];
inline int LocationAuth::_internal_secrets_size() const {
  return secrets_.size();
}
inline int LocationAuth::secrets_size() const {
  return _internal_secrets_size();
}
inline void LocationAuth::clear_secrets() {
  secrets_.Clear();
}
inline ::viam::app::v1::SharedSecret* LocationAuth::mutable_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.secrets)
  return secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
LocationAuth::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.LocationAuth.secrets)
  return &secrets_;
}
inline const ::viam::app::v1::SharedSecret& LocationAuth::_internal_secrets(int index) const {
  return secrets_.Get(index);
}
inline const ::viam::app::v1::SharedSecret& LocationAuth::secrets(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.secrets)
  return _internal_secrets(index);
}
inline ::viam::app::v1::SharedSecret* LocationAuth::_internal_add_secrets() {
  return secrets_.Add();
}
inline ::viam::app::v1::SharedSecret* LocationAuth::add_secrets() {
  ::viam::app::v1::SharedSecret* _add = _internal_add_secrets();
  // @@protoc_insertion_point(field_add:viam.app.v1.LocationAuth.secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
LocationAuth::secrets() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.LocationAuth.secrets)
  return secrets_;
}

// -------------------------------------------------------------------

// StorageConfig

// string region = 1 [json_name = "region"];
inline void StorageConfig::clear_region() {
  region_.ClearToEmpty();
}
inline const std::string& StorageConfig::region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.StorageConfig.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageConfig::set_region(ArgT0&& arg0, ArgT... args) {
 
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.StorageConfig.region)
}
inline std::string* StorageConfig::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.StorageConfig.region)
  return _s;
}
inline const std::string& StorageConfig::_internal_region() const {
  return region_.Get();
}
inline void StorageConfig::_internal_set_region(const std::string& value) {
  
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageConfig::_internal_mutable_region() {
  
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageConfig::release_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.StorageConfig.region)
  return region_.Release();
}
inline void StorageConfig::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.StorageConfig.region)
}

// -------------------------------------------------------------------

// Location

// string id = 1 [json_name = "id"];
inline void Location::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Location::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.id)
}
inline std::string* Location::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.id)
  return _s;
}
inline const std::string& Location::_internal_id() const {
  return id_.Get();
}
inline void Location::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.id)
  return id_.Release();
}
inline void Location::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.id)
}

// string name = 2 [json_name = "name"];
inline void Location::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Location::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.name)
}
inline std::string* Location::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.name)
  return _s;
}
inline const std::string& Location::_internal_name() const {
  return name_.Get();
}
inline void Location::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.name)
  return name_.Release();
}
inline void Location::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.name)
}

// string parent_location_id = 4 [json_name = "parentLocationId"];
inline void Location::clear_parent_location_id() {
  parent_location_id_.ClearToEmpty();
}
inline const std::string& Location::parent_location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.parent_location_id)
  return _internal_parent_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_parent_location_id(ArgT0&& arg0, ArgT... args) {
 
 parent_location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.parent_location_id)
}
inline std::string* Location::mutable_parent_location_id() {
  std::string* _s = _internal_mutable_parent_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.parent_location_id)
  return _s;
}
inline const std::string& Location::_internal_parent_location_id() const {
  return parent_location_id_.Get();
}
inline void Location::_internal_set_parent_location_id(const std::string& value) {
  
  parent_location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_parent_location_id() {
  
  return parent_location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_parent_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.parent_location_id)
  return parent_location_id_.Release();
}
inline void Location::set_allocated_parent_location_id(std::string* parent_location_id) {
  if (parent_location_id != nullptr) {
    
  } else {
    
  }
  parent_location_id_.SetAllocated(parent_location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.parent_location_id)
}

// .viam.app.v1.LocationAuth auth = 5 [json_name = "auth"];
inline bool Location::_internal_has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline bool Location::has_auth() const {
  return _internal_has_auth();
}
inline void Location::clear_auth() {
  if (GetArenaForAllocation() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& Location::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& Location::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.auth)
  return _internal_auth();
}
inline void Location::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.auth)
}
inline ::viam::app::v1::LocationAuth* Location::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* Location::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.auth)
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* Location::_internal_mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::LocationAuth* Location::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.auth)
  return _msg;
}
inline void Location::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.auth)
}

// repeated .viam.app.v1.LocationOrganization organizations = 6 [json_name = "organizations"];
inline int Location::_internal_organizations_size() const {
  return organizations_.size();
}
inline int Location::organizations_size() const {
  return _internal_organizations_size();
}
inline void Location::clear_organizations() {
  organizations_.Clear();
}
inline ::viam::app::v1::LocationOrganization* Location::mutable_organizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.organizations)
  return organizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >*
Location::mutable_organizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Location.organizations)
  return &organizations_;
}
inline const ::viam::app::v1::LocationOrganization& Location::_internal_organizations(int index) const {
  return organizations_.Get(index);
}
inline const ::viam::app::v1::LocationOrganization& Location::organizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.organizations)
  return _internal_organizations(index);
}
inline ::viam::app::v1::LocationOrganization* Location::_internal_add_organizations() {
  return organizations_.Add();
}
inline ::viam::app::v1::LocationOrganization* Location::add_organizations() {
  ::viam::app::v1::LocationOrganization* _add = _internal_add_organizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.Location.organizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationOrganization >&
Location::organizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Location.organizations)
  return organizations_;
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool Location::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Location::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Location::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Location::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.created_on)
  return _internal_created_on();
}
inline void Location::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.created_on)
  return _msg;
}
inline void Location::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.created_on)
}

// int32 robot_count = 7 [json_name = "robotCount"];
inline void Location::clear_robot_count() {
  robot_count_ = 0;
}
inline int32_t Location::_internal_robot_count() const {
  return robot_count_;
}
inline int32_t Location::robot_count() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.robot_count)
  return _internal_robot_count();
}
inline void Location::_internal_set_robot_count(int32_t value) {
  
  robot_count_ = value;
}
inline void Location::set_robot_count(int32_t value) {
  _internal_set_robot_count(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.robot_count)
}

// .viam.app.v1.StorageConfig config = 8 [json_name = "config"];
inline bool Location::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool Location::has_config() const {
  return _internal_has_config();
}
inline void Location::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::viam::app::v1::StorageConfig& Location::_internal_config() const {
  const ::viam::app::v1::StorageConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::StorageConfig&>(
      ::viam::app::v1::_StorageConfig_default_instance_);
}
inline const ::viam::app::v1::StorageConfig& Location::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.config)
  return _internal_config();
}
inline void Location::unsafe_arena_set_allocated_config(
    ::viam::app::v1::StorageConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.config)
}
inline ::viam::app::v1::StorageConfig* Location::release_config() {
  
  ::viam::app::v1::StorageConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::StorageConfig* Location::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.config)
  
  ::viam::app::v1::StorageConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::StorageConfig* Location::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::StorageConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::viam::app::v1::StorageConfig* Location::mutable_config() {
  ::viam::app::v1::StorageConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.config)
  return _msg;
}
inline void Location::set_allocated_config(::viam::app::v1::StorageConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.config)
}

// -------------------------------------------------------------------

// SharedSecret

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"id\""];
inline void SharedSecret::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SharedSecret::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharedSecret::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.id)
}
inline std::string* SharedSecret::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.id)
  return _s;
}
inline const std::string& SharedSecret::_internal_id() const {
  return id_.Get();
}
inline void SharedSecret::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedSecret::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedSecret::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.id)
  return id_.Release();
}
inline void SharedSecret::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.id)
}

// string secret = 2 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\""];
inline void SharedSecret::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& SharedSecret::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharedSecret::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.secret)
}
inline std::string* SharedSecret::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.secret)
  return _s;
}
inline const std::string& SharedSecret::_internal_secret() const {
  return secret_.Get();
}
inline void SharedSecret::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedSecret::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedSecret::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.secret)
  return secret_.Release();
}
inline void SharedSecret::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.secret)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
inline bool SharedSecret::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool SharedSecret::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SharedSecret::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SharedSecret::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.created_on)
  return _internal_created_on();
}
inline void SharedSecret::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.SharedSecret.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.created_on)
  return _msg;
}
inline void SharedSecret::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.created_on)
}

// .viam.app.v1.SharedSecret.State state = 4 [json_name = "state", (.tagger.v1.tags) = "bson:\"state\""];
inline void SharedSecret::clear_state() {
  state_ = 0;
}
inline ::viam::app::v1::SharedSecret_State SharedSecret::_internal_state() const {
  return static_cast< ::viam::app::v1::SharedSecret_State >(state_);
}
inline ::viam::app::v1::SharedSecret_State SharedSecret::state() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.state)
  return _internal_state();
}
inline void SharedSecret::_internal_set_state(::viam::app::v1::SharedSecret_State value) {
  
  state_ = value;
}
inline void SharedSecret::set_state(::viam::app::v1::SharedSecret_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.state)
}

// -------------------------------------------------------------------

// CreateLocationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateLocationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateLocationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.organization_id)
}
inline std::string* CreateLocationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.organization_id)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateLocationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateLocationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.organization_id)
}

// string name = 2 [json_name = "name"];
inline void CreateLocationRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateLocationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.name)
}
inline std::string* CreateLocationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.name)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateLocationRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.name)
  return name_.Release();
}
inline void CreateLocationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.name)
}

// optional string parent_location_id = 3 [json_name = "parentLocationId"];
inline bool CreateLocationRequest::_internal_has_parent_location_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateLocationRequest::has_parent_location_id() const {
  return _internal_has_parent_location_id();
}
inline void CreateLocationRequest::clear_parent_location_id() {
  parent_location_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateLocationRequest::parent_location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.parent_location_id)
  return _internal_parent_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_parent_location_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 parent_location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.parent_location_id)
}
inline std::string* CreateLocationRequest::mutable_parent_location_id() {
  std::string* _s = _internal_mutable_parent_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.parent_location_id)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_parent_location_id() const {
  return parent_location_id_.Get();
}
inline void CreateLocationRequest::_internal_set_parent_location_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  parent_location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_parent_location_id() {
  _has_bits_[0] |= 0x00000001u;
  return parent_location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_parent_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.parent_location_id)
  if (!_internal_has_parent_location_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = parent_location_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateLocationRequest::set_allocated_parent_location_id(std::string* parent_location_id) {
  if (parent_location_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parent_location_id_.SetAllocated(parent_location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.parent_location_id)
}

// -------------------------------------------------------------------

// CreateLocationResponse

// .viam.app.v1.Location location = 1 [json_name = "location"];
inline bool CreateLocationResponse::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool CreateLocationResponse::has_location() const {
  return _internal_has_location();
}
inline void CreateLocationResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::viam::app::v1::Location& CreateLocationResponse::_internal_location() const {
  const ::viam::app::v1::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Location&>(
      ::viam::app::v1::_Location_default_instance_);
}
inline const ::viam::app::v1::Location& CreateLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationResponse.location)
  return _internal_location();
}
inline void CreateLocationResponse::unsafe_arena_set_allocated_location(
    ::viam::app::v1::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateLocationResponse.location)
}
inline ::viam::app::v1::Location* CreateLocationResponse::release_location() {
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Location* CreateLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationResponse.location)
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Location* CreateLocationResponse::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::viam::app::v1::Location* CreateLocationResponse::mutable_location() {
  ::viam::app::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationResponse.location)
  return _msg;
}
inline void CreateLocationResponse::set_allocated_location(::viam::app::v1::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationResponse.location)
}

// -------------------------------------------------------------------

// GetLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void GetLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& GetLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetLocationRequest.location_id)
}
inline std::string* GetLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetLocationRequest.location_id)
  return _s;
}
inline const std::string& GetLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void GetLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetLocationRequest.location_id)
  return location_id_.Release();
}
inline void GetLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetLocationRequest.location_id)
}

// -------------------------------------------------------------------

// GetLocationResponse

// .viam.app.v1.Location location = 1 [json_name = "location"];
inline bool GetLocationResponse::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool GetLocationResponse::has_location() const {
  return _internal_has_location();
}
inline void GetLocationResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::viam::app::v1::Location& GetLocationResponse::_internal_location() const {
  const ::viam::app::v1::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Location&>(
      ::viam::app::v1::_Location_default_instance_);
}
inline const ::viam::app::v1::Location& GetLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetLocationResponse.location)
  return _internal_location();
}
inline void GetLocationResponse::unsafe_arena_set_allocated_location(
    ::viam::app::v1::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetLocationResponse.location)
}
inline ::viam::app::v1::Location* GetLocationResponse::release_location() {
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Location* GetLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetLocationResponse.location)
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Location* GetLocationResponse::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::viam::app::v1::Location* GetLocationResponse::mutable_location() {
  ::viam::app::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetLocationResponse.location)
  return _msg;
}
inline void GetLocationResponse::set_allocated_location(::viam::app::v1::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetLocationResponse.location)
}

// -------------------------------------------------------------------

// UpdateLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void UpdateLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& UpdateLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.location_id)
}
inline std::string* UpdateLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.location_id)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void UpdateLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.location_id)
  return location_id_.Release();
}
inline void UpdateLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.location_id)
}

// optional string name = 2 [json_name = "name"];
inline bool UpdateLocationRequest::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateLocationRequest::has_name() const {
  return _internal_has_name();
}
inline void UpdateLocationRequest::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateLocationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.name)
}
inline std::string* UpdateLocationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.name)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateLocationRequest::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateLocationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.name)
}

// optional string parent_location_id = 3 [json_name = "parentLocationId"];
inline bool UpdateLocationRequest::_internal_has_parent_location_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateLocationRequest::has_parent_location_id() const {
  return _internal_has_parent_location_id();
}
inline void UpdateLocationRequest::clear_parent_location_id() {
  parent_location_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateLocationRequest::parent_location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.parent_location_id)
  return _internal_parent_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_parent_location_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 parent_location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.parent_location_id)
}
inline std::string* UpdateLocationRequest::mutable_parent_location_id() {
  std::string* _s = _internal_mutable_parent_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.parent_location_id)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_parent_location_id() const {
  return parent_location_id_.Get();
}
inline void UpdateLocationRequest::_internal_set_parent_location_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  parent_location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_parent_location_id() {
  _has_bits_[0] |= 0x00000002u;
  return parent_location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_parent_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.parent_location_id)
  if (!_internal_has_parent_location_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = parent_location_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateLocationRequest::set_allocated_parent_location_id(std::string* parent_location_id) {
  if (parent_location_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_location_id_.SetAllocated(parent_location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_location_id_.IsDefault()) {
    parent_location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.parent_location_id)
}

// optional string region = 4 [json_name = "region"];
inline bool UpdateLocationRequest::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateLocationRequest::has_region() const {
  return _internal_has_region();
}
inline void UpdateLocationRequest::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UpdateLocationRequest::region() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocationRequest::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateLocationRequest.region)
}
inline std::string* UpdateLocationRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationRequest.region)
  return _s;
}
inline const std::string& UpdateLocationRequest::_internal_region() const {
  return region_.Get();
}
inline void UpdateLocationRequest::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000004u;
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocationRequest::release_region() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationRequest.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateLocationRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationRequest.region)
}

// -------------------------------------------------------------------

// UpdateLocationResponse

// .viam.app.v1.Location location = 1 [json_name = "location"];
inline bool UpdateLocationResponse::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool UpdateLocationResponse::has_location() const {
  return _internal_has_location();
}
inline void UpdateLocationResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::viam::app::v1::Location& UpdateLocationResponse::_internal_location() const {
  const ::viam::app::v1::Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Location&>(
      ::viam::app::v1::_Location_default_instance_);
}
inline const ::viam::app::v1::Location& UpdateLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateLocationResponse.location)
  return _internal_location();
}
inline void UpdateLocationResponse::unsafe_arena_set_allocated_location(
    ::viam::app::v1::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateLocationResponse.location)
}
inline ::viam::app::v1::Location* UpdateLocationResponse::release_location() {
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Location* UpdateLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateLocationResponse.location)
  
  ::viam::app::v1::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Location* UpdateLocationResponse::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::viam::app::v1::Location* UpdateLocationResponse::mutable_location() {
  ::viam::app::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateLocationResponse.location)
  return _msg;
}
inline void UpdateLocationResponse::set_allocated_location(::viam::app::v1::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateLocationResponse.location)
}

// -------------------------------------------------------------------

// DeleteLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void DeleteLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationRequest.location_id)
}
inline std::string* DeleteLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationRequest.location_id)
  return _s;
}
inline const std::string& DeleteLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void DeleteLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationRequest.location_id)
  return location_id_.Release();
}
inline void DeleteLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationRequest.location_id)
}

// -------------------------------------------------------------------

// DeleteLocationResponse

// -------------------------------------------------------------------

// GetOrganizationsWithAccessToLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void GetOrganizationsWithAccessToLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& GetOrganizationsWithAccessToLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationsWithAccessToLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
}
inline std::string* GetOrganizationsWithAccessToLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
  return _s;
}
inline const std::string& GetOrganizationsWithAccessToLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void GetOrganizationsWithAccessToLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationsWithAccessToLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationsWithAccessToLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
  return location_id_.Release();
}
inline void GetOrganizationsWithAccessToLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetOrganizationsWithAccessToLocationRequest.location_id)
}

// -------------------------------------------------------------------

// GetOrganizationsWithAccessToLocationResponse

// repeated .viam.app.v1.OrganizationIdentity organization_identities = 1 [json_name = "organizationIdentities"];
inline int GetOrganizationsWithAccessToLocationResponse::_internal_organization_identities_size() const {
  return organization_identities_.size();
}
inline int GetOrganizationsWithAccessToLocationResponse::organization_identities_size() const {
  return _internal_organization_identities_size();
}
inline void GetOrganizationsWithAccessToLocationResponse::clear_organization_identities() {
  organization_identities_.Clear();
}
inline ::viam::app::v1::OrganizationIdentity* GetOrganizationsWithAccessToLocationResponse::mutable_organization_identities(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return organization_identities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >*
GetOrganizationsWithAccessToLocationResponse::mutable_organization_identities() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return &organization_identities_;
}
inline const ::viam::app::v1::OrganizationIdentity& GetOrganizationsWithAccessToLocationResponse::_internal_organization_identities(int index) const {
  return organization_identities_.Get(index);
}
inline const ::viam::app::v1::OrganizationIdentity& GetOrganizationsWithAccessToLocationResponse::organization_identities(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return _internal_organization_identities(index);
}
inline ::viam::app::v1::OrganizationIdentity* GetOrganizationsWithAccessToLocationResponse::_internal_add_organization_identities() {
  return organization_identities_.Add();
}
inline ::viam::app::v1::OrganizationIdentity* GetOrganizationsWithAccessToLocationResponse::add_organization_identities() {
  ::viam::app::v1::OrganizationIdentity* _add = _internal_add_organization_identities();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrganizationIdentity >&
GetOrganizationsWithAccessToLocationResponse::organization_identities() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetOrganizationsWithAccessToLocationResponse.organization_identities)
  return organization_identities_;
}

// -------------------------------------------------------------------

// ListLocationsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListLocationsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListLocationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListLocationsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocationsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListLocationsRequest.organization_id)
}
inline std::string* ListLocationsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListLocationsRequest.organization_id)
  return _s;
}
inline const std::string& ListLocationsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListLocationsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocationsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocationsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListLocationsRequest.organization_id)
  return organization_id_.Release();
}
inline void ListLocationsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListLocationsRequest.organization_id)
}

// -------------------------------------------------------------------

// ShareLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void ShareLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& ShareLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ShareLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ShareLocationRequest.location_id)
}
inline std::string* ShareLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ShareLocationRequest.location_id)
  return _s;
}
inline const std::string& ShareLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void ShareLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ShareLocationRequest.location_id)
  return location_id_.Release();
}
inline void ShareLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ShareLocationRequest.location_id)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void ShareLocationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ShareLocationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ShareLocationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareLocationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ShareLocationRequest.organization_id)
}
inline std::string* ShareLocationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ShareLocationRequest.organization_id)
  return _s;
}
inline const std::string& ShareLocationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ShareLocationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareLocationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ShareLocationRequest.organization_id)
  return organization_id_.Release();
}
inline void ShareLocationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ShareLocationRequest.organization_id)
}

// -------------------------------------------------------------------

// ShareLocationResponse

// -------------------------------------------------------------------

// UnshareLocationRequest

// string location_id = 1 [json_name = "locationId"];
inline void UnshareLocationRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& UnshareLocationRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UnshareLocationRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnshareLocationRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UnshareLocationRequest.location_id)
}
inline std::string* UnshareLocationRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UnshareLocationRequest.location_id)
  return _s;
}
inline const std::string& UnshareLocationRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void UnshareLocationRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UnshareLocationRequest.location_id)
  return location_id_.Release();
}
inline void UnshareLocationRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UnshareLocationRequest.location_id)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void UnshareLocationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& UnshareLocationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UnshareLocationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnshareLocationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UnshareLocationRequest.organization_id)
}
inline std::string* UnshareLocationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UnshareLocationRequest.organization_id)
  return _s;
}
inline const std::string& UnshareLocationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void UnshareLocationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UnshareLocationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UnshareLocationRequest.organization_id)
  return organization_id_.Release();
}
inline void UnshareLocationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UnshareLocationRequest.organization_id)
}

// -------------------------------------------------------------------

// UnshareLocationResponse

// -------------------------------------------------------------------

// ListLocationsResponse

// repeated .viam.app.v1.Location locations = 1 [json_name = "locations"];
inline int ListLocationsResponse::_internal_locations_size() const {
  return locations_.size();
}
inline int ListLocationsResponse::locations_size() const {
  return _internal_locations_size();
}
inline void ListLocationsResponse::clear_locations() {
  locations_.Clear();
}
inline ::viam::app::v1::Location* ListLocationsResponse::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListLocationsResponse.locations)
  return locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >*
ListLocationsResponse::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListLocationsResponse.locations)
  return &locations_;
}
inline const ::viam::app::v1::Location& ListLocationsResponse::_internal_locations(int index) const {
  return locations_.Get(index);
}
inline const ::viam::app::v1::Location& ListLocationsResponse::locations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListLocationsResponse.locations)
  return _internal_locations(index);
}
inline ::viam::app::v1::Location* ListLocationsResponse::_internal_add_locations() {
  return locations_.Add();
}
inline ::viam::app::v1::Location* ListLocationsResponse::add_locations() {
  ::viam::app::v1::Location* _add = _internal_add_locations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListLocationsResponse.locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >&
ListLocationsResponse::locations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListLocationsResponse.locations)
  return locations_;
}

// -------------------------------------------------------------------

// CreateLocationSecretRequest

// string location_id = 1 [json_name = "locationId"];
inline void CreateLocationSecretRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& CreateLocationSecretRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationSecretRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationSecretRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationSecretRequest.location_id)
}
inline std::string* CreateLocationSecretRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationSecretRequest.location_id)
  return _s;
}
inline const std::string& CreateLocationSecretRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void CreateLocationSecretRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationSecretRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationSecretRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationSecretRequest.location_id)
  return location_id_.Release();
}
inline void CreateLocationSecretRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationSecretRequest.location_id)
}

// -------------------------------------------------------------------

// CreateLocationSecretResponse

// .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
inline bool CreateLocationSecretResponse::_internal_has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline bool CreateLocationSecretResponse::has_auth() const {
  return _internal_has_auth();
}
inline void CreateLocationSecretResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& CreateLocationSecretResponse::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& CreateLocationSecretResponse::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationSecretResponse.auth)
  return _internal_auth();
}
inline void CreateLocationSecretResponse::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateLocationSecretResponse.auth)
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationSecretResponse.auth)
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::_internal_mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationSecretResponse.auth)
  return _msg;
}
inline void CreateLocationSecretResponse::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationSecretResponse.auth)
}

// -------------------------------------------------------------------

// DeleteLocationSecretRequest

// string location_id = 1 [json_name = "locationId"];
inline void DeleteLocationSecretRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationSecretRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationSecretRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationSecretRequest.location_id)
}
inline std::string* DeleteLocationSecretRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return _s;
}
inline const std::string& DeleteLocationSecretRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void DeleteLocationSecretRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return location_id_.Release();
}
inline void DeleteLocationSecretRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationSecretRequest.location_id)
}

// string secret_id = 2 [json_name = "secretId"];
inline void DeleteLocationSecretRequest::clear_secret_id() {
  secret_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationSecretRequest::secret_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return _internal_secret_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationSecretRequest::set_secret_id(ArgT0&& arg0, ArgT... args) {
 
 secret_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationSecretRequest.secret_id)
}
inline std::string* DeleteLocationSecretRequest::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return _s;
}
inline const std::string& DeleteLocationSecretRequest::_internal_secret_id() const {
  return secret_id_.Get();
}
inline void DeleteLocationSecretRequest::_internal_set_secret_id(const std::string& value) {
  
  secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::_internal_mutable_secret_id() {
  
  return secret_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::release_secret_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return secret_id_.Release();
}
inline void DeleteLocationSecretRequest::set_allocated_secret_id(std::string* secret_id) {
  if (secret_id != nullptr) {
    
  } else {
    
  }
  secret_id_.SetAllocated(secret_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_id_.IsDefault()) {
    secret_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationSecretRequest.secret_id)
}

// -------------------------------------------------------------------

// DeleteLocationSecretResponse

// -------------------------------------------------------------------

// LocationAuthRequest

// string location_id = 1 [json_name = "locationId"];
inline void LocationAuthRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& LocationAuthRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuthRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuthRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuthRequest.location_id)
}
inline std::string* LocationAuthRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuthRequest.location_id)
  return _s;
}
inline const std::string& LocationAuthRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void LocationAuthRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuthRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuthRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuthRequest.location_id)
  return location_id_.Release();
}
inline void LocationAuthRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuthRequest.location_id)
}

// -------------------------------------------------------------------

// LocationAuthResponse

// .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
inline bool LocationAuthResponse::_internal_has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline bool LocationAuthResponse::has_auth() const {
  return _internal_has_auth();
}
inline void LocationAuthResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& LocationAuthResponse::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& LocationAuthResponse::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuthResponse.auth)
  return _internal_auth();
}
inline void LocationAuthResponse::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.LocationAuthResponse.auth)
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuthResponse.auth)
  
  ::viam::app::v1::LocationAuth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::_internal_mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuthResponse.auth)
  return _msg;
}
inline void LocationAuthResponse::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuthResponse.auth)
}

// -------------------------------------------------------------------

// GetRobotRequest

// string id = 1 [json_name = "id"];
inline void GetRobotRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotRequest.id)
}
inline std::string* GetRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotRequest.id)
  return _s;
}
inline const std::string& GetRobotRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotRequest.id)
  return id_.Release();
}
inline void GetRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotRequest.id)
}

// -------------------------------------------------------------------

// GetRoverRentalRobotsRequest

// string org_id = 1 [json_name = "orgId"];
inline void GetRoverRentalRobotsRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& GetRoverRentalRobotsRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRoverRentalRobotsRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
}
inline std::string* GetRoverRentalRobotsRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
  return _s;
}
inline const std::string& GetRoverRentalRobotsRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void GetRoverRentalRobotsRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRoverRentalRobotsRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRoverRentalRobotsRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
  return org_id_.Release();
}
inline void GetRoverRentalRobotsRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRoverRentalRobotsRequest.org_id)
}

// -------------------------------------------------------------------

// RoverRentalRobot

// string robot_id = 1 [json_name = "robotId"];
inline void RoverRentalRobot::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.robot_id)
}
inline std::string* RoverRentalRobot::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.robot_id)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void RoverRentalRobot::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.robot_id)
  return robot_id_.Release();
}
inline void RoverRentalRobot::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.robot_id)
}

// string location_id = 2 [json_name = "locationId"];
inline void RoverRentalRobot::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.location_id)
}
inline std::string* RoverRentalRobot::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.location_id)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_location_id() const {
  return location_id_.Get();
}
inline void RoverRentalRobot::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.location_id)
  return location_id_.Release();
}
inline void RoverRentalRobot::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.location_id)
}

// string robot_name = 3 [json_name = "robotName"];
inline void RoverRentalRobot::clear_robot_name() {
  robot_name_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::robot_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.robot_name)
  return _internal_robot_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_robot_name(ArgT0&& arg0, ArgT... args) {
 
 robot_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.robot_name)
}
inline std::string* RoverRentalRobot::mutable_robot_name() {
  std::string* _s = _internal_mutable_robot_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.robot_name)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_robot_name() const {
  return robot_name_.Get();
}
inline void RoverRentalRobot::_internal_set_robot_name(const std::string& value) {
  
  robot_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_robot_name() {
  
  return robot_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_robot_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.robot_name)
  return robot_name_.Release();
}
inline void RoverRentalRobot::set_allocated_robot_name(std::string* robot_name) {
  if (robot_name != nullptr) {
    
  } else {
    
  }
  robot_name_.SetAllocated(robot_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_name_.IsDefault()) {
    robot_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.robot_name)
}

// string robot_main_part_id = 4 [json_name = "robotMainPartId"];
inline void RoverRentalRobot::clear_robot_main_part_id() {
  robot_main_part_id_.ClearToEmpty();
}
inline const std::string& RoverRentalRobot::robot_main_part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RoverRentalRobot.robot_main_part_id)
  return _internal_robot_main_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoverRentalRobot::set_robot_main_part_id(ArgT0&& arg0, ArgT... args) {
 
 robot_main_part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RoverRentalRobot.robot_main_part_id)
}
inline std::string* RoverRentalRobot::mutable_robot_main_part_id() {
  std::string* _s = _internal_mutable_robot_main_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RoverRentalRobot.robot_main_part_id)
  return _s;
}
inline const std::string& RoverRentalRobot::_internal_robot_main_part_id() const {
  return robot_main_part_id_.Get();
}
inline void RoverRentalRobot::_internal_set_robot_main_part_id(const std::string& value) {
  
  robot_main_part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::_internal_mutable_robot_main_part_id() {
  
  return robot_main_part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RoverRentalRobot::release_robot_main_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RoverRentalRobot.robot_main_part_id)
  return robot_main_part_id_.Release();
}
inline void RoverRentalRobot::set_allocated_robot_main_part_id(std::string* robot_main_part_id) {
  if (robot_main_part_id != nullptr) {
    
  } else {
    
  }
  robot_main_part_id_.SetAllocated(robot_main_part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_main_part_id_.IsDefault()) {
    robot_main_part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RoverRentalRobot.robot_main_part_id)
}

// -------------------------------------------------------------------

// GetRoverRentalRobotsResponse

// repeated .viam.app.v1.RoverRentalRobot robots = 1 [json_name = "robots"];
inline int GetRoverRentalRobotsResponse::_internal_robots_size() const {
  return robots_.size();
}
inline int GetRoverRentalRobotsResponse::robots_size() const {
  return _internal_robots_size();
}
inline void GetRoverRentalRobotsResponse::clear_robots() {
  robots_.Clear();
}
inline ::viam::app::v1::RoverRentalRobot* GetRoverRentalRobotsResponse::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >*
GetRoverRentalRobotsResponse::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return &robots_;
}
inline const ::viam::app::v1::RoverRentalRobot& GetRoverRentalRobotsResponse::_internal_robots(int index) const {
  return robots_.Get(index);
}
inline const ::viam::app::v1::RoverRentalRobot& GetRoverRentalRobotsResponse::robots(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return _internal_robots(index);
}
inline ::viam::app::v1::RoverRentalRobot* GetRoverRentalRobotsResponse::_internal_add_robots() {
  return robots_.Add();
}
inline ::viam::app::v1::RoverRentalRobot* GetRoverRentalRobotsResponse::add_robots() {
  ::viam::app::v1::RoverRentalRobot* _add = _internal_add_robots();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RoverRentalRobot >&
GetRoverRentalRobotsResponse::robots() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRoverRentalRobotsResponse.robots)
  return robots_;
}

// -------------------------------------------------------------------

// GetRobotResponse

// .viam.app.v1.Robot robot = 1 [json_name = "robot"];
inline bool GetRobotResponse::_internal_has_robot() const {
  return this != internal_default_instance() && robot_ != nullptr;
}
inline bool GetRobotResponse::has_robot() const {
  return _internal_has_robot();
}
inline void GetRobotResponse::clear_robot() {
  if (GetArenaForAllocation() == nullptr && robot_ != nullptr) {
    delete robot_;
  }
  robot_ = nullptr;
}
inline const ::viam::app::v1::Robot& GetRobotResponse::_internal_robot() const {
  const ::viam::app::v1::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Robot&>(
      ::viam::app::v1::_Robot_default_instance_);
}
inline const ::viam::app::v1::Robot& GetRobotResponse::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotResponse.robot)
  return _internal_robot();
}
inline void GetRobotResponse::unsafe_arena_set_allocated_robot(
    ::viam::app::v1::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotResponse.robot)
}
inline ::viam::app::v1::Robot* GetRobotResponse::release_robot() {
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Robot* GetRobotResponse::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotResponse.robot)
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Robot* GetRobotResponse::_internal_mutable_robot() {
  
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Robot>(GetArenaForAllocation());
    robot_ = p;
  }
  return robot_;
}
inline ::viam::app::v1::Robot* GetRobotResponse::mutable_robot() {
  ::viam::app::v1::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotResponse.robot)
  return _msg;
}
inline void GetRobotResponse::set_allocated_robot(::viam::app::v1::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    
  } else {
    
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotResponse.robot)
}

// -------------------------------------------------------------------

// GetRobotPartsRequest

// string robot_id = 1 [json_name = "robotId"];
inline void GetRobotPartsRequest::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& GetRobotPartsRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartsRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartsRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartsRequest.robot_id)
}
inline std::string* GetRobotPartsRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartsRequest.robot_id)
  return _s;
}
inline const std::string& GetRobotPartsRequest::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void GetRobotPartsRequest::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartsRequest::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartsRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartsRequest.robot_id)
  return robot_id_.Release();
}
inline void GetRobotPartsRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartsRequest.robot_id)
}

// -------------------------------------------------------------------

// GetRobotPartsResponse

// repeated .viam.app.v1.RobotPart parts = 1 [json_name = "parts"];
inline int GetRobotPartsResponse::_internal_parts_size() const {
  return parts_.size();
}
inline int GetRobotPartsResponse::parts_size() const {
  return _internal_parts_size();
}
inline void GetRobotPartsResponse::clear_parts() {
  parts_.Clear();
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartsResponse.parts)
  return parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >*
GetRobotPartsResponse::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartsResponse.parts)
  return &parts_;
}
inline const ::viam::app::v1::RobotPart& GetRobotPartsResponse::_internal_parts(int index) const {
  return parts_.Get(index);
}
inline const ::viam::app::v1::RobotPart& GetRobotPartsResponse::parts(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartsResponse.parts)
  return _internal_parts(index);
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::_internal_add_parts() {
  return parts_.Add();
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::add_parts() {
  ::viam::app::v1::RobotPart* _add = _internal_add_parts();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartsResponse.parts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >&
GetRobotPartsResponse::parts() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartsResponse.parts)
  return parts_;
}

// -------------------------------------------------------------------

// GetRobotPartRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotPartRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartRequest.id)
}
inline std::string* GetRobotPartRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartRequest.id)
  return _s;
}
inline const std::string& GetRobotPartRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotPartRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartRequest.id)
  return id_.Release();
}
inline void GetRobotPartRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartRequest.id)
}

// -------------------------------------------------------------------

// GetRobotPartResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool GetRobotPartResponse::_internal_has_part() const {
  return this != internal_default_instance() && part_ != nullptr;
}
inline bool GetRobotPartResponse::has_part() const {
  return _internal_has_part();
}
inline void GetRobotPartResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && part_ != nullptr) {
    delete part_;
  }
  part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& GetRobotPartResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& GetRobotPartResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartResponse.part)
  return _internal_part();
}
inline void GetRobotPartResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(part_);
  }
  part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotPartResponse.part)
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartResponse.part)
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::_internal_mutable_part() {
  
  if (part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    part_ = p;
  }
  return part_;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartResponse.part)
  return _msg;
}
inline void GetRobotPartResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartResponse.part)
}

// string config_json = 2 [json_name = "configJson"];
inline void GetRobotPartResponse::clear_config_json() {
  config_json_.ClearToEmpty();
}
inline const std::string& GetRobotPartResponse::config_json() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartResponse.config_json)
  return _internal_config_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartResponse::set_config_json(ArgT0&& arg0, ArgT... args) {
 
 config_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartResponse.config_json)
}
inline std::string* GetRobotPartResponse::mutable_config_json() {
  std::string* _s = _internal_mutable_config_json();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartResponse.config_json)
  return _s;
}
inline const std::string& GetRobotPartResponse::_internal_config_json() const {
  return config_json_.Get();
}
inline void GetRobotPartResponse::_internal_set_config_json(const std::string& value) {
  
  config_json_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartResponse::_internal_mutable_config_json() {
  
  return config_json_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartResponse::release_config_json() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartResponse.config_json)
  return config_json_.Release();
}
inline void GetRobotPartResponse::set_allocated_config_json(std::string* config_json) {
  if (config_json != nullptr) {
    
  } else {
    
  }
  config_json_.SetAllocated(config_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_json_.IsDefault()) {
    config_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartResponse.config_json)
}

// -------------------------------------------------------------------

// GetRobotPartLogsRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartLogsRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotPartLogsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.id)
}
inline std::string* GetRobotPartLogsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.id)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.id)
  return id_.Release();
}
inline void GetRobotPartLogsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.id)
}

// bool errors_only = 2 [json_name = "errorsOnly", deprecated = true];
inline void GetRobotPartLogsRequest::clear_errors_only() {
  errors_only_ = false;
}
inline bool GetRobotPartLogsRequest::_internal_errors_only() const {
  return errors_only_;
}
inline bool GetRobotPartLogsRequest::errors_only() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.errors_only)
  return _internal_errors_only();
}
inline void GetRobotPartLogsRequest::_internal_set_errors_only(bool value) {
  
  errors_only_ = value;
}
inline void GetRobotPartLogsRequest::set_errors_only(bool value) {
  _internal_set_errors_only(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.errors_only)
}

// optional string filter = 3 [json_name = "filter"];
inline bool GetRobotPartLogsRequest::_internal_has_filter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetRobotPartLogsRequest::has_filter() const {
  return _internal_has_filter();
}
inline void GetRobotPartLogsRequest::clear_filter() {
  filter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetRobotPartLogsRequest::filter() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.filter)
}
inline std::string* GetRobotPartLogsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.filter)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_filter() const {
  return filter_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  return filter_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.filter)
  if (!_internal_has_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetRobotPartLogsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.filter)
}

// optional string page_token = 4 [json_name = "pageToken"];
inline bool GetRobotPartLogsRequest::_internal_has_page_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetRobotPartLogsRequest::has_page_token() const {
  return _internal_has_page_token();
}
inline void GetRobotPartLogsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetRobotPartLogsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.page_token)
}
inline std::string* GetRobotPartLogsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.page_token)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_page_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_page_token() {
  _has_bits_[0] |= 0x00000002u;
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.page_token)
  if (!_internal_has_page_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetRobotPartLogsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.page_token)
}

// repeated string levels = 5 [json_name = "levels"];
inline int GetRobotPartLogsRequest::_internal_levels_size() const {
  return levels_.size();
}
inline int GetRobotPartLogsRequest::levels_size() const {
  return _internal_levels_size();
}
inline void GetRobotPartLogsRequest::clear_levels() {
  levels_.Clear();
}
inline std::string* GetRobotPartLogsRequest::add_levels() {
  std::string* _s = _internal_add_levels();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.GetRobotPartLogsRequest.levels)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_levels(int index) const {
  return levels_.Get(index);
}
inline const std::string& GetRobotPartLogsRequest::levels(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.levels)
  return _internal_levels(index);
}
inline std::string* GetRobotPartLogsRequest::mutable_levels(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.levels)
  return levels_.Mutable(index);
}
inline void GetRobotPartLogsRequest::set_levels(int index, const std::string& value) {
  levels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::set_levels(int index, std::string&& value) {
  levels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::set_levels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  levels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::set_levels(int index, const char* value, size_t size) {
  levels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline std::string* GetRobotPartLogsRequest::_internal_add_levels() {
  return levels_.Add();
}
inline void GetRobotPartLogsRequest::add_levels(const std::string& value) {
  levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::add_levels(std::string&& value) {
  levels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::add_levels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline void GetRobotPartLogsRequest::add_levels(const char* value, size_t size) {
  levels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.GetRobotPartLogsRequest.levels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetRobotPartLogsRequest::levels() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartLogsRequest.levels)
  return levels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetRobotPartLogsRequest::mutable_levels() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartLogsRequest.levels)
  return &levels_;
}

// -------------------------------------------------------------------

// GetRobotPartLogsResponse

// repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
inline int GetRobotPartLogsResponse::_internal_logs_size() const {
  return logs_.size();
}
inline int GetRobotPartLogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline ::viam::common::v1::LogEntry* GetRobotPartLogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsResponse.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
GetRobotPartLogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartLogsResponse.logs)
  return &logs_;
}
inline const ::viam::common::v1::LogEntry& GetRobotPartLogsResponse::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::viam::common::v1::LogEntry& GetRobotPartLogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _internal_logs(index);
}
inline ::viam::common::v1::LogEntry* GetRobotPartLogsResponse::_internal_add_logs() {
  return logs_.Add();
}
inline ::viam::common::v1::LogEntry* GetRobotPartLogsResponse::add_logs() {
  ::viam::common::v1::LogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
GetRobotPartLogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartLogsResponse.logs)
  return logs_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void GetRobotPartLogsResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& GetRobotPartLogsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
}
inline std::string* GetRobotPartLogsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
  return _s;
}
inline const std::string& GetRobotPartLogsResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void GetRobotPartLogsResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
  return next_page_token_.Release();
}
inline void GetRobotPartLogsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsResponse.next_page_token)
}

// -------------------------------------------------------------------

// TailRobotPartLogsRequest

// string id = 1 [json_name = "id"];
inline void TailRobotPartLogsRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TailRobotPartLogsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TailRobotPartLogsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.id)
}
inline std::string* TailRobotPartLogsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsRequest.id)
  return _s;
}
inline const std::string& TailRobotPartLogsRequest::_internal_id() const {
  return id_.Get();
}
inline void TailRobotPartLogsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TailRobotPartLogsRequest.id)
  return id_.Release();
}
inline void TailRobotPartLogsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TailRobotPartLogsRequest.id)
}

// bool errors_only = 2 [json_name = "errorsOnly"];
inline void TailRobotPartLogsRequest::clear_errors_only() {
  errors_only_ = false;
}
inline bool TailRobotPartLogsRequest::_internal_errors_only() const {
  return errors_only_;
}
inline bool TailRobotPartLogsRequest::errors_only() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.errors_only)
  return _internal_errors_only();
}
inline void TailRobotPartLogsRequest::_internal_set_errors_only(bool value) {
  
  errors_only_ = value;
}
inline void TailRobotPartLogsRequest::set_errors_only(bool value) {
  _internal_set_errors_only(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.errors_only)
}

// optional string filter = 3 [json_name = "filter"];
inline bool TailRobotPartLogsRequest::_internal_has_filter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TailRobotPartLogsRequest::has_filter() const {
  return _internal_has_filter();
}
inline void TailRobotPartLogsRequest::clear_filter() {
  filter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TailRobotPartLogsRequest::filter() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TailRobotPartLogsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.filter)
}
inline std::string* TailRobotPartLogsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsRequest.filter)
  return _s;
}
inline const std::string& TailRobotPartLogsRequest::_internal_filter() const {
  return filter_.Get();
}
inline void TailRobotPartLogsRequest::_internal_set_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_.Set(value, GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::_internal_mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  return filter_.Mutable(GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TailRobotPartLogsRequest.filter)
  if (!_internal_has_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TailRobotPartLogsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_.IsDefault()) {
    filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TailRobotPartLogsRequest.filter)
}

// -------------------------------------------------------------------

// TailRobotPartLogsResponse

// repeated .viam.common.v1.LogEntry logs = 1 [json_name = "logs"];
inline int TailRobotPartLogsResponse::_internal_logs_size() const {
  return logs_.size();
}
inline int TailRobotPartLogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline ::viam::common::v1::LogEntry* TailRobotPartLogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsResponse.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
TailRobotPartLogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.TailRobotPartLogsResponse.logs)
  return &logs_;
}
inline const ::viam::common::v1::LogEntry& TailRobotPartLogsResponse::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::viam::common::v1::LogEntry& TailRobotPartLogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _internal_logs(index);
}
inline ::viam::common::v1::LogEntry* TailRobotPartLogsResponse::_internal_add_logs() {
  return logs_.Add();
}
inline ::viam::common::v1::LogEntry* TailRobotPartLogsResponse::add_logs() {
  ::viam::common::v1::LogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
TailRobotPartLogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.TailRobotPartLogsResponse.logs)
  return logs_;
}

// -------------------------------------------------------------------

// GetRobotPartHistoryRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartHistoryRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRobotPartHistoryRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartHistoryRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartHistoryRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartHistoryRequest.id)
}
inline std::string* GetRobotPartHistoryRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartHistoryRequest.id)
  return _s;
}
inline const std::string& GetRobotPartHistoryRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRobotPartHistoryRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartHistoryRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartHistoryRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartHistoryRequest.id)
  return id_.Release();
}
inline void GetRobotPartHistoryRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartHistoryRequest.id)
}

// -------------------------------------------------------------------

// GetRobotPartHistoryResponse

// repeated .viam.app.v1.RobotPartHistoryEntry history = 1 [json_name = "history"];
inline int GetRobotPartHistoryResponse::_internal_history_size() const {
  return history_.size();
}
inline int GetRobotPartHistoryResponse::history_size() const {
  return _internal_history_size();
}
inline void GetRobotPartHistoryResponse::clear_history() {
  history_.Clear();
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartHistoryResponse.history)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >*
GetRobotPartHistoryResponse::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartHistoryResponse.history)
  return &history_;
}
inline const ::viam::app::v1::RobotPartHistoryEntry& GetRobotPartHistoryResponse::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::viam::app::v1::RobotPartHistoryEntry& GetRobotPartHistoryResponse::history(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _internal_history(index);
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::_internal_add_history() {
  return history_.Add();
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::add_history() {
  ::viam::app::v1::RobotPartHistoryEntry* _add = _internal_add_history();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >&
GetRobotPartHistoryResponse::history() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartHistoryResponse.history)
  return history_;
}

// -------------------------------------------------------------------

// UpdateRobotPartRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotPartRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateRobotPartRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotPartRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotPartRequest.id)
}
inline std::string* UpdateRobotPartRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.id)
  return _s;
}
inline const std::string& UpdateRobotPartRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateRobotPartRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.id)
  return id_.Release();
}
inline void UpdateRobotPartRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateRobotPartRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateRobotPartRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotPartRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotPartRequest.name)
}
inline std::string* UpdateRobotPartRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.name)
  return _s;
}
inline const std::string& UpdateRobotPartRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateRobotPartRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.name)
  return name_.Release();
}
inline void UpdateRobotPartRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.name)
}

// .google.protobuf.Struct robot_config = 3 [json_name = "robotConfig"];
inline bool UpdateRobotPartRequest::_internal_has_robot_config() const {
  return this != internal_default_instance() && robot_config_ != nullptr;
}
inline bool UpdateRobotPartRequest::has_robot_config() const {
  return _internal_has_robot_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartRequest::_internal_robot_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = robot_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartRequest::robot_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.robot_config)
  return _internal_robot_config();
}
inline void UpdateRobotPartRequest::unsafe_arena_set_allocated_robot_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  robot_config_ = robot_config;
  if (robot_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartRequest.robot_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::release_robot_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::unsafe_arena_release_robot_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.robot_config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = robot_config_;
  robot_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::_internal_mutable_robot_config() {
  
  if (robot_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    robot_config_ = p;
  }
  return robot_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::mutable_robot_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_robot_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.robot_config)
  return _msg;
}
inline void UpdateRobotPartRequest::set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config_);
  }
  if (robot_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config));
    if (message_arena != submessage_arena) {
      robot_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_config, submessage_arena);
    }
    
  } else {
    
  }
  robot_config_ = robot_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.robot_config)
}

// -------------------------------------------------------------------

// UpdateRobotPartResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool UpdateRobotPartResponse::_internal_has_part() const {
  return this != internal_default_instance() && part_ != nullptr;
}
inline bool UpdateRobotPartResponse::has_part() const {
  return _internal_has_part();
}
inline void UpdateRobotPartResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && part_ != nullptr) {
    delete part_;
  }
  part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& UpdateRobotPartResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& UpdateRobotPartResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartResponse.part)
  return _internal_part();
}
inline void UpdateRobotPartResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(part_);
  }
  part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartResponse.part)
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartResponse.part)
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::_internal_mutable_part() {
  
  if (part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    part_ = p;
  }
  return part_;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartResponse.part)
  return _msg;
}
inline void UpdateRobotPartResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartResponse.part)
}

// -------------------------------------------------------------------

// NewRobotPartRequest

// string robot_id = 1 [json_name = "robotId"];
inline void NewRobotPartRequest::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& NewRobotPartRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartRequest.robot_id)
}
inline std::string* NewRobotPartRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartRequest.robot_id)
  return _s;
}
inline const std::string& NewRobotPartRequest::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void NewRobotPartRequest::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartRequest.robot_id)
  return robot_id_.Release();
}
inline void NewRobotPartRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartRequest.robot_id)
}

// string part_name = 2 [json_name = "partName"];
inline void NewRobotPartRequest::clear_part_name() {
  part_name_.ClearToEmpty();
}
inline const std::string& NewRobotPartRequest::part_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartRequest.part_name)
  return _internal_part_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartRequest::set_part_name(ArgT0&& arg0, ArgT... args) {
 
 part_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartRequest.part_name)
}
inline std::string* NewRobotPartRequest::mutable_part_name() {
  std::string* _s = _internal_mutable_part_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartRequest.part_name)
  return _s;
}
inline const std::string& NewRobotPartRequest::_internal_part_name() const {
  return part_name_.Get();
}
inline void NewRobotPartRequest::_internal_set_part_name(const std::string& value) {
  
  part_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::_internal_mutable_part_name() {
  
  return part_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::release_part_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartRequest.part_name)
  return part_name_.Release();
}
inline void NewRobotPartRequest::set_allocated_part_name(std::string* part_name) {
  if (part_name != nullptr) {
    
  } else {
    
  }
  part_name_.SetAllocated(part_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_name_.IsDefault()) {
    part_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartRequest.part_name)
}

// -------------------------------------------------------------------

// NewRobotPartResponse

// string part_id = 1 [json_name = "partId"];
inline void NewRobotPartResponse::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& NewRobotPartResponse::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartResponse.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartResponse::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartResponse.part_id)
}
inline std::string* NewRobotPartResponse::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartResponse.part_id)
  return _s;
}
inline const std::string& NewRobotPartResponse::_internal_part_id() const {
  return part_id_.Get();
}
inline void NewRobotPartResponse::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartResponse::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartResponse::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartResponse.part_id)
  return part_id_.Release();
}
inline void NewRobotPartResponse::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartResponse.part_id)
}

// -------------------------------------------------------------------

// DeleteRobotPartRequest

// string part_id = 1 [json_name = "partId"];
inline void DeleteRobotPartRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartRequest.part_id)
}
inline std::string* DeleteRobotPartRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartRequest.part_id)
  return _s;
}
inline const std::string& DeleteRobotPartRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void DeleteRobotPartRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartRequest.part_id)
  return part_id_.Release();
}
inline void DeleteRobotPartRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartRequest.part_id)
}

// -------------------------------------------------------------------

// GetRobotAPIKeysRequest

// string robot_id = 1 [json_name = "robotId"];
inline void GetRobotAPIKeysRequest::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& GetRobotAPIKeysRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotAPIKeysRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
}
inline std::string* GetRobotAPIKeysRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
  return _s;
}
inline const std::string& GetRobotAPIKeysRequest::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void GetRobotAPIKeysRequest::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotAPIKeysRequest::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotAPIKeysRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
  return robot_id_.Release();
}
inline void GetRobotAPIKeysRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotAPIKeysRequest.robot_id)
}

// -------------------------------------------------------------------

// APIKey

// string id = 1 [json_name = "id"];
inline void APIKey::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& APIKey::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKey::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.APIKey.id)
}
inline std::string* APIKey::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.id)
  return _s;
}
inline const std::string& APIKey::_internal_id() const {
  return id_.Get();
}
inline void APIKey::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKey::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKey::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.id)
  return id_.Release();
}
inline void APIKey::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.id)
}

// string key = 2 [json_name = "key"];
inline void APIKey::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& APIKey::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKey::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.APIKey.key)
}
inline std::string* APIKey::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.key)
  return _s;
}
inline const std::string& APIKey::_internal_key() const {
  return key_.Get();
}
inline void APIKey::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKey::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKey::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.key)
  return key_.Release();
}
inline void APIKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.key)
}

// string name = 3 [json_name = "name"];
inline void APIKey::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& APIKey::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKey::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.APIKey.name)
}
inline std::string* APIKey::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.name)
  return _s;
}
inline const std::string& APIKey::_internal_name() const {
  return name_.Get();
}
inline void APIKey::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKey::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKey::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.name)
  return name_.Release();
}
inline void APIKey::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.name)
}

// .google.protobuf.Timestamp created_on = 4 [json_name = "createdOn"];
inline bool APIKey::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool APIKey::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& APIKey::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& APIKey::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKey.created_on)
  return _internal_created_on();
}
inline void APIKey::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.APIKey.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKey.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* APIKey::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKey.created_on)
  return _msg;
}
inline void APIKey::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKey.created_on)
}

// -------------------------------------------------------------------

// GetRobotAPIKeysResponse

// repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
inline int GetRobotAPIKeysResponse::_internal_api_keys_size() const {
  return api_keys_.size();
}
inline int GetRobotAPIKeysResponse::api_keys_size() const {
  return _internal_api_keys_size();
}
inline void GetRobotAPIKeysResponse::clear_api_keys() {
  api_keys_.Clear();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* GetRobotAPIKeysResponse::mutable_api_keys(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return api_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
GetRobotAPIKeysResponse::mutable_api_keys() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return &api_keys_;
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& GetRobotAPIKeysResponse::_internal_api_keys(int index) const {
  return api_keys_.Get(index);
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& GetRobotAPIKeysResponse::api_keys(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return _internal_api_keys(index);
}
inline ::viam::app::v1::APIKeyWithAuthorizations* GetRobotAPIKeysResponse::_internal_add_api_keys() {
  return api_keys_.Add();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* GetRobotAPIKeysResponse::add_api_keys() {
  ::viam::app::v1::APIKeyWithAuthorizations* _add = _internal_add_api_keys();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
GetRobotAPIKeysResponse::api_keys() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotAPIKeysResponse.api_keys)
  return api_keys_;
}

// -------------------------------------------------------------------

// DeleteRobotPartResponse

// -------------------------------------------------------------------

// Fragment

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void Fragment::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Fragment::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.id)
}
inline std::string* Fragment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.id)
  return _s;
}
inline const std::string& Fragment::_internal_id() const {
  return id_.Get();
}
inline void Fragment::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.id)
  return id_.Release();
}
inline void Fragment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void Fragment::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Fragment::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.name)
}
inline std::string* Fragment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.name)
  return _s;
}
inline const std::string& Fragment::_internal_name() const {
  return name_.Get();
}
inline void Fragment::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.name)
  return name_.Release();
}
inline void Fragment::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.name)
}

// .google.protobuf.Struct fragment = 3 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
inline bool Fragment::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool Fragment::has_fragment() const {
  return _internal_has_fragment();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Fragment::_internal_fragment() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Fragment::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.fragment)
  return _internal_fragment();
}
inline void Fragment::unsafe_arena_set_allocated_fragment(
    ::PROTOBUF_NAMESPACE_ID::Struct* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Fragment.fragment)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::release_fragment() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.fragment)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::mutable_fragment() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.fragment)
  return _msg;
}
inline void Fragment::set_allocated_fragment(::PROTOBUF_NAMESPACE_ID::Struct* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment));
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.fragment)
}

// string organization_owner = 4 [json_name = "organizationOwner", (.tagger.v1.tags) = "bson:\"organization_owner\" json:\"owner\""];
inline void Fragment::clear_organization_owner() {
  organization_owner_.ClearToEmpty();
}
inline const std::string& Fragment::organization_owner() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.organization_owner)
  return _internal_organization_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_organization_owner(ArgT0&& arg0, ArgT... args) {
 
 organization_owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.organization_owner)
}
inline std::string* Fragment::mutable_organization_owner() {
  std::string* _s = _internal_mutable_organization_owner();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.organization_owner)
  return _s;
}
inline const std::string& Fragment::_internal_organization_owner() const {
  return organization_owner_.Get();
}
inline void Fragment::_internal_set_organization_owner(const std::string& value) {
  
  organization_owner_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_organization_owner() {
  
  return organization_owner_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_organization_owner() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.organization_owner)
  return organization_owner_.Release();
}
inline void Fragment::set_allocated_organization_owner(std::string* organization_owner) {
  if (organization_owner != nullptr) {
    
  } else {
    
  }
  organization_owner_.SetAllocated(organization_owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_owner_.IsDefault()) {
    organization_owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.organization_owner)
}

// bool public = 5 [json_name = "public", (.tagger.v1.tags) = "bson:\"public\" json:\"public\""];
inline void Fragment::clear_public_() {
  public__ = false;
}
inline bool Fragment::_internal_public_() const {
  return public__;
}
inline bool Fragment::public_() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.public)
  return _internal_public_();
}
inline void Fragment::_internal_set_public_(bool value) {
  
  public__ = value;
}
inline void Fragment::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.public)
}

// .google.protobuf.Timestamp created_on = 6 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool Fragment::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool Fragment::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.created_on)
  return _internal_created_on();
}
inline void Fragment::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Fragment.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.created_on)
  return _msg;
}
inline void Fragment::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.created_on)
}

// string organization_name = 7 [json_name = "organizationName"];
inline void Fragment::clear_organization_name() {
  organization_name_.ClearToEmpty();
}
inline const std::string& Fragment::organization_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.organization_name)
  return _internal_organization_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_organization_name(ArgT0&& arg0, ArgT... args) {
 
 organization_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.organization_name)
}
inline std::string* Fragment::mutable_organization_name() {
  std::string* _s = _internal_mutable_organization_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.organization_name)
  return _s;
}
inline const std::string& Fragment::_internal_organization_name() const {
  return organization_name_.Get();
}
inline void Fragment::_internal_set_organization_name(const std::string& value) {
  
  organization_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_organization_name() {
  
  return organization_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_organization_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.organization_name)
  return organization_name_.Release();
}
inline void Fragment::set_allocated_organization_name(std::string* organization_name) {
  if (organization_name != nullptr) {
    
  } else {
    
  }
  organization_name_.SetAllocated(organization_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_name_.IsDefault()) {
    organization_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.organization_name)
}

// int32 robot_part_count = 9 [json_name = "robotPartCount"];
inline void Fragment::clear_robot_part_count() {
  robot_part_count_ = 0;
}
inline int32_t Fragment::_internal_robot_part_count() const {
  return robot_part_count_;
}
inline int32_t Fragment::robot_part_count() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.robot_part_count)
  return _internal_robot_part_count();
}
inline void Fragment::_internal_set_robot_part_count(int32_t value) {
  
  robot_part_count_ = value;
}
inline void Fragment::set_robot_part_count(int32_t value) {
  _internal_set_robot_part_count(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.robot_part_count)
}

// int32 organization_count = 10 [json_name = "organizationCount"];
inline void Fragment::clear_organization_count() {
  organization_count_ = 0;
}
inline int32_t Fragment::_internal_organization_count() const {
  return organization_count_;
}
inline int32_t Fragment::organization_count() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.organization_count)
  return _internal_organization_count();
}
inline void Fragment::_internal_set_organization_count(int32_t value) {
  
  organization_count_ = value;
}
inline void Fragment::set_organization_count(int32_t value) {
  _internal_set_organization_count(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.organization_count)
}

// bool only_used_by_owner = 11 [json_name = "onlyUsedByOwner"];
inline void Fragment::clear_only_used_by_owner() {
  only_used_by_owner_ = false;
}
inline bool Fragment::_internal_only_used_by_owner() const {
  return only_used_by_owner_;
}
inline bool Fragment::only_used_by_owner() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.only_used_by_owner)
  return _internal_only_used_by_owner();
}
inline void Fragment::_internal_set_only_used_by_owner(bool value) {
  
  only_used_by_owner_ = value;
}
inline void Fragment::set_only_used_by_owner(bool value) {
  _internal_set_only_used_by_owner(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.only_used_by_owner)
}

// -------------------------------------------------------------------

// ListFragmentsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListFragmentsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListFragmentsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListFragmentsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListFragmentsRequest.organization_id)
}
inline std::string* ListFragmentsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListFragmentsRequest.organization_id)
  return _s;
}
inline const std::string& ListFragmentsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListFragmentsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListFragmentsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListFragmentsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListFragmentsRequest.organization_id)
  return organization_id_.Release();
}
inline void ListFragmentsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListFragmentsRequest.organization_id)
}

// bool show_public = 2 [json_name = "showPublic"];
inline void ListFragmentsRequest::clear_show_public() {
  show_public_ = false;
}
inline bool ListFragmentsRequest::_internal_show_public() const {
  return show_public_;
}
inline bool ListFragmentsRequest::show_public() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsRequest.show_public)
  return _internal_show_public();
}
inline void ListFragmentsRequest::_internal_set_show_public(bool value) {
  
  show_public_ = value;
}
inline void ListFragmentsRequest::set_show_public(bool value) {
  _internal_set_show_public(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListFragmentsRequest.show_public)
}

// -------------------------------------------------------------------

// ListFragmentsResponse

// repeated .viam.app.v1.Fragment fragments = 1 [json_name = "fragments"];
inline int ListFragmentsResponse::_internal_fragments_size() const {
  return fragments_.size();
}
inline int ListFragmentsResponse::fragments_size() const {
  return _internal_fragments_size();
}
inline void ListFragmentsResponse::clear_fragments() {
  fragments_.Clear();
}
inline ::viam::app::v1::Fragment* ListFragmentsResponse::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListFragmentsResponse.fragments)
  return fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >*
ListFragmentsResponse::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListFragmentsResponse.fragments)
  return &fragments_;
}
inline const ::viam::app::v1::Fragment& ListFragmentsResponse::_internal_fragments(int index) const {
  return fragments_.Get(index);
}
inline const ::viam::app::v1::Fragment& ListFragmentsResponse::fragments(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListFragmentsResponse.fragments)
  return _internal_fragments(index);
}
inline ::viam::app::v1::Fragment* ListFragmentsResponse::_internal_add_fragments() {
  return fragments_.Add();
}
inline ::viam::app::v1::Fragment* ListFragmentsResponse::add_fragments() {
  ::viam::app::v1::Fragment* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListFragmentsResponse.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Fragment >&
ListFragmentsResponse::fragments() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListFragmentsResponse.fragments)
  return fragments_;
}

// -------------------------------------------------------------------

// GetFragmentRequest

// string id = 1 [json_name = "id"];
inline void GetFragmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetFragmentRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFragmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetFragmentRequest.id)
}
inline std::string* GetFragmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentRequest.id)
  return _s;
}
inline const std::string& GetFragmentRequest::_internal_id() const {
  return id_.Get();
}
inline void GetFragmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFragmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentRequest.id)
  return id_.Release();
}
inline void GetFragmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentRequest.id)
}

// -------------------------------------------------------------------

// GetFragmentResponse

// .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
inline bool GetFragmentResponse::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool GetFragmentResponse::has_fragment() const {
  return _internal_has_fragment();
}
inline void GetFragmentResponse::clear_fragment() {
  if (GetArenaForAllocation() == nullptr && fragment_ != nullptr) {
    delete fragment_;
  }
  fragment_ = nullptr;
}
inline const ::viam::app::v1::Fragment& GetFragmentResponse::_internal_fragment() const {
  const ::viam::app::v1::Fragment* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Fragment&>(
      ::viam::app::v1::_Fragment_default_instance_);
}
inline const ::viam::app::v1::Fragment& GetFragmentResponse::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetFragmentResponse.fragment)
  return _internal_fragment();
}
inline void GetFragmentResponse::unsafe_arena_set_allocated_fragment(
    ::viam::app::v1::Fragment* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetFragmentResponse.fragment)
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::release_fragment() {
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetFragmentResponse.fragment)
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Fragment>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::viam::app::v1::Fragment* GetFragmentResponse::mutable_fragment() {
  ::viam::app::v1::Fragment* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetFragmentResponse.fragment)
  return _msg;
}
inline void GetFragmentResponse::set_allocated_fragment(::viam::app::v1::Fragment* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_;
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment);
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetFragmentResponse.fragment)
}

// -------------------------------------------------------------------

// CreateFragmentRequest

// string name = 1 [json_name = "name"];
inline void CreateFragmentRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateFragmentRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFragmentRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateFragmentRequest.name)
}
inline std::string* CreateFragmentRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentRequest.name)
  return _s;
}
inline const std::string& CreateFragmentRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateFragmentRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentRequest.name)
  return name_.Release();
}
inline void CreateFragmentRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentRequest.name)
}

// .google.protobuf.Struct config = 2 [json_name = "config"];
inline bool CreateFragmentRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool CreateFragmentRequest::has_config() const {
  return _internal_has_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CreateFragmentRequest::_internal_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CreateFragmentRequest::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentRequest.config)
  return _internal_config();
}
inline void CreateFragmentRequest::unsafe_arena_set_allocated_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateFragmentRequest.config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::release_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentRequest.config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateFragmentRequest::mutable_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentRequest.config)
  return _msg;
}
inline void CreateFragmentRequest::set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentRequest.config)
}

// string organization_id = 3 [json_name = "organizationId"];
inline void CreateFragmentRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateFragmentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFragmentRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateFragmentRequest.organization_id)
}
inline std::string* CreateFragmentRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentRequest.organization_id)
  return _s;
}
inline const std::string& CreateFragmentRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateFragmentRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFragmentRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateFragmentRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentRequest.organization_id)
}

// -------------------------------------------------------------------

// CreateFragmentResponse

// .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
inline bool CreateFragmentResponse::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool CreateFragmentResponse::has_fragment() const {
  return _internal_has_fragment();
}
inline void CreateFragmentResponse::clear_fragment() {
  if (GetArenaForAllocation() == nullptr && fragment_ != nullptr) {
    delete fragment_;
  }
  fragment_ = nullptr;
}
inline const ::viam::app::v1::Fragment& CreateFragmentResponse::_internal_fragment() const {
  const ::viam::app::v1::Fragment* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Fragment&>(
      ::viam::app::v1::_Fragment_default_instance_);
}
inline const ::viam::app::v1::Fragment& CreateFragmentResponse::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateFragmentResponse.fragment)
  return _internal_fragment();
}
inline void CreateFragmentResponse::unsafe_arena_set_allocated_fragment(
    ::viam::app::v1::Fragment* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateFragmentResponse.fragment)
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::release_fragment() {
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateFragmentResponse.fragment)
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Fragment>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::viam::app::v1::Fragment* CreateFragmentResponse::mutable_fragment() {
  ::viam::app::v1::Fragment* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateFragmentResponse.fragment)
  return _msg;
}
inline void CreateFragmentResponse::set_allocated_fragment(::viam::app::v1::Fragment* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_;
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment);
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateFragmentResponse.fragment)
}

// -------------------------------------------------------------------

// UpdateFragmentRequest

// string id = 1 [json_name = "id"];
inline void UpdateFragmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateFragmentRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateFragmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateFragmentRequest.id)
}
inline std::string* UpdateFragmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentRequest.id)
  return _s;
}
inline const std::string& UpdateFragmentRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateFragmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentRequest.id)
  return id_.Release();
}
inline void UpdateFragmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateFragmentRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateFragmentRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateFragmentRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateFragmentRequest.name)
}
inline std::string* UpdateFragmentRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentRequest.name)
  return _s;
}
inline const std::string& UpdateFragmentRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateFragmentRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateFragmentRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentRequest.name)
  return name_.Release();
}
inline void UpdateFragmentRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentRequest.name)
}

// .google.protobuf.Struct config = 3 [json_name = "config"];
inline bool UpdateFragmentRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool UpdateFragmentRequest::has_config() const {
  return _internal_has_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateFragmentRequest::_internal_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateFragmentRequest::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.config)
  return _internal_config();
}
inline void UpdateFragmentRequest::unsafe_arena_set_allocated_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateFragmentRequest.config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::release_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentRequest.config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateFragmentRequest::mutable_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentRequest.config)
  return _msg;
}
inline void UpdateFragmentRequest::set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentRequest.config)
}

// optional bool public = 4 [json_name = "public"];
inline bool UpdateFragmentRequest::_internal_has_public_() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateFragmentRequest::has_public_() const {
  return _internal_has_public_();
}
inline void UpdateFragmentRequest::clear_public_() {
  public__ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool UpdateFragmentRequest::_internal_public_() const {
  return public__;
}
inline bool UpdateFragmentRequest::public_() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentRequest.public)
  return _internal_public_();
}
inline void UpdateFragmentRequest::_internal_set_public_(bool value) {
  _has_bits_[0] |= 0x00000001u;
  public__ = value;
}
inline void UpdateFragmentRequest::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateFragmentRequest.public)
}

// -------------------------------------------------------------------

// UpdateFragmentResponse

// .viam.app.v1.Fragment fragment = 1 [json_name = "fragment"];
inline bool UpdateFragmentResponse::_internal_has_fragment() const {
  return this != internal_default_instance() && fragment_ != nullptr;
}
inline bool UpdateFragmentResponse::has_fragment() const {
  return _internal_has_fragment();
}
inline void UpdateFragmentResponse::clear_fragment() {
  if (GetArenaForAllocation() == nullptr && fragment_ != nullptr) {
    delete fragment_;
  }
  fragment_ = nullptr;
}
inline const ::viam::app::v1::Fragment& UpdateFragmentResponse::_internal_fragment() const {
  const ::viam::app::v1::Fragment* p = fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Fragment&>(
      ::viam::app::v1::_Fragment_default_instance_);
}
inline const ::viam::app::v1::Fragment& UpdateFragmentResponse::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateFragmentResponse.fragment)
  return _internal_fragment();
}
inline void UpdateFragmentResponse::unsafe_arena_set_allocated_fragment(
    ::viam::app::v1::Fragment* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_);
  }
  fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateFragmentResponse.fragment)
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::release_fragment() {
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateFragmentResponse.fragment)
  
  ::viam::app::v1::Fragment* temp = fragment_;
  fragment_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::_internal_mutable_fragment() {
  
  if (fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Fragment>(GetArenaForAllocation());
    fragment_ = p;
  }
  return fragment_;
}
inline ::viam::app::v1::Fragment* UpdateFragmentResponse::mutable_fragment() {
  ::viam::app::v1::Fragment* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateFragmentResponse.fragment)
  return _msg;
}
inline void UpdateFragmentResponse::set_allocated_fragment(::viam::app::v1::Fragment* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_;
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment);
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateFragmentResponse.fragment)
}

// -------------------------------------------------------------------

// DeleteFragmentRequest

// string id = 1 [json_name = "id"];
inline void DeleteFragmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteFragmentRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteFragmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFragmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteFragmentRequest.id)
}
inline std::string* DeleteFragmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteFragmentRequest.id)
  return _s;
}
inline const std::string& DeleteFragmentRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteFragmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFragmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFragmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteFragmentRequest.id)
  return id_.Release();
}
inline void DeleteFragmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteFragmentRequest.id)
}

// -------------------------------------------------------------------

// DeleteFragmentResponse

// -------------------------------------------------------------------

// ListRobotsRequest

// string location_id = 1 [json_name = "locationId"];
inline void ListRobotsRequest::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& ListRobotsRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRobotsRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRobotsRequest.location_id)
}
inline std::string* ListRobotsRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsRequest.location_id)
  return _s;
}
inline const std::string& ListRobotsRequest::_internal_location_id() const {
  return location_id_.Get();
}
inline void ListRobotsRequest::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRobotsRequest::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRobotsRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRobotsRequest.location_id)
  return location_id_.Release();
}
inline void ListRobotsRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRobotsRequest.location_id)
}

// -------------------------------------------------------------------

// ListRobotsResponse

// repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
inline int ListRobotsResponse::_internal_robots_size() const {
  return robots_.size();
}
inline int ListRobotsResponse::robots_size() const {
  return _internal_robots_size();
}
inline void ListRobotsResponse::clear_robots() {
  robots_.Clear();
}
inline ::viam::app::v1::Robot* ListRobotsResponse::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRobotsResponse.robots)
  return robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
ListRobotsResponse::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRobotsResponse.robots)
  return &robots_;
}
inline const ::viam::app::v1::Robot& ListRobotsResponse::_internal_robots(int index) const {
  return robots_.Get(index);
}
inline const ::viam::app::v1::Robot& ListRobotsResponse::robots(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRobotsResponse.robots)
  return _internal_robots(index);
}
inline ::viam::app::v1::Robot* ListRobotsResponse::_internal_add_robots() {
  return robots_.Add();
}
inline ::viam::app::v1::Robot* ListRobotsResponse::add_robots() {
  ::viam::app::v1::Robot* _add = _internal_add_robots();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRobotsResponse.robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
ListRobotsResponse::robots() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRobotsResponse.robots)
  return robots_;
}

// -------------------------------------------------------------------

// NewRobotRequest

// string name = 1 [json_name = "name"];
inline void NewRobotRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NewRobotRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotRequest.name)
}
inline std::string* NewRobotRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotRequest.name)
  return _s;
}
inline const std::string& NewRobotRequest::_internal_name() const {
  return name_.Get();
}
inline void NewRobotRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotRequest.name)
  return name_.Release();
}
inline void NewRobotRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotRequest.name)
}

// string location = 2 [json_name = "location"];
inline void NewRobotRequest::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& NewRobotRequest::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotRequest.location)
}
inline std::string* NewRobotRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotRequest.location)
  return _s;
}
inline const std::string& NewRobotRequest::_internal_location() const {
  return location_.Get();
}
inline void NewRobotRequest::_internal_set_location(const std::string& value) {
  
  location_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotRequest::_internal_mutable_location() {
  
  return location_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotRequest::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotRequest.location)
  return location_.Release();
}
inline void NewRobotRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault()) {
    location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotRequest.location)
}

// -------------------------------------------------------------------

// NewRobotResponse

// string id = 1 [json_name = "id"];
inline void NewRobotResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& NewRobotResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotResponse.id)
}
inline std::string* NewRobotResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotResponse.id)
  return _s;
}
inline const std::string& NewRobotResponse::_internal_id() const {
  return id_.Get();
}
inline void NewRobotResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotResponse.id)
  return id_.Release();
}
inline void NewRobotResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotResponse.id)
}

// -------------------------------------------------------------------

// UpdateRobotRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.id)
}
inline std::string* UpdateRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.id)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateRobotRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.id)
  return id_.Release();
}
inline void UpdateRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateRobotRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.name)
}
inline std::string* UpdateRobotRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.name)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateRobotRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.name)
  return name_.Release();
}
inline void UpdateRobotRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.name)
}

// string location = 3 [json_name = "location"];
inline void UpdateRobotRequest::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.location)
}
inline std::string* UpdateRobotRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.location)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_location() const {
  return location_.Get();
}
inline void UpdateRobotRequest::_internal_set_location(const std::string& value) {
  
  location_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_location() {
  
  return location_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.location)
  return location_.Release();
}
inline void UpdateRobotRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault()) {
    location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.location)
}

// -------------------------------------------------------------------

// UpdateRobotResponse

// .viam.app.v1.Robot robot = 1 [json_name = "robot"];
inline bool UpdateRobotResponse::_internal_has_robot() const {
  return this != internal_default_instance() && robot_ != nullptr;
}
inline bool UpdateRobotResponse::has_robot() const {
  return _internal_has_robot();
}
inline void UpdateRobotResponse::clear_robot() {
  if (GetArenaForAllocation() == nullptr && robot_ != nullptr) {
    delete robot_;
  }
  robot_ = nullptr;
}
inline const ::viam::app::v1::Robot& UpdateRobotResponse::_internal_robot() const {
  const ::viam::app::v1::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Robot&>(
      ::viam::app::v1::_Robot_default_instance_);
}
inline const ::viam::app::v1::Robot& UpdateRobotResponse::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotResponse.robot)
  return _internal_robot();
}
inline void UpdateRobotResponse::unsafe_arena_set_allocated_robot(
    ::viam::app::v1::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotResponse.robot)
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::release_robot() {
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotResponse.robot)
  
  ::viam::app::v1::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::_internal_mutable_robot() {
  
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Robot>(GetArenaForAllocation());
    robot_ = p;
  }
  return robot_;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::mutable_robot() {
  ::viam::app::v1::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotResponse.robot)
  return _msg;
}
inline void UpdateRobotResponse::set_allocated_robot(::viam::app::v1::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    
  } else {
    
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotResponse.robot)
}

// -------------------------------------------------------------------

// DeleteRobotRequest

// string id = 1 [json_name = "id"];
inline void DeleteRobotRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotRequest.id)
}
inline std::string* DeleteRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotRequest.id)
  return _s;
}
inline const std::string& DeleteRobotRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteRobotRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotRequest.id)
  return id_.Release();
}
inline void DeleteRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotRequest.id)
}

// -------------------------------------------------------------------

// DeleteRobotResponse

// -------------------------------------------------------------------

// MarkPartAsMainRequest

// string part_id = 1 [json_name = "partId"];
inline void MarkPartAsMainRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& MarkPartAsMainRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MarkPartAsMainRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkPartAsMainRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MarkPartAsMainRequest.part_id)
}
inline std::string* MarkPartAsMainRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MarkPartAsMainRequest.part_id)
  return _s;
}
inline const std::string& MarkPartAsMainRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void MarkPartAsMainRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkPartAsMainRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkPartAsMainRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MarkPartAsMainRequest.part_id)
  return part_id_.Release();
}
inline void MarkPartAsMainRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MarkPartAsMainRequest.part_id)
}

// -------------------------------------------------------------------

// MarkPartAsMainResponse

// -------------------------------------------------------------------

// MarkPartForRestartRequest

// string part_id = 1 [json_name = "partId"];
inline void MarkPartForRestartRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& MarkPartForRestartRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MarkPartForRestartRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkPartForRestartRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MarkPartForRestartRequest.part_id)
}
inline std::string* MarkPartForRestartRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MarkPartForRestartRequest.part_id)
  return _s;
}
inline const std::string& MarkPartForRestartRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void MarkPartForRestartRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkPartForRestartRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkPartForRestartRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MarkPartForRestartRequest.part_id)
  return part_id_.Release();
}
inline void MarkPartForRestartRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MarkPartForRestartRequest.part_id)
}

// -------------------------------------------------------------------

// MarkPartForRestartResponse

// -------------------------------------------------------------------

// CreateRobotPartSecretRequest

// string part_id = 1 [json_name = "partId"];
inline void CreateRobotPartSecretRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& CreateRobotPartSecretRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRobotPartSecretRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRobotPartSecretRequest.part_id)
}
inline std::string* CreateRobotPartSecretRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return _s;
}
inline const std::string& CreateRobotPartSecretRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void CreateRobotPartSecretRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRobotPartSecretRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRobotPartSecretRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return part_id_.Release();
}
inline void CreateRobotPartSecretRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRobotPartSecretRequest.part_id)
}

// -------------------------------------------------------------------

// CreateRobotPartSecretResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool CreateRobotPartSecretResponse::_internal_has_part() const {
  return this != internal_default_instance() && part_ != nullptr;
}
inline bool CreateRobotPartSecretResponse::has_part() const {
  return _internal_has_part();
}
inline void CreateRobotPartSecretResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && part_ != nullptr) {
    delete part_;
  }
  part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& CreateRobotPartSecretResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& CreateRobotPartSecretResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRobotPartSecretResponse.part)
  return _internal_part();
}
inline void CreateRobotPartSecretResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(part_);
  }
  part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateRobotPartSecretResponse.part)
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRobotPartSecretResponse.part)
  
  ::viam::app::v1::RobotPart* temp = part_;
  part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::_internal_mutable_part() {
  
  if (part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    part_ = p;
  }
  return part_;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRobotPartSecretResponse.part)
  return _msg;
}
inline void CreateRobotPartSecretResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRobotPartSecretResponse.part)
}

// -------------------------------------------------------------------

// DeleteRobotPartSecretRequest

// string part_id = 1 [json_name = "partId"];
inline void DeleteRobotPartSecretRequest::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartSecretRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartSecretRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
}
inline std::string* DeleteRobotPartSecretRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return _s;
}
inline const std::string& DeleteRobotPartSecretRequest::_internal_part_id() const {
  return part_id_.Get();
}
inline void DeleteRobotPartSecretRequest::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return part_id_.Release();
}
inline void DeleteRobotPartSecretRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
}

// string secret_id = 2 [json_name = "secretId"];
inline void DeleteRobotPartSecretRequest::clear_secret_id() {
  secret_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartSecretRequest::secret_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return _internal_secret_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartSecretRequest::set_secret_id(ArgT0&& arg0, ArgT... args) {
 
 secret_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
}
inline std::string* DeleteRobotPartSecretRequest::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return _s;
}
inline const std::string& DeleteRobotPartSecretRequest::_internal_secret_id() const {
  return secret_id_.Get();
}
inline void DeleteRobotPartSecretRequest::_internal_set_secret_id(const std::string& value) {
  
  secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::_internal_mutable_secret_id() {
  
  return secret_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::release_secret_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return secret_id_.Release();
}
inline void DeleteRobotPartSecretRequest::set_allocated_secret_id(std::string* secret_id) {
  if (secret_id != nullptr) {
    
  } else {
    
  }
  secret_id_.SetAllocated(secret_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_id_.IsDefault()) {
    secret_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
}

// -------------------------------------------------------------------

// DeleteRobotPartSecretResponse

// -------------------------------------------------------------------

// Authorization

// string authorization_type = 1 [json_name = "authorizationType"];
inline void Authorization::clear_authorization_type() {
  authorization_type_.ClearToEmpty();
}
inline const std::string& Authorization::authorization_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.authorization_type)
  return _internal_authorization_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_authorization_type(ArgT0&& arg0, ArgT... args) {
 
 authorization_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.authorization_type)
}
inline std::string* Authorization::mutable_authorization_type() {
  std::string* _s = _internal_mutable_authorization_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.authorization_type)
  return _s;
}
inline const std::string& Authorization::_internal_authorization_type() const {
  return authorization_type_.Get();
}
inline void Authorization::_internal_set_authorization_type(const std::string& value) {
  
  authorization_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_authorization_type() {
  
  return authorization_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_authorization_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.authorization_type)
  return authorization_type_.Release();
}
inline void Authorization::set_allocated_authorization_type(std::string* authorization_type) {
  if (authorization_type != nullptr) {
    
  } else {
    
  }
  authorization_type_.SetAllocated(authorization_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_type_.IsDefault()) {
    authorization_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.authorization_type)
}

// string authorization_id = 2 [json_name = "authorizationId"];
inline void Authorization::clear_authorization_id() {
  authorization_id_.ClearToEmpty();
}
inline const std::string& Authorization::authorization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.authorization_id)
  return _internal_authorization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_authorization_id(ArgT0&& arg0, ArgT... args) {
 
 authorization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.authorization_id)
}
inline std::string* Authorization::mutable_authorization_id() {
  std::string* _s = _internal_mutable_authorization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.authorization_id)
  return _s;
}
inline const std::string& Authorization::_internal_authorization_id() const {
  return authorization_id_.Get();
}
inline void Authorization::_internal_set_authorization_id(const std::string& value) {
  
  authorization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_authorization_id() {
  
  return authorization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_authorization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.authorization_id)
  return authorization_id_.Release();
}
inline void Authorization::set_allocated_authorization_id(std::string* authorization_id) {
  if (authorization_id != nullptr) {
    
  } else {
    
  }
  authorization_id_.SetAllocated(authorization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_id_.IsDefault()) {
    authorization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.authorization_id)
}

// string resource_type = 3 [json_name = "resourceType"];
inline void Authorization::clear_resource_type() {
  resource_type_.ClearToEmpty();
}
inline const std::string& Authorization::resource_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.resource_type)
}
inline std::string* Authorization::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.resource_type)
  return _s;
}
inline const std::string& Authorization::_internal_resource_type() const {
  return resource_type_.Get();
}
inline void Authorization::_internal_set_resource_type(const std::string& value) {
  
  resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_resource_type() {
  
  return resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_resource_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.resource_type)
  return resource_type_.Release();
}
inline void Authorization::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_type_.IsDefault()) {
    resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.resource_type)
}

// string resource_id = 4 [json_name = "resourceId"];
inline void Authorization::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& Authorization::resource_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.resource_id)
}
inline std::string* Authorization::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.resource_id)
  return _s;
}
inline const std::string& Authorization::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void Authorization::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_resource_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.resource_id)
  return resource_id_.Release();
}
inline void Authorization::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault()) {
    resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.resource_id)
}

// string identity_id = 5 [json_name = "identityId"];
inline void Authorization::clear_identity_id() {
  identity_id_.ClearToEmpty();
}
inline const std::string& Authorization::identity_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.identity_id)
  return _internal_identity_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_identity_id(ArgT0&& arg0, ArgT... args) {
 
 identity_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.identity_id)
}
inline std::string* Authorization::mutable_identity_id() {
  std::string* _s = _internal_mutable_identity_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.identity_id)
  return _s;
}
inline const std::string& Authorization::_internal_identity_id() const {
  return identity_id_.Get();
}
inline void Authorization::_internal_set_identity_id(const std::string& value) {
  
  identity_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_identity_id() {
  
  return identity_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_identity_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.identity_id)
  return identity_id_.Release();
}
inline void Authorization::set_allocated_identity_id(std::string* identity_id) {
  if (identity_id != nullptr) {
    
  } else {
    
  }
  identity_id_.SetAllocated(identity_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identity_id_.IsDefault()) {
    identity_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.identity_id)
}

// string organization_id = 6 [json_name = "organizationId"];
inline void Authorization::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& Authorization::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.organization_id)
}
inline std::string* Authorization::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.organization_id)
  return _s;
}
inline const std::string& Authorization::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void Authorization::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.organization_id)
  return organization_id_.Release();
}
inline void Authorization::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.organization_id)
}

// string identity_type = 7 [json_name = "identityType"];
inline void Authorization::clear_identity_type() {
  identity_type_.ClearToEmpty();
}
inline const std::string& Authorization::identity_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Authorization.identity_type)
  return _internal_identity_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Authorization::set_identity_type(ArgT0&& arg0, ArgT... args) {
 
 identity_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Authorization.identity_type)
}
inline std::string* Authorization::mutable_identity_type() {
  std::string* _s = _internal_mutable_identity_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Authorization.identity_type)
  return _s;
}
inline const std::string& Authorization::_internal_identity_type() const {
  return identity_type_.Get();
}
inline void Authorization::_internal_set_identity_type(const std::string& value) {
  
  identity_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Authorization::_internal_mutable_identity_type() {
  
  return identity_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Authorization::release_identity_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Authorization.identity_type)
  return identity_type_.Release();
}
inline void Authorization::set_allocated_identity_type(std::string* identity_type) {
  if (identity_type != nullptr) {
    
  } else {
    
  }
  identity_type_.SetAllocated(identity_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identity_type_.IsDefault()) {
    identity_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Authorization.identity_type)
}

// -------------------------------------------------------------------

// AddRoleRequest

// .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
inline bool AddRoleRequest::_internal_has_authorization() const {
  return this != internal_default_instance() && authorization_ != nullptr;
}
inline bool AddRoleRequest::has_authorization() const {
  return _internal_has_authorization();
}
inline void AddRoleRequest::clear_authorization() {
  if (GetArenaForAllocation() == nullptr && authorization_ != nullptr) {
    delete authorization_;
  }
  authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& AddRoleRequest::_internal_authorization() const {
  const ::viam::app::v1::Authorization* p = authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& AddRoleRequest::authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AddRoleRequest.authorization)
  return _internal_authorization();
}
inline void AddRoleRequest::unsafe_arena_set_allocated_authorization(
    ::viam::app::v1::Authorization* authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authorization_);
  }
  authorization_ = authorization;
  if (authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.AddRoleRequest.authorization)
}
inline ::viam::app::v1::Authorization* AddRoleRequest::release_authorization() {
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* AddRoleRequest::unsafe_arena_release_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AddRoleRequest.authorization)
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* AddRoleRequest::_internal_mutable_authorization() {
  
  if (authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    authorization_ = p;
  }
  return authorization_;
}
inline ::viam::app::v1::Authorization* AddRoleRequest::mutable_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AddRoleRequest.authorization)
  return _msg;
}
inline void AddRoleRequest::set_allocated_authorization(::viam::app::v1::Authorization* authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authorization_;
  }
  if (authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorization);
    if (message_arena != submessage_arena) {
      authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization, submessage_arena);
    }
    
  } else {
    
  }
  authorization_ = authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AddRoleRequest.authorization)
}

// -------------------------------------------------------------------

// AddRoleResponse

// -------------------------------------------------------------------

// RemoveRoleRequest

// .viam.app.v1.Authorization authorization = 1 [json_name = "authorization"];
inline bool RemoveRoleRequest::_internal_has_authorization() const {
  return this != internal_default_instance() && authorization_ != nullptr;
}
inline bool RemoveRoleRequest::has_authorization() const {
  return _internal_has_authorization();
}
inline void RemoveRoleRequest::clear_authorization() {
  if (GetArenaForAllocation() == nullptr && authorization_ != nullptr) {
    delete authorization_;
  }
  authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& RemoveRoleRequest::_internal_authorization() const {
  const ::viam::app::v1::Authorization* p = authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& RemoveRoleRequest::authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoveRoleRequest.authorization)
  return _internal_authorization();
}
inline void RemoveRoleRequest::unsafe_arena_set_allocated_authorization(
    ::viam::app::v1::Authorization* authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authorization_);
  }
  authorization_ = authorization;
  if (authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoveRoleRequest.authorization)
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::release_authorization() {
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::unsafe_arena_release_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoveRoleRequest.authorization)
  
  ::viam::app::v1::Authorization* temp = authorization_;
  authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::_internal_mutable_authorization() {
  
  if (authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    authorization_ = p;
  }
  return authorization_;
}
inline ::viam::app::v1::Authorization* RemoveRoleRequest::mutable_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoveRoleRequest.authorization)
  return _msg;
}
inline void RemoveRoleRequest::set_allocated_authorization(::viam::app::v1::Authorization* authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authorization_;
  }
  if (authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorization);
    if (message_arena != submessage_arena) {
      authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization, submessage_arena);
    }
    
  } else {
    
  }
  authorization_ = authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoveRoleRequest.authorization)
}

// -------------------------------------------------------------------

// RemoveRoleResponse

// -------------------------------------------------------------------

// ChangeRoleRequest

// .viam.app.v1.Authorization old_authorization = 1 [json_name = "oldAuthorization"];
inline bool ChangeRoleRequest::_internal_has_old_authorization() const {
  return this != internal_default_instance() && old_authorization_ != nullptr;
}
inline bool ChangeRoleRequest::has_old_authorization() const {
  return _internal_has_old_authorization();
}
inline void ChangeRoleRequest::clear_old_authorization() {
  if (GetArenaForAllocation() == nullptr && old_authorization_ != nullptr) {
    delete old_authorization_;
  }
  old_authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::_internal_old_authorization() const {
  const ::viam::app::v1::Authorization* p = old_authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::old_authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ChangeRoleRequest.old_authorization)
  return _internal_old_authorization();
}
inline void ChangeRoleRequest::unsafe_arena_set_allocated_old_authorization(
    ::viam::app::v1::Authorization* old_authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_authorization_);
  }
  old_authorization_ = old_authorization;
  if (old_authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ChangeRoleRequest.old_authorization)
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::release_old_authorization() {
  
  ::viam::app::v1::Authorization* temp = old_authorization_;
  old_authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::unsafe_arena_release_old_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ChangeRoleRequest.old_authorization)
  
  ::viam::app::v1::Authorization* temp = old_authorization_;
  old_authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::_internal_mutable_old_authorization() {
  
  if (old_authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    old_authorization_ = p;
  }
  return old_authorization_;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::mutable_old_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_old_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ChangeRoleRequest.old_authorization)
  return _msg;
}
inline void ChangeRoleRequest::set_allocated_old_authorization(::viam::app::v1::Authorization* old_authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete old_authorization_;
  }
  if (old_authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_authorization);
    if (message_arena != submessage_arena) {
      old_authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_authorization, submessage_arena);
    }
    
  } else {
    
  }
  old_authorization_ = old_authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ChangeRoleRequest.old_authorization)
}

// .viam.app.v1.Authorization new_authorization = 2 [json_name = "newAuthorization"];
inline bool ChangeRoleRequest::_internal_has_new_authorization() const {
  return this != internal_default_instance() && new_authorization_ != nullptr;
}
inline bool ChangeRoleRequest::has_new_authorization() const {
  return _internal_has_new_authorization();
}
inline void ChangeRoleRequest::clear_new_authorization() {
  if (GetArenaForAllocation() == nullptr && new_authorization_ != nullptr) {
    delete new_authorization_;
  }
  new_authorization_ = nullptr;
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::_internal_new_authorization() const {
  const ::viam::app::v1::Authorization* p = new_authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Authorization&>(
      ::viam::app::v1::_Authorization_default_instance_);
}
inline const ::viam::app::v1::Authorization& ChangeRoleRequest::new_authorization() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ChangeRoleRequest.new_authorization)
  return _internal_new_authorization();
}
inline void ChangeRoleRequest::unsafe_arena_set_allocated_new_authorization(
    ::viam::app::v1::Authorization* new_authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_authorization_);
  }
  new_authorization_ = new_authorization;
  if (new_authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ChangeRoleRequest.new_authorization)
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::release_new_authorization() {
  
  ::viam::app::v1::Authorization* temp = new_authorization_;
  new_authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::unsafe_arena_release_new_authorization() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ChangeRoleRequest.new_authorization)
  
  ::viam::app::v1::Authorization* temp = new_authorization_;
  new_authorization_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::_internal_mutable_new_authorization() {
  
  if (new_authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Authorization>(GetArenaForAllocation());
    new_authorization_ = p;
  }
  return new_authorization_;
}
inline ::viam::app::v1::Authorization* ChangeRoleRequest::mutable_new_authorization() {
  ::viam::app::v1::Authorization* _msg = _internal_mutable_new_authorization();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ChangeRoleRequest.new_authorization)
  return _msg;
}
inline void ChangeRoleRequest::set_allocated_new_authorization(::viam::app::v1::Authorization* new_authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete new_authorization_;
  }
  if (new_authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_authorization);
    if (message_arena != submessage_arena) {
      new_authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_authorization, submessage_arena);
    }
    
  } else {
    
  }
  new_authorization_ = new_authorization;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ChangeRoleRequest.new_authorization)
}

// -------------------------------------------------------------------

// ChangeRoleResponse

// -------------------------------------------------------------------

// ListAuthorizationsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListAuthorizationsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListAuthorizationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListAuthorizationsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListAuthorizationsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListAuthorizationsRequest.organization_id)
}
inline std::string* ListAuthorizationsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListAuthorizationsRequest.organization_id)
  return _s;
}
inline const std::string& ListAuthorizationsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListAuthorizationsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAuthorizationsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListAuthorizationsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListAuthorizationsRequest.organization_id)
  return organization_id_.Release();
}
inline void ListAuthorizationsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListAuthorizationsRequest.organization_id)
}

// repeated string resource_ids = 2 [json_name = "resourceIds"];
inline int ListAuthorizationsRequest::_internal_resource_ids_size() const {
  return resource_ids_.size();
}
inline int ListAuthorizationsRequest::resource_ids_size() const {
  return _internal_resource_ids_size();
}
inline void ListAuthorizationsRequest::clear_resource_ids() {
  resource_ids_.Clear();
}
inline std::string* ListAuthorizationsRequest::add_resource_ids() {
  std::string* _s = _internal_add_resource_ids();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return _s;
}
inline const std::string& ListAuthorizationsRequest::_internal_resource_ids(int index) const {
  return resource_ids_.Get(index);
}
inline const std::string& ListAuthorizationsRequest::resource_ids(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return _internal_resource_ids(index);
}
inline std::string* ListAuthorizationsRequest::mutable_resource_ids(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return resource_ids_.Mutable(index);
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, const std::string& value) {
  resource_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, std::string&& value) {
  resource_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resource_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::set_resource_ids(int index, const char* value, size_t size) {
  resource_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline std::string* ListAuthorizationsRequest::_internal_add_resource_ids() {
  return resource_ids_.Add();
}
inline void ListAuthorizationsRequest::add_resource_ids(const std::string& value) {
  resource_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::add_resource_ids(std::string&& value) {
  resource_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::add_resource_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resource_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline void ListAuthorizationsRequest::add_resource_ids(const char* value, size_t size) {
  resource_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListAuthorizationsRequest.resource_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListAuthorizationsRequest::resource_ids() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return resource_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListAuthorizationsRequest::mutable_resource_ids() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListAuthorizationsRequest.resource_ids)
  return &resource_ids_;
}

// -------------------------------------------------------------------

// ListAuthorizationsResponse

// repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
inline int ListAuthorizationsResponse::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int ListAuthorizationsResponse::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void ListAuthorizationsResponse::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* ListAuthorizationsResponse::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
ListAuthorizationsResponse::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& ListAuthorizationsResponse::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& ListAuthorizationsResponse::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* ListAuthorizationsResponse::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* ListAuthorizationsResponse::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
ListAuthorizationsResponse::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListAuthorizationsResponse.authorizations)
  return authorizations_;
}

// -------------------------------------------------------------------

// CheckPermissionsRequest

// repeated .viam.app.v1.AuthorizedPermissions permissions = 1 [json_name = "permissions"];
inline int CheckPermissionsRequest::_internal_permissions_size() const {
  return permissions_.size();
}
inline int CheckPermissionsRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void CheckPermissionsRequest::clear_permissions() {
  permissions_.Clear();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CheckPermissionsRequest.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
CheckPermissionsRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CheckPermissionsRequest.permissions)
  return &permissions_;
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsRequest::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CheckPermissionsRequest.permissions)
  return _internal_permissions(index);
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsRequest::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsRequest::add_permissions() {
  ::viam::app::v1::AuthorizedPermissions* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:viam.app.v1.CheckPermissionsRequest.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
CheckPermissionsRequest::permissions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CheckPermissionsRequest.permissions)
  return permissions_;
}

// -------------------------------------------------------------------

// AuthorizedPermissions

// string resource_type = 1 [json_name = "resourceType"];
inline void AuthorizedPermissions::clear_resource_type() {
  resource_type_.ClearToEmpty();
}
inline const std::string& AuthorizedPermissions::resource_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizedPermissions.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizedPermissions::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.resource_type)
}
inline std::string* AuthorizedPermissions::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizedPermissions.resource_type)
  return _s;
}
inline const std::string& AuthorizedPermissions::_internal_resource_type() const {
  return resource_type_.Get();
}
inline void AuthorizedPermissions::_internal_set_resource_type(const std::string& value) {
  
  resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::_internal_mutable_resource_type() {
  
  return resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::release_resource_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizedPermissions.resource_type)
  return resource_type_.Release();
}
inline void AuthorizedPermissions::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_type_.IsDefault()) {
    resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizedPermissions.resource_type)
}

// string resource_id = 2 [json_name = "resourceId"];
inline void AuthorizedPermissions::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& AuthorizedPermissions::resource_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizedPermissions.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizedPermissions::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.resource_id)
}
inline std::string* AuthorizedPermissions::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizedPermissions.resource_id)
  return _s;
}
inline const std::string& AuthorizedPermissions::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void AuthorizedPermissions::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizedPermissions::release_resource_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizedPermissions.resource_id)
  return resource_id_.Release();
}
inline void AuthorizedPermissions::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault()) {
    resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizedPermissions.resource_id)
}

// repeated string permissions = 3 [json_name = "permissions"];
inline int AuthorizedPermissions::_internal_permissions_size() const {
  return permissions_.size();
}
inline int AuthorizedPermissions::permissions_size() const {
  return _internal_permissions_size();
}
inline void AuthorizedPermissions::clear_permissions() {
  permissions_.Clear();
}
inline std::string* AuthorizedPermissions::add_permissions() {
  std::string* _s = _internal_add_permissions();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.AuthorizedPermissions.permissions)
  return _s;
}
inline const std::string& AuthorizedPermissions::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const std::string& AuthorizedPermissions::permissions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizedPermissions.permissions)
  return _internal_permissions(index);
}
inline std::string* AuthorizedPermissions::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizedPermissions.permissions)
  return permissions_.Mutable(index);
}
inline void AuthorizedPermissions::set_permissions(int index, const std::string& value) {
  permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::set_permissions(int index, std::string&& value) {
  permissions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::set_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::set_permissions(int index, const char* value, size_t size) {
  permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.AuthorizedPermissions.permissions)
}
inline std::string* AuthorizedPermissions::_internal_add_permissions() {
  return permissions_.Add();
}
inline void AuthorizedPermissions::add_permissions(const std::string& value) {
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::add_permissions(std::string&& value) {
  permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::add_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.AuthorizedPermissions.permissions)
}
inline void AuthorizedPermissions::add_permissions(const char* value, size_t size) {
  permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.AuthorizedPermissions.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthorizedPermissions::permissions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.AuthorizedPermissions.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AuthorizedPermissions::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AuthorizedPermissions.permissions)
  return &permissions_;
}

// -------------------------------------------------------------------

// CheckPermissionsResponse

// repeated .viam.app.v1.AuthorizedPermissions authorized_permissions = 1 [json_name = "authorizedPermissions"];
inline int CheckPermissionsResponse::_internal_authorized_permissions_size() const {
  return authorized_permissions_.size();
}
inline int CheckPermissionsResponse::authorized_permissions_size() const {
  return _internal_authorized_permissions_size();
}
inline void CheckPermissionsResponse::clear_authorized_permissions() {
  authorized_permissions_.Clear();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsResponse::mutable_authorized_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return authorized_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >*
CheckPermissionsResponse::mutable_authorized_permissions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return &authorized_permissions_;
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsResponse::_internal_authorized_permissions(int index) const {
  return authorized_permissions_.Get(index);
}
inline const ::viam::app::v1::AuthorizedPermissions& CheckPermissionsResponse::authorized_permissions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return _internal_authorized_permissions(index);
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsResponse::_internal_add_authorized_permissions() {
  return authorized_permissions_.Add();
}
inline ::viam::app::v1::AuthorizedPermissions* CheckPermissionsResponse::add_authorized_permissions() {
  ::viam::app::v1::AuthorizedPermissions* _add = _internal_add_authorized_permissions();
  // @@protoc_insertion_point(field_add:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizedPermissions >&
CheckPermissionsResponse::authorized_permissions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CheckPermissionsResponse.authorized_permissions)
  return authorized_permissions_;
}

// -------------------------------------------------------------------

// ModuleVersion

// string version = 1 [json_name = "version"];
inline void ModuleVersion::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ModuleVersion::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleVersion.version)
}
inline std::string* ModuleVersion::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.version)
  return _s;
}
inline const std::string& ModuleVersion::_internal_version() const {
  return version_.Get();
}
inline void ModuleVersion::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleVersion.version)
  return version_.Release();
}
inline void ModuleVersion::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleVersion.version)
}

// repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
inline int ModuleVersion::_internal_files_size() const {
  return files_.size();
}
inline int ModuleVersion::files_size() const {
  return _internal_files_size();
}
inline void ModuleVersion::clear_files() {
  files_.Clear();
}
inline ::viam::app::v1::Uploads* ModuleVersion::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
ModuleVersion::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleVersion.files)
  return &files_;
}
inline const ::viam::app::v1::Uploads& ModuleVersion::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::viam::app::v1::Uploads& ModuleVersion::files(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.files)
  return _internal_files(index);
}
inline ::viam::app::v1::Uploads* ModuleVersion::_internal_add_files() {
  return files_.Add();
}
inline ::viam::app::v1::Uploads* ModuleVersion::add_files() {
  ::viam::app::v1::Uploads* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleVersion.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
ModuleVersion::files() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleVersion.files)
  return files_;
}

// repeated .viam.app.v1.Model models = 3 [json_name = "models"];
inline int ModuleVersion::_internal_models_size() const {
  return models_.size();
}
inline int ModuleVersion::models_size() const {
  return _internal_models_size();
}
inline void ModuleVersion::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* ModuleVersion::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
ModuleVersion::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleVersion.models)
  return &models_;
}
inline const ::viam::app::v1::Model& ModuleVersion::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& ModuleVersion::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* ModuleVersion::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* ModuleVersion::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleVersion.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
ModuleVersion::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleVersion.models)
  return models_;
}

// string entrypoint = 4 [json_name = "entrypoint"];
inline void ModuleVersion::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& ModuleVersion::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleVersion.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleVersion::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleVersion.entrypoint)
}
inline std::string* ModuleVersion::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleVersion.entrypoint)
  return _s;
}
inline const std::string& ModuleVersion::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void ModuleVersion::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleVersion::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleVersion::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleVersion.entrypoint)
  return entrypoint_.Release();
}
inline void ModuleVersion::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleVersion.entrypoint)
}

// -------------------------------------------------------------------

// ModuleMetadata

// repeated .viam.app.v1.Model models = 1 [json_name = "models"];
inline int ModuleMetadata::_internal_models_size() const {
  return models_.size();
}
inline int ModuleMetadata::models_size() const {
  return _internal_models_size();
}
inline void ModuleMetadata::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* ModuleMetadata::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
ModuleMetadata::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleMetadata.models)
  return &models_;
}
inline const ::viam::app::v1::Model& ModuleMetadata::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& ModuleMetadata::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* ModuleMetadata::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* ModuleMetadata::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleMetadata.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
ModuleMetadata::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleMetadata.models)
  return models_;
}

// repeated .viam.app.v1.ModuleVersion versions = 2 [json_name = "versions"];
inline int ModuleMetadata::_internal_versions_size() const {
  return versions_.size();
}
inline int ModuleMetadata::versions_size() const {
  return _internal_versions_size();
}
inline void ModuleMetadata::clear_versions() {
  versions_.Clear();
}
inline ::viam::app::v1::ModuleVersion* ModuleMetadata::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.versions)
  return versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >*
ModuleMetadata::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ModuleMetadata.versions)
  return &versions_;
}
inline const ::viam::app::v1::ModuleVersion& ModuleMetadata::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const ::viam::app::v1::ModuleVersion& ModuleMetadata::versions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.versions)
  return _internal_versions(index);
}
inline ::viam::app::v1::ModuleVersion* ModuleMetadata::_internal_add_versions() {
  return versions_.Add();
}
inline ::viam::app::v1::ModuleVersion* ModuleMetadata::add_versions() {
  ::viam::app::v1::ModuleVersion* _add = _internal_add_versions();
  // @@protoc_insertion_point(field_add:viam.app.v1.ModuleMetadata.versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleVersion >&
ModuleMetadata::versions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ModuleMetadata.versions)
  return versions_;
}

// string entrypoint = 3 [json_name = "entrypoint"];
inline void ModuleMetadata::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& ModuleMetadata::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleMetadata.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleMetadata::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleMetadata.entrypoint)
}
inline std::string* ModuleMetadata::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleMetadata.entrypoint)
  return _s;
}
inline const std::string& ModuleMetadata::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void ModuleMetadata::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleMetadata::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleMetadata::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleMetadata.entrypoint)
  return entrypoint_.Release();
}
inline void ModuleMetadata::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleMetadata.entrypoint)
}

// -------------------------------------------------------------------

// MLModelMetadata

// repeated string versions = 1 [json_name = "versions"];
inline int MLModelMetadata::_internal_versions_size() const {
  return versions_.size();
}
inline int MLModelMetadata::versions_size() const {
  return _internal_versions_size();
}
inline void MLModelMetadata::clear_versions() {
  versions_.Clear();
}
inline std::string* MLModelMetadata::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.MLModelMetadata.versions)
  return _s;
}
inline const std::string& MLModelMetadata::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const std::string& MLModelMetadata::versions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MLModelMetadata.versions)
  return _internal_versions(index);
}
inline std::string* MLModelMetadata::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MLModelMetadata.versions)
  return versions_.Mutable(index);
}
inline void MLModelMetadata::set_versions(int index, const std::string& value) {
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::set_versions(int index, std::string&& value) {
  versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::set_versions(int index, const char* value, size_t size) {
  versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.MLModelMetadata.versions)
}
inline std::string* MLModelMetadata::_internal_add_versions() {
  return versions_.Add();
}
inline void MLModelMetadata::add_versions(const std::string& value) {
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::add_versions(std::string&& value) {
  versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.MLModelMetadata.versions)
}
inline void MLModelMetadata::add_versions(const char* value, size_t size) {
  versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.MLModelMetadata.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MLModelMetadata::versions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.MLModelMetadata.versions)
  return versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MLModelMetadata::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.MLModelMetadata.versions)
  return &versions_;
}

// -------------------------------------------------------------------

// RegistryItem

// string item_id = 1 [json_name = "itemId"];
inline void RegistryItem::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& RegistryItem::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.item_id)
}
inline std::string* RegistryItem::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.item_id)
  return _s;
}
inline const std::string& RegistryItem::_internal_item_id() const {
  return item_id_.Get();
}
inline void RegistryItem::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.item_id)
  return item_id_.Release();
}
inline void RegistryItem::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.item_id)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void RegistryItem::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& RegistryItem::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.organization_id)
}
inline std::string* RegistryItem::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.organization_id)
  return _s;
}
inline const std::string& RegistryItem::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void RegistryItem::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.organization_id)
  return organization_id_.Release();
}
inline void RegistryItem::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.organization_id)
}

// string public_namespace = 3 [json_name = "publicNamespace"];
inline void RegistryItem::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& RegistryItem::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.public_namespace)
}
inline std::string* RegistryItem::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.public_namespace)
  return _s;
}
inline const std::string& RegistryItem::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void RegistryItem::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.public_namespace)
  return public_namespace_.Release();
}
inline void RegistryItem::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.public_namespace)
}

// string name = 4 [json_name = "name"];
inline void RegistryItem::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RegistryItem::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.name)
}
inline std::string* RegistryItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.name)
  return _s;
}
inline const std::string& RegistryItem::_internal_name() const {
  return name_.Get();
}
inline void RegistryItem::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.name)
  return name_.Release();
}
inline void RegistryItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.name)
}

// .viam.app.packages.v1.PackageType type = 5 [json_name = "type"];
inline void RegistryItem::clear_type() {
  type_ = 0;
}
inline ::viam::app::packages::v1::PackageType RegistryItem::_internal_type() const {
  return static_cast< ::viam::app::packages::v1::PackageType >(type_);
}
inline ::viam::app::packages::v1::PackageType RegistryItem::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.type)
  return _internal_type();
}
inline void RegistryItem::_internal_set_type(::viam::app::packages::v1::PackageType value) {
  
  type_ = value;
}
inline void RegistryItem::set_type(::viam::app::packages::v1::PackageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.type)
}

// .viam.app.v1.Visibility visibility = 6 [json_name = "visibility"];
inline void RegistryItem::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility RegistryItem::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility RegistryItem::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.visibility)
  return _internal_visibility();
}
inline void RegistryItem::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void RegistryItem::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.visibility)
}

// string url = 7 [json_name = "url"];
inline void RegistryItem::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& RegistryItem::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.url)
}
inline std::string* RegistryItem::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.url)
  return _s;
}
inline const std::string& RegistryItem::_internal_url() const {
  return url_.Get();
}
inline void RegistryItem::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.url)
  return url_.Release();
}
inline void RegistryItem::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.url)
}

// string description = 8 [json_name = "description"];
inline void RegistryItem::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& RegistryItem::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistryItem::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.description)
}
inline std::string* RegistryItem::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.description)
  return _s;
}
inline const std::string& RegistryItem::_internal_description() const {
  return description_.Get();
}
inline void RegistryItem::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistryItem::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistryItem::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.description)
  return description_.Release();
}
inline void RegistryItem::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.description)
}

// int64 total_robot_usage = 9 [json_name = "totalRobotUsage"];
inline void RegistryItem::clear_total_robot_usage() {
  total_robot_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_robot_usage() const {
  return total_robot_usage_;
}
inline int64_t RegistryItem::total_robot_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_robot_usage)
  return _internal_total_robot_usage();
}
inline void RegistryItem::_internal_set_total_robot_usage(int64_t value) {
  
  total_robot_usage_ = value;
}
inline void RegistryItem::set_total_robot_usage(int64_t value) {
  _internal_set_total_robot_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_robot_usage)
}

// int64 total_external_robot_usage = 13 [json_name = "totalExternalRobotUsage"];
inline void RegistryItem::clear_total_external_robot_usage() {
  total_external_robot_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_external_robot_usage() const {
  return total_external_robot_usage_;
}
inline int64_t RegistryItem::total_external_robot_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_external_robot_usage)
  return _internal_total_external_robot_usage();
}
inline void RegistryItem::_internal_set_total_external_robot_usage(int64_t value) {
  
  total_external_robot_usage_ = value;
}
inline void RegistryItem::set_total_external_robot_usage(int64_t value) {
  _internal_set_total_external_robot_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_external_robot_usage)
}

// int64 total_organization_usage = 10 [json_name = "totalOrganizationUsage"];
inline void RegistryItem::clear_total_organization_usage() {
  total_organization_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_organization_usage() const {
  return total_organization_usage_;
}
inline int64_t RegistryItem::total_organization_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_organization_usage)
  return _internal_total_organization_usage();
}
inline void RegistryItem::_internal_set_total_organization_usage(int64_t value) {
  
  total_organization_usage_ = value;
}
inline void RegistryItem::set_total_organization_usage(int64_t value) {
  _internal_set_total_organization_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_organization_usage)
}

// int64 total_external_organization_usage = 14 [json_name = "totalExternalOrganizationUsage"];
inline void RegistryItem::clear_total_external_organization_usage() {
  total_external_organization_usage_ = int64_t{0};
}
inline int64_t RegistryItem::_internal_total_external_organization_usage() const {
  return total_external_organization_usage_;
}
inline int64_t RegistryItem::total_external_organization_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.total_external_organization_usage)
  return _internal_total_external_organization_usage();
}
inline void RegistryItem::_internal_set_total_external_organization_usage(int64_t value) {
  
  total_external_organization_usage_ = value;
}
inline void RegistryItem::set_total_external_organization_usage(int64_t value) {
  _internal_set_total_external_organization_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RegistryItem.total_external_organization_usage)
}

// .viam.app.v1.ModuleMetadata module_metadata = 11 [json_name = "moduleMetadata"];
inline bool RegistryItem::_internal_has_module_metadata() const {
  return metadata_case() == kModuleMetadata;
}
inline bool RegistryItem::has_module_metadata() const {
  return _internal_has_module_metadata();
}
inline void RegistryItem::set_has_module_metadata() {
  _oneof_case_[0] = kModuleMetadata;
}
inline void RegistryItem::clear_module_metadata() {
  if (_internal_has_module_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.module_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::release_module_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.module_metadata)
  if (_internal_has_module_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::ModuleMetadata* temp = metadata_.module_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.module_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::ModuleMetadata& RegistryItem::_internal_module_metadata() const {
  return _internal_has_module_metadata()
      ? *metadata_.module_metadata_
      : reinterpret_cast< ::viam::app::v1::ModuleMetadata&>(::viam::app::v1::_ModuleMetadata_default_instance_);
}
inline const ::viam::app::v1::ModuleMetadata& RegistryItem::module_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.module_metadata)
  return _internal_module_metadata();
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::unsafe_arena_release_module_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.RegistryItem.module_metadata)
  if (_internal_has_module_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::ModuleMetadata* temp = metadata_.module_metadata_;
    metadata_.module_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistryItem::unsafe_arena_set_allocated_module_metadata(::viam::app::v1::ModuleMetadata* module_metadata) {
  clear_metadata();
  if (module_metadata) {
    set_has_module_metadata();
    metadata_.module_metadata_ = module_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.module_metadata)
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::_internal_mutable_module_metadata() {
  if (!_internal_has_module_metadata()) {
    clear_metadata();
    set_has_module_metadata();
    metadata_.module_metadata_ = CreateMaybeMessage< ::viam::app::v1::ModuleMetadata >(GetArenaForAllocation());
  }
  return metadata_.module_metadata_;
}
inline ::viam::app::v1::ModuleMetadata* RegistryItem::mutable_module_metadata() {
  ::viam::app::v1::ModuleMetadata* _msg = _internal_mutable_module_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.module_metadata)
  return _msg;
}

// .viam.app.v1.MLModelMetadata ml_model_metadata = 12 [json_name = "mlModelMetadata"];
inline bool RegistryItem::_internal_has_ml_model_metadata() const {
  return metadata_case() == kMlModelMetadata;
}
inline bool RegistryItem::has_ml_model_metadata() const {
  return _internal_has_ml_model_metadata();
}
inline void RegistryItem::set_has_ml_model_metadata() {
  _oneof_case_[0] = kMlModelMetadata;
}
inline void RegistryItem::clear_ml_model_metadata() {
  if (_internal_has_ml_model_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.ml_model_metadata_;
    }
    clear_has_metadata();
  }
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::release_ml_model_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.ml_model_metadata)
  if (_internal_has_ml_model_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::MLModelMetadata* temp = metadata_.ml_model_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.ml_model_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::MLModelMetadata& RegistryItem::_internal_ml_model_metadata() const {
  return _internal_has_ml_model_metadata()
      ? *metadata_.ml_model_metadata_
      : reinterpret_cast< ::viam::app::v1::MLModelMetadata&>(::viam::app::v1::_MLModelMetadata_default_instance_);
}
inline const ::viam::app::v1::MLModelMetadata& RegistryItem::ml_model_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.ml_model_metadata)
  return _internal_ml_model_metadata();
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::unsafe_arena_release_ml_model_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.RegistryItem.ml_model_metadata)
  if (_internal_has_ml_model_metadata()) {
    clear_has_metadata();
    ::viam::app::v1::MLModelMetadata* temp = metadata_.ml_model_metadata_;
    metadata_.ml_model_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistryItem::unsafe_arena_set_allocated_ml_model_metadata(::viam::app::v1::MLModelMetadata* ml_model_metadata) {
  clear_metadata();
  if (ml_model_metadata) {
    set_has_ml_model_metadata();
    metadata_.ml_model_metadata_ = ml_model_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.ml_model_metadata)
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::_internal_mutable_ml_model_metadata() {
  if (!_internal_has_ml_model_metadata()) {
    clear_metadata();
    set_has_ml_model_metadata();
    metadata_.ml_model_metadata_ = CreateMaybeMessage< ::viam::app::v1::MLModelMetadata >(GetArenaForAllocation());
  }
  return metadata_.ml_model_metadata_;
}
inline ::viam::app::v1::MLModelMetadata* RegistryItem::mutable_ml_model_metadata() {
  ::viam::app::v1::MLModelMetadata* _msg = _internal_mutable_ml_model_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.ml_model_metadata)
  return _msg;
}

// .google.protobuf.Timestamp created_at = 15 [json_name = "createdAt"];
inline bool RegistryItem::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool RegistryItem::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::created_at() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.created_at)
  return _internal_created_at();
}
inline void RegistryItem::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.created_at)
  return _msg;
}
inline void RegistryItem::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.created_at)
}

// .google.protobuf.Timestamp updated_at = 16 [json_name = "updatedAt"];
inline bool RegistryItem::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool RegistryItem::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RegistryItem::updated_at() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RegistryItem.updated_at)
  return _internal_updated_at();
}
inline void RegistryItem::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RegistryItem.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RegistryItem.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RegistryItem::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RegistryItem.updated_at)
  return _msg;
}
inline void RegistryItem::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RegistryItem.updated_at)
}

inline bool RegistryItem::has_metadata() const {
  return metadata_case() != METADATA_NOT_SET;
}
inline void RegistryItem::clear_has_metadata() {
  _oneof_case_[0] = METADATA_NOT_SET;
}
inline RegistryItem::MetadataCase RegistryItem::metadata_case() const {
  return RegistryItem::MetadataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void GetRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& GetRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRegistryItemRequest.item_id)
}
inline std::string* GetRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& GetRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void GetRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void GetRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRegistryItemRequest.item_id)
}

// -------------------------------------------------------------------

// GetRegistryItemResponse

// .viam.app.v1.RegistryItem item = 1 [json_name = "item"];
inline bool GetRegistryItemResponse::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool GetRegistryItemResponse::has_item() const {
  return _internal_has_item();
}
inline void GetRegistryItemResponse::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::viam::app::v1::RegistryItem& GetRegistryItemResponse::_internal_item() const {
  const ::viam::app::v1::RegistryItem* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RegistryItem&>(
      ::viam::app::v1::_RegistryItem_default_instance_);
}
inline const ::viam::app::v1::RegistryItem& GetRegistryItemResponse::item() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRegistryItemResponse.item)
  return _internal_item();
}
inline void GetRegistryItemResponse::unsafe_arena_set_allocated_item(
    ::viam::app::v1::RegistryItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRegistryItemResponse.item)
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::release_item() {
  
  ::viam::app::v1::RegistryItem* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRegistryItemResponse.item)
  
  ::viam::app::v1::RegistryItem* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RegistryItem>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::viam::app::v1::RegistryItem* GetRegistryItemResponse::mutable_item() {
  ::viam::app::v1::RegistryItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRegistryItemResponse.item)
  return _msg;
}
inline void GetRegistryItemResponse::set_allocated_item(::viam::app::v1::RegistryItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRegistryItemResponse.item)
}

// -------------------------------------------------------------------

// CreateRegistryItemRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateRegistryItemRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateRegistryItemRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRegistryItemRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRegistryItemRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRegistryItemRequest.organization_id)
}
inline std::string* CreateRegistryItemRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRegistryItemRequest.organization_id)
  return _s;
}
inline const std::string& CreateRegistryItemRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateRegistryItemRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRegistryItemRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateRegistryItemRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRegistryItemRequest.organization_id)
}

// string name = 2 [json_name = "name"];
inline void CreateRegistryItemRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateRegistryItemRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRegistryItemRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRegistryItemRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRegistryItemRequest.name)
}
inline std::string* CreateRegistryItemRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRegistryItemRequest.name)
  return _s;
}
inline const std::string& CreateRegistryItemRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateRegistryItemRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRegistryItemRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRegistryItemRequest.name)
  return name_.Release();
}
inline void CreateRegistryItemRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRegistryItemRequest.name)
}

// .viam.app.packages.v1.PackageType type = 3 [json_name = "type"];
inline void CreateRegistryItemRequest::clear_type() {
  type_ = 0;
}
inline ::viam::app::packages::v1::PackageType CreateRegistryItemRequest::_internal_type() const {
  return static_cast< ::viam::app::packages::v1::PackageType >(type_);
}
inline ::viam::app::packages::v1::PackageType CreateRegistryItemRequest::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRegistryItemRequest.type)
  return _internal_type();
}
inline void CreateRegistryItemRequest::_internal_set_type(::viam::app::packages::v1::PackageType value) {
  
  type_ = value;
}
inline void CreateRegistryItemRequest::set_type(::viam::app::packages::v1::PackageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRegistryItemRequest.type)
}

// -------------------------------------------------------------------

// CreateRegistryItemResponse

// -------------------------------------------------------------------

// UpdateRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void UpdateRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& UpdateRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.item_id)
}
inline std::string* UpdateRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& UpdateRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void UpdateRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void UpdateRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRegistryItemRequest.item_id)
}

// .viam.app.packages.v1.PackageType type = 2 [json_name = "type"];
inline void UpdateRegistryItemRequest::clear_type() {
  type_ = 0;
}
inline ::viam::app::packages::v1::PackageType UpdateRegistryItemRequest::_internal_type() const {
  return static_cast< ::viam::app::packages::v1::PackageType >(type_);
}
inline ::viam::app::packages::v1::PackageType UpdateRegistryItemRequest::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.type)
  return _internal_type();
}
inline void UpdateRegistryItemRequest::_internal_set_type(::viam::app::packages::v1::PackageType value) {
  
  type_ = value;
}
inline void UpdateRegistryItemRequest::set_type(::viam::app::packages::v1::PackageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.type)
}

// string description = 3 [json_name = "description"];
inline void UpdateRegistryItemRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& UpdateRegistryItemRequest::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRegistryItemRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.description)
}
inline std::string* UpdateRegistryItemRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRegistryItemRequest.description)
  return _s;
}
inline const std::string& UpdateRegistryItemRequest::_internal_description() const {
  return description_.Get();
}
inline void UpdateRegistryItemRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRegistryItemRequest::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRegistryItemRequest.description)
  return description_.Release();
}
inline void UpdateRegistryItemRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRegistryItemRequest.description)
}

// .viam.app.v1.Visibility visibility = 4 [json_name = "visibility"];
inline void UpdateRegistryItemRequest::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility UpdateRegistryItemRequest::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility UpdateRegistryItemRequest::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRegistryItemRequest.visibility)
  return _internal_visibility();
}
inline void UpdateRegistryItemRequest::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void UpdateRegistryItemRequest::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRegistryItemRequest.visibility)
}

// -------------------------------------------------------------------

// UpdateRegistryItemResponse

// -------------------------------------------------------------------

// ListRegistryItemsRequest

// optional string organization_id = 1 [json_name = "organizationId"];
inline bool ListRegistryItemsRequest::_internal_has_organization_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListRegistryItemsRequest::has_organization_id() const {
  return _internal_has_organization_id();
}
inline void ListRegistryItemsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListRegistryItemsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRegistryItemsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.organization_id)
}
inline std::string* ListRegistryItemsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.organization_id)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListRegistryItemsRequest::_internal_set_organization_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::_internal_mutable_organization_id() {
  _has_bits_[0] |= 0x00000001u;
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRegistryItemsRequest.organization_id)
  if (!_internal_has_organization_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = organization_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListRegistryItemsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRegistryItemsRequest.organization_id)
}

// repeated .viam.app.packages.v1.PackageType types = 2 [json_name = "types"];
inline int ListRegistryItemsRequest::_internal_types_size() const {
  return types_.size();
}
inline int ListRegistryItemsRequest::types_size() const {
  return _internal_types_size();
}
inline void ListRegistryItemsRequest::clear_types() {
  types_.Clear();
}
inline ::viam::app::packages::v1::PackageType ListRegistryItemsRequest::_internal_types(int index) const {
  return static_cast< ::viam::app::packages::v1::PackageType >(types_.Get(index));
}
inline ::viam::app::packages::v1::PackageType ListRegistryItemsRequest::types(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.types)
  return _internal_types(index);
}
inline void ListRegistryItemsRequest::set_types(int index, ::viam::app::packages::v1::PackageType value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.types)
}
inline void ListRegistryItemsRequest::_internal_add_types(::viam::app::packages::v1::PackageType value) {
  types_.Add(value);
}
inline void ListRegistryItemsRequest::add_types(::viam::app::packages::v1::PackageType value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::types() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.types)
  return types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_types() {
  return &types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.types)
  return _internal_mutable_types();
}

// repeated .viam.app.v1.Visibility visibilities = 3 [json_name = "visibilities"];
inline int ListRegistryItemsRequest::_internal_visibilities_size() const {
  return visibilities_.size();
}
inline int ListRegistryItemsRequest::visibilities_size() const {
  return _internal_visibilities_size();
}
inline void ListRegistryItemsRequest::clear_visibilities() {
  visibilities_.Clear();
}
inline ::viam::app::v1::Visibility ListRegistryItemsRequest::_internal_visibilities(int index) const {
  return static_cast< ::viam::app::v1::Visibility >(visibilities_.Get(index));
}
inline ::viam::app::v1::Visibility ListRegistryItemsRequest::visibilities(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.visibilities)
  return _internal_visibilities(index);
}
inline void ListRegistryItemsRequest::set_visibilities(int index, ::viam::app::v1::Visibility value) {
  visibilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.visibilities)
}
inline void ListRegistryItemsRequest::_internal_add_visibilities(::viam::app::v1::Visibility value) {
  visibilities_.Add(value);
}
inline void ListRegistryItemsRequest::add_visibilities(::viam::app::v1::Visibility value) {
  _internal_add_visibilities(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.visibilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::visibilities() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.visibilities)
  return visibilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_visibilities() {
  return &visibilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_visibilities() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.visibilities)
  return _internal_mutable_visibilities();
}

// repeated string platforms = 4 [json_name = "platforms"];
inline int ListRegistryItemsRequest::_internal_platforms_size() const {
  return platforms_.size();
}
inline int ListRegistryItemsRequest::platforms_size() const {
  return _internal_platforms_size();
}
inline void ListRegistryItemsRequest::clear_platforms() {
  platforms_.Clear();
}
inline std::string* ListRegistryItemsRequest::add_platforms() {
  std::string* _s = _internal_add_platforms();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ListRegistryItemsRequest.platforms)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_platforms(int index) const {
  return platforms_.Get(index);
}
inline const std::string& ListRegistryItemsRequest::platforms(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.platforms)
  return _internal_platforms(index);
}
inline std::string* ListRegistryItemsRequest::mutable_platforms(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.platforms)
  return platforms_.Mutable(index);
}
inline void ListRegistryItemsRequest::set_platforms(int index, const std::string& value) {
  platforms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::set_platforms(int index, std::string&& value) {
  platforms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::set_platforms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platforms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::set_platforms(int index, const char* value, size_t size) {
  platforms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline std::string* ListRegistryItemsRequest::_internal_add_platforms() {
  return platforms_.Add();
}
inline void ListRegistryItemsRequest::add_platforms(const std::string& value) {
  platforms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::add_platforms(std::string&& value) {
  platforms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::add_platforms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platforms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline void ListRegistryItemsRequest::add_platforms(const char* value, size_t size) {
  platforms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ListRegistryItemsRequest.platforms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRegistryItemsRequest::platforms() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.platforms)
  return platforms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRegistryItemsRequest::mutable_platforms() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.platforms)
  return &platforms_;
}

// repeated .viam.app.v1.RegistryItemStatus statuses = 5 [json_name = "statuses"];
inline int ListRegistryItemsRequest::_internal_statuses_size() const {
  return statuses_.size();
}
inline int ListRegistryItemsRequest::statuses_size() const {
  return _internal_statuses_size();
}
inline void ListRegistryItemsRequest::clear_statuses() {
  statuses_.Clear();
}
inline ::viam::app::v1::RegistryItemStatus ListRegistryItemsRequest::_internal_statuses(int index) const {
  return static_cast< ::viam::app::v1::RegistryItemStatus >(statuses_.Get(index));
}
inline ::viam::app::v1::RegistryItemStatus ListRegistryItemsRequest::statuses(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.statuses)
  return _internal_statuses(index);
}
inline void ListRegistryItemsRequest::set_statuses(int index, ::viam::app::v1::RegistryItemStatus value) {
  statuses_.Set(index, value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.statuses)
}
inline void ListRegistryItemsRequest::_internal_add_statuses(::viam::app::v1::RegistryItemStatus value) {
  statuses_.Add(value);
}
inline void ListRegistryItemsRequest::add_statuses(::viam::app::v1::RegistryItemStatus value) {
  _internal_add_statuses(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsRequest.statuses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListRegistryItemsRequest::statuses() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsRequest.statuses)
  return statuses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::_internal_mutable_statuses() {
  return &statuses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListRegistryItemsRequest::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsRequest.statuses)
  return _internal_mutable_statuses();
}

// optional string search_term = 6 [json_name = "searchTerm"];
inline bool ListRegistryItemsRequest::_internal_has_search_term() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListRegistryItemsRequest::has_search_term() const {
  return _internal_has_search_term();
}
inline void ListRegistryItemsRequest::clear_search_term() {
  search_term_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListRegistryItemsRequest::search_term() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.search_term)
  return _internal_search_term();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRegistryItemsRequest::set_search_term(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 search_term_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.search_term)
}
inline std::string* ListRegistryItemsRequest::mutable_search_term() {
  std::string* _s = _internal_mutable_search_term();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.search_term)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_search_term() const {
  return search_term_.Get();
}
inline void ListRegistryItemsRequest::_internal_set_search_term(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  search_term_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::_internal_mutable_search_term() {
  _has_bits_[0] |= 0x00000002u;
  return search_term_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::release_search_term() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRegistryItemsRequest.search_term)
  if (!_internal_has_search_term()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = search_term_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_term_.IsDefault()) {
    search_term_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListRegistryItemsRequest::set_allocated_search_term(std::string* search_term) {
  if (search_term != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  search_term_.SetAllocated(search_term, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_term_.IsDefault()) {
    search_term_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRegistryItemsRequest.search_term)
}

// optional string page_token = 7 [json_name = "pageToken"];
inline bool ListRegistryItemsRequest::_internal_has_page_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListRegistryItemsRequest::has_page_token() const {
  return _internal_has_page_token();
}
inline void ListRegistryItemsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ListRegistryItemsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRegistryItemsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListRegistryItemsRequest.page_token)
}
inline std::string* ListRegistryItemsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsRequest.page_token)
  return _s;
}
inline const std::string& ListRegistryItemsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListRegistryItemsRequest::_internal_set_page_token(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::_internal_mutable_page_token() {
  _has_bits_[0] |= 0x00000004u;
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRegistryItemsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListRegistryItemsRequest.page_token)
  if (!_internal_has_page_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListRegistryItemsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListRegistryItemsRequest.page_token)
}

// -------------------------------------------------------------------

// ListRegistryItemsResponse

// repeated .viam.app.v1.RegistryItem items = 1 [json_name = "items"];
inline int ListRegistryItemsResponse::_internal_items_size() const {
  return items_.size();
}
inline int ListRegistryItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ListRegistryItemsResponse::clear_items() {
  items_.Clear();
}
inline ::viam::app::v1::RegistryItem* ListRegistryItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListRegistryItemsResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >*
ListRegistryItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListRegistryItemsResponse.items)
  return &items_;
}
inline const ::viam::app::v1::RegistryItem& ListRegistryItemsResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::viam::app::v1::RegistryItem& ListRegistryItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListRegistryItemsResponse.items)
  return _internal_items(index);
}
inline ::viam::app::v1::RegistryItem* ListRegistryItemsResponse::_internal_add_items() {
  return items_.Add();
}
inline ::viam::app::v1::RegistryItem* ListRegistryItemsResponse::add_items() {
  ::viam::app::v1::RegistryItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListRegistryItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RegistryItem >&
ListRegistryItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListRegistryItemsResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// DeleteRegistryItemRequest

// string item_id = 1 [json_name = "itemId"];
inline void DeleteRegistryItemRequest::clear_item_id() {
  item_id_.ClearToEmpty();
}
inline const std::string& DeleteRegistryItemRequest::item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRegistryItemRequest.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRegistryItemRequest::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRegistryItemRequest.item_id)
}
inline std::string* DeleteRegistryItemRequest::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRegistryItemRequest.item_id)
  return _s;
}
inline const std::string& DeleteRegistryItemRequest::_internal_item_id() const {
  return item_id_.Get();
}
inline void DeleteRegistryItemRequest::_internal_set_item_id(const std::string& value) {
  
  item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRegistryItemRequest::_internal_mutable_item_id() {
  
  return item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRegistryItemRequest::release_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRegistryItemRequest.item_id)
  return item_id_.Release();
}
inline void DeleteRegistryItemRequest::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (item_id_.IsDefault()) {
    item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRegistryItemRequest.item_id)
}

// -------------------------------------------------------------------

// DeleteRegistryItemResponse

// -------------------------------------------------------------------

// CreateModuleRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateModuleRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& CreateModuleRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleRequest.organization_id)
}
inline std::string* CreateModuleRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleRequest.organization_id)
  return _s;
}
inline const std::string& CreateModuleRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void CreateModuleRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleRequest.organization_id)
  return organization_id_.Release();
}
inline void CreateModuleRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleRequest.organization_id)
}

// string name = 2 [json_name = "name"];
inline void CreateModuleRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateModuleRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleRequest.name)
}
inline std::string* CreateModuleRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleRequest.name)
  return _s;
}
inline const std::string& CreateModuleRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateModuleRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleRequest.name)
  return name_.Release();
}
inline void CreateModuleRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleRequest.name)
}

// -------------------------------------------------------------------

// CreateModuleResponse

// string module_id = 1 [json_name = "moduleId"];
inline void CreateModuleResponse::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& CreateModuleResponse::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleResponse.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleResponse::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleResponse.module_id)
}
inline std::string* CreateModuleResponse::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleResponse.module_id)
  return _s;
}
inline const std::string& CreateModuleResponse::_internal_module_id() const {
  return module_id_.Get();
}
inline void CreateModuleResponse::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleResponse.module_id)
  return module_id_.Release();
}
inline void CreateModuleResponse::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleResponse.module_id)
}

// string url = 2 [json_name = "url"];
inline void CreateModuleResponse::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& CreateModuleResponse::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateModuleResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateModuleResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateModuleResponse.url)
}
inline std::string* CreateModuleResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateModuleResponse.url)
  return _s;
}
inline const std::string& CreateModuleResponse::_internal_url() const {
  return url_.Get();
}
inline void CreateModuleResponse::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateModuleResponse::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateModuleResponse.url)
  return url_.Release();
}
inline void CreateModuleResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateModuleResponse.url)
}

// -------------------------------------------------------------------

// UpdateModuleRequest

// string module_id = 1 [json_name = "moduleId"];
inline void UpdateModuleRequest::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.module_id)
}
inline std::string* UpdateModuleRequest::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.module_id)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_module_id() const {
  return module_id_.Get();
}
inline void UpdateModuleRequest::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.module_id)
  return module_id_.Release();
}
inline void UpdateModuleRequest::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.module_id)
}

// .viam.app.v1.Visibility visibility = 2 [json_name = "visibility"];
inline void UpdateModuleRequest::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility UpdateModuleRequest::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility UpdateModuleRequest::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.visibility)
  return _internal_visibility();
}
inline void UpdateModuleRequest::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void UpdateModuleRequest::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.visibility)
}

// string url = 3 [json_name = "url"];
inline void UpdateModuleRequest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.url)
}
inline std::string* UpdateModuleRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.url)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_url() const {
  return url_.Get();
}
inline void UpdateModuleRequest::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.url)
  return url_.Release();
}
inline void UpdateModuleRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.url)
}

// string description = 4 [json_name = "description"];
inline void UpdateModuleRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.description)
}
inline std::string* UpdateModuleRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.description)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_description() const {
  return description_.Get();
}
inline void UpdateModuleRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.description)
  return description_.Release();
}
inline void UpdateModuleRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.description)
}

// repeated .viam.app.v1.Model models = 5 [json_name = "models"];
inline int UpdateModuleRequest::_internal_models_size() const {
  return models_.size();
}
inline int UpdateModuleRequest::models_size() const {
  return _internal_models_size();
}
inline void UpdateModuleRequest::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* UpdateModuleRequest::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
UpdateModuleRequest::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.UpdateModuleRequest.models)
  return &models_;
}
inline const ::viam::app::v1::Model& UpdateModuleRequest::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& UpdateModuleRequest::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* UpdateModuleRequest::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* UpdateModuleRequest::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.UpdateModuleRequest.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
UpdateModuleRequest::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.UpdateModuleRequest.models)
  return models_;
}

// string entrypoint = 6 [json_name = "entrypoint"];
inline void UpdateModuleRequest::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& UpdateModuleRequest::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleRequest.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleRequest::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleRequest.entrypoint)
}
inline std::string* UpdateModuleRequest::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleRequest.entrypoint)
  return _s;
}
inline const std::string& UpdateModuleRequest::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void UpdateModuleRequest::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleRequest::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleRequest.entrypoint)
  return entrypoint_.Release();
}
inline void UpdateModuleRequest::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleRequest.entrypoint)
}

// -------------------------------------------------------------------

// UpdateModuleResponse

// string url = 1 [json_name = "url"];
inline void UpdateModuleResponse::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& UpdateModuleResponse::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateModuleResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateModuleResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateModuleResponse.url)
}
inline std::string* UpdateModuleResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateModuleResponse.url)
  return _s;
}
inline const std::string& UpdateModuleResponse::_internal_url() const {
  return url_.Get();
}
inline void UpdateModuleResponse::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateModuleResponse::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateModuleResponse::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateModuleResponse.url)
  return url_.Release();
}
inline void UpdateModuleResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateModuleResponse.url)
}

// -------------------------------------------------------------------

// Model

// string api = 1 [json_name = "api"];
inline void Model::clear_api() {
  api_.ClearToEmpty();
}
inline const std::string& Model::api() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Model.api)
  return _internal_api();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_api(ArgT0&& arg0, ArgT... args) {
 
 api_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.api)
}
inline std::string* Model::mutable_api() {
  std::string* _s = _internal_mutable_api();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Model.api)
  return _s;
}
inline const std::string& Model::_internal_api() const {
  return api_.Get();
}
inline void Model::_internal_set_api(const std::string& value) {
  
  api_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_api() {
  
  return api_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_api() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Model.api)
  return api_.Release();
}
inline void Model::set_allocated_api(std::string* api) {
  if (api != nullptr) {
    
  } else {
    
  }
  api_.SetAllocated(api, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_.IsDefault()) {
    api_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Model.api)
}

// string model = 2 [json_name = "model"];
inline void Model::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& Model::model() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Model.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Model.model)
}
inline std::string* Model::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Model.model)
  return _s;
}
inline const std::string& Model::_internal_model() const {
  return model_.Get();
}
inline void Model::_internal_set_model(const std::string& value) {
  
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_model() {
  
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_model() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Model.model)
  return model_.Release();
}
inline void Model::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Model.model)
}

// -------------------------------------------------------------------

// ModuleFileInfo

// string module_id = 1 [json_name = "moduleId"];
inline void ModuleFileInfo::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& ModuleFileInfo::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleFileInfo.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleFileInfo::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.module_id)
}
inline std::string* ModuleFileInfo::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleFileInfo.module_id)
  return _s;
}
inline const std::string& ModuleFileInfo::_internal_module_id() const {
  return module_id_.Get();
}
inline void ModuleFileInfo::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleFileInfo.module_id)
  return module_id_.Release();
}
inline void ModuleFileInfo::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleFileInfo.module_id)
}

// string version = 2 [json_name = "version"];
inline void ModuleFileInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ModuleFileInfo::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleFileInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleFileInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.version)
}
inline std::string* ModuleFileInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleFileInfo.version)
  return _s;
}
inline const std::string& ModuleFileInfo::_internal_version() const {
  return version_.Get();
}
inline void ModuleFileInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleFileInfo.version)
  return version_.Release();
}
inline void ModuleFileInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleFileInfo.version)
}

// string platform = 3 [json_name = "platform"];
inline void ModuleFileInfo::clear_platform() {
  platform_.ClearToEmpty();
}
inline const std::string& ModuleFileInfo::platform() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleFileInfo.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleFileInfo::set_platform(ArgT0&& arg0, ArgT... args) {
 
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleFileInfo.platform)
}
inline std::string* ModuleFileInfo::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleFileInfo.platform)
  return _s;
}
inline const std::string& ModuleFileInfo::_internal_platform() const {
  return platform_.Get();
}
inline void ModuleFileInfo::_internal_set_platform(const std::string& value) {
  
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::_internal_mutable_platform() {
  
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleFileInfo::release_platform() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleFileInfo.platform)
  return platform_.Release();
}
inline void ModuleFileInfo::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleFileInfo.platform)
}

// -------------------------------------------------------------------

// UploadModuleFileRequest

// .viam.app.v1.ModuleFileInfo module_file_info = 1 [json_name = "moduleFileInfo"];
inline bool UploadModuleFileRequest::_internal_has_module_file_info() const {
  return module_file_case() == kModuleFileInfo;
}
inline bool UploadModuleFileRequest::has_module_file_info() const {
  return _internal_has_module_file_info();
}
inline void UploadModuleFileRequest::set_has_module_file_info() {
  _oneof_case_[0] = kModuleFileInfo;
}
inline void UploadModuleFileRequest::clear_module_file_info() {
  if (_internal_has_module_file_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete module_file_.module_file_info_;
    }
    clear_has_module_file();
  }
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::release_module_file_info() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UploadModuleFileRequest.module_file_info)
  if (_internal_has_module_file_info()) {
    clear_has_module_file();
    ::viam::app::v1::ModuleFileInfo* temp = module_file_.module_file_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    module_file_.module_file_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::ModuleFileInfo& UploadModuleFileRequest::_internal_module_file_info() const {
  return _internal_has_module_file_info()
      ? *module_file_.module_file_info_
      : reinterpret_cast< ::viam::app::v1::ModuleFileInfo&>(::viam::app::v1::_ModuleFileInfo_default_instance_);
}
inline const ::viam::app::v1::ModuleFileInfo& UploadModuleFileRequest::module_file_info() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UploadModuleFileRequest.module_file_info)
  return _internal_module_file_info();
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::unsafe_arena_release_module_file_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.UploadModuleFileRequest.module_file_info)
  if (_internal_has_module_file_info()) {
    clear_has_module_file();
    ::viam::app::v1::ModuleFileInfo* temp = module_file_.module_file_info_;
    module_file_.module_file_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UploadModuleFileRequest::unsafe_arena_set_allocated_module_file_info(::viam::app::v1::ModuleFileInfo* module_file_info) {
  clear_module_file();
  if (module_file_info) {
    set_has_module_file_info();
    module_file_.module_file_info_ = module_file_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UploadModuleFileRequest.module_file_info)
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::_internal_mutable_module_file_info() {
  if (!_internal_has_module_file_info()) {
    clear_module_file();
    set_has_module_file_info();
    module_file_.module_file_info_ = CreateMaybeMessage< ::viam::app::v1::ModuleFileInfo >(GetArenaForAllocation());
  }
  return module_file_.module_file_info_;
}
inline ::viam::app::v1::ModuleFileInfo* UploadModuleFileRequest::mutable_module_file_info() {
  ::viam::app::v1::ModuleFileInfo* _msg = _internal_mutable_module_file_info();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UploadModuleFileRequest.module_file_info)
  return _msg;
}

// bytes file = 2 [json_name = "file"];
inline bool UploadModuleFileRequest::_internal_has_file() const {
  return module_file_case() == kFile;
}
inline bool UploadModuleFileRequest::has_file() const {
  return _internal_has_file();
}
inline void UploadModuleFileRequest::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline void UploadModuleFileRequest::clear_file() {
  if (_internal_has_file()) {
    module_file_.file_.Destroy();
    clear_has_module_file();
  }
}
inline const std::string& UploadModuleFileRequest::file() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UploadModuleFileRequest.file)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline void UploadModuleFileRequest::set_file(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_file()) {
    clear_module_file();
    set_has_file();
    module_file_.file_.InitDefault();
  }
  module_file_.file_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UploadModuleFileRequest.file)
}
inline std::string* UploadModuleFileRequest::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UploadModuleFileRequest.file)
  return _s;
}
inline const std::string& UploadModuleFileRequest::_internal_file() const {
  if (_internal_has_file()) {
    return module_file_.file_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UploadModuleFileRequest::_internal_set_file(const std::string& value) {
  if (!_internal_has_file()) {
    clear_module_file();
    set_has_file();
    module_file_.file_.InitDefault();
  }
  module_file_.file_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadModuleFileRequest::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_module_file();
    set_has_file();
    module_file_.file_.InitDefault();
  }
  return module_file_.file_.Mutable(      GetArenaForAllocation());
}
inline std::string* UploadModuleFileRequest::release_file() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UploadModuleFileRequest.file)
  if (_internal_has_file()) {
    clear_has_module_file();
    return module_file_.file_.Release();
  } else {
    return nullptr;
  }
}
inline void UploadModuleFileRequest::set_allocated_file(std::string* file) {
  if (has_module_file()) {
    clear_module_file();
  }
  if (file != nullptr) {
    set_has_file();
    module_file_.file_.InitAllocated(file, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UploadModuleFileRequest.file)
}

inline bool UploadModuleFileRequest::has_module_file() const {
  return module_file_case() != MODULE_FILE_NOT_SET;
}
inline void UploadModuleFileRequest::clear_has_module_file() {
  _oneof_case_[0] = MODULE_FILE_NOT_SET;
}
inline UploadModuleFileRequest::ModuleFileCase UploadModuleFileRequest::module_file_case() const {
  return UploadModuleFileRequest::ModuleFileCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UploadModuleFileResponse

// string url = 1 [json_name = "url"];
inline void UploadModuleFileResponse::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& UploadModuleFileResponse::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UploadModuleFileResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadModuleFileResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UploadModuleFileResponse.url)
}
inline std::string* UploadModuleFileResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UploadModuleFileResponse.url)
  return _s;
}
inline const std::string& UploadModuleFileResponse::_internal_url() const {
  return url_.Get();
}
inline void UploadModuleFileResponse::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadModuleFileResponse::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadModuleFileResponse::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UploadModuleFileResponse.url)
  return url_.Release();
}
inline void UploadModuleFileResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UploadModuleFileResponse.url)
}

// -------------------------------------------------------------------

// GetModuleRequest

// string module_id = 1 [json_name = "moduleId"];
inline void GetModuleRequest::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& GetModuleRequest::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetModuleRequest.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetModuleRequest::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetModuleRequest.module_id)
}
inline std::string* GetModuleRequest::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetModuleRequest.module_id)
  return _s;
}
inline const std::string& GetModuleRequest::_internal_module_id() const {
  return module_id_.Get();
}
inline void GetModuleRequest::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModuleRequest::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModuleRequest::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetModuleRequest.module_id)
  return module_id_.Release();
}
inline void GetModuleRequest::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetModuleRequest.module_id)
}

// -------------------------------------------------------------------

// GetModuleResponse

// .viam.app.v1.Module module = 1 [json_name = "module"];
inline bool GetModuleResponse::_internal_has_module() const {
  return this != internal_default_instance() && module_ != nullptr;
}
inline bool GetModuleResponse::has_module() const {
  return _internal_has_module();
}
inline void GetModuleResponse::clear_module() {
  if (GetArenaForAllocation() == nullptr && module_ != nullptr) {
    delete module_;
  }
  module_ = nullptr;
}
inline const ::viam::app::v1::Module& GetModuleResponse::_internal_module() const {
  const ::viam::app::v1::Module* p = module_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Module&>(
      ::viam::app::v1::_Module_default_instance_);
}
inline const ::viam::app::v1::Module& GetModuleResponse::module() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetModuleResponse.module)
  return _internal_module();
}
inline void GetModuleResponse::unsafe_arena_set_allocated_module(
    ::viam::app::v1::Module* module) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_);
  }
  module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetModuleResponse.module)
}
inline ::viam::app::v1::Module* GetModuleResponse::release_module() {
  
  ::viam::app::v1::Module* temp = module_;
  module_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Module* GetModuleResponse::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetModuleResponse.module)
  
  ::viam::app::v1::Module* temp = module_;
  module_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Module* GetModuleResponse::_internal_mutable_module() {
  
  if (module_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Module>(GetArenaForAllocation());
    module_ = p;
  }
  return module_;
}
inline ::viam::app::v1::Module* GetModuleResponse::mutable_module() {
  ::viam::app::v1::Module* _msg = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetModuleResponse.module)
  return _msg;
}
inline void GetModuleResponse::set_allocated_module(::viam::app::v1::Module* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete module_;
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(module);
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  module_ = module;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetModuleResponse.module)
}

// -------------------------------------------------------------------

// Module

// string module_id = 1 [json_name = "moduleId"];
inline void Module::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& Module::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.module_id)
}
inline std::string* Module::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.module_id)
  return _s;
}
inline const std::string& Module::_internal_module_id() const {
  return module_id_.Get();
}
inline void Module::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.module_id)
  return module_id_.Release();
}
inline void Module::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.module_id)
}

// string name = 2 [json_name = "name"];
inline void Module::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Module::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.name)
}
inline std::string* Module::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.name)
  return _s;
}
inline const std::string& Module::_internal_name() const {
  return name_.Get();
}
inline void Module::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.name)
  return name_.Release();
}
inline void Module::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.name)
}

// .viam.app.v1.Visibility visibility = 3 [json_name = "visibility"];
inline void Module::clear_visibility() {
  visibility_ = 0;
}
inline ::viam::app::v1::Visibility Module::_internal_visibility() const {
  return static_cast< ::viam::app::v1::Visibility >(visibility_);
}
inline ::viam::app::v1::Visibility Module::visibility() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.visibility)
  return _internal_visibility();
}
inline void Module::_internal_set_visibility(::viam::app::v1::Visibility value) {
  
  visibility_ = value;
}
inline void Module::set_visibility(::viam::app::v1::Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.visibility)
}

// repeated .viam.app.v1.VersionHistory versions = 4 [json_name = "versions"];
inline int Module::_internal_versions_size() const {
  return versions_.size();
}
inline int Module::versions_size() const {
  return _internal_versions_size();
}
inline void Module::clear_versions() {
  versions_.Clear();
}
inline ::viam::app::v1::VersionHistory* Module::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.versions)
  return versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >*
Module::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Module.versions)
  return &versions_;
}
inline const ::viam::app::v1::VersionHistory& Module::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const ::viam::app::v1::VersionHistory& Module::versions(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.versions)
  return _internal_versions(index);
}
inline ::viam::app::v1::VersionHistory* Module::_internal_add_versions() {
  return versions_.Add();
}
inline ::viam::app::v1::VersionHistory* Module::add_versions() {
  ::viam::app::v1::VersionHistory* _add = _internal_add_versions();
  // @@protoc_insertion_point(field_add:viam.app.v1.Module.versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::VersionHistory >&
Module::versions() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Module.versions)
  return versions_;
}

// string url = 5 [json_name = "url"];
inline void Module::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Module::url() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.url)
}
inline std::string* Module::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.url)
  return _s;
}
inline const std::string& Module::_internal_url() const {
  return url_.Get();
}
inline void Module::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_url() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.url)
  return url_.Release();
}
inline void Module::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.url)
}

// string description = 6 [json_name = "description"];
inline void Module::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Module::description() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.description)
}
inline std::string* Module::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.description)
  return _s;
}
inline const std::string& Module::_internal_description() const {
  return description_.Get();
}
inline void Module::_internal_set_description(const std::string& value) {
  
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_description() {
  
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_description() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.description)
  return description_.Release();
}
inline void Module::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.description)
}

// repeated .viam.app.v1.Model models = 7 [json_name = "models"];
inline int Module::_internal_models_size() const {
  return models_.size();
}
inline int Module::models_size() const {
  return _internal_models_size();
}
inline void Module::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* Module::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
Module::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.Module.models)
  return &models_;
}
inline const ::viam::app::v1::Model& Module::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& Module::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* Module::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* Module::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.Module.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
Module::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.Module.models)
  return models_;
}

// int64 total_robot_usage = 8 [json_name = "totalRobotUsage"];
inline void Module::clear_total_robot_usage() {
  total_robot_usage_ = int64_t{0};
}
inline int64_t Module::_internal_total_robot_usage() const {
  return total_robot_usage_;
}
inline int64_t Module::total_robot_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.total_robot_usage)
  return _internal_total_robot_usage();
}
inline void Module::_internal_set_total_robot_usage(int64_t value) {
  
  total_robot_usage_ = value;
}
inline void Module::set_total_robot_usage(int64_t value) {
  _internal_set_total_robot_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.total_robot_usage)
}

// int64 total_organization_usage = 9 [json_name = "totalOrganizationUsage"];
inline void Module::clear_total_organization_usage() {
  total_organization_usage_ = int64_t{0};
}
inline int64_t Module::_internal_total_organization_usage() const {
  return total_organization_usage_;
}
inline int64_t Module::total_organization_usage() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.total_organization_usage)
  return _internal_total_organization_usage();
}
inline void Module::_internal_set_total_organization_usage(int64_t value) {
  
  total_organization_usage_ = value;
}
inline void Module::set_total_organization_usage(int64_t value) {
  _internal_set_total_organization_usage(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.total_organization_usage)
}

// string organization_id = 10 [json_name = "organizationId"];
inline void Module::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& Module::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.organization_id)
}
inline std::string* Module::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.organization_id)
  return _s;
}
inline const std::string& Module::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void Module::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.organization_id)
  return organization_id_.Release();
}
inline void Module::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.organization_id)
}

// string entrypoint = 11 [json_name = "entrypoint"];
inline void Module::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& Module::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.entrypoint)
}
inline std::string* Module::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.entrypoint)
  return _s;
}
inline const std::string& Module::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void Module::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.entrypoint)
  return entrypoint_.Release();
}
inline void Module::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.entrypoint)
}

// string public_namespace = 12 [json_name = "publicNamespace"];
inline void Module::clear_public_namespace() {
  public_namespace_.ClearToEmpty();
}
inline const std::string& Module::public_namespace() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Module.public_namespace)
  return _internal_public_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Module::set_public_namespace(ArgT0&& arg0, ArgT... args) {
 
 public_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Module.public_namespace)
}
inline std::string* Module::mutable_public_namespace() {
  std::string* _s = _internal_mutable_public_namespace();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Module.public_namespace)
  return _s;
}
inline const std::string& Module::_internal_public_namespace() const {
  return public_namespace_.Get();
}
inline void Module::_internal_set_public_namespace(const std::string& value) {
  
  public_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Module::_internal_mutable_public_namespace() {
  
  return public_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Module::release_public_namespace() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Module.public_namespace)
  return public_namespace_.Release();
}
inline void Module::set_allocated_public_namespace(std::string* public_namespace) {
  if (public_namespace != nullptr) {
    
  } else {
    
  }
  public_namespace_.SetAllocated(public_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_namespace_.IsDefault()) {
    public_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Module.public_namespace)
}

// -------------------------------------------------------------------

// VersionHistory

// string version = 1 [json_name = "version"];
inline void VersionHistory::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& VersionHistory::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionHistory::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.VersionHistory.version)
}
inline std::string* VersionHistory::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.version)
  return _s;
}
inline const std::string& VersionHistory::_internal_version() const {
  return version_.Get();
}
inline void VersionHistory::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionHistory::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionHistory::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.VersionHistory.version)
  return version_.Release();
}
inline void VersionHistory::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.VersionHistory.version)
}

// repeated .viam.app.v1.Uploads files = 2 [json_name = "files"];
inline int VersionHistory::_internal_files_size() const {
  return files_.size();
}
inline int VersionHistory::files_size() const {
  return _internal_files_size();
}
inline void VersionHistory::clear_files() {
  files_.Clear();
}
inline ::viam::app::v1::Uploads* VersionHistory::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >*
VersionHistory::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.VersionHistory.files)
  return &files_;
}
inline const ::viam::app::v1::Uploads& VersionHistory::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::viam::app::v1::Uploads& VersionHistory::files(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.files)
  return _internal_files(index);
}
inline ::viam::app::v1::Uploads* VersionHistory::_internal_add_files() {
  return files_.Add();
}
inline ::viam::app::v1::Uploads* VersionHistory::add_files() {
  ::viam::app::v1::Uploads* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:viam.app.v1.VersionHistory.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Uploads >&
VersionHistory::files() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.VersionHistory.files)
  return files_;
}

// repeated .viam.app.v1.Model models = 3 [json_name = "models"];
inline int VersionHistory::_internal_models_size() const {
  return models_.size();
}
inline int VersionHistory::models_size() const {
  return _internal_models_size();
}
inline void VersionHistory::clear_models() {
  models_.Clear();
}
inline ::viam::app::v1::Model* VersionHistory::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >*
VersionHistory::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.VersionHistory.models)
  return &models_;
}
inline const ::viam::app::v1::Model& VersionHistory::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::viam::app::v1::Model& VersionHistory::models(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.models)
  return _internal_models(index);
}
inline ::viam::app::v1::Model* VersionHistory::_internal_add_models() {
  return models_.Add();
}
inline ::viam::app::v1::Model* VersionHistory::add_models() {
  ::viam::app::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:viam.app.v1.VersionHistory.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Model >&
VersionHistory::models() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.VersionHistory.models)
  return models_;
}

// string entrypoint = 4 [json_name = "entrypoint"];
inline void VersionHistory::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& VersionHistory::entrypoint() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.VersionHistory.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionHistory::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.VersionHistory.entrypoint)
}
inline std::string* VersionHistory::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.VersionHistory.entrypoint)
  return _s;
}
inline const std::string& VersionHistory::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void VersionHistory::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionHistory::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionHistory::release_entrypoint() {
  // @@protoc_insertion_point(field_release:viam.app.v1.VersionHistory.entrypoint)
  return entrypoint_.Release();
}
inline void VersionHistory::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(entrypoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entrypoint_.IsDefault()) {
    entrypoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.VersionHistory.entrypoint)
}

// -------------------------------------------------------------------

// Uploads

// string platform = 1 [json_name = "platform"];
inline void Uploads::clear_platform() {
  platform_.ClearToEmpty();
}
inline const std::string& Uploads::platform() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Uploads.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Uploads::set_platform(ArgT0&& arg0, ArgT... args) {
 
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Uploads.platform)
}
inline std::string* Uploads::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Uploads.platform)
  return _s;
}
inline const std::string& Uploads::_internal_platform() const {
  return platform_.Get();
}
inline void Uploads::_internal_set_platform(const std::string& value) {
  
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* Uploads::_internal_mutable_platform() {
  
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* Uploads::release_platform() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Uploads.platform)
  return platform_.Release();
}
inline void Uploads::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Uploads.platform)
}

// .google.protobuf.Timestamp uploaded_at = 2 [json_name = "uploadedAt"];
inline bool Uploads::_internal_has_uploaded_at() const {
  return this != internal_default_instance() && uploaded_at_ != nullptr;
}
inline bool Uploads::has_uploaded_at() const {
  return _internal_has_uploaded_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Uploads::_internal_uploaded_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = uploaded_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Uploads::uploaded_at() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Uploads.uploaded_at)
  return _internal_uploaded_at();
}
inline void Uploads::unsafe_arena_set_allocated_uploaded_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaded_at_);
  }
  uploaded_at_ = uploaded_at;
  if (uploaded_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Uploads.uploaded_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::release_uploaded_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = uploaded_at_;
  uploaded_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::unsafe_arena_release_uploaded_at() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Uploads.uploaded_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = uploaded_at_;
  uploaded_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::_internal_mutable_uploaded_at() {
  
  if (uploaded_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    uploaded_at_ = p;
  }
  return uploaded_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Uploads::mutable_uploaded_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_uploaded_at();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Uploads.uploaded_at)
  return _msg;
}
inline void Uploads::set_allocated_uploaded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaded_at_);
  }
  if (uploaded_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaded_at));
    if (message_arena != submessage_arena) {
      uploaded_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uploaded_at, submessage_arena);
    }
    
  } else {
    
  }
  uploaded_at_ = uploaded_at;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Uploads.uploaded_at)
}

// -------------------------------------------------------------------

// ListModulesRequest

// optional string organization_id = 1 [json_name = "organizationId"];
inline bool ListModulesRequest::_internal_has_organization_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListModulesRequest::has_organization_id() const {
  return _internal_has_organization_id();
}
inline void ListModulesRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListModulesRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListModulesRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListModulesRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListModulesRequest.organization_id)
}
inline std::string* ListModulesRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListModulesRequest.organization_id)
  return _s;
}
inline const std::string& ListModulesRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListModulesRequest::_internal_set_organization_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListModulesRequest::_internal_mutable_organization_id() {
  _has_bits_[0] |= 0x00000001u;
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListModulesRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListModulesRequest.organization_id)
  if (!_internal_has_organization_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = organization_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListModulesRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListModulesRequest.organization_id)
}

// -------------------------------------------------------------------

// ListModulesResponse

// repeated .viam.app.v1.Module modules = 1 [json_name = "modules"];
inline int ListModulesResponse::_internal_modules_size() const {
  return modules_.size();
}
inline int ListModulesResponse::modules_size() const {
  return _internal_modules_size();
}
inline void ListModulesResponse::clear_modules() {
  modules_.Clear();
}
inline ::viam::app::v1::Module* ListModulesResponse::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListModulesResponse.modules)
  return modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >*
ListModulesResponse::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListModulesResponse.modules)
  return &modules_;
}
inline const ::viam::app::v1::Module& ListModulesResponse::_internal_modules(int index) const {
  return modules_.Get(index);
}
inline const ::viam::app::v1::Module& ListModulesResponse::modules(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListModulesResponse.modules)
  return _internal_modules(index);
}
inline ::viam::app::v1::Module* ListModulesResponse::_internal_add_modules() {
  return modules_.Add();
}
inline ::viam::app::v1::Module* ListModulesResponse::add_modules() {
  ::viam::app::v1::Module* _add = _internal_add_modules();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListModulesResponse.modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Module >&
ListModulesResponse::modules() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListModulesResponse.modules)
  return modules_;
}

// -------------------------------------------------------------------

// GetUserIDByEmailRequest

// string email = 1 [json_name = "email"];
inline void GetUserIDByEmailRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& GetUserIDByEmailRequest::email() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetUserIDByEmailRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserIDByEmailRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetUserIDByEmailRequest.email)
}
inline std::string* GetUserIDByEmailRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetUserIDByEmailRequest.email)
  return _s;
}
inline const std::string& GetUserIDByEmailRequest::_internal_email() const {
  return email_.Get();
}
inline void GetUserIDByEmailRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailRequest::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailRequest::release_email() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetUserIDByEmailRequest.email)
  return email_.Release();
}
inline void GetUserIDByEmailRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetUserIDByEmailRequest.email)
}

// -------------------------------------------------------------------

// GetUserIDByEmailResponse

// string user_id = 1 [json_name = "userId"];
inline void GetUserIDByEmailResponse::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetUserIDByEmailResponse::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetUserIDByEmailResponse.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserIDByEmailResponse::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetUserIDByEmailResponse.user_id)
}
inline std::string* GetUserIDByEmailResponse::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetUserIDByEmailResponse.user_id)
  return _s;
}
inline const std::string& GetUserIDByEmailResponse::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetUserIDByEmailResponse::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailResponse::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserIDByEmailResponse::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetUserIDByEmailResponse.user_id)
  return user_id_.Release();
}
inline void GetUserIDByEmailResponse::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetUserIDByEmailResponse.user_id)
}

// -------------------------------------------------------------------

// ListOrganizationsByUserRequest

// string user_id = 1 [json_name = "userId"];
inline void ListOrganizationsByUserRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ListOrganizationsByUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationsByUserRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOrganizationsByUserRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListOrganizationsByUserRequest.user_id)
}
inline std::string* ListOrganizationsByUserRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationsByUserRequest.user_id)
  return _s;
}
inline const std::string& ListOrganizationsByUserRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ListOrganizationsByUserRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOrganizationsByUserRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOrganizationsByUserRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListOrganizationsByUserRequest.user_id)
  return user_id_.Release();
}
inline void ListOrganizationsByUserRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault()) {
    user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListOrganizationsByUserRequest.user_id)
}

// -------------------------------------------------------------------

// OrgDetails

// string org_id = 1 [json_name = "orgId"];
inline void OrgDetails::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& OrgDetails::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrgDetails.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrgDetails::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrgDetails.org_id)
}
inline std::string* OrgDetails::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrgDetails.org_id)
  return _s;
}
inline const std::string& OrgDetails::_internal_org_id() const {
  return org_id_.Get();
}
inline void OrgDetails::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrgDetails::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrgDetails::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrgDetails.org_id)
  return org_id_.Release();
}
inline void OrgDetails::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrgDetails.org_id)
}

// string org_name = 2 [json_name = "orgName"];
inline void OrgDetails::clear_org_name() {
  org_name_.ClearToEmpty();
}
inline const std::string& OrgDetails::org_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.OrgDetails.org_name)
  return _internal_org_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrgDetails::set_org_name(ArgT0&& arg0, ArgT... args) {
 
 org_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.OrgDetails.org_name)
}
inline std::string* OrgDetails::mutable_org_name() {
  std::string* _s = _internal_mutable_org_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.OrgDetails.org_name)
  return _s;
}
inline const std::string& OrgDetails::_internal_org_name() const {
  return org_name_.Get();
}
inline void OrgDetails::_internal_set_org_name(const std::string& value) {
  
  org_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OrgDetails::_internal_mutable_org_name() {
  
  return org_name_.Mutable(GetArenaForAllocation());
}
inline std::string* OrgDetails::release_org_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.OrgDetails.org_name)
  return org_name_.Release();
}
inline void OrgDetails::set_allocated_org_name(std::string* org_name) {
  if (org_name != nullptr) {
    
  } else {
    
  }
  org_name_.SetAllocated(org_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_name_.IsDefault()) {
    org_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.OrgDetails.org_name)
}

// -------------------------------------------------------------------

// ListOrganizationsByUserResponse

// repeated .viam.app.v1.OrgDetails orgs = 1 [json_name = "orgs"];
inline int ListOrganizationsByUserResponse::_internal_orgs_size() const {
  return orgs_.size();
}
inline int ListOrganizationsByUserResponse::orgs_size() const {
  return _internal_orgs_size();
}
inline void ListOrganizationsByUserResponse::clear_orgs() {
  orgs_.Clear();
}
inline ::viam::app::v1::OrgDetails* ListOrganizationsByUserResponse::mutable_orgs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return orgs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >*
ListOrganizationsByUserResponse::mutable_orgs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return &orgs_;
}
inline const ::viam::app::v1::OrgDetails& ListOrganizationsByUserResponse::_internal_orgs(int index) const {
  return orgs_.Get(index);
}
inline const ::viam::app::v1::OrgDetails& ListOrganizationsByUserResponse::orgs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return _internal_orgs(index);
}
inline ::viam::app::v1::OrgDetails* ListOrganizationsByUserResponse::_internal_add_orgs() {
  return orgs_.Add();
}
inline ::viam::app::v1::OrgDetails* ListOrganizationsByUserResponse::add_orgs() {
  ::viam::app::v1::OrgDetails* _add = _internal_add_orgs();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::OrgDetails >&
ListOrganizationsByUserResponse::orgs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationsByUserResponse.orgs)
  return orgs_;
}

// -------------------------------------------------------------------

// CreateKeyRequest

// repeated .viam.app.v1.Authorization authorizations = 1 [json_name = "authorizations"];
inline int CreateKeyRequest::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int CreateKeyRequest::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void CreateKeyRequest::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::Authorization* CreateKeyRequest::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyRequest.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >*
CreateKeyRequest::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CreateKeyRequest.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::Authorization& CreateKeyRequest::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::Authorization& CreateKeyRequest::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyRequest.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::Authorization* CreateKeyRequest::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::Authorization* CreateKeyRequest::add_authorizations() {
  ::viam::app::v1::Authorization* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.CreateKeyRequest.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Authorization >&
CreateKeyRequest::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CreateKeyRequest.authorizations)
  return authorizations_;
}

// string name = 2 [json_name = "name"];
inline void CreateKeyRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyRequest.name)
}
inline std::string* CreateKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyRequest.name)
  return _s;
}
inline const std::string& CreateKeyRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateKeyRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyRequest.name)
  return name_.Release();
}
inline void CreateKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyRequest.name)
}

// -------------------------------------------------------------------

// CreateKeyResponse

// string key = 1 [json_name = "key"];
inline void CreateKeyResponse::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& CreateKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyResponse.key)
}
inline std::string* CreateKeyResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyResponse.key)
  return _s;
}
inline const std::string& CreateKeyResponse::_internal_key() const {
  return key_.Get();
}
inline void CreateKeyResponse::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyResponse.key)
  return key_.Release();
}
inline void CreateKeyResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyResponse.key)
}

// string id = 2 [json_name = "id"];
inline void CreateKeyResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateKeyResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyResponse.id)
}
inline std::string* CreateKeyResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyResponse.id)
  return _s;
}
inline const std::string& CreateKeyResponse::_internal_id() const {
  return id_.Get();
}
inline void CreateKeyResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyResponse.id)
  return id_.Release();
}
inline void CreateKeyResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyResponse.id)
}

// -------------------------------------------------------------------

// DeleteKeyRequest

// string id = 1 [json_name = "id"];
inline void DeleteKeyRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteKeyRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteKeyRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteKeyRequest.id)
}
inline std::string* DeleteKeyRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteKeyRequest.id)
  return _s;
}
inline const std::string& DeleteKeyRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteKeyRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteKeyRequest.id)
  return id_.Release();
}
inline void DeleteKeyRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteKeyRequest.id)
}

// -------------------------------------------------------------------

// DeleteKeyResponse

// -------------------------------------------------------------------

// AuthorizationDetails

// string authorization_type = 1 [json_name = "authorizationType"];
inline void AuthorizationDetails::clear_authorization_type() {
  authorization_type_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::authorization_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.authorization_type)
  return _internal_authorization_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_authorization_type(ArgT0&& arg0, ArgT... args) {
 
 authorization_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.authorization_type)
}
inline std::string* AuthorizationDetails::mutable_authorization_type() {
  std::string* _s = _internal_mutable_authorization_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.authorization_type)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_authorization_type() const {
  return authorization_type_.Get();
}
inline void AuthorizationDetails::_internal_set_authorization_type(const std::string& value) {
  
  authorization_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_authorization_type() {
  
  return authorization_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_authorization_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.authorization_type)
  return authorization_type_.Release();
}
inline void AuthorizationDetails::set_allocated_authorization_type(std::string* authorization_type) {
  if (authorization_type != nullptr) {
    
  } else {
    
  }
  authorization_type_.SetAllocated(authorization_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_type_.IsDefault()) {
    authorization_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.authorization_type)
}

// string authorization_id = 2 [json_name = "authorizationId"];
inline void AuthorizationDetails::clear_authorization_id() {
  authorization_id_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::authorization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.authorization_id)
  return _internal_authorization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_authorization_id(ArgT0&& arg0, ArgT... args) {
 
 authorization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.authorization_id)
}
inline std::string* AuthorizationDetails::mutable_authorization_id() {
  std::string* _s = _internal_mutable_authorization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.authorization_id)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_authorization_id() const {
  return authorization_id_.Get();
}
inline void AuthorizationDetails::_internal_set_authorization_id(const std::string& value) {
  
  authorization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_authorization_id() {
  
  return authorization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_authorization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.authorization_id)
  return authorization_id_.Release();
}
inline void AuthorizationDetails::set_allocated_authorization_id(std::string* authorization_id) {
  if (authorization_id != nullptr) {
    
  } else {
    
  }
  authorization_id_.SetAllocated(authorization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (authorization_id_.IsDefault()) {
    authorization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.authorization_id)
}

// string resource_type = 3 [json_name = "resourceType"];
inline void AuthorizationDetails::clear_resource_type() {
  resource_type_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::resource_type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.resource_type)
}
inline std::string* AuthorizationDetails::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.resource_type)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_resource_type() const {
  return resource_type_.Get();
}
inline void AuthorizationDetails::_internal_set_resource_type(const std::string& value) {
  
  resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_resource_type() {
  
  return resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_resource_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.resource_type)
  return resource_type_.Release();
}
inline void AuthorizationDetails::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_type_.IsDefault()) {
    resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.resource_type)
}

// string resource_id = 4 [json_name = "resourceId"];
inline void AuthorizationDetails::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::resource_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.resource_id)
}
inline std::string* AuthorizationDetails::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.resource_id)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void AuthorizationDetails::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_resource_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.resource_id)
  return resource_id_.Release();
}
inline void AuthorizationDetails::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault()) {
    resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.resource_id)
}

// string org_id = 5 [json_name = "orgId"];
inline void AuthorizationDetails::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& AuthorizationDetails::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthorizationDetails.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationDetails::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthorizationDetails.org_id)
}
inline std::string* AuthorizationDetails::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthorizationDetails.org_id)
  return _s;
}
inline const std::string& AuthorizationDetails::_internal_org_id() const {
  return org_id_.Get();
}
inline void AuthorizationDetails::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationDetails::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthorizationDetails.org_id)
  return org_id_.Release();
}
inline void AuthorizationDetails::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthorizationDetails.org_id)
}

// -------------------------------------------------------------------

// APIKeyWithAuthorizations

// .viam.app.v1.APIKey api_key = 1 [json_name = "apiKey"];
inline bool APIKeyWithAuthorizations::_internal_has_api_key() const {
  return this != internal_default_instance() && api_key_ != nullptr;
}
inline bool APIKeyWithAuthorizations::has_api_key() const {
  return _internal_has_api_key();
}
inline void APIKeyWithAuthorizations::clear_api_key() {
  if (GetArenaForAllocation() == nullptr && api_key_ != nullptr) {
    delete api_key_;
  }
  api_key_ = nullptr;
}
inline const ::viam::app::v1::APIKey& APIKeyWithAuthorizations::_internal_api_key() const {
  const ::viam::app::v1::APIKey* p = api_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::APIKey&>(
      ::viam::app::v1::_APIKey_default_instance_);
}
inline const ::viam::app::v1::APIKey& APIKeyWithAuthorizations::api_key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKeyWithAuthorizations.api_key)
  return _internal_api_key();
}
inline void APIKeyWithAuthorizations::unsafe_arena_set_allocated_api_key(
    ::viam::app::v1::APIKey* api_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_key_);
  }
  api_key_ = api_key;
  if (api_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.APIKeyWithAuthorizations.api_key)
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::release_api_key() {
  
  ::viam::app::v1::APIKey* temp = api_key_;
  api_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::unsafe_arena_release_api_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.APIKeyWithAuthorizations.api_key)
  
  ::viam::app::v1::APIKey* temp = api_key_;
  api_key_ = nullptr;
  return temp;
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::_internal_mutable_api_key() {
  
  if (api_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::APIKey>(GetArenaForAllocation());
    api_key_ = p;
  }
  return api_key_;
}
inline ::viam::app::v1::APIKey* APIKeyWithAuthorizations::mutable_api_key() {
  ::viam::app::v1::APIKey* _msg = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKeyWithAuthorizations.api_key)
  return _msg;
}
inline void APIKeyWithAuthorizations::set_allocated_api_key(::viam::app::v1::APIKey* api_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete api_key_;
  }
  if (api_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(api_key);
    if (message_arena != submessage_arena) {
      api_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_key, submessage_arena);
    }
    
  } else {
    
  }
  api_key_ = api_key;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.APIKeyWithAuthorizations.api_key)
}

// repeated .viam.app.v1.AuthorizationDetails authorizations = 2 [json_name = "authorizations"];
inline int APIKeyWithAuthorizations::_internal_authorizations_size() const {
  return authorizations_.size();
}
inline int APIKeyWithAuthorizations::authorizations_size() const {
  return _internal_authorizations_size();
}
inline void APIKeyWithAuthorizations::clear_authorizations() {
  authorizations_.Clear();
}
inline ::viam::app::v1::AuthorizationDetails* APIKeyWithAuthorizations::mutable_authorizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return authorizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >*
APIKeyWithAuthorizations::mutable_authorizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return &authorizations_;
}
inline const ::viam::app::v1::AuthorizationDetails& APIKeyWithAuthorizations::_internal_authorizations(int index) const {
  return authorizations_.Get(index);
}
inline const ::viam::app::v1::AuthorizationDetails& APIKeyWithAuthorizations::authorizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return _internal_authorizations(index);
}
inline ::viam::app::v1::AuthorizationDetails* APIKeyWithAuthorizations::_internal_add_authorizations() {
  return authorizations_.Add();
}
inline ::viam::app::v1::AuthorizationDetails* APIKeyWithAuthorizations::add_authorizations() {
  ::viam::app::v1::AuthorizationDetails* _add = _internal_add_authorizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthorizationDetails >&
APIKeyWithAuthorizations::authorizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.APIKeyWithAuthorizations.authorizations)
  return authorizations_;
}

// -------------------------------------------------------------------

// ListKeysRequest

// string org_id = 1 [json_name = "orgId"];
inline void ListKeysRequest::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& ListKeysRequest::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListKeysRequest.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListKeysRequest::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListKeysRequest.org_id)
}
inline std::string* ListKeysRequest::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListKeysRequest.org_id)
  return _s;
}
inline const std::string& ListKeysRequest::_internal_org_id() const {
  return org_id_.Get();
}
inline void ListKeysRequest::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListKeysRequest::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListKeysRequest::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListKeysRequest.org_id)
  return org_id_.Release();
}
inline void ListKeysRequest::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListKeysRequest.org_id)
}

// -------------------------------------------------------------------

// ListKeysResponse

// repeated .viam.app.v1.APIKeyWithAuthorizations api_keys = 1 [json_name = "apiKeys"];
inline int ListKeysResponse::_internal_api_keys_size() const {
  return api_keys_.size();
}
inline int ListKeysResponse::api_keys_size() const {
  return _internal_api_keys_size();
}
inline void ListKeysResponse::clear_api_keys() {
  api_keys_.Clear();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* ListKeysResponse::mutable_api_keys(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListKeysResponse.api_keys)
  return api_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >*
ListKeysResponse::mutable_api_keys() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListKeysResponse.api_keys)
  return &api_keys_;
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& ListKeysResponse::_internal_api_keys(int index) const {
  return api_keys_.Get(index);
}
inline const ::viam::app::v1::APIKeyWithAuthorizations& ListKeysResponse::api_keys(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListKeysResponse.api_keys)
  return _internal_api_keys(index);
}
inline ::viam::app::v1::APIKeyWithAuthorizations* ListKeysResponse::_internal_add_api_keys() {
  return api_keys_.Add();
}
inline ::viam::app::v1::APIKeyWithAuthorizations* ListKeysResponse::add_api_keys() {
  ::viam::app::v1::APIKeyWithAuthorizations* _add = _internal_add_api_keys();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListKeysResponse.api_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::APIKeyWithAuthorizations >&
ListKeysResponse::api_keys() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListKeysResponse.api_keys)
  return api_keys_;
}

// -------------------------------------------------------------------

// RotateKeyRequest

// string id = 1 [json_name = "id"];
inline void RotateKeyRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RotateKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RotateKeyRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RotateKeyRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RotateKeyRequest.id)
}
inline std::string* RotateKeyRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RotateKeyRequest.id)
  return _s;
}
inline const std::string& RotateKeyRequest::_internal_id() const {
  return id_.Get();
}
inline void RotateKeyRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RotateKeyRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RotateKeyRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RotateKeyRequest.id)
  return id_.Release();
}
inline void RotateKeyRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RotateKeyRequest.id)
}

// -------------------------------------------------------------------

// RotateKeyResponse

// string id = 1 [json_name = "id"];
inline void RotateKeyResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RotateKeyResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RotateKeyResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RotateKeyResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RotateKeyResponse.id)
}
inline std::string* RotateKeyResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RotateKeyResponse.id)
  return _s;
}
inline const std::string& RotateKeyResponse::_internal_id() const {
  return id_.Get();
}
inline void RotateKeyResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RotateKeyResponse.id)
  return id_.Release();
}
inline void RotateKeyResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RotateKeyResponse.id)
}

// string key = 2 [json_name = "key"];
inline void RotateKeyResponse::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& RotateKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RotateKeyResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RotateKeyResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RotateKeyResponse.key)
}
inline std::string* RotateKeyResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RotateKeyResponse.key)
  return _s;
}
inline const std::string& RotateKeyResponse::_internal_key() const {
  return key_.Get();
}
inline void RotateKeyResponse::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* RotateKeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RotateKeyResponse.key)
  return key_.Release();
}
inline void RotateKeyResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RotateKeyResponse.key)
}

// -------------------------------------------------------------------

// CreateKeyFromExistingKeyAuthorizationsRequest

// string id = 1 [json_name = "id"];
inline void CreateKeyFromExistingKeyAuthorizationsRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyFromExistingKeyAuthorizationsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
  return _s;
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsRequest::_internal_id() const {
  return id_.Get();
}
inline void CreateKeyFromExistingKeyAuthorizationsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
  return id_.Release();
}
inline void CreateKeyFromExistingKeyAuthorizationsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsRequest.id)
}

// -------------------------------------------------------------------

// CreateKeyFromExistingKeyAuthorizationsResponse

// string id = 1 [json_name = "id"];
inline void CreateKeyFromExistingKeyAuthorizationsResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyFromExistingKeyAuthorizationsResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
  return _s;
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::_internal_id() const {
  return id_.Get();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
  return id_.Release();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.id)
}

// string key = 2 [json_name = "key"];
inline void CreateKeyFromExistingKeyAuthorizationsResponse::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyFromExistingKeyAuthorizationsResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
  return _s;
}
inline const std::string& CreateKeyFromExistingKeyAuthorizationsResponse::_internal_key() const {
  return key_.Get();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateKeyFromExistingKeyAuthorizationsResponse::release_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
  return key_.Release();
}
inline void CreateKeyFromExistingKeyAuthorizationsResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateKeyFromExistingKeyAuthorizationsResponse.key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::v1::SharedSecret_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::SharedSecret_State>() {
  return ::viam::app::v1::SharedSecret_State_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::RegistryItemStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::RegistryItemStatus>() {
  return ::viam::app::v1::RegistryItemStatus_descriptor();
}
template <> struct is_proto_enum< ::viam::app::v1::Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::Visibility>() {
  return ::viam::app::v1::Visibility_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto
