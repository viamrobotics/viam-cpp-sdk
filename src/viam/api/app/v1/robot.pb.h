// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/v1/robot.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2frobot_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2frobot_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common/v1/common.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/struct.pb.h"
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_app_2fv1_2frobot_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fv1_2frobot_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_app_2fv1_2frobot_2eproto;
namespace viam {
namespace app {
namespace v1 {
class AgentInfo;
struct AgentInfoDefaultTypeInternal;
extern AgentInfoDefaultTypeInternal _AgentInfo_default_instance_;
class AppValidationStatus;
struct AppValidationStatusDefaultTypeInternal;
extern AppValidationStatusDefaultTypeInternal _AppValidationStatus_default_instance_;
class AuthConfig;
struct AuthConfigDefaultTypeInternal;
extern AuthConfigDefaultTypeInternal _AuthConfig_default_instance_;
class AuthHandlerConfig;
struct AuthHandlerConfigDefaultTypeInternal;
extern AuthHandlerConfigDefaultTypeInternal _AuthHandlerConfig_default_instance_;
class CertificateRequest;
struct CertificateRequestDefaultTypeInternal;
extern CertificateRequestDefaultTypeInternal _CertificateRequest_default_instance_;
class CertificateResponse;
struct CertificateResponseDefaultTypeInternal;
extern CertificateResponseDefaultTypeInternal _CertificateResponse_default_instance_;
class CloudConfig;
struct CloudConfigDefaultTypeInternal;
extern CloudConfigDefaultTypeInternal _CloudConfig_default_instance_;
class ComponentConfig;
struct ComponentConfigDefaultTypeInternal;
extern ComponentConfigDefaultTypeInternal _ComponentConfig_default_instance_;
class ConfigRequest;
struct ConfigRequestDefaultTypeInternal;
extern ConfigRequestDefaultTypeInternal _ConfigRequest_default_instance_;
class ConfigResponse;
struct ConfigResponseDefaultTypeInternal;
extern ConfigResponseDefaultTypeInternal _ConfigResponse_default_instance_;
class ExternalAuthConfig;
struct ExternalAuthConfigDefaultTypeInternal;
extern ExternalAuthConfigDefaultTypeInternal _ExternalAuthConfig_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class JWKSFile;
struct JWKSFileDefaultTypeInternal;
extern JWKSFileDefaultTypeInternal _JWKSFile_default_instance_;
class LocationSecret;
struct LocationSecretDefaultTypeInternal;
extern LocationSecretDefaultTypeInternal _LocationSecret_default_instance_;
class LogConfiguration;
struct LogConfigurationDefaultTypeInternal;
extern LogConfigurationDefaultTypeInternal _LogConfiguration_default_instance_;
class LogRequest;
struct LogRequestDefaultTypeInternal;
extern LogRequestDefaultTypeInternal _LogRequest_default_instance_;
class LogResponse;
struct LogResponseDefaultTypeInternal;
extern LogResponseDefaultTypeInternal _LogResponse_default_instance_;
class ModuleConfig;
struct ModuleConfigDefaultTypeInternal;
extern ModuleConfigDefaultTypeInternal _ModuleConfig_default_instance_;
class ModuleConfig_EnvEntry_DoNotUse;
struct ModuleConfig_EnvEntry_DoNotUseDefaultTypeInternal;
extern ModuleConfig_EnvEntry_DoNotUseDefaultTypeInternal _ModuleConfig_EnvEntry_DoNotUse_default_instance_;
class NeedsRestartRequest;
struct NeedsRestartRequestDefaultTypeInternal;
extern NeedsRestartRequestDefaultTypeInternal _NeedsRestartRequest_default_instance_;
class NeedsRestartResponse;
struct NeedsRestartResponseDefaultTypeInternal;
extern NeedsRestartResponseDefaultTypeInternal _NeedsRestartResponse_default_instance_;
class NetworkConfig;
struct NetworkConfigDefaultTypeInternal;
extern NetworkConfigDefaultTypeInternal _NetworkConfig_default_instance_;
class Orientation;
struct OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class Orientation_AxisAngles;
struct Orientation_AxisAnglesDefaultTypeInternal;
extern Orientation_AxisAnglesDefaultTypeInternal _Orientation_AxisAngles_default_instance_;
class Orientation_EulerAngles;
struct Orientation_EulerAnglesDefaultTypeInternal;
extern Orientation_EulerAnglesDefaultTypeInternal _Orientation_EulerAngles_default_instance_;
class Orientation_NoOrientation;
struct Orientation_NoOrientationDefaultTypeInternal;
extern Orientation_NoOrientationDefaultTypeInternal _Orientation_NoOrientation_default_instance_;
class Orientation_OrientationVectorDegrees;
struct Orientation_OrientationVectorDegreesDefaultTypeInternal;
extern Orientation_OrientationVectorDegreesDefaultTypeInternal _Orientation_OrientationVectorDegrees_default_instance_;
class Orientation_OrientationVectorRadians;
struct Orientation_OrientationVectorRadiansDefaultTypeInternal;
extern Orientation_OrientationVectorRadiansDefaultTypeInternal _Orientation_OrientationVectorRadians_default_instance_;
class Orientation_Quaternion;
struct Orientation_QuaternionDefaultTypeInternal;
extern Orientation_QuaternionDefaultTypeInternal _Orientation_Quaternion_default_instance_;
class PackageConfig;
struct PackageConfigDefaultTypeInternal;
extern PackageConfigDefaultTypeInternal _PackageConfig_default_instance_;
class ProcessConfig;
struct ProcessConfigDefaultTypeInternal;
extern ProcessConfigDefaultTypeInternal _ProcessConfig_default_instance_;
class ProcessConfig_EnvEntry_DoNotUse;
struct ProcessConfig_EnvEntry_DoNotUseDefaultTypeInternal;
extern ProcessConfig_EnvEntry_DoNotUseDefaultTypeInternal _ProcessConfig_EnvEntry_DoNotUse_default_instance_;
class RemoteAuth;
struct RemoteAuthDefaultTypeInternal;
extern RemoteAuthDefaultTypeInternal _RemoteAuth_default_instance_;
class RemoteAuth_Credentials;
struct RemoteAuth_CredentialsDefaultTypeInternal;
extern RemoteAuth_CredentialsDefaultTypeInternal _RemoteAuth_Credentials_default_instance_;
class RemoteConfig;
struct RemoteConfigDefaultTypeInternal;
extern RemoteConfigDefaultTypeInternal _RemoteConfig_default_instance_;
class ResourceLevelServiceConfig;
struct ResourceLevelServiceConfigDefaultTypeInternal;
extern ResourceLevelServiceConfigDefaultTypeInternal _ResourceLevelServiceConfig_default_instance_;
class RobotConfig;
struct RobotConfigDefaultTypeInternal;
extern RobotConfigDefaultTypeInternal _RobotConfig_default_instance_;
class ServiceConfig;
struct ServiceConfigDefaultTypeInternal;
extern ServiceConfigDefaultTypeInternal _ServiceConfig_default_instance_;
class SessionsConfig;
struct SessionsConfigDefaultTypeInternal;
extern SessionsConfigDefaultTypeInternal _SessionsConfig_default_instance_;
class Translation;
struct TranslationDefaultTypeInternal;
extern TranslationDefaultTypeInternal _Translation_default_instance_;
}  // namespace v1
}  // namespace app
}  // namespace viam
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace viam {
namespace app {
namespace v1 {
enum CredentialsType : int {
  CREDENTIALS_TYPE_UNSPECIFIED = 0,
  CREDENTIALS_TYPE_INTERNAL = 1,
  CREDENTIALS_TYPE_API_KEY = 2,
  CREDENTIALS_TYPE_ROBOT_SECRET = 3,
  CREDENTIALS_TYPE_ROBOT_LOCATION_SECRET = 4,
  CredentialsType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CredentialsType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CredentialsType_IsValid(int value);
extern const uint32_t CredentialsType_internal_data_[];
constexpr CredentialsType CredentialsType_MIN = static_cast<CredentialsType>(0);
constexpr CredentialsType CredentialsType_MAX = static_cast<CredentialsType>(4);
constexpr int CredentialsType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
CredentialsType_descriptor();
template <typename T>
const std::string& CredentialsType_Name(T value) {
  static_assert(std::is_same<T, CredentialsType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CredentialsType_Name().");
  return CredentialsType_Name(static_cast<CredentialsType>(value));
}
template <>
inline const std::string& CredentialsType_Name(CredentialsType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CredentialsType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool CredentialsType_Parse(absl::string_view name, CredentialsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CredentialsType>(
      CredentialsType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Translation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Translation) */ {
 public:
  inline Translation() : Translation(nullptr) {}
  ~Translation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Translation(::google::protobuf::internal::ConstantInitialized);

  inline Translation(const Translation& from)
      : Translation(nullptr, from) {}
  Translation(Translation&& from) noexcept
    : Translation() {
    *this = ::std::move(from);
  }

  inline Translation& operator=(const Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Translation& operator=(Translation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Translation* internal_default_instance() {
    return reinterpret_cast<const Translation*>(
               &_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Translation& a, Translation& b) {
    a.Swap(&b);
  }
  inline void Swap(Translation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Translation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Translation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Translation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Translation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Translation& from) {
    Translation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Translation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Translation";
  }
  protected:
  explicit Translation(::google::protobuf::Arena* arena);
  Translation(::google::protobuf::Arena* arena, const Translation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1 [json_name = "x"];
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2 [json_name = "y"];
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3 [json_name = "z"];
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.Translation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class RemoteAuth_Credentials final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoteAuth.Credentials) */ {
 public:
  inline RemoteAuth_Credentials() : RemoteAuth_Credentials(nullptr) {}
  ~RemoteAuth_Credentials() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteAuth_Credentials(::google::protobuf::internal::ConstantInitialized);

  inline RemoteAuth_Credentials(const RemoteAuth_Credentials& from)
      : RemoteAuth_Credentials(nullptr, from) {}
  RemoteAuth_Credentials(RemoteAuth_Credentials&& from) noexcept
    : RemoteAuth_Credentials() {
    *this = ::std::move(from);
  }

  inline RemoteAuth_Credentials& operator=(const RemoteAuth_Credentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteAuth_Credentials& operator=(RemoteAuth_Credentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteAuth_Credentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteAuth_Credentials* internal_default_instance() {
    return reinterpret_cast<const RemoteAuth_Credentials*>(
               &_RemoteAuth_Credentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RemoteAuth_Credentials& a, RemoteAuth_Credentials& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteAuth_Credentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteAuth_Credentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteAuth_Credentials* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteAuth_Credentials>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteAuth_Credentials& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RemoteAuth_Credentials& from) {
    RemoteAuth_Credentials::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemoteAuth_Credentials* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.RemoteAuth.Credentials";
  }
  protected:
  explicit RemoteAuth_Credentials(::google::protobuf::Arena* arena);
  RemoteAuth_Credentials(::google::protobuf::Arena* arena, const RemoteAuth_Credentials& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string payload = 2 [json_name = "payload"];
  void clear_payload() ;
  const std::string& payload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* value);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
  void clear_type() ;
  ::viam::app::v1::CredentialsType type() const;
  void set_type(::viam::app::v1::CredentialsType value);

  private:
  ::viam::app::v1::CredentialsType _internal_type() const;
  void _internal_set_type(::viam::app::v1::CredentialsType value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoteAuth.Credentials)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr payload_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ProcessConfig_EnvEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ProcessConfig_EnvEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ProcessConfig_EnvEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ProcessConfig_EnvEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessConfig_EnvEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ProcessConfig_EnvEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ProcessConfig_EnvEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ProcessConfig_EnvEntry_DoNotUse*>(
        &_ProcessConfig_EnvEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "viam.app.v1.ProcessConfig.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "viam.app.v1.ProcessConfig.EnvEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation_Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.Quaternion) */ {
 public:
  inline Orientation_Quaternion() : Orientation_Quaternion(nullptr) {}
  ~Orientation_Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation_Quaternion(::google::protobuf::internal::ConstantInitialized);

  inline Orientation_Quaternion(const Orientation_Quaternion& from)
      : Orientation_Quaternion(nullptr, from) {}
  Orientation_Quaternion(Orientation_Quaternion&& from) noexcept
    : Orientation_Quaternion() {
    *this = ::std::move(from);
  }

  inline Orientation_Quaternion& operator=(const Orientation_Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_Quaternion& operator=(Orientation_Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_Quaternion* internal_default_instance() {
    return reinterpret_cast<const Orientation_Quaternion*>(
               &_Orientation_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Orientation_Quaternion& a, Orientation_Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_Quaternion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation_Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Orientation_Quaternion& from) {
    Orientation_Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Orientation_Quaternion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Orientation.Quaternion";
  }
  protected:
  explicit Orientation_Quaternion(::google::protobuf::Arena* arena);
  Orientation_Quaternion(::google::protobuf::Arena* arena, const Orientation_Quaternion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double w = 1 [json_name = "w"];
  void clear_w() ;
  double w() const;
  void set_w(double value);

  private:
  double _internal_w() const;
  void _internal_set_w(double value);

  public:
  // double x = 2 [json_name = "x"];
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 3 [json_name = "y"];
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 4 [json_name = "z"];
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.Quaternion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double w_;
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class Orientation_OrientationVectorRadians final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.OrientationVectorRadians) */ {
 public:
  inline Orientation_OrientationVectorRadians() : Orientation_OrientationVectorRadians(nullptr) {}
  ~Orientation_OrientationVectorRadians() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation_OrientationVectorRadians(::google::protobuf::internal::ConstantInitialized);

  inline Orientation_OrientationVectorRadians(const Orientation_OrientationVectorRadians& from)
      : Orientation_OrientationVectorRadians(nullptr, from) {}
  Orientation_OrientationVectorRadians(Orientation_OrientationVectorRadians&& from) noexcept
    : Orientation_OrientationVectorRadians() {
    *this = ::std::move(from);
  }

  inline Orientation_OrientationVectorRadians& operator=(const Orientation_OrientationVectorRadians& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_OrientationVectorRadians& operator=(Orientation_OrientationVectorRadians&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_OrientationVectorRadians& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_OrientationVectorRadians* internal_default_instance() {
    return reinterpret_cast<const Orientation_OrientationVectorRadians*>(
               &_Orientation_OrientationVectorRadians_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Orientation_OrientationVectorRadians& a, Orientation_OrientationVectorRadians& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_OrientationVectorRadians* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_OrientationVectorRadians* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_OrientationVectorRadians* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_OrientationVectorRadians>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation_OrientationVectorRadians& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Orientation_OrientationVectorRadians& from) {
    Orientation_OrientationVectorRadians::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Orientation_OrientationVectorRadians* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Orientation.OrientationVectorRadians";
  }
  protected:
  explicit Orientation_OrientationVectorRadians(::google::protobuf::Arena* arena);
  Orientation_OrientationVectorRadians(::google::protobuf::Arena* arena, const Orientation_OrientationVectorRadians& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThetaFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
  void clear_theta() ;
  double theta() const;
  void set_theta(double value);

  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);

  public:
  // double x = 2 [json_name = "x"];
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 3 [json_name = "y"];
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 4 [json_name = "z"];
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.OrientationVectorRadians)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double theta_;
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class Orientation_OrientationVectorDegrees final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.OrientationVectorDegrees) */ {
 public:
  inline Orientation_OrientationVectorDegrees() : Orientation_OrientationVectorDegrees(nullptr) {}
  ~Orientation_OrientationVectorDegrees() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation_OrientationVectorDegrees(::google::protobuf::internal::ConstantInitialized);

  inline Orientation_OrientationVectorDegrees(const Orientation_OrientationVectorDegrees& from)
      : Orientation_OrientationVectorDegrees(nullptr, from) {}
  Orientation_OrientationVectorDegrees(Orientation_OrientationVectorDegrees&& from) noexcept
    : Orientation_OrientationVectorDegrees() {
    *this = ::std::move(from);
  }

  inline Orientation_OrientationVectorDegrees& operator=(const Orientation_OrientationVectorDegrees& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_OrientationVectorDegrees& operator=(Orientation_OrientationVectorDegrees&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_OrientationVectorDegrees& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_OrientationVectorDegrees* internal_default_instance() {
    return reinterpret_cast<const Orientation_OrientationVectorDegrees*>(
               &_Orientation_OrientationVectorDegrees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Orientation_OrientationVectorDegrees& a, Orientation_OrientationVectorDegrees& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_OrientationVectorDegrees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_OrientationVectorDegrees* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_OrientationVectorDegrees* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_OrientationVectorDegrees>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation_OrientationVectorDegrees& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Orientation_OrientationVectorDegrees& from) {
    Orientation_OrientationVectorDegrees::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Orientation_OrientationVectorDegrees* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Orientation.OrientationVectorDegrees";
  }
  protected:
  explicit Orientation_OrientationVectorDegrees(::google::protobuf::Arena* arena);
  Orientation_OrientationVectorDegrees(::google::protobuf::Arena* arena, const Orientation_OrientationVectorDegrees& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThetaFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
  void clear_theta() ;
  double theta() const;
  void set_theta(double value);

  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);

  public:
  // double x = 2 [json_name = "x"];
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 3 [json_name = "y"];
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 4 [json_name = "z"];
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.OrientationVectorDegrees)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double theta_;
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class Orientation_NoOrientation final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.NoOrientation) */ {
 public:
  inline Orientation_NoOrientation() : Orientation_NoOrientation(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation_NoOrientation(::google::protobuf::internal::ConstantInitialized);

  inline Orientation_NoOrientation(const Orientation_NoOrientation& from)
      : Orientation_NoOrientation(nullptr, from) {}
  Orientation_NoOrientation(Orientation_NoOrientation&& from) noexcept
    : Orientation_NoOrientation() {
    *this = ::std::move(from);
  }

  inline Orientation_NoOrientation& operator=(const Orientation_NoOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_NoOrientation& operator=(Orientation_NoOrientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_NoOrientation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_NoOrientation* internal_default_instance() {
    return reinterpret_cast<const Orientation_NoOrientation*>(
               &_Orientation_NoOrientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Orientation_NoOrientation& a, Orientation_NoOrientation& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_NoOrientation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_NoOrientation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_NoOrientation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_NoOrientation>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Orientation_NoOrientation& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Orientation_NoOrientation& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Orientation.NoOrientation";
  }
  protected:
  explicit Orientation_NoOrientation(::google::protobuf::Arena* arena);
  Orientation_NoOrientation(::google::protobuf::Arena* arena, const Orientation_NoOrientation& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.NoOrientation)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class Orientation_EulerAngles final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.EulerAngles) */ {
 public:
  inline Orientation_EulerAngles() : Orientation_EulerAngles(nullptr) {}
  ~Orientation_EulerAngles() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation_EulerAngles(::google::protobuf::internal::ConstantInitialized);

  inline Orientation_EulerAngles(const Orientation_EulerAngles& from)
      : Orientation_EulerAngles(nullptr, from) {}
  Orientation_EulerAngles(Orientation_EulerAngles&& from) noexcept
    : Orientation_EulerAngles() {
    *this = ::std::move(from);
  }

  inline Orientation_EulerAngles& operator=(const Orientation_EulerAngles& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_EulerAngles& operator=(Orientation_EulerAngles&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_EulerAngles& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_EulerAngles* internal_default_instance() {
    return reinterpret_cast<const Orientation_EulerAngles*>(
               &_Orientation_EulerAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Orientation_EulerAngles& a, Orientation_EulerAngles& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_EulerAngles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_EulerAngles* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_EulerAngles* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_EulerAngles>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation_EulerAngles& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Orientation_EulerAngles& from) {
    Orientation_EulerAngles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Orientation_EulerAngles* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Orientation.EulerAngles";
  }
  protected:
  explicit Orientation_EulerAngles(::google::protobuf::Arena* arena);
  Orientation_EulerAngles(::google::protobuf::Arena* arena, const Orientation_EulerAngles& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollFieldNumber = 1,
    kPitchFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // double roll = 1 [json_name = "roll"];
  void clear_roll() ;
  double roll() const;
  void set_roll(double value);

  private:
  double _internal_roll() const;
  void _internal_set_roll(double value);

  public:
  // double pitch = 2 [json_name = "pitch"];
  void clear_pitch() ;
  double pitch() const;
  void set_pitch(double value);

  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);

  public:
  // double yaw = 3 [json_name = "yaw"];
  void clear_yaw() ;
  double yaw() const;
  void set_yaw(double value);

  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.EulerAngles)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double roll_;
    double pitch_;
    double yaw_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class Orientation_AxisAngles final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.AxisAngles) */ {
 public:
  inline Orientation_AxisAngles() : Orientation_AxisAngles(nullptr) {}
  ~Orientation_AxisAngles() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation_AxisAngles(::google::protobuf::internal::ConstantInitialized);

  inline Orientation_AxisAngles(const Orientation_AxisAngles& from)
      : Orientation_AxisAngles(nullptr, from) {}
  Orientation_AxisAngles(Orientation_AxisAngles&& from) noexcept
    : Orientation_AxisAngles() {
    *this = ::std::move(from);
  }

  inline Orientation_AxisAngles& operator=(const Orientation_AxisAngles& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_AxisAngles& operator=(Orientation_AxisAngles&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_AxisAngles& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_AxisAngles* internal_default_instance() {
    return reinterpret_cast<const Orientation_AxisAngles*>(
               &_Orientation_AxisAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Orientation_AxisAngles& a, Orientation_AxisAngles& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_AxisAngles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_AxisAngles* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_AxisAngles* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_AxisAngles>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation_AxisAngles& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Orientation_AxisAngles& from) {
    Orientation_AxisAngles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Orientation_AxisAngles* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Orientation.AxisAngles";
  }
  protected:
  explicit Orientation_AxisAngles(::google::protobuf::Arena* arena);
  Orientation_AxisAngles(::google::protobuf::Arena* arena, const Orientation_AxisAngles& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThetaFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
  void clear_theta() ;
  double theta() const;
  void set_theta(double value);

  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);

  public:
  // double x = 2 [json_name = "x"];
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 3 [json_name = "y"];
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 4 [json_name = "z"];
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.AxisAngles)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double theta_;
    double x_;
    double y_;
    double z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class NeedsRestartRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NeedsRestartRequest) */ {
 public:
  inline NeedsRestartRequest() : NeedsRestartRequest(nullptr) {}
  ~NeedsRestartRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NeedsRestartRequest(::google::protobuf::internal::ConstantInitialized);

  inline NeedsRestartRequest(const NeedsRestartRequest& from)
      : NeedsRestartRequest(nullptr, from) {}
  NeedsRestartRequest(NeedsRestartRequest&& from) noexcept
    : NeedsRestartRequest() {
    *this = ::std::move(from);
  }

  inline NeedsRestartRequest& operator=(const NeedsRestartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeedsRestartRequest& operator=(NeedsRestartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeedsRestartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeedsRestartRequest* internal_default_instance() {
    return reinterpret_cast<const NeedsRestartRequest*>(
               &_NeedsRestartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(NeedsRestartRequest& a, NeedsRestartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NeedsRestartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeedsRestartRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeedsRestartRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeedsRestartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NeedsRestartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NeedsRestartRequest& from) {
    NeedsRestartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NeedsRestartRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.NeedsRestartRequest";
  }
  protected:
  explicit NeedsRestartRequest(::google::protobuf::Arena* arena);
  NeedsRestartRequest(::google::protobuf::Arena* arena, const NeedsRestartRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.NeedsRestartRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ModuleConfig_EnvEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ModuleConfig_EnvEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ModuleConfig_EnvEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModuleConfig_EnvEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModuleConfig_EnvEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModuleConfig_EnvEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModuleConfig_EnvEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_EnvEntry_DoNotUse*>(
        &_ModuleConfig_EnvEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "viam.app.v1.ModuleConfig.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "viam.app.v1.ModuleConfig.EnvEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class LogResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.LogResponse) */ {
 public:
  inline LogResponse() : LogResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LogResponse(::google::protobuf::internal::ConstantInitialized);

  inline LogResponse(const LogResponse& from)
      : LogResponse(nullptr, from) {}
  LogResponse(LogResponse&& from) noexcept
    : LogResponse() {
    *this = ::std::move(from);
  }

  inline LogResponse& operator=(const LogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogResponse& operator=(LogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogResponse* internal_default_instance() {
    return reinterpret_cast<const LogResponse*>(
               &_LogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(LogResponse& a, LogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LogResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LogResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.LogResponse";
  }
  protected:
  explicit LogResponse(::google::protobuf::Arena* arena);
  LogResponse(::google::protobuf::Arena* arena, const LogResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.LogResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class LogConfiguration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LogConfiguration) */ {
 public:
  inline LogConfiguration() : LogConfiguration(nullptr) {}
  ~LogConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LogConfiguration(::google::protobuf::internal::ConstantInitialized);

  inline LogConfiguration(const LogConfiguration& from)
      : LogConfiguration(nullptr, from) {}
  LogConfiguration(LogConfiguration&& from) noexcept
    : LogConfiguration() {
    *this = ::std::move(from);
  }

  inline LogConfiguration& operator=(const LogConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogConfiguration& operator=(LogConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogConfiguration* internal_default_instance() {
    return reinterpret_cast<const LogConfiguration*>(
               &_LogConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LogConfiguration& a, LogConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(LogConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogConfiguration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LogConfiguration& from) {
    LogConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LogConfiguration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.LogConfiguration";
  }
  protected:
  explicit LogConfiguration(::google::protobuf::Arena* arena);
  LogConfiguration(::google::protobuf::Arena* arena, const LogConfiguration& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // string level = 1 [json_name = "level"];
  void clear_level() ;
  const std::string& level() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_level(Arg_&& arg, Args_... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* value);

  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(
      const std::string& value);
  std::string* _internal_mutable_level();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.LogConfiguration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr level_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class LocationSecret final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationSecret) */ {
 public:
  inline LocationSecret() : LocationSecret(nullptr) {}
  ~LocationSecret() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LocationSecret(::google::protobuf::internal::ConstantInitialized);

  inline LocationSecret(const LocationSecret& from)
      : LocationSecret(nullptr, from) {}
  LocationSecret(LocationSecret&& from) noexcept
    : LocationSecret() {
    *this = ::std::move(from);
  }

  inline LocationSecret& operator=(const LocationSecret& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationSecret& operator=(LocationSecret&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationSecret& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationSecret* internal_default_instance() {
    return reinterpret_cast<const LocationSecret*>(
               &_LocationSecret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LocationSecret& a, LocationSecret& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationSecret* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationSecret* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationSecret* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationSecret>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocationSecret& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LocationSecret& from) {
    LocationSecret::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LocationSecret* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.LocationSecret";
  }
  protected:
  explicit LocationSecret(::google::protobuf::Arena* arena);
  LocationSecret(::google::protobuf::Arena* arena, const LocationSecret& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSecretFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string secret = 2 [json_name = "secret"];
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationSecret)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class CertificateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CertificateResponse) */ {
 public:
  inline CertificateResponse() : CertificateResponse(nullptr) {}
  ~CertificateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CertificateResponse(::google::protobuf::internal::ConstantInitialized);

  inline CertificateResponse(const CertificateResponse& from)
      : CertificateResponse(nullptr, from) {}
  CertificateResponse(CertificateResponse&& from) noexcept
    : CertificateResponse() {
    *this = ::std::move(from);
  }

  inline CertificateResponse& operator=(const CertificateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateResponse& operator=(CertificateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateResponse* internal_default_instance() {
    return reinterpret_cast<const CertificateResponse*>(
               &_CertificateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CertificateResponse& a, CertificateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CertificateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CertificateResponse& from) {
    CertificateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CertificateResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.CertificateResponse";
  }
  protected:
  explicit CertificateResponse(::google::protobuf::Arena* arena);
  CertificateResponse(::google::protobuf::Arena* arena, const CertificateResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTlsCertificateFieldNumber = 2,
    kTlsPrivateKeyFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string tls_certificate = 2 [json_name = "tlsCertificate"];
  void clear_tls_certificate() ;
  const std::string& tls_certificate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tls_certificate(Arg_&& arg, Args_... args);
  std::string* mutable_tls_certificate();
  PROTOBUF_NODISCARD std::string* release_tls_certificate();
  void set_allocated_tls_certificate(std::string* value);

  private:
  const std::string& _internal_tls_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_certificate(
      const std::string& value);
  std::string* _internal_mutable_tls_certificate();

  public:
  // string tls_private_key = 3 [json_name = "tlsPrivateKey"];
  void clear_tls_private_key() ;
  const std::string& tls_private_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tls_private_key(Arg_&& arg, Args_... args);
  std::string* mutable_tls_private_key();
  PROTOBUF_NODISCARD std::string* release_tls_private_key();
  void set_allocated_tls_private_key(std::string* value);

  private:
  const std::string& _internal_tls_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_private_key(
      const std::string& value);
  std::string* _internal_mutable_tls_private_key();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.CertificateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      72, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr tls_certificate_;
    ::google::protobuf::internal::ArenaStringPtr tls_private_key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class CertificateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CertificateRequest) */ {
 public:
  inline CertificateRequest() : CertificateRequest(nullptr) {}
  ~CertificateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CertificateRequest(::google::protobuf::internal::ConstantInitialized);

  inline CertificateRequest(const CertificateRequest& from)
      : CertificateRequest(nullptr, from) {}
  CertificateRequest(CertificateRequest&& from) noexcept
    : CertificateRequest() {
    *this = ::std::move(from);
  }

  inline CertificateRequest& operator=(const CertificateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateRequest& operator=(CertificateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateRequest* internal_default_instance() {
    return reinterpret_cast<const CertificateRequest*>(
               &_CertificateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CertificateRequest& a, CertificateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CertificateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CertificateRequest& from) {
    CertificateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CertificateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.CertificateRequest";
  }
  protected:
  explicit CertificateRequest(::google::protobuf::Arena* arena);
  CertificateRequest(::google::protobuf::Arena* arena, const CertificateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.CertificateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class AppValidationStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AppValidationStatus) */ {
 public:
  inline AppValidationStatus() : AppValidationStatus(nullptr) {}
  ~AppValidationStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AppValidationStatus(::google::protobuf::internal::ConstantInitialized);

  inline AppValidationStatus(const AppValidationStatus& from)
      : AppValidationStatus(nullptr, from) {}
  AppValidationStatus(AppValidationStatus&& from) noexcept
    : AppValidationStatus() {
    *this = ::std::move(from);
  }

  inline AppValidationStatus& operator=(const AppValidationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppValidationStatus& operator=(AppValidationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppValidationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppValidationStatus* internal_default_instance() {
    return reinterpret_cast<const AppValidationStatus*>(
               &_AppValidationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AppValidationStatus& a, AppValidationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(AppValidationStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppValidationStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppValidationStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppValidationStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AppValidationStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AppValidationStatus& from) {
    AppValidationStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AppValidationStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.AppValidationStatus";
  }
  protected:
  explicit AppValidationStatus(::google::protobuf::Arena* arena);
  AppValidationStatus(::google::protobuf::Arena* arena, const AppValidationStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1 [json_name = "error"];
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.AppValidationStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class AgentInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AgentInfo) */ {
 public:
  inline AgentInfo() : AgentInfo(nullptr) {}
  ~AgentInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AgentInfo(::google::protobuf::internal::ConstantInitialized);

  inline AgentInfo(const AgentInfo& from)
      : AgentInfo(nullptr, from) {}
  AgentInfo(AgentInfo&& from) noexcept
    : AgentInfo() {
    *this = ::std::move(from);
  }

  inline AgentInfo& operator=(const AgentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentInfo& operator=(AgentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentInfo* internal_default_instance() {
    return reinterpret_cast<const AgentInfo*>(
               &_AgentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AgentInfo& a, AgentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AgentInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AgentInfo& from) {
    AgentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AgentInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.AgentInfo";
  }
  protected:
  explicit AgentInfo(::google::protobuf::Arena* arena);
  AgentInfo(::google::protobuf::Arena* arena, const AgentInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsFieldNumber = 3,
    kHostFieldNumber = 1,
    kOsFieldNumber = 2,
    kVersionFieldNumber = 4,
    kGitRevisionFieldNumber = 5,
    kPlatformFieldNumber = 6,
  };
  // repeated string ips = 3 [json_name = "ips"];
  int ips_size() const;
  private:
  int _internal_ips_size() const;

  public:
  void clear_ips() ;
  const std::string& ips(int index) const;
  std::string* mutable_ips(int index);
  void set_ips(int index, const std::string& value);
  void set_ips(int index, std::string&& value);
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, std::size_t size);
  void set_ips(int index, absl::string_view value);
  std::string* add_ips();
  void add_ips(const std::string& value);
  void add_ips(std::string&& value);
  void add_ips(const char* value);
  void add_ips(const char* value, std::size_t size);
  void add_ips(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& ips() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_ips();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_ips() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_ips();

  public:
  // string host = 1 [json_name = "host"];
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // string os = 2 [json_name = "os"];
  void clear_os() ;
  const std::string& os() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_os(Arg_&& arg, Args_... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* value);

  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(
      const std::string& value);
  std::string* _internal_mutable_os();

  public:
  // string version = 4 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string git_revision = 5 [json_name = "gitRevision"];
  void clear_git_revision() ;
  const std::string& git_revision() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_git_revision(Arg_&& arg, Args_... args);
  std::string* mutable_git_revision();
  PROTOBUF_NODISCARD std::string* release_git_revision();
  void set_allocated_git_revision(std::string* value);

  private:
  const std::string& _internal_git_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_git_revision(
      const std::string& value);
  std::string* _internal_mutable_git_revision();

  public:
  // optional string platform = 6 [json_name = "platform"];
  bool has_platform() const;
  void clear_platform() ;
  const std::string& platform() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform(Arg_&& arg, Args_... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* value);

  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(
      const std::string& value);
  std::string* _internal_mutable_platform();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.AgentInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> ips_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::google::protobuf::internal::ArenaStringPtr os_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr git_revision_;
    ::google::protobuf::internal::ArenaStringPtr platform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class SessionsConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SessionsConfig) */ {
 public:
  inline SessionsConfig() : SessionsConfig(nullptr) {}
  ~SessionsConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SessionsConfig(::google::protobuf::internal::ConstantInitialized);

  inline SessionsConfig(const SessionsConfig& from)
      : SessionsConfig(nullptr, from) {}
  SessionsConfig(SessionsConfig&& from) noexcept
    : SessionsConfig() {
    *this = ::std::move(from);
  }

  inline SessionsConfig& operator=(const SessionsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionsConfig& operator=(SessionsConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionsConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionsConfig* internal_default_instance() {
    return reinterpret_cast<const SessionsConfig*>(
               &_SessionsConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SessionsConfig& a, SessionsConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionsConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionsConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionsConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionsConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionsConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SessionsConfig& from) {
    SessionsConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionsConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.SessionsConfig";
  }
  protected:
  explicit SessionsConfig(::google::protobuf::Arena* arena);
  SessionsConfig(::google::protobuf::Arena* arena, const SessionsConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatWindowFieldNumber = 1,
  };
  // .google.protobuf.Duration heartbeat_window = 1 [json_name = "heartbeatWindow"];
  bool has_heartbeat_window() const;
  void clear_heartbeat_window() ;
  const ::google::protobuf::Duration& heartbeat_window() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_heartbeat_window();
  ::google::protobuf::Duration* mutable_heartbeat_window();
  void set_allocated_heartbeat_window(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_heartbeat_window(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_heartbeat_window();

  private:
  const ::google::protobuf::Duration& _internal_heartbeat_window() const;
  ::google::protobuf::Duration* _internal_mutable_heartbeat_window();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.SessionsConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Duration* heartbeat_window_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ResourceLevelServiceConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ResourceLevelServiceConfig) */ {
 public:
  inline ResourceLevelServiceConfig() : ResourceLevelServiceConfig(nullptr) {}
  ~ResourceLevelServiceConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResourceLevelServiceConfig(::google::protobuf::internal::ConstantInitialized);

  inline ResourceLevelServiceConfig(const ResourceLevelServiceConfig& from)
      : ResourceLevelServiceConfig(nullptr, from) {}
  ResourceLevelServiceConfig(ResourceLevelServiceConfig&& from) noexcept
    : ResourceLevelServiceConfig() {
    *this = ::std::move(from);
  }

  inline ResourceLevelServiceConfig& operator=(const ResourceLevelServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceLevelServiceConfig& operator=(ResourceLevelServiceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceLevelServiceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceLevelServiceConfig* internal_default_instance() {
    return reinterpret_cast<const ResourceLevelServiceConfig*>(
               &_ResourceLevelServiceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResourceLevelServiceConfig& a, ResourceLevelServiceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceLevelServiceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceLevelServiceConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceLevelServiceConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceLevelServiceConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResourceLevelServiceConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ResourceLevelServiceConfig& from) {
    ResourceLevelServiceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResourceLevelServiceConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ResourceLevelServiceConfig";
  }
  protected:
  explicit ResourceLevelServiceConfig(::google::protobuf::Arena* arena);
  ResourceLevelServiceConfig(::google::protobuf::Arena* arena, const ResourceLevelServiceConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // .google.protobuf.Struct attributes = 2 [json_name = "attributes"];
  bool has_attributes() const;
  void clear_attributes() ;
  const ::google::protobuf::Struct& attributes() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_attributes();
  ::google::protobuf::Struct* mutable_attributes();
  void set_allocated_attributes(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_attributes(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_attributes();

  private:
  const ::google::protobuf::Struct& _internal_attributes() const;
  ::google::protobuf::Struct* _internal_mutable_attributes();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ResourceLevelServiceConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::Struct* attributes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class RemoteAuth final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoteAuth) */ {
 public:
  inline RemoteAuth() : RemoteAuth(nullptr) {}
  ~RemoteAuth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteAuth(::google::protobuf::internal::ConstantInitialized);

  inline RemoteAuth(const RemoteAuth& from)
      : RemoteAuth(nullptr, from) {}
  RemoteAuth(RemoteAuth&& from) noexcept
    : RemoteAuth() {
    *this = ::std::move(from);
  }

  inline RemoteAuth& operator=(const RemoteAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteAuth& operator=(RemoteAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteAuth* internal_default_instance() {
    return reinterpret_cast<const RemoteAuth*>(
               &_RemoteAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RemoteAuth& a, RemoteAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteAuth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteAuth* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteAuth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteAuth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RemoteAuth& from) {
    RemoteAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemoteAuth* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.RemoteAuth";
  }
  protected:
  explicit RemoteAuth(::google::protobuf::Arena* arena);
  RemoteAuth(::google::protobuf::Arena* arena, const RemoteAuth& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Credentials = RemoteAuth_Credentials;

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 2,
    kCredentialsFieldNumber = 1,
  };
  // string entity = 2 [json_name = "entity"];
  void clear_entity() ;
  const std::string& entity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity(Arg_&& arg, Args_... args);
  std::string* mutable_entity();
  PROTOBUF_NODISCARD std::string* release_entity();
  void set_allocated_entity(std::string* value);

  private:
  const std::string& _internal_entity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity(
      const std::string& value);
  std::string* _internal_mutable_entity();

  public:
  // .viam.app.v1.RemoteAuth.Credentials credentials = 1 [json_name = "credentials"];
  bool has_credentials() const;
  void clear_credentials() ;
  const ::viam::app::v1::RemoteAuth_Credentials& credentials() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RemoteAuth_Credentials* release_credentials();
  ::viam::app::v1::RemoteAuth_Credentials* mutable_credentials();
  void set_allocated_credentials(::viam::app::v1::RemoteAuth_Credentials* value);
  void unsafe_arena_set_allocated_credentials(::viam::app::v1::RemoteAuth_Credentials* value);
  ::viam::app::v1::RemoteAuth_Credentials* unsafe_arena_release_credentials();

  private:
  const ::viam::app::v1::RemoteAuth_Credentials& _internal_credentials() const;
  ::viam::app::v1::RemoteAuth_Credentials* _internal_mutable_credentials();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoteAuth)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_;
    ::viam::app::v1::RemoteAuth_Credentials* credentials_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ProcessConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ProcessConfig) */ {
 public:
  inline ProcessConfig() : ProcessConfig(nullptr) {}
  ~ProcessConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessConfig(::google::protobuf::internal::ConstantInitialized);

  inline ProcessConfig(const ProcessConfig& from)
      : ProcessConfig(nullptr, from) {}
  ProcessConfig(ProcessConfig&& from) noexcept
    : ProcessConfig() {
    *this = ::std::move(from);
  }

  inline ProcessConfig& operator=(const ProcessConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessConfig& operator=(ProcessConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessConfig* internal_default_instance() {
    return reinterpret_cast<const ProcessConfig*>(
               &_ProcessConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProcessConfig& a, ProcessConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcessConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProcessConfig& from) {
    ProcessConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProcessConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ProcessConfig";
  }
  protected:
  explicit ProcessConfig(::google::protobuf::Arena* arena);
  ProcessConfig(::google::protobuf::Arena* arena, const ProcessConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kEnvFieldNumber = 9,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCwdFieldNumber = 4,
    kStopTimeoutFieldNumber = 8,
    kOneShotFieldNumber = 5,
    kLogFieldNumber = 6,
    kStopSignalFieldNumber = 7,
  };
  // repeated string args = 3 [json_name = "args"];
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, std::size_t size);
  void set_args(int index, absl::string_view value);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, std::size_t size);
  void add_args(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_args();

  public:
  // map<string, string> env = 9 [json_name = "env"];
  int env_size() const;
  private:
  int _internal_env_size() const;

  public:
  void clear_env() ;
  const ::google::protobuf::Map<std::string, std::string>& env() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_env();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_env() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_env();

  public:
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string cwd = 4 [json_name = "cwd"];
  void clear_cwd() ;
  const std::string& cwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cwd(Arg_&& arg, Args_... args);
  std::string* mutable_cwd();
  PROTOBUF_NODISCARD std::string* release_cwd();
  void set_allocated_cwd(std::string* value);

  private:
  const std::string& _internal_cwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cwd(
      const std::string& value);
  std::string* _internal_mutable_cwd();

  public:
  // .google.protobuf.Duration stop_timeout = 8 [json_name = "stopTimeout"];
  bool has_stop_timeout() const;
  void clear_stop_timeout() ;
  const ::google::protobuf::Duration& stop_timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_stop_timeout();
  ::google::protobuf::Duration* mutable_stop_timeout();
  void set_allocated_stop_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_stop_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_stop_timeout();

  private:
  const ::google::protobuf::Duration& _internal_stop_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_stop_timeout();

  public:
  // bool one_shot = 5 [json_name = "oneShot"];
  void clear_one_shot() ;
  bool one_shot() const;
  void set_one_shot(bool value);

  private:
  bool _internal_one_shot() const;
  void _internal_set_one_shot(bool value);

  public:
  // bool log = 6 [json_name = "log"];
  void clear_log() ;
  bool log() const;
  void set_log(bool value);

  private:
  bool _internal_log() const;
  void _internal_set_log(bool value);

  public:
  // int32 stop_signal = 7 [json_name = "stopSignal"];
  void clear_stop_signal() ;
  ::int32_t stop_signal() const;
  void set_stop_signal(::int32_t value);

  private:
  ::int32_t _internal_stop_signal() const;
  void _internal_set_stop_signal(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ProcessConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 2,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> args_;
    ::google::protobuf::internal::MapField<ProcessConfig_EnvEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        env_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr cwd_;
    ::google::protobuf::Duration* stop_timeout_;
    bool one_shot_;
    bool log_;
    ::int32_t stop_signal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class PackageConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.PackageConfig) */ {
 public:
  inline PackageConfig() : PackageConfig(nullptr) {}
  ~PackageConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PackageConfig(::google::protobuf::internal::ConstantInitialized);

  inline PackageConfig(const PackageConfig& from)
      : PackageConfig(nullptr, from) {}
  PackageConfig(PackageConfig&& from) noexcept
    : PackageConfig() {
    *this = ::std::move(from);
  }

  inline PackageConfig& operator=(const PackageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackageConfig& operator=(PackageConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackageConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackageConfig* internal_default_instance() {
    return reinterpret_cast<const PackageConfig*>(
               &_PackageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(PackageConfig& a, PackageConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PackageConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackageConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackageConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackageConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PackageConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PackageConfig& from) {
    PackageConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PackageConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.PackageConfig";
  }
  protected:
  explicit PackageConfig(::google::protobuf::Arena* arena);
  PackageConfig(::google::protobuf::Arena* arena, const PackageConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPackageFieldNumber = 2,
    kVersionFieldNumber = 3,
    kTypeFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string package = 2 [json_name = "package"];
  void clear_package() ;
  const std::string& package() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_package(Arg_&& arg, Args_... args);
  std::string* mutable_package();
  PROTOBUF_NODISCARD std::string* release_package();
  void set_allocated_package(std::string* value);

  private:
  const std::string& _internal_package() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package(
      const std::string& value);
  std::string* _internal_mutable_package();

  public:
  // string version = 3 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string type = 4 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // .viam.app.v1.AppValidationStatus status = 5 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::viam::app::v1::AppValidationStatus& status() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AppValidationStatus* release_status();
  ::viam::app::v1::AppValidationStatus* mutable_status();
  void set_allocated_status(::viam::app::v1::AppValidationStatus* value);
  void unsafe_arena_set_allocated_status(::viam::app::v1::AppValidationStatus* value);
  ::viam::app::v1::AppValidationStatus* unsafe_arena_release_status();

  private:
  const ::viam::app::v1::AppValidationStatus& _internal_status() const;
  ::viam::app::v1::AppValidationStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.PackageConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr package_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::viam::app::v1::AppValidationStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class Orientation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation) */ {
 public:
  inline Orientation() : Orientation(nullptr) {}
  ~Orientation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation(::google::protobuf::internal::ConstantInitialized);

  inline Orientation(const Orientation& from)
      : Orientation(nullptr, from) {}
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation& operator=(Orientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kNoOrientation = 1,
    kVectorRadians = 2,
    kVectorDegrees = 3,
    kEulerAngles = 4,
    kAxisAngles = 5,
    kQuaternion = 6,
    TYPE_NOT_SET = 0,
  };

  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Orientation& from) {
    Orientation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Orientation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Orientation";
  }
  protected:
  explicit Orientation(::google::protobuf::Arena* arena);
  Orientation(::google::protobuf::Arena* arena, const Orientation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using NoOrientation = Orientation_NoOrientation;
  using OrientationVectorRadians = Orientation_OrientationVectorRadians;
  using OrientationVectorDegrees = Orientation_OrientationVectorDegrees;
  using EulerAngles = Orientation_EulerAngles;
  using AxisAngles = Orientation_AxisAngles;
  using Quaternion = Orientation_Quaternion;

  // accessors -------------------------------------------------------

  enum : int {
    kNoOrientationFieldNumber = 1,
    kVectorRadiansFieldNumber = 2,
    kVectorDegreesFieldNumber = 3,
    kEulerAnglesFieldNumber = 4,
    kAxisAnglesFieldNumber = 5,
    kQuaternionFieldNumber = 6,
  };
  // .viam.app.v1.Orientation.NoOrientation no_orientation = 1 [json_name = "noOrientation"];
  bool has_no_orientation() const;
  private:
  bool _internal_has_no_orientation() const;

  public:
  void clear_no_orientation() ;
  const ::viam::app::v1::Orientation_NoOrientation& no_orientation() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_NoOrientation* release_no_orientation();
  ::viam::app::v1::Orientation_NoOrientation* mutable_no_orientation();
  void set_allocated_no_orientation(::viam::app::v1::Orientation_NoOrientation* value);
  void unsafe_arena_set_allocated_no_orientation(::viam::app::v1::Orientation_NoOrientation* value);
  ::viam::app::v1::Orientation_NoOrientation* unsafe_arena_release_no_orientation();

  private:
  const ::viam::app::v1::Orientation_NoOrientation& _internal_no_orientation() const;
  ::viam::app::v1::Orientation_NoOrientation* _internal_mutable_no_orientation();

  public:
  // .viam.app.v1.Orientation.OrientationVectorRadians vector_radians = 2 [json_name = "vectorRadians"];
  bool has_vector_radians() const;
  private:
  bool _internal_has_vector_radians() const;

  public:
  void clear_vector_radians() ;
  const ::viam::app::v1::Orientation_OrientationVectorRadians& vector_radians() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_OrientationVectorRadians* release_vector_radians();
  ::viam::app::v1::Orientation_OrientationVectorRadians* mutable_vector_radians();
  void set_allocated_vector_radians(::viam::app::v1::Orientation_OrientationVectorRadians* value);
  void unsafe_arena_set_allocated_vector_radians(::viam::app::v1::Orientation_OrientationVectorRadians* value);
  ::viam::app::v1::Orientation_OrientationVectorRadians* unsafe_arena_release_vector_radians();

  private:
  const ::viam::app::v1::Orientation_OrientationVectorRadians& _internal_vector_radians() const;
  ::viam::app::v1::Orientation_OrientationVectorRadians* _internal_mutable_vector_radians();

  public:
  // .viam.app.v1.Orientation.OrientationVectorDegrees vector_degrees = 3 [json_name = "vectorDegrees"];
  bool has_vector_degrees() const;
  private:
  bool _internal_has_vector_degrees() const;

  public:
  void clear_vector_degrees() ;
  const ::viam::app::v1::Orientation_OrientationVectorDegrees& vector_degrees() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_OrientationVectorDegrees* release_vector_degrees();
  ::viam::app::v1::Orientation_OrientationVectorDegrees* mutable_vector_degrees();
  void set_allocated_vector_degrees(::viam::app::v1::Orientation_OrientationVectorDegrees* value);
  void unsafe_arena_set_allocated_vector_degrees(::viam::app::v1::Orientation_OrientationVectorDegrees* value);
  ::viam::app::v1::Orientation_OrientationVectorDegrees* unsafe_arena_release_vector_degrees();

  private:
  const ::viam::app::v1::Orientation_OrientationVectorDegrees& _internal_vector_degrees() const;
  ::viam::app::v1::Orientation_OrientationVectorDegrees* _internal_mutable_vector_degrees();

  public:
  // .viam.app.v1.Orientation.EulerAngles euler_angles = 4 [json_name = "eulerAngles"];
  bool has_euler_angles() const;
  private:
  bool _internal_has_euler_angles() const;

  public:
  void clear_euler_angles() ;
  const ::viam::app::v1::Orientation_EulerAngles& euler_angles() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_EulerAngles* release_euler_angles();
  ::viam::app::v1::Orientation_EulerAngles* mutable_euler_angles();
  void set_allocated_euler_angles(::viam::app::v1::Orientation_EulerAngles* value);
  void unsafe_arena_set_allocated_euler_angles(::viam::app::v1::Orientation_EulerAngles* value);
  ::viam::app::v1::Orientation_EulerAngles* unsafe_arena_release_euler_angles();

  private:
  const ::viam::app::v1::Orientation_EulerAngles& _internal_euler_angles() const;
  ::viam::app::v1::Orientation_EulerAngles* _internal_mutable_euler_angles();

  public:
  // .viam.app.v1.Orientation.AxisAngles axis_angles = 5 [json_name = "axisAngles"];
  bool has_axis_angles() const;
  private:
  bool _internal_has_axis_angles() const;

  public:
  void clear_axis_angles() ;
  const ::viam::app::v1::Orientation_AxisAngles& axis_angles() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_AxisAngles* release_axis_angles();
  ::viam::app::v1::Orientation_AxisAngles* mutable_axis_angles();
  void set_allocated_axis_angles(::viam::app::v1::Orientation_AxisAngles* value);
  void unsafe_arena_set_allocated_axis_angles(::viam::app::v1::Orientation_AxisAngles* value);
  ::viam::app::v1::Orientation_AxisAngles* unsafe_arena_release_axis_angles();

  private:
  const ::viam::app::v1::Orientation_AxisAngles& _internal_axis_angles() const;
  ::viam::app::v1::Orientation_AxisAngles* _internal_mutable_axis_angles();

  public:
  // .viam.app.v1.Orientation.Quaternion quaternion = 6 [json_name = "quaternion"];
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;

  public:
  void clear_quaternion() ;
  const ::viam::app::v1::Orientation_Quaternion& quaternion() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_Quaternion* release_quaternion();
  ::viam::app::v1::Orientation_Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::viam::app::v1::Orientation_Quaternion* value);
  void unsafe_arena_set_allocated_quaternion(::viam::app::v1::Orientation_Quaternion* value);
  ::viam::app::v1::Orientation_Quaternion* unsafe_arena_release_quaternion();

  private:
  const ::viam::app::v1::Orientation_Quaternion& _internal_quaternion() const;
  ::viam::app::v1::Orientation_Quaternion* _internal_mutable_quaternion();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation)
 private:
  class _Internal;
  void set_has_no_orientation();
  void set_has_vector_radians();
  void set_has_vector_degrees();
  void set_has_euler_angles();
  void set_has_axis_angles();
  void set_has_quaternion();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::viam::app::v1::Orientation_NoOrientation* no_orientation_;
      ::viam::app::v1::Orientation_OrientationVectorRadians* vector_radians_;
      ::viam::app::v1::Orientation_OrientationVectorDegrees* vector_degrees_;
      ::viam::app::v1::Orientation_EulerAngles* euler_angles_;
      ::viam::app::v1::Orientation_AxisAngles* axis_angles_;
      ::viam::app::v1::Orientation_Quaternion* quaternion_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class NeedsRestartResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NeedsRestartResponse) */ {
 public:
  inline NeedsRestartResponse() : NeedsRestartResponse(nullptr) {}
  ~NeedsRestartResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NeedsRestartResponse(::google::protobuf::internal::ConstantInitialized);

  inline NeedsRestartResponse(const NeedsRestartResponse& from)
      : NeedsRestartResponse(nullptr, from) {}
  NeedsRestartResponse(NeedsRestartResponse&& from) noexcept
    : NeedsRestartResponse() {
    *this = ::std::move(from);
  }

  inline NeedsRestartResponse& operator=(const NeedsRestartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeedsRestartResponse& operator=(NeedsRestartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeedsRestartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeedsRestartResponse* internal_default_instance() {
    return reinterpret_cast<const NeedsRestartResponse*>(
               &_NeedsRestartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(NeedsRestartResponse& a, NeedsRestartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NeedsRestartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeedsRestartResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeedsRestartResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeedsRestartResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NeedsRestartResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NeedsRestartResponse& from) {
    NeedsRestartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NeedsRestartResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.NeedsRestartResponse";
  }
  protected:
  explicit NeedsRestartResponse(::google::protobuf::Arena* arena);
  NeedsRestartResponse(::google::protobuf::Arena* arena, const NeedsRestartResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRestartCheckIntervalFieldNumber = 3,
    kMustRestartFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .google.protobuf.Duration restart_check_interval = 3 [json_name = "restartCheckInterval"];
  bool has_restart_check_interval() const;
  void clear_restart_check_interval() ;
  const ::google::protobuf::Duration& restart_check_interval() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_restart_check_interval();
  ::google::protobuf::Duration* mutable_restart_check_interval();
  void set_allocated_restart_check_interval(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_restart_check_interval(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_restart_check_interval();

  private:
  const ::google::protobuf::Duration& _internal_restart_check_interval() const;
  ::google::protobuf::Duration* _internal_mutable_restart_check_interval();

  public:
  // bool must_restart = 2 [json_name = "mustRestart"];
  void clear_must_restart() ;
  bool must_restart() const;
  void set_must_restart(bool value);

  private:
  bool _internal_must_restart() const;
  void _internal_set_must_restart(bool value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.NeedsRestartResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::Duration* restart_check_interval_;
    bool must_restart_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ModuleConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleConfig) */ {
 public:
  inline ModuleConfig() : ModuleConfig(nullptr) {}
  ~ModuleConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModuleConfig(::google::protobuf::internal::ConstantInitialized);

  inline ModuleConfig(const ModuleConfig& from)
      : ModuleConfig(nullptr, from) {}
  ModuleConfig(ModuleConfig&& from) noexcept
    : ModuleConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig& operator=(const ModuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig& operator=(ModuleConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig*>(
               &_ModuleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ModuleConfig& a, ModuleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModuleConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ModuleConfig& from) {
    ModuleConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ModuleConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ModuleConfig";
  }
  protected:
  explicit ModuleConfig(::google::protobuf::Arena* arena);
  ModuleConfig(::google::protobuf::Arena* arena, const ModuleConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 6,
    kNameFieldNumber = 1,
    kPathFieldNumber = 2,
    kLogLevelFieldNumber = 3,
    kTypeFieldNumber = 4,
    kModuleIdFieldNumber = 5,
    kStatusFieldNumber = 7,
  };
  // map<string, string> env = 6 [json_name = "env"];
  int env_size() const;
  private:
  int _internal_env_size() const;

  public:
  void clear_env() ;
  const ::google::protobuf::Map<std::string, std::string>& env() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_env();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_env() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_env();

  public:
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string path = 2 [json_name = "path"];
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // string log_level = 3 [json_name = "logLevel"];
  void clear_log_level() ;
  const std::string& log_level() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_level(Arg_&& arg, Args_... args);
  std::string* mutable_log_level();
  PROTOBUF_NODISCARD std::string* release_log_level();
  void set_allocated_log_level(std::string* value);

  private:
  const std::string& _internal_log_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_level(
      const std::string& value);
  std::string* _internal_mutable_log_level();

  public:
  // string type = 4 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string module_id = 5 [json_name = "moduleId"];
  void clear_module_id() ;
  const std::string& module_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_module_id(Arg_&& arg, Args_... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* value);

  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(
      const std::string& value);
  std::string* _internal_mutable_module_id();

  public:
  // .viam.app.v1.AppValidationStatus status = 7 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::viam::app::v1::AppValidationStatus& status() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AppValidationStatus* release_status();
  ::viam::app::v1::AppValidationStatus* mutable_status();
  void set_allocated_status(::viam::app::v1::AppValidationStatus* value);
  void unsafe_arena_set_allocated_status(::viam::app::v1::AppValidationStatus* value);
  ::viam::app::v1::AppValidationStatus* unsafe_arena_release_status();

  private:
  const ::viam::app::v1::AppValidationStatus& _internal_status() const;
  ::viam::app::v1::AppValidationStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<ModuleConfig_EnvEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        env_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr log_level_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr module_id_;
    ::viam::app::v1::AppValidationStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class JWKSFile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.JWKSFile) */ {
 public:
  inline JWKSFile() : JWKSFile(nullptr) {}
  ~JWKSFile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JWKSFile(::google::protobuf::internal::ConstantInitialized);

  inline JWKSFile(const JWKSFile& from)
      : JWKSFile(nullptr, from) {}
  JWKSFile(JWKSFile&& from) noexcept
    : JWKSFile() {
    *this = ::std::move(from);
  }

  inline JWKSFile& operator=(const JWKSFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline JWKSFile& operator=(JWKSFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JWKSFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const JWKSFile* internal_default_instance() {
    return reinterpret_cast<const JWKSFile*>(
               &_JWKSFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JWKSFile& a, JWKSFile& b) {
    a.Swap(&b);
  }
  inline void Swap(JWKSFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JWKSFile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JWKSFile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JWKSFile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JWKSFile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JWKSFile& from) {
    JWKSFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JWKSFile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.JWKSFile";
  }
  protected:
  explicit JWKSFile(::google::protobuf::Arena* arena);
  JWKSFile(::google::protobuf::Arena* arena, const JWKSFile& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonFieldNumber = 1,
  };
  // .google.protobuf.Struct json = 1 [json_name = "json"];
  bool has_json() const;
  void clear_json() ;
  const ::google::protobuf::Struct& json() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_json();
  ::google::protobuf::Struct* mutable_json();
  void set_allocated_json(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_json(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_json();

  private:
  const ::google::protobuf::Struct& _internal_json() const;
  ::google::protobuf::Struct* _internal_mutable_json();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.JWKSFile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Struct* json_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ConfigRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ConfigRequest) */ {
 public:
  inline ConfigRequest() : ConfigRequest(nullptr) {}
  ~ConfigRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigRequest(::google::protobuf::internal::ConstantInitialized);

  inline ConfigRequest(const ConfigRequest& from)
      : ConfigRequest(nullptr, from) {}
  ConfigRequest(ConfigRequest&& from) noexcept
    : ConfigRequest() {
    *this = ::std::move(from);
  }

  inline ConfigRequest& operator=(const ConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigRequest& operator=(ConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigRequest*>(
               &_ConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ConfigRequest& a, ConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfigRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConfigRequest& from) {
    ConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfigRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ConfigRequest";
  }
  protected:
  explicit ConfigRequest(::google::protobuf::Arena* arena);
  ConfigRequest(::google::protobuf::Arena* arena, const ConfigRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAgentInfoFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .viam.app.v1.AgentInfo agent_info = 2 [json_name = "agentInfo"];
  bool has_agent_info() const;
  void clear_agent_info() ;
  const ::viam::app::v1::AgentInfo& agent_info() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AgentInfo* release_agent_info();
  ::viam::app::v1::AgentInfo* mutable_agent_info();
  void set_allocated_agent_info(::viam::app::v1::AgentInfo* value);
  void unsafe_arena_set_allocated_agent_info(::viam::app::v1::AgentInfo* value);
  ::viam::app::v1::AgentInfo* unsafe_arena_release_agent_info();

  private:
  const ::viam::app::v1::AgentInfo& _internal_agent_info() const;
  ::viam::app::v1::AgentInfo* _internal_mutable_agent_info();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ConfigRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::viam::app::v1::AgentInfo* agent_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class CloudConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CloudConfig) */ {
 public:
  inline CloudConfig() : CloudConfig(nullptr) {}
  ~CloudConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CloudConfig(::google::protobuf::internal::ConstantInitialized);

  inline CloudConfig(const CloudConfig& from)
      : CloudConfig(nullptr, from) {}
  CloudConfig(CloudConfig&& from) noexcept
    : CloudConfig() {
    *this = ::std::move(from);
  }

  inline CloudConfig& operator=(const CloudConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudConfig& operator=(CloudConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloudConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloudConfig* internal_default_instance() {
    return reinterpret_cast<const CloudConfig*>(
               &_CloudConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CloudConfig& a, CloudConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CloudConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloudConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloudConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloudConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CloudConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CloudConfig& from) {
    CloudConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CloudConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.CloudConfig";
  }
  protected:
  explicit CloudConfig(::google::protobuf::Arena* arena);
  CloudConfig(::google::protobuf::Arena* arena, const CloudConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationSecretsFieldNumber = 9,
    kIdFieldNumber = 1,
    kFqdnFieldNumber = 2,
    kLocalFqdnFieldNumber = 3,
    kManagedByFieldNumber = 4,
    kSignalingAddressFieldNumber = 5,
    kLocationSecretFieldNumber = 7,
    kSecretFieldNumber = 8,
    kPrimaryOrgIdFieldNumber = 10,
    kLocationIdFieldNumber = 11,
    kMachineIdFieldNumber = 12,
    kSignalingInsecureFieldNumber = 6,
  };
  // repeated .viam.app.v1.LocationSecret location_secrets = 9 [json_name = "locationSecrets"];
  int location_secrets_size() const;
  private:
  int _internal_location_secrets_size() const;

  public:
  void clear_location_secrets() ;
  ::viam::app::v1::LocationSecret* mutable_location_secrets(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::LocationSecret >*
      mutable_location_secrets();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::LocationSecret>& _internal_location_secrets() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::LocationSecret>* _internal_mutable_location_secrets();
  public:
  const ::viam::app::v1::LocationSecret& location_secrets(int index) const;
  ::viam::app::v1::LocationSecret* add_location_secrets();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::LocationSecret >&
      location_secrets() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string fqdn = 2 [json_name = "fqdn"];
  void clear_fqdn() ;
  const std::string& fqdn() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fqdn(Arg_&& arg, Args_... args);
  std::string* mutable_fqdn();
  PROTOBUF_NODISCARD std::string* release_fqdn();
  void set_allocated_fqdn(std::string* value);

  private:
  const std::string& _internal_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fqdn(
      const std::string& value);
  std::string* _internal_mutable_fqdn();

  public:
  // string local_fqdn = 3 [json_name = "localFqdn"];
  void clear_local_fqdn() ;
  const std::string& local_fqdn() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_fqdn(Arg_&& arg, Args_... args);
  std::string* mutable_local_fqdn();
  PROTOBUF_NODISCARD std::string* release_local_fqdn();
  void set_allocated_local_fqdn(std::string* value);

  private:
  const std::string& _internal_local_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_fqdn(
      const std::string& value);
  std::string* _internal_mutable_local_fqdn();

  public:
  // string managed_by = 4 [json_name = "managedBy"];
  void clear_managed_by() ;
  const std::string& managed_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_managed_by(Arg_&& arg, Args_... args);
  std::string* mutable_managed_by();
  PROTOBUF_NODISCARD std::string* release_managed_by();
  void set_allocated_managed_by(std::string* value);

  private:
  const std::string& _internal_managed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_managed_by(
      const std::string& value);
  std::string* _internal_mutable_managed_by();

  public:
  // string signaling_address = 5 [json_name = "signalingAddress"];
  void clear_signaling_address() ;
  const std::string& signaling_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signaling_address(Arg_&& arg, Args_... args);
  std::string* mutable_signaling_address();
  PROTOBUF_NODISCARD std::string* release_signaling_address();
  void set_allocated_signaling_address(std::string* value);

  private:
  const std::string& _internal_signaling_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signaling_address(
      const std::string& value);
  std::string* _internal_mutable_signaling_address();

  public:
  // string location_secret = 7 [json_name = "locationSecret", deprecated = true];
  [[deprecated]]  void clear_location_secret() ;
  [[deprecated]] const std::string& location_secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_location_secret(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_location_secret();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_location_secret();
  [[deprecated]] void set_allocated_location_secret(std::string* value);

  private:
  const std::string& _internal_location_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_secret(
      const std::string& value);
  std::string* _internal_mutable_location_secret();

  public:
  // string secret = 8 [json_name = "secret"];
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // string primary_org_id = 10 [json_name = "primaryOrgId"];
  void clear_primary_org_id() ;
  const std::string& primary_org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_primary_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_primary_org_id();
  PROTOBUF_NODISCARD std::string* release_primary_org_id();
  void set_allocated_primary_org_id(std::string* value);

  private:
  const std::string& _internal_primary_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_org_id(
      const std::string& value);
  std::string* _internal_mutable_primary_org_id();

  public:
  // string location_id = 11 [json_name = "locationId"];
  void clear_location_id() ;
  const std::string& location_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location_id(Arg_&& arg, Args_... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* value);

  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(
      const std::string& value);
  std::string* _internal_mutable_location_id();

  public:
  // string machine_id = 12 [json_name = "machineId"];
  void clear_machine_id() ;
  const std::string& machine_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_machine_id(Arg_&& arg, Args_... args);
  std::string* mutable_machine_id();
  PROTOBUF_NODISCARD std::string* release_machine_id();
  void set_allocated_machine_id(std::string* value);

  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(
      const std::string& value);
  std::string* _internal_mutable_machine_id();

  public:
  // bool signaling_insecure = 6 [json_name = "signalingInsecure"];
  void clear_signaling_insecure() ;
  bool signaling_insecure() const;
  void set_signaling_insecure(bool value);

  private:
  bool _internal_signaling_insecure() const;
  void _internal_set_signaling_insecure(bool value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.CloudConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 1,
      139, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::LocationSecret > location_secrets_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr fqdn_;
    ::google::protobuf::internal::ArenaStringPtr local_fqdn_;
    ::google::protobuf::internal::ArenaStringPtr managed_by_;
    ::google::protobuf::internal::ArenaStringPtr signaling_address_;
    ::google::protobuf::internal::ArenaStringPtr location_secret_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::google::protobuf::internal::ArenaStringPtr primary_org_id_;
    ::google::protobuf::internal::ArenaStringPtr location_id_;
    ::google::protobuf::internal::ArenaStringPtr machine_id_;
    bool signaling_insecure_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class AuthHandlerConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthHandlerConfig) */ {
 public:
  inline AuthHandlerConfig() : AuthHandlerConfig(nullptr) {}
  ~AuthHandlerConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthHandlerConfig(::google::protobuf::internal::ConstantInitialized);

  inline AuthHandlerConfig(const AuthHandlerConfig& from)
      : AuthHandlerConfig(nullptr, from) {}
  AuthHandlerConfig(AuthHandlerConfig&& from) noexcept
    : AuthHandlerConfig() {
    *this = ::std::move(from);
  }

  inline AuthHandlerConfig& operator=(const AuthHandlerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthHandlerConfig& operator=(AuthHandlerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthHandlerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthHandlerConfig* internal_default_instance() {
    return reinterpret_cast<const AuthHandlerConfig*>(
               &_AuthHandlerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AuthHandlerConfig& a, AuthHandlerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthHandlerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthHandlerConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthHandlerConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthHandlerConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthHandlerConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AuthHandlerConfig& from) {
    AuthHandlerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AuthHandlerConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.AuthHandlerConfig";
  }
  protected:
  explicit AuthHandlerConfig(::google::protobuf::Arena* arena);
  AuthHandlerConfig(::google::protobuf::Arena* arena, const AuthHandlerConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // .google.protobuf.Struct config = 5 [json_name = "config"];
  bool has_config() const;
  void clear_config() ;
  const ::google::protobuf::Struct& config() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_config();
  ::google::protobuf::Struct* mutable_config();
  void set_allocated_config(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_config(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_config();

  private:
  const ::google::protobuf::Struct& _internal_config() const;
  ::google::protobuf::Struct* _internal_mutable_config();

  public:
  // .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
  void clear_type() ;
  ::viam::app::v1::CredentialsType type() const;
  void set_type(::viam::app::v1::CredentialsType value);

  private:
  ::viam::app::v1::CredentialsType _internal_type() const;
  void _internal_set_type(::viam::app::v1::CredentialsType value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthHandlerConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Struct* config_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ServiceConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ServiceConfig) */ {
 public:
  inline ServiceConfig() : ServiceConfig(nullptr) {}
  ~ServiceConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceConfig(::google::protobuf::internal::ConstantInitialized);

  inline ServiceConfig(const ServiceConfig& from)
      : ServiceConfig(nullptr, from) {}
  ServiceConfig(ServiceConfig&& from) noexcept
    : ServiceConfig() {
    *this = ::std::move(from);
  }

  inline ServiceConfig& operator=(const ServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceConfig& operator=(ServiceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceConfig* internal_default_instance() {
    return reinterpret_cast<const ServiceConfig*>(
               &_ServiceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ServiceConfig& a, ServiceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServiceConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ServiceConfig& from) {
    ServiceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServiceConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ServiceConfig";
  }
  protected:
  explicit ServiceConfig(::google::protobuf::Arena* arena);
  ServiceConfig(::google::protobuf::Arena* arena, const ServiceConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependsOnFieldNumber = 5,
    kServiceConfigsFieldNumber = 10,
    kNameFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kTypeFieldNumber = 3,
    kModelFieldNumber = 6,
    kApiFieldNumber = 9,
    kAttributesFieldNumber = 4,
    kLogConfigurationFieldNumber = 11,
  };
  // repeated string depends_on = 5 [json_name = "dependsOn"];
  int depends_on_size() const;
  private:
  int _internal_depends_on_size() const;

  public:
  void clear_depends_on() ;
  const std::string& depends_on(int index) const;
  std::string* mutable_depends_on(int index);
  void set_depends_on(int index, const std::string& value);
  void set_depends_on(int index, std::string&& value);
  void set_depends_on(int index, const char* value);
  void set_depends_on(int index, const char* value, std::size_t size);
  void set_depends_on(int index, absl::string_view value);
  std::string* add_depends_on();
  void add_depends_on(const std::string& value);
  void add_depends_on(std::string&& value);
  void add_depends_on(const char* value);
  void add_depends_on(const char* value, std::size_t size);
  void add_depends_on(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& depends_on() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_depends_on();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_depends_on() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_depends_on();

  public:
  // repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 10 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
  int service_configs_size() const;
  private:
  int _internal_service_configs_size() const;

  public:
  void clear_service_configs() ;
  ::viam::app::v1::ResourceLevelServiceConfig* mutable_service_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
      mutable_service_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>& _internal_service_configs() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>* _internal_mutable_service_configs();
  public:
  const ::viam::app::v1::ResourceLevelServiceConfig& service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* add_service_configs();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
      service_configs() const;
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string namespace = 2 [json_name = "namespace"];
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* value);

  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(
      const std::string& value);
  std::string* _internal_mutable_namespace_();

  public:
  // string type = 3 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string model = 6 [json_name = "model"];
  void clear_model() ;
  const std::string& model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* value);

  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(
      const std::string& value);
  std::string* _internal_mutable_model();

  public:
  // string api = 9 [json_name = "api"];
  void clear_api() ;
  const std::string& api() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_api(Arg_&& arg, Args_... args);
  std::string* mutable_api();
  PROTOBUF_NODISCARD std::string* release_api();
  void set_allocated_api(std::string* value);

  private:
  const std::string& _internal_api() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api(
      const std::string& value);
  std::string* _internal_mutable_api();

  public:
  // .google.protobuf.Struct attributes = 4 [json_name = "attributes"];
  bool has_attributes() const;
  void clear_attributes() ;
  const ::google::protobuf::Struct& attributes() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_attributes();
  ::google::protobuf::Struct* mutable_attributes();
  void set_allocated_attributes(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_attributes(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_attributes();

  private:
  const ::google::protobuf::Struct& _internal_attributes() const;
  ::google::protobuf::Struct* _internal_mutable_attributes();

  public:
  // .viam.app.v1.LogConfiguration log_configuration = 11 [json_name = "logConfiguration"];
  bool has_log_configuration() const;
  void clear_log_configuration() ;
  const ::viam::app::v1::LogConfiguration& log_configuration() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LogConfiguration* release_log_configuration();
  ::viam::app::v1::LogConfiguration* mutable_log_configuration();
  void set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value);
  void unsafe_arena_set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value);
  ::viam::app::v1::LogConfiguration* unsafe_arena_release_log_configuration();

  private:
  const ::viam::app::v1::LogConfiguration& _internal_log_configuration() const;
  ::viam::app::v1::LogConfiguration* _internal_mutable_log_configuration();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ServiceConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> depends_on_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig > service_configs_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr model_;
    ::google::protobuf::internal::ArenaStringPtr api_;
    ::google::protobuf::Struct* attributes_;
    ::viam::app::v1::LogConfiguration* log_configuration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class NetworkConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NetworkConfig) */ {
 public:
  inline NetworkConfig() : NetworkConfig(nullptr) {}
  ~NetworkConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkConfig(::google::protobuf::internal::ConstantInitialized);

  inline NetworkConfig(const NetworkConfig& from)
      : NetworkConfig(nullptr, from) {}
  NetworkConfig(NetworkConfig&& from) noexcept
    : NetworkConfig() {
    *this = ::std::move(from);
  }

  inline NetworkConfig& operator=(const NetworkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConfig& operator=(NetworkConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkConfig* internal_default_instance() {
    return reinterpret_cast<const NetworkConfig*>(
               &_NetworkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NetworkConfig& a, NetworkConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetworkConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NetworkConfig& from) {
    NetworkConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NetworkConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.NetworkConfig";
  }
  protected:
  explicit NetworkConfig(::google::protobuf::Arena* arena);
  NetworkConfig(::google::protobuf::Arena* arena, const NetworkConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFqdnFieldNumber = 1,
    kBindAddressFieldNumber = 2,
    kTlsCertFileFieldNumber = 3,
    kTlsKeyFileFieldNumber = 4,
    kSessionsFieldNumber = 5,
  };
  // string fqdn = 1 [json_name = "fqdn"];
  void clear_fqdn() ;
  const std::string& fqdn() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fqdn(Arg_&& arg, Args_... args);
  std::string* mutable_fqdn();
  PROTOBUF_NODISCARD std::string* release_fqdn();
  void set_allocated_fqdn(std::string* value);

  private:
  const std::string& _internal_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fqdn(
      const std::string& value);
  std::string* _internal_mutable_fqdn();

  public:
  // string bind_address = 2 [json_name = "bindAddress"];
  void clear_bind_address() ;
  const std::string& bind_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bind_address(Arg_&& arg, Args_... args);
  std::string* mutable_bind_address();
  PROTOBUF_NODISCARD std::string* release_bind_address();
  void set_allocated_bind_address(std::string* value);

  private:
  const std::string& _internal_bind_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bind_address(
      const std::string& value);
  std::string* _internal_mutable_bind_address();

  public:
  // string tls_cert_file = 3 [json_name = "tlsCertFile"];
  void clear_tls_cert_file() ;
  const std::string& tls_cert_file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tls_cert_file(Arg_&& arg, Args_... args);
  std::string* mutable_tls_cert_file();
  PROTOBUF_NODISCARD std::string* release_tls_cert_file();
  void set_allocated_tls_cert_file(std::string* value);

  private:
  const std::string& _internal_tls_cert_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_cert_file(
      const std::string& value);
  std::string* _internal_mutable_tls_cert_file();

  public:
  // string tls_key_file = 4 [json_name = "tlsKeyFile"];
  void clear_tls_key_file() ;
  const std::string& tls_key_file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tls_key_file(Arg_&& arg, Args_... args);
  std::string* mutable_tls_key_file();
  PROTOBUF_NODISCARD std::string* release_tls_key_file();
  void set_allocated_tls_key_file(std::string* value);

  private:
  const std::string& _internal_tls_key_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_key_file(
      const std::string& value);
  std::string* _internal_mutable_tls_key_file();

  public:
  // .viam.app.v1.SessionsConfig sessions = 5 [json_name = "sessions"];
  bool has_sessions() const;
  void clear_sessions() ;
  const ::viam::app::v1::SessionsConfig& sessions() const;
  PROTOBUF_NODISCARD ::viam::app::v1::SessionsConfig* release_sessions();
  ::viam::app::v1::SessionsConfig* mutable_sessions();
  void set_allocated_sessions(::viam::app::v1::SessionsConfig* value);
  void unsafe_arena_set_allocated_sessions(::viam::app::v1::SessionsConfig* value);
  ::viam::app::v1::SessionsConfig* unsafe_arena_release_sessions();

  private:
  const ::viam::app::v1::SessionsConfig& _internal_sessions() const;
  ::viam::app::v1::SessionsConfig* _internal_mutable_sessions();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.NetworkConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr fqdn_;
    ::google::protobuf::internal::ArenaStringPtr bind_address_;
    ::google::protobuf::internal::ArenaStringPtr tls_cert_file_;
    ::google::protobuf::internal::ArenaStringPtr tls_key_file_;
    ::viam::app::v1::SessionsConfig* sessions_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class LogRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LogRequest) */ {
 public:
  inline LogRequest() : LogRequest(nullptr) {}
  ~LogRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LogRequest(::google::protobuf::internal::ConstantInitialized);

  inline LogRequest(const LogRequest& from)
      : LogRequest(nullptr, from) {}
  LogRequest(LogRequest&& from) noexcept
    : LogRequest() {
    *this = ::std::move(from);
  }

  inline LogRequest& operator=(const LogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRequest& operator=(LogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRequest* internal_default_instance() {
    return reinterpret_cast<const LogRequest*>(
               &_LogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(LogRequest& a, LogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LogRequest& from) {
    LogRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LogRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.LogRequest";
  }
  protected:
  explicit LogRequest(::google::protobuf::Arena* arena);
  LogRequest(::google::protobuf::Arena* arena, const LogRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .viam.common.v1.LogEntry logs = 2 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;

  public:
  void clear_logs() ;
  ::viam::common::v1::LogEntry* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::common::v1::LogEntry >*
      mutable_logs();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::common::v1::LogEntry>& _internal_logs() const;
  ::google::protobuf::RepeatedPtrField<::viam::common::v1::LogEntry>* _internal_mutable_logs();
  public:
  const ::viam::common::v1::LogEntry& logs(int index) const;
  ::viam::common::v1::LogEntry* add_logs();
  const ::google::protobuf::RepeatedPtrField< ::viam::common::v1::LogEntry >&
      logs() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.LogRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::viam::common::v1::LogEntry > logs_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ExternalAuthConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ExternalAuthConfig) */ {
 public:
  inline ExternalAuthConfig() : ExternalAuthConfig(nullptr) {}
  ~ExternalAuthConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalAuthConfig(::google::protobuf::internal::ConstantInitialized);

  inline ExternalAuthConfig(const ExternalAuthConfig& from)
      : ExternalAuthConfig(nullptr, from) {}
  ExternalAuthConfig(ExternalAuthConfig&& from) noexcept
    : ExternalAuthConfig() {
    *this = ::std::move(from);
  }

  inline ExternalAuthConfig& operator=(const ExternalAuthConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalAuthConfig& operator=(ExternalAuthConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalAuthConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalAuthConfig* internal_default_instance() {
    return reinterpret_cast<const ExternalAuthConfig*>(
               &_ExternalAuthConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ExternalAuthConfig& a, ExternalAuthConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalAuthConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalAuthConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalAuthConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalAuthConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExternalAuthConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExternalAuthConfig& from) {
    ExternalAuthConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExternalAuthConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ExternalAuthConfig";
  }
  protected:
  explicit ExternalAuthConfig(::google::protobuf::Arena* arena);
  ExternalAuthConfig(::google::protobuf::Arena* arena, const ExternalAuthConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJwksFieldNumber = 1,
  };
  // .viam.app.v1.JWKSFile jwks = 1 [json_name = "jwks"];
  bool has_jwks() const;
  void clear_jwks() ;
  const ::viam::app::v1::JWKSFile& jwks() const;
  PROTOBUF_NODISCARD ::viam::app::v1::JWKSFile* release_jwks();
  ::viam::app::v1::JWKSFile* mutable_jwks();
  void set_allocated_jwks(::viam::app::v1::JWKSFile* value);
  void unsafe_arena_set_allocated_jwks(::viam::app::v1::JWKSFile* value);
  ::viam::app::v1::JWKSFile* unsafe_arena_release_jwks();

  private:
  const ::viam::app::v1::JWKSFile& _internal_jwks() const;
  ::viam::app::v1::JWKSFile* _internal_mutable_jwks();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ExternalAuthConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::viam::app::v1::JWKSFile* jwks_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class Frame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Frame(::google::protobuf::internal::ConstantInitialized);

  inline Frame(const Frame& from)
      : Frame(nullptr, from) {}
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Frame& from) {
    Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Frame* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.Frame";
  }
  protected:
  explicit Frame(::google::protobuf::Arena* arena);
  Frame(::google::protobuf::Arena* arena, const Frame& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kTranslationFieldNumber = 2,
    kOrientationFieldNumber = 3,
    kGeometryFieldNumber = 4,
  };
  // string parent = 1 [json_name = "parent"];
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // .viam.app.v1.Translation translation = 2 [json_name = "translation"];
  bool has_translation() const;
  void clear_translation() ;
  const ::viam::app::v1::Translation& translation() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Translation* release_translation();
  ::viam::app::v1::Translation* mutable_translation();
  void set_allocated_translation(::viam::app::v1::Translation* value);
  void unsafe_arena_set_allocated_translation(::viam::app::v1::Translation* value);
  ::viam::app::v1::Translation* unsafe_arena_release_translation();

  private:
  const ::viam::app::v1::Translation& _internal_translation() const;
  ::viam::app::v1::Translation* _internal_mutable_translation();

  public:
  // .viam.app.v1.Orientation orientation = 3 [json_name = "orientation"];
  bool has_orientation() const;
  void clear_orientation() ;
  const ::viam::app::v1::Orientation& orientation() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation* release_orientation();
  ::viam::app::v1::Orientation* mutable_orientation();
  void set_allocated_orientation(::viam::app::v1::Orientation* value);
  void unsafe_arena_set_allocated_orientation(::viam::app::v1::Orientation* value);
  ::viam::app::v1::Orientation* unsafe_arena_release_orientation();

  private:
  const ::viam::app::v1::Orientation& _internal_orientation() const;
  ::viam::app::v1::Orientation* _internal_mutable_orientation();

  public:
  // .viam.common.v1.Geometry geometry = 4 [json_name = "geometry"];
  bool has_geometry() const;
  void clear_geometry() ;
  const ::viam::common::v1::Geometry& geometry() const;
  PROTOBUF_NODISCARD ::viam::common::v1::Geometry* release_geometry();
  ::viam::common::v1::Geometry* mutable_geometry();
  void set_allocated_geometry(::viam::common::v1::Geometry* value);
  void unsafe_arena_set_allocated_geometry(::viam::common::v1::Geometry* value);
  ::viam::common::v1::Geometry* unsafe_arena_release_geometry();

  private:
  const ::viam::common::v1::Geometry& _internal_geometry() const;
  ::viam::common::v1::Geometry* _internal_mutable_geometry();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.Frame)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::viam::app::v1::Translation* translation_;
    ::viam::app::v1::Orientation* orientation_;
    ::viam::common::v1::Geometry* geometry_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class AuthConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthConfig) */ {
 public:
  inline AuthConfig() : AuthConfig(nullptr) {}
  ~AuthConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthConfig(::google::protobuf::internal::ConstantInitialized);

  inline AuthConfig(const AuthConfig& from)
      : AuthConfig(nullptr, from) {}
  AuthConfig(AuthConfig&& from) noexcept
    : AuthConfig() {
    *this = ::std::move(from);
  }

  inline AuthConfig& operator=(const AuthConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthConfig& operator=(AuthConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthConfig* internal_default_instance() {
    return reinterpret_cast<const AuthConfig*>(
               &_AuthConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AuthConfig& a, AuthConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AuthConfig& from) {
    AuthConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AuthConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.AuthConfig";
  }
  protected:
  explicit AuthConfig(::google::protobuf::Arena* arena);
  AuthConfig(::google::protobuf::Arena* arena, const AuthConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlersFieldNumber = 1,
    kTlsAuthEntitiesFieldNumber = 2,
    kExternalAuthConfigFieldNumber = 3,
  };
  // repeated .viam.app.v1.AuthHandlerConfig handlers = 1 [json_name = "handlers"];
  int handlers_size() const;
  private:
  int _internal_handlers_size() const;

  public:
  void clear_handlers() ;
  ::viam::app::v1::AuthHandlerConfig* mutable_handlers(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig >*
      mutable_handlers();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::AuthHandlerConfig>& _internal_handlers() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::AuthHandlerConfig>* _internal_mutable_handlers();
  public:
  const ::viam::app::v1::AuthHandlerConfig& handlers(int index) const;
  ::viam::app::v1::AuthHandlerConfig* add_handlers();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig >&
      handlers() const;
  // repeated string tls_auth_entities = 2 [json_name = "tlsAuthEntities"];
  int tls_auth_entities_size() const;
  private:
  int _internal_tls_auth_entities_size() const;

  public:
  void clear_tls_auth_entities() ;
  const std::string& tls_auth_entities(int index) const;
  std::string* mutable_tls_auth_entities(int index);
  void set_tls_auth_entities(int index, const std::string& value);
  void set_tls_auth_entities(int index, std::string&& value);
  void set_tls_auth_entities(int index, const char* value);
  void set_tls_auth_entities(int index, const char* value, std::size_t size);
  void set_tls_auth_entities(int index, absl::string_view value);
  std::string* add_tls_auth_entities();
  void add_tls_auth_entities(const std::string& value);
  void add_tls_auth_entities(std::string&& value);
  void add_tls_auth_entities(const char* value);
  void add_tls_auth_entities(const char* value, std::size_t size);
  void add_tls_auth_entities(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tls_auth_entities() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tls_auth_entities();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tls_auth_entities() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tls_auth_entities();

  public:
  // optional .viam.app.v1.ExternalAuthConfig external_auth_config = 3 [json_name = "externalAuthConfig"];
  bool has_external_auth_config() const;
  void clear_external_auth_config() ;
  const ::viam::app::v1::ExternalAuthConfig& external_auth_config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ExternalAuthConfig* release_external_auth_config();
  ::viam::app::v1::ExternalAuthConfig* mutable_external_auth_config();
  void set_allocated_external_auth_config(::viam::app::v1::ExternalAuthConfig* value);
  void unsafe_arena_set_allocated_external_auth_config(::viam::app::v1::ExternalAuthConfig* value);
  ::viam::app::v1::ExternalAuthConfig* unsafe_arena_release_external_auth_config();

  private:
  const ::viam::app::v1::ExternalAuthConfig& _internal_external_auth_config() const;
  ::viam::app::v1::ExternalAuthConfig* _internal_mutable_external_auth_config();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig > handlers_;
    ::google::protobuf::RepeatedPtrField<std::string> tls_auth_entities_;
    ::viam::app::v1::ExternalAuthConfig* external_auth_config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class RemoteConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoteConfig) */ {
 public:
  inline RemoteConfig() : RemoteConfig(nullptr) {}
  ~RemoteConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteConfig(::google::protobuf::internal::ConstantInitialized);

  inline RemoteConfig(const RemoteConfig& from)
      : RemoteConfig(nullptr, from) {}
  RemoteConfig(RemoteConfig&& from) noexcept
    : RemoteConfig() {
    *this = ::std::move(from);
  }

  inline RemoteConfig& operator=(const RemoteConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteConfig& operator=(RemoteConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteConfig* internal_default_instance() {
    return reinterpret_cast<const RemoteConfig*>(
               &_RemoteConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RemoteConfig& a, RemoteConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RemoteConfig& from) {
    RemoteConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemoteConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.RemoteConfig";
  }
  protected:
  explicit RemoteConfig(::google::protobuf::Arena* arena);
  RemoteConfig(::google::protobuf::Arena* arena, const RemoteConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceConfigsFieldNumber = 9,
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kManagedByFieldNumber = 5,
    kSecretFieldNumber = 10,
    kFrameFieldNumber = 3,
    kAuthFieldNumber = 4,
    kConnectionCheckIntervalFieldNumber = 7,
    kReconnectIntervalFieldNumber = 8,
    kInsecureFieldNumber = 6,
  };
  // repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 9 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
  int service_configs_size() const;
  private:
  int _internal_service_configs_size() const;

  public:
  void clear_service_configs() ;
  ::viam::app::v1::ResourceLevelServiceConfig* mutable_service_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
      mutable_service_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>& _internal_service_configs() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>* _internal_mutable_service_configs();
  public:
  const ::viam::app::v1::ResourceLevelServiceConfig& service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* add_service_configs();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
      service_configs() const;
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string managed_by = 5 [json_name = "managedBy"];
  void clear_managed_by() ;
  const std::string& managed_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_managed_by(Arg_&& arg, Args_... args);
  std::string* mutable_managed_by();
  PROTOBUF_NODISCARD std::string* release_managed_by();
  void set_allocated_managed_by(std::string* value);

  private:
  const std::string& _internal_managed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_managed_by(
      const std::string& value);
  std::string* _internal_mutable_managed_by();

  public:
  // string secret = 10 [json_name = "secret"];
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // .viam.app.v1.Frame frame = 3 [json_name = "frame"];
  bool has_frame() const;
  void clear_frame() ;
  const ::viam::app::v1::Frame& frame() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Frame* release_frame();
  ::viam::app::v1::Frame* mutable_frame();
  void set_allocated_frame(::viam::app::v1::Frame* value);
  void unsafe_arena_set_allocated_frame(::viam::app::v1::Frame* value);
  ::viam::app::v1::Frame* unsafe_arena_release_frame();

  private:
  const ::viam::app::v1::Frame& _internal_frame() const;
  ::viam::app::v1::Frame* _internal_mutable_frame();

  public:
  // .viam.app.v1.RemoteAuth auth = 4 [json_name = "auth"];
  bool has_auth() const;
  void clear_auth() ;
  const ::viam::app::v1::RemoteAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RemoteAuth* release_auth();
  ::viam::app::v1::RemoteAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::RemoteAuth* value);
  void unsafe_arena_set_allocated_auth(::viam::app::v1::RemoteAuth* value);
  ::viam::app::v1::RemoteAuth* unsafe_arena_release_auth();

  private:
  const ::viam::app::v1::RemoteAuth& _internal_auth() const;
  ::viam::app::v1::RemoteAuth* _internal_mutable_auth();

  public:
  // .google.protobuf.Duration connection_check_interval = 7 [json_name = "connectionCheckInterval"];
  bool has_connection_check_interval() const;
  void clear_connection_check_interval() ;
  const ::google::protobuf::Duration& connection_check_interval() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_connection_check_interval();
  ::google::protobuf::Duration* mutable_connection_check_interval();
  void set_allocated_connection_check_interval(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_connection_check_interval(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_connection_check_interval();

  private:
  const ::google::protobuf::Duration& _internal_connection_check_interval() const;
  ::google::protobuf::Duration* _internal_mutable_connection_check_interval();

  public:
  // .google.protobuf.Duration reconnect_interval = 8 [json_name = "reconnectInterval"];
  bool has_reconnect_interval() const;
  void clear_reconnect_interval() ;
  const ::google::protobuf::Duration& reconnect_interval() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_reconnect_interval();
  ::google::protobuf::Duration* mutable_reconnect_interval();
  void set_allocated_reconnect_interval(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_reconnect_interval(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_reconnect_interval();

  private:
  const ::google::protobuf::Duration& _internal_reconnect_interval() const;
  ::google::protobuf::Duration* _internal_mutable_reconnect_interval();

  public:
  // bool insecure = 6 [json_name = "insecure"];
  void clear_insecure() ;
  bool insecure() const;
  void set_insecure(bool value);

  private:
  bool _internal_insecure() const;
  void _internal_set_insecure(bool value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoteConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 5,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig > service_configs_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr managed_by_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::viam::app::v1::Frame* frame_;
    ::viam::app::v1::RemoteAuth* auth_;
    ::google::protobuf::Duration* connection_check_interval_;
    ::google::protobuf::Duration* reconnect_interval_;
    bool insecure_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ComponentConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ComponentConfig) */ {
 public:
  inline ComponentConfig() : ComponentConfig(nullptr) {}
  ~ComponentConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ComponentConfig(::google::protobuf::internal::ConstantInitialized);

  inline ComponentConfig(const ComponentConfig& from)
      : ComponentConfig(nullptr, from) {}
  ComponentConfig(ComponentConfig&& from) noexcept
    : ComponentConfig() {
    *this = ::std::move(from);
  }

  inline ComponentConfig& operator=(const ComponentConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComponentConfig& operator=(ComponentConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComponentConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComponentConfig* internal_default_instance() {
    return reinterpret_cast<const ComponentConfig*>(
               &_ComponentConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ComponentConfig& a, ComponentConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ComponentConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComponentConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComponentConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComponentConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComponentConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ComponentConfig& from) {
    ComponentConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ComponentConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ComponentConfig";
  }
  protected:
  explicit ComponentConfig(::google::protobuf::Arena* arena);
  ComponentConfig(::google::protobuf::Arena* arena, const ComponentConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependsOnFieldNumber = 6,
    kServiceConfigsFieldNumber = 7,
    kNameFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kTypeFieldNumber = 3,
    kModelFieldNumber = 4,
    kApiFieldNumber = 9,
    kFrameFieldNumber = 5,
    kAttributesFieldNumber = 8,
    kLogConfigurationFieldNumber = 10,
  };
  // repeated string depends_on = 6 [json_name = "dependsOn"];
  int depends_on_size() const;
  private:
  int _internal_depends_on_size() const;

  public:
  void clear_depends_on() ;
  const std::string& depends_on(int index) const;
  std::string* mutable_depends_on(int index);
  void set_depends_on(int index, const std::string& value);
  void set_depends_on(int index, std::string&& value);
  void set_depends_on(int index, const char* value);
  void set_depends_on(int index, const char* value, std::size_t size);
  void set_depends_on(int index, absl::string_view value);
  std::string* add_depends_on();
  void add_depends_on(const std::string& value);
  void add_depends_on(std::string&& value);
  void add_depends_on(const char* value);
  void add_depends_on(const char* value, std::size_t size);
  void add_depends_on(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& depends_on() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_depends_on();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_depends_on() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_depends_on();

  public:
  // repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 7 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
  int service_configs_size() const;
  private:
  int _internal_service_configs_size() const;

  public:
  void clear_service_configs() ;
  ::viam::app::v1::ResourceLevelServiceConfig* mutable_service_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
      mutable_service_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>& _internal_service_configs() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>* _internal_mutable_service_configs();
  public:
  const ::viam::app::v1::ResourceLevelServiceConfig& service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* add_service_configs();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
      service_configs() const;
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string namespace = 2 [json_name = "namespace"];
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* value);

  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(
      const std::string& value);
  std::string* _internal_mutable_namespace_();

  public:
  // string type = 3 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string model = 4 [json_name = "model"];
  void clear_model() ;
  const std::string& model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* value);

  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(
      const std::string& value);
  std::string* _internal_mutable_model();

  public:
  // string api = 9 [json_name = "api"];
  void clear_api() ;
  const std::string& api() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_api(Arg_&& arg, Args_... args);
  std::string* mutable_api();
  PROTOBUF_NODISCARD std::string* release_api();
  void set_allocated_api(std::string* value);

  private:
  const std::string& _internal_api() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api(
      const std::string& value);
  std::string* _internal_mutable_api();

  public:
  // .viam.app.v1.Frame frame = 5 [json_name = "frame"];
  bool has_frame() const;
  void clear_frame() ;
  const ::viam::app::v1::Frame& frame() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Frame* release_frame();
  ::viam::app::v1::Frame* mutable_frame();
  void set_allocated_frame(::viam::app::v1::Frame* value);
  void unsafe_arena_set_allocated_frame(::viam::app::v1::Frame* value);
  ::viam::app::v1::Frame* unsafe_arena_release_frame();

  private:
  const ::viam::app::v1::Frame& _internal_frame() const;
  ::viam::app::v1::Frame* _internal_mutable_frame();

  public:
  // .google.protobuf.Struct attributes = 8 [json_name = "attributes"];
  bool has_attributes() const;
  void clear_attributes() ;
  const ::google::protobuf::Struct& attributes() const;
  PROTOBUF_NODISCARD ::google::protobuf::Struct* release_attributes();
  ::google::protobuf::Struct* mutable_attributes();
  void set_allocated_attributes(::google::protobuf::Struct* value);
  void unsafe_arena_set_allocated_attributes(::google::protobuf::Struct* value);
  ::google::protobuf::Struct* unsafe_arena_release_attributes();

  private:
  const ::google::protobuf::Struct& _internal_attributes() const;
  ::google::protobuf::Struct* _internal_mutable_attributes();

  public:
  // .viam.app.v1.LogConfiguration log_configuration = 10 [json_name = "logConfiguration"];
  bool has_log_configuration() const;
  void clear_log_configuration() ;
  const ::viam::app::v1::LogConfiguration& log_configuration() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LogConfiguration* release_log_configuration();
  ::viam::app::v1::LogConfiguration* mutable_log_configuration();
  void set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value);
  void unsafe_arena_set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value);
  ::viam::app::v1::LogConfiguration* unsafe_arena_release_log_configuration();

  private:
  const ::viam::app::v1::LogConfiguration& _internal_log_configuration() const;
  ::viam::app::v1::LogConfiguration* _internal_mutable_log_configuration();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ComponentConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 4,
      79, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> depends_on_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig > service_configs_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr model_;
    ::google::protobuf::internal::ArenaStringPtr api_;
    ::viam::app::v1::Frame* frame_;
    ::google::protobuf::Struct* attributes_;
    ::viam::app::v1::LogConfiguration* log_configuration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class RobotConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotConfig) */ {
 public:
  inline RobotConfig() : RobotConfig(nullptr) {}
  ~RobotConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RobotConfig(::google::protobuf::internal::ConstantInitialized);

  inline RobotConfig(const RobotConfig& from)
      : RobotConfig(nullptr, from) {}
  RobotConfig(RobotConfig&& from) noexcept
    : RobotConfig() {
    *this = ::std::move(from);
  }

  inline RobotConfig& operator=(const RobotConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotConfig& operator=(RobotConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotConfig* internal_default_instance() {
    return reinterpret_cast<const RobotConfig*>(
               &_RobotConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RobotConfig& a, RobotConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RobotConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RobotConfig& from) {
    RobotConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RobotConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.RobotConfig";
  }
  protected:
  explicit RobotConfig(::google::protobuf::Arena* arena);
  RobotConfig(::google::protobuf::Arena* arena, const RobotConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemotesFieldNumber = 2,
    kComponentsFieldNumber = 3,
    kProcessesFieldNumber = 4,
    kServicesFieldNumber = 5,
    kModulesFieldNumber = 9,
    kPackagesFieldNumber = 11,
    kOverwriteFragmentStatusFieldNumber = 12,
    kCloudFieldNumber = 1,
    kNetworkFieldNumber = 6,
    kAuthFieldNumber = 7,
    kDebugFieldNumber = 8,
    kDisablePartialStartFieldNumber = 10,
    kEnableWebProfileFieldNumber = 13,
  };
  // repeated .viam.app.v1.RemoteConfig remotes = 2 [json_name = "remotes"];
  int remotes_size() const;
  private:
  int _internal_remotes_size() const;

  public:
  void clear_remotes() ;
  ::viam::app::v1::RemoteConfig* mutable_remotes(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::RemoteConfig >*
      mutable_remotes();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::RemoteConfig>& _internal_remotes() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::RemoteConfig>* _internal_mutable_remotes();
  public:
  const ::viam::app::v1::RemoteConfig& remotes(int index) const;
  ::viam::app::v1::RemoteConfig* add_remotes();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::RemoteConfig >&
      remotes() const;
  // repeated .viam.app.v1.ComponentConfig components = 3 [json_name = "components"];
  int components_size() const;
  private:
  int _internal_components_size() const;

  public:
  void clear_components() ;
  ::viam::app::v1::ComponentConfig* mutable_components(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ComponentConfig >*
      mutable_components();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ComponentConfig>& _internal_components() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::ComponentConfig>* _internal_mutable_components();
  public:
  const ::viam::app::v1::ComponentConfig& components(int index) const;
  ::viam::app::v1::ComponentConfig* add_components();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ComponentConfig >&
      components() const;
  // repeated .viam.app.v1.ProcessConfig processes = 4 [json_name = "processes"];
  int processes_size() const;
  private:
  int _internal_processes_size() const;

  public:
  void clear_processes() ;
  ::viam::app::v1::ProcessConfig* mutable_processes(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ProcessConfig >*
      mutable_processes();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ProcessConfig>& _internal_processes() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::ProcessConfig>* _internal_mutable_processes();
  public:
  const ::viam::app::v1::ProcessConfig& processes(int index) const;
  ::viam::app::v1::ProcessConfig* add_processes();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ProcessConfig >&
      processes() const;
  // repeated .viam.app.v1.ServiceConfig services = 5 [json_name = "services"];
  int services_size() const;
  private:
  int _internal_services_size() const;

  public:
  void clear_services() ;
  ::viam::app::v1::ServiceConfig* mutable_services(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ServiceConfig >*
      mutable_services();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ServiceConfig>& _internal_services() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::ServiceConfig>* _internal_mutable_services();
  public:
  const ::viam::app::v1::ServiceConfig& services(int index) const;
  ::viam::app::v1::ServiceConfig* add_services();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ServiceConfig >&
      services() const;
  // repeated .viam.app.v1.ModuleConfig modules = 9 [json_name = "modules"];
  int modules_size() const;
  private:
  int _internal_modules_size() const;

  public:
  void clear_modules() ;
  ::viam::app::v1::ModuleConfig* mutable_modules(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ModuleConfig >*
      mutable_modules();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ModuleConfig>& _internal_modules() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::ModuleConfig>* _internal_mutable_modules();
  public:
  const ::viam::app::v1::ModuleConfig& modules(int index) const;
  ::viam::app::v1::ModuleConfig* add_modules();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ModuleConfig >&
      modules() const;
  // repeated .viam.app.v1.PackageConfig packages = 11 [json_name = "packages"];
  int packages_size() const;
  private:
  int _internal_packages_size() const;

  public:
  void clear_packages() ;
  ::viam::app::v1::PackageConfig* mutable_packages(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::PackageConfig >*
      mutable_packages();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::PackageConfig>& _internal_packages() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::PackageConfig>* _internal_mutable_packages();
  public:
  const ::viam::app::v1::PackageConfig& packages(int index) const;
  ::viam::app::v1::PackageConfig* add_packages();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::PackageConfig >&
      packages() const;
  // repeated .viam.app.v1.AppValidationStatus overwrite_fragment_status = 12 [json_name = "overwriteFragmentStatus"];
  int overwrite_fragment_status_size() const;
  private:
  int _internal_overwrite_fragment_status_size() const;

  public:
  void clear_overwrite_fragment_status() ;
  ::viam::app::v1::AppValidationStatus* mutable_overwrite_fragment_status(int index);
  ::google::protobuf::RepeatedPtrField< ::viam::app::v1::AppValidationStatus >*
      mutable_overwrite_fragment_status();
  private:
  const ::google::protobuf::RepeatedPtrField<::viam::app::v1::AppValidationStatus>& _internal_overwrite_fragment_status() const;
  ::google::protobuf::RepeatedPtrField<::viam::app::v1::AppValidationStatus>* _internal_mutable_overwrite_fragment_status();
  public:
  const ::viam::app::v1::AppValidationStatus& overwrite_fragment_status(int index) const;
  ::viam::app::v1::AppValidationStatus* add_overwrite_fragment_status();
  const ::google::protobuf::RepeatedPtrField< ::viam::app::v1::AppValidationStatus >&
      overwrite_fragment_status() const;
  // .viam.app.v1.CloudConfig cloud = 1 [json_name = "cloud"];
  bool has_cloud() const;
  void clear_cloud() ;
  const ::viam::app::v1::CloudConfig& cloud() const;
  PROTOBUF_NODISCARD ::viam::app::v1::CloudConfig* release_cloud();
  ::viam::app::v1::CloudConfig* mutable_cloud();
  void set_allocated_cloud(::viam::app::v1::CloudConfig* value);
  void unsafe_arena_set_allocated_cloud(::viam::app::v1::CloudConfig* value);
  ::viam::app::v1::CloudConfig* unsafe_arena_release_cloud();

  private:
  const ::viam::app::v1::CloudConfig& _internal_cloud() const;
  ::viam::app::v1::CloudConfig* _internal_mutable_cloud();

  public:
  // optional .viam.app.v1.NetworkConfig network = 6 [json_name = "network"];
  bool has_network() const;
  void clear_network() ;
  const ::viam::app::v1::NetworkConfig& network() const;
  PROTOBUF_NODISCARD ::viam::app::v1::NetworkConfig* release_network();
  ::viam::app::v1::NetworkConfig* mutable_network();
  void set_allocated_network(::viam::app::v1::NetworkConfig* value);
  void unsafe_arena_set_allocated_network(::viam::app::v1::NetworkConfig* value);
  ::viam::app::v1::NetworkConfig* unsafe_arena_release_network();

  private:
  const ::viam::app::v1::NetworkConfig& _internal_network() const;
  ::viam::app::v1::NetworkConfig* _internal_mutable_network();

  public:
  // optional .viam.app.v1.AuthConfig auth = 7 [json_name = "auth"];
  bool has_auth() const;
  void clear_auth() ;
  const ::viam::app::v1::AuthConfig& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AuthConfig* release_auth();
  ::viam::app::v1::AuthConfig* mutable_auth();
  void set_allocated_auth(::viam::app::v1::AuthConfig* value);
  void unsafe_arena_set_allocated_auth(::viam::app::v1::AuthConfig* value);
  ::viam::app::v1::AuthConfig* unsafe_arena_release_auth();

  private:
  const ::viam::app::v1::AuthConfig& _internal_auth() const;
  ::viam::app::v1::AuthConfig* _internal_mutable_auth();

  public:
  // optional bool debug = 8 [json_name = "debug"];
  bool has_debug() const;
  void clear_debug() ;
  bool debug() const;
  void set_debug(bool value);

  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);

  public:
  // optional bool disable_partial_start = 10 [json_name = "disablePartialStart"];
  bool has_disable_partial_start() const;
  void clear_disable_partial_start() ;
  bool disable_partial_start() const;
  void set_disable_partial_start(bool value);

  private:
  bool _internal_disable_partial_start() const;
  void _internal_set_disable_partial_start(bool value);

  public:
  // bool enable_web_profile = 13 [json_name = "enableWebProfile"];
  void clear_enable_web_profile() ;
  bool enable_web_profile() const;
  void set_enable_web_profile(bool value);

  private:
  bool _internal_enable_web_profile() const;
  void _internal_set_enable_web_profile(bool value);

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 10,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::RemoteConfig > remotes_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ComponentConfig > components_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ProcessConfig > processes_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ServiceConfig > services_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::ModuleConfig > modules_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::PackageConfig > packages_;
    ::google::protobuf::RepeatedPtrField< ::viam::app::v1::AppValidationStatus > overwrite_fragment_status_;
    ::viam::app::v1::CloudConfig* cloud_;
    ::viam::app::v1::NetworkConfig* network_;
    ::viam::app::v1::AuthConfig* auth_;
    bool debug_;
    bool disable_partial_start_;
    bool enable_web_profile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};// -------------------------------------------------------------------

class ConfigResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ConfigResponse) */ {
 public:
  inline ConfigResponse() : ConfigResponse(nullptr) {}
  ~ConfigResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigResponse(::google::protobuf::internal::ConstantInitialized);

  inline ConfigResponse(const ConfigResponse& from)
      : ConfigResponse(nullptr, from) {}
  ConfigResponse(ConfigResponse&& from) noexcept
    : ConfigResponse() {
    *this = ::std::move(from);
  }

  inline ConfigResponse& operator=(const ConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigResponse& operator=(ConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigResponse*>(
               &_ConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ConfigResponse& a, ConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfigResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConfigResponse& from) {
    ConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfigResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "viam.app.v1.ConfigResponse";
  }
  protected:
  explicit ConfigResponse(::google::protobuf::Arena* arena);
  ConfigResponse(::google::protobuf::Arena* arena, const ConfigResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .viam.app.v1.RobotConfig config = 1 [json_name = "config"];
  bool has_config() const;
  void clear_config() ;
  const ::viam::app::v1::RobotConfig& config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotConfig* release_config();
  ::viam::app::v1::RobotConfig* mutable_config();
  void set_allocated_config(::viam::app::v1::RobotConfig* value);
  void unsafe_arena_set_allocated_config(::viam::app::v1::RobotConfig* value);
  ::viam::app::v1::RobotConfig* unsafe_arena_release_config();

  private:
  const ::viam::app::v1::RobotConfig& _internal_config() const;
  ::viam::app::v1::RobotConfig* _internal_mutable_config();

  public:
  // @@protoc_insertion_point(class_scope:viam.app.v1.ConfigResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::viam::app::v1::RobotConfig* config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RobotConfig

// .viam.app.v1.CloudConfig cloud = 1 [json_name = "cloud"];
inline bool RobotConfig::has_cloud() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cloud_ != nullptr);
  return value;
}
inline void RobotConfig::clear_cloud() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cloud_ != nullptr) _impl_.cloud_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::CloudConfig& RobotConfig::_internal_cloud() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::CloudConfig* p = _impl_.cloud_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::CloudConfig&>(::viam::app::v1::_CloudConfig_default_instance_);
}
inline const ::viam::app::v1::CloudConfig& RobotConfig::cloud() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.cloud)
  return _internal_cloud();
}
inline void RobotConfig::unsafe_arena_set_allocated_cloud(::viam::app::v1::CloudConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cloud_);
  }
  _impl_.cloud_ = reinterpret_cast<::viam::app::v1::CloudConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotConfig.cloud)
}
inline ::viam::app::v1::CloudConfig* RobotConfig::release_cloud() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::CloudConfig* released = _impl_.cloud_;
  _impl_.cloud_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::CloudConfig* RobotConfig::unsafe_arena_release_cloud() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.cloud)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::CloudConfig* temp = _impl_.cloud_;
  _impl_.cloud_ = nullptr;
  return temp;
}
inline ::viam::app::v1::CloudConfig* RobotConfig::_internal_mutable_cloud() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cloud_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::CloudConfig>(GetArena());
    _impl_.cloud_ = reinterpret_cast<::viam::app::v1::CloudConfig*>(p);
  }
  return _impl_.cloud_;
}
inline ::viam::app::v1::CloudConfig* RobotConfig::mutable_cloud() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::CloudConfig* _msg = _internal_mutable_cloud();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.cloud)
  return _msg;
}
inline void RobotConfig::set_allocated_cloud(::viam::app::v1::CloudConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::CloudConfig*>(_impl_.cloud_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::CloudConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.cloud_ = reinterpret_cast<::viam::app::v1::CloudConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.cloud)
}

// repeated .viam.app.v1.RemoteConfig remotes = 2 [json_name = "remotes"];
inline int RobotConfig::_internal_remotes_size() const {
  return _internal_remotes().size();
}
inline int RobotConfig::remotes_size() const {
  return _internal_remotes_size();
}
inline void RobotConfig::clear_remotes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remotes_.Clear();
}
inline ::viam::app::v1::RemoteConfig* RobotConfig::mutable_remotes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.remotes)
  return _internal_mutable_remotes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::RemoteConfig>* RobotConfig::mutable_remotes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.remotes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_remotes();
}
inline const ::viam::app::v1::RemoteConfig& RobotConfig::remotes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.remotes)
  return _internal_remotes().Get(index);
}
inline ::viam::app::v1::RemoteConfig* RobotConfig::add_remotes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::RemoteConfig* _add = _internal_mutable_remotes()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.remotes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::RemoteConfig>& RobotConfig::remotes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.remotes)
  return _internal_remotes();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::RemoteConfig>&
RobotConfig::_internal_remotes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remotes_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::RemoteConfig>*
RobotConfig::_internal_mutable_remotes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.remotes_;
}

// repeated .viam.app.v1.ComponentConfig components = 3 [json_name = "components"];
inline int RobotConfig::_internal_components_size() const {
  return _internal_components().size();
}
inline int RobotConfig::components_size() const {
  return _internal_components_size();
}
inline void RobotConfig::clear_components() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.components_.Clear();
}
inline ::viam::app::v1::ComponentConfig* RobotConfig::mutable_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.components)
  return _internal_mutable_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ComponentConfig>* RobotConfig::mutable_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.components)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_components();
}
inline const ::viam::app::v1::ComponentConfig& RobotConfig::components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.components)
  return _internal_components().Get(index);
}
inline ::viam::app::v1::ComponentConfig* RobotConfig::add_components() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::ComponentConfig* _add = _internal_mutable_components()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ComponentConfig>& RobotConfig::components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.components)
  return _internal_components();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ComponentConfig>&
RobotConfig::_internal_components() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.components_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ComponentConfig>*
RobotConfig::_internal_mutable_components() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.components_;
}

// repeated .viam.app.v1.ProcessConfig processes = 4 [json_name = "processes"];
inline int RobotConfig::_internal_processes_size() const {
  return _internal_processes().size();
}
inline int RobotConfig::processes_size() const {
  return _internal_processes_size();
}
inline void RobotConfig::clear_processes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.processes_.Clear();
}
inline ::viam::app::v1::ProcessConfig* RobotConfig::mutable_processes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.processes)
  return _internal_mutable_processes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ProcessConfig>* RobotConfig::mutable_processes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.processes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_processes();
}
inline const ::viam::app::v1::ProcessConfig& RobotConfig::processes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.processes)
  return _internal_processes().Get(index);
}
inline ::viam::app::v1::ProcessConfig* RobotConfig::add_processes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::ProcessConfig* _add = _internal_mutable_processes()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.processes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ProcessConfig>& RobotConfig::processes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.processes)
  return _internal_processes();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ProcessConfig>&
RobotConfig::_internal_processes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.processes_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ProcessConfig>*
RobotConfig::_internal_mutable_processes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.processes_;
}

// repeated .viam.app.v1.ServiceConfig services = 5 [json_name = "services"];
inline int RobotConfig::_internal_services_size() const {
  return _internal_services().size();
}
inline int RobotConfig::services_size() const {
  return _internal_services_size();
}
inline void RobotConfig::clear_services() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.services_.Clear();
}
inline ::viam::app::v1::ServiceConfig* RobotConfig::mutable_services(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.services)
  return _internal_mutable_services()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ServiceConfig>* RobotConfig::mutable_services()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.services)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_services();
}
inline const ::viam::app::v1::ServiceConfig& RobotConfig::services(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.services)
  return _internal_services().Get(index);
}
inline ::viam::app::v1::ServiceConfig* RobotConfig::add_services() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::ServiceConfig* _add = _internal_mutable_services()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.services)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ServiceConfig>& RobotConfig::services() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.services)
  return _internal_services();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ServiceConfig>&
RobotConfig::_internal_services() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.services_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ServiceConfig>*
RobotConfig::_internal_mutable_services() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.services_;
}

// optional .viam.app.v1.NetworkConfig network = 6 [json_name = "network"];
inline bool RobotConfig::has_network() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.network_ != nullptr);
  return value;
}
inline void RobotConfig::clear_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.network_ != nullptr) _impl_.network_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::app::v1::NetworkConfig& RobotConfig::_internal_network() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::NetworkConfig* p = _impl_.network_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::NetworkConfig&>(::viam::app::v1::_NetworkConfig_default_instance_);
}
inline const ::viam::app::v1::NetworkConfig& RobotConfig::network() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.network)
  return _internal_network();
}
inline void RobotConfig::unsafe_arena_set_allocated_network(::viam::app::v1::NetworkConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.network_);
  }
  _impl_.network_ = reinterpret_cast<::viam::app::v1::NetworkConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotConfig.network)
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::NetworkConfig* released = _impl_.network_;
  _impl_.network_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::unsafe_arena_release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.network)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::NetworkConfig* temp = _impl_.network_;
  _impl_.network_ = nullptr;
  return temp;
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::_internal_mutable_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.network_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::NetworkConfig>(GetArena());
    _impl_.network_ = reinterpret_cast<::viam::app::v1::NetworkConfig*>(p);
  }
  return _impl_.network_;
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::mutable_network() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::NetworkConfig* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.network)
  return _msg;
}
inline void RobotConfig::set_allocated_network(::viam::app::v1::NetworkConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::NetworkConfig*>(_impl_.network_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::NetworkConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.network_ = reinterpret_cast<::viam::app::v1::NetworkConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.network)
}

// optional .viam.app.v1.AuthConfig auth = 7 [json_name = "auth"];
inline bool RobotConfig::has_auth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auth_ != nullptr);
  return value;
}
inline void RobotConfig::clear_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.auth_ != nullptr) _impl_.auth_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::viam::app::v1::AuthConfig& RobotConfig::_internal_auth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::AuthConfig* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AuthConfig&>(::viam::app::v1::_AuthConfig_default_instance_);
}
inline const ::viam::app::v1::AuthConfig& RobotConfig::auth() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.auth)
  return _internal_auth();
}
inline void RobotConfig::unsafe_arena_set_allocated_auth(::viam::app::v1::AuthConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = reinterpret_cast<::viam::app::v1::AuthConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotConfig.auth)
}
inline ::viam::app::v1::AuthConfig* RobotConfig::release_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::app::v1::AuthConfig* released = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::AuthConfig* RobotConfig::unsafe_arena_release_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.auth)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::app::v1::AuthConfig* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AuthConfig* RobotConfig::_internal_mutable_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AuthConfig>(GetArena());
    _impl_.auth_ = reinterpret_cast<::viam::app::v1::AuthConfig*>(p);
  }
  return _impl_.auth_;
}
inline ::viam::app::v1::AuthConfig* RobotConfig::mutable_auth() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::AuthConfig* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.auth)
  return _msg;
}
inline void RobotConfig::set_allocated_auth(::viam::app::v1::AuthConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::AuthConfig*>(_impl_.auth_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::AuthConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.auth_ = reinterpret_cast<::viam::app::v1::AuthConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.auth)
}

// optional bool debug = 8 [json_name = "debug"];
inline bool RobotConfig::has_debug() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RobotConfig::clear_debug() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.debug_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RobotConfig::debug() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.debug)
  return _internal_debug();
}
inline void RobotConfig::set_debug(bool value) {
  _internal_set_debug(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.debug)
}
inline bool RobotConfig::_internal_debug() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.debug_;
}
inline void RobotConfig::_internal_set_debug(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.debug_ = value;
}

// repeated .viam.app.v1.ModuleConfig modules = 9 [json_name = "modules"];
inline int RobotConfig::_internal_modules_size() const {
  return _internal_modules().size();
}
inline int RobotConfig::modules_size() const {
  return _internal_modules_size();
}
inline void RobotConfig::clear_modules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modules_.Clear();
}
inline ::viam::app::v1::ModuleConfig* RobotConfig::mutable_modules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.modules)
  return _internal_mutable_modules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ModuleConfig>* RobotConfig::mutable_modules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.modules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_modules();
}
inline const ::viam::app::v1::ModuleConfig& RobotConfig::modules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.modules)
  return _internal_modules().Get(index);
}
inline ::viam::app::v1::ModuleConfig* RobotConfig::add_modules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::ModuleConfig* _add = _internal_mutable_modules()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.modules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ModuleConfig>& RobotConfig::modules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.modules)
  return _internal_modules();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ModuleConfig>&
RobotConfig::_internal_modules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modules_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ModuleConfig>*
RobotConfig::_internal_mutable_modules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.modules_;
}

// optional bool disable_partial_start = 10 [json_name = "disablePartialStart"];
inline bool RobotConfig::has_disable_partial_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RobotConfig::clear_disable_partial_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_partial_start_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RobotConfig::disable_partial_start() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.disable_partial_start)
  return _internal_disable_partial_start();
}
inline void RobotConfig::set_disable_partial_start(bool value) {
  _internal_set_disable_partial_start(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.disable_partial_start)
}
inline bool RobotConfig::_internal_disable_partial_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_partial_start_;
}
inline void RobotConfig::_internal_set_disable_partial_start(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.disable_partial_start_ = value;
}

// repeated .viam.app.v1.PackageConfig packages = 11 [json_name = "packages"];
inline int RobotConfig::_internal_packages_size() const {
  return _internal_packages().size();
}
inline int RobotConfig::packages_size() const {
  return _internal_packages_size();
}
inline void RobotConfig::clear_packages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packages_.Clear();
}
inline ::viam::app::v1::PackageConfig* RobotConfig::mutable_packages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.packages)
  return _internal_mutable_packages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::PackageConfig>* RobotConfig::mutable_packages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.packages)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_packages();
}
inline const ::viam::app::v1::PackageConfig& RobotConfig::packages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.packages)
  return _internal_packages().Get(index);
}
inline ::viam::app::v1::PackageConfig* RobotConfig::add_packages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::PackageConfig* _add = _internal_mutable_packages()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.packages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::PackageConfig>& RobotConfig::packages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.packages)
  return _internal_packages();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::PackageConfig>&
RobotConfig::_internal_packages() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packages_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::PackageConfig>*
RobotConfig::_internal_mutable_packages() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.packages_;
}

// repeated .viam.app.v1.AppValidationStatus overwrite_fragment_status = 12 [json_name = "overwriteFragmentStatus"];
inline int RobotConfig::_internal_overwrite_fragment_status_size() const {
  return _internal_overwrite_fragment_status().size();
}
inline int RobotConfig::overwrite_fragment_status_size() const {
  return _internal_overwrite_fragment_status_size();
}
inline void RobotConfig::clear_overwrite_fragment_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.overwrite_fragment_status_.Clear();
}
inline ::viam::app::v1::AppValidationStatus* RobotConfig::mutable_overwrite_fragment_status(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return _internal_mutable_overwrite_fragment_status()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::AppValidationStatus>* RobotConfig::mutable_overwrite_fragment_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.overwrite_fragment_status)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_overwrite_fragment_status();
}
inline const ::viam::app::v1::AppValidationStatus& RobotConfig::overwrite_fragment_status(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return _internal_overwrite_fragment_status().Get(index);
}
inline ::viam::app::v1::AppValidationStatus* RobotConfig::add_overwrite_fragment_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::AppValidationStatus* _add = _internal_mutable_overwrite_fragment_status()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::AppValidationStatus>& RobotConfig::overwrite_fragment_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return _internal_overwrite_fragment_status();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::AppValidationStatus>&
RobotConfig::_internal_overwrite_fragment_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.overwrite_fragment_status_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::AppValidationStatus>*
RobotConfig::_internal_mutable_overwrite_fragment_status() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.overwrite_fragment_status_;
}

// bool enable_web_profile = 13 [json_name = "enableWebProfile"];
inline void RobotConfig::clear_enable_web_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_web_profile_ = false;
}
inline bool RobotConfig::enable_web_profile() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.enable_web_profile)
  return _internal_enable_web_profile();
}
inline void RobotConfig::set_enable_web_profile(bool value) {
  _internal_set_enable_web_profile(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.enable_web_profile)
}
inline bool RobotConfig::_internal_enable_web_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_web_profile_;
}
inline void RobotConfig::_internal_set_enable_web_profile(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_web_profile_ = value;
}

// -------------------------------------------------------------------

// LocationSecret

// string id = 1 [json_name = "id"];
inline void LocationSecret::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& LocationSecret::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationSecret.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocationSecret::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationSecret.id)
}
inline std::string* LocationSecret::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationSecret.id)
  return _s;
}
inline const std::string& LocationSecret::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void LocationSecret::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* LocationSecret::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* LocationSecret::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationSecret.id)
  return _impl_.id_.Release();
}
inline void LocationSecret::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationSecret.id)
}

// string secret = 2 [json_name = "secret"];
inline void LocationSecret::clear_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& LocationSecret::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationSecret.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocationSecret::set_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationSecret.secret)
}
inline std::string* LocationSecret::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationSecret.secret)
  return _s;
}
inline const std::string& LocationSecret::_internal_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secret_.Get();
}
inline void LocationSecret::_internal_set_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* LocationSecret::_internal_mutable_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* LocationSecret::release_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationSecret.secret)
  return _impl_.secret_.Release();
}
inline void LocationSecret::set_allocated_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationSecret.secret)
}

// -------------------------------------------------------------------

// AppValidationStatus

// string error = 1 [json_name = "error"];
inline void AppValidationStatus::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& AppValidationStatus::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AppValidationStatus.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AppValidationStatus::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.AppValidationStatus.error)
}
inline std::string* AppValidationStatus::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AppValidationStatus.error)
  return _s;
}
inline const std::string& AppValidationStatus::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void AppValidationStatus::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* AppValidationStatus::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* AppValidationStatus::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AppValidationStatus.error)
  return _impl_.error_.Release();
}
inline void AppValidationStatus::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AppValidationStatus.error)
}

// -------------------------------------------------------------------

// CloudConfig

// string id = 1 [json_name = "id"];
inline void CloudConfig::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CloudConfig::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.id)
}
inline std::string* CloudConfig::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.id)
  return _s;
}
inline const std::string& CloudConfig::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CloudConfig::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.id)
  return _impl_.id_.Release();
}
inline void CloudConfig::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.id)
}

// string fqdn = 2 [json_name = "fqdn"];
inline void CloudConfig::clear_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fqdn_.ClearToEmpty();
}
inline const std::string& CloudConfig::fqdn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.fqdn)
  return _internal_fqdn();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_fqdn(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fqdn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.fqdn)
}
inline std::string* CloudConfig::mutable_fqdn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.fqdn)
  return _s;
}
inline const std::string& CloudConfig::_internal_fqdn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fqdn_.Get();
}
inline void CloudConfig::_internal_set_fqdn(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fqdn_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fqdn_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.fqdn)
  return _impl_.fqdn_.Release();
}
inline void CloudConfig::set_allocated_fqdn(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fqdn_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fqdn_.IsDefault()) {
          _impl_.fqdn_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.fqdn)
}

// string local_fqdn = 3 [json_name = "localFqdn"];
inline void CloudConfig::clear_local_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_fqdn_.ClearToEmpty();
}
inline const std::string& CloudConfig::local_fqdn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.local_fqdn)
  return _internal_local_fqdn();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_local_fqdn(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.local_fqdn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.local_fqdn)
}
inline std::string* CloudConfig::mutable_local_fqdn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.local_fqdn)
  return _s;
}
inline const std::string& CloudConfig::_internal_local_fqdn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_fqdn_.Get();
}
inline void CloudConfig::_internal_set_local_fqdn(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.local_fqdn_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_local_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.local_fqdn_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_local_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.local_fqdn)
  return _impl_.local_fqdn_.Release();
}
inline void CloudConfig::set_allocated_local_fqdn(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_fqdn_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.local_fqdn_.IsDefault()) {
          _impl_.local_fqdn_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.local_fqdn)
}

// string managed_by = 4 [json_name = "managedBy"];
inline void CloudConfig::clear_managed_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.managed_by_.ClearToEmpty();
}
inline const std::string& CloudConfig::managed_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.managed_by)
  return _internal_managed_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_managed_by(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.managed_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.managed_by)
}
inline std::string* CloudConfig::mutable_managed_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_managed_by();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.managed_by)
  return _s;
}
inline const std::string& CloudConfig::_internal_managed_by() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.managed_by_.Get();
}
inline void CloudConfig::_internal_set_managed_by(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.managed_by_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_managed_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.managed_by_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_managed_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.managed_by)
  return _impl_.managed_by_.Release();
}
inline void CloudConfig::set_allocated_managed_by(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.managed_by_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.managed_by_.IsDefault()) {
          _impl_.managed_by_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.managed_by)
}

// string signaling_address = 5 [json_name = "signalingAddress"];
inline void CloudConfig::clear_signaling_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signaling_address_.ClearToEmpty();
}
inline const std::string& CloudConfig::signaling_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.signaling_address)
  return _internal_signaling_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_signaling_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.signaling_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.signaling_address)
}
inline std::string* CloudConfig::mutable_signaling_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signaling_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.signaling_address)
  return _s;
}
inline const std::string& CloudConfig::_internal_signaling_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signaling_address_.Get();
}
inline void CloudConfig::_internal_set_signaling_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.signaling_address_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_signaling_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.signaling_address_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_signaling_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.signaling_address)
  return _impl_.signaling_address_.Release();
}
inline void CloudConfig::set_allocated_signaling_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signaling_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signaling_address_.IsDefault()) {
          _impl_.signaling_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.signaling_address)
}

// bool signaling_insecure = 6 [json_name = "signalingInsecure"];
inline void CloudConfig::clear_signaling_insecure() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signaling_insecure_ = false;
}
inline bool CloudConfig::signaling_insecure() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.signaling_insecure)
  return _internal_signaling_insecure();
}
inline void CloudConfig::set_signaling_insecure(bool value) {
  _internal_set_signaling_insecure(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.signaling_insecure)
}
inline bool CloudConfig::_internal_signaling_insecure() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signaling_insecure_;
}
inline void CloudConfig::_internal_set_signaling_insecure(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.signaling_insecure_ = value;
}

// string location_secret = 7 [json_name = "locationSecret", deprecated = true];
inline void CloudConfig::clear_location_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_secret_.ClearToEmpty();
}
inline const std::string& CloudConfig::location_secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.location_secret)
  return _internal_location_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_location_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.location_secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.location_secret)
}
inline std::string* CloudConfig::mutable_location_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_location_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.location_secret)
  return _s;
}
inline const std::string& CloudConfig::_internal_location_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_secret_.Get();
}
inline void CloudConfig::_internal_set_location_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.location_secret_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_location_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.location_secret_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_location_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.location_secret)
  return _impl_.location_secret_.Release();
}
inline void CloudConfig::set_allocated_location_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_secret_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_secret_.IsDefault()) {
          _impl_.location_secret_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.location_secret)
}

// string secret = 8 [json_name = "secret"];
inline void CloudConfig::clear_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& CloudConfig::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.secret)
}
inline std::string* CloudConfig::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.secret)
  return _s;
}
inline const std::string& CloudConfig::_internal_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secret_.Get();
}
inline void CloudConfig::_internal_set_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.secret)
  return _impl_.secret_.Release();
}
inline void CloudConfig::set_allocated_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.secret)
}

// repeated .viam.app.v1.LocationSecret location_secrets = 9 [json_name = "locationSecrets"];
inline int CloudConfig::_internal_location_secrets_size() const {
  return _internal_location_secrets().size();
}
inline int CloudConfig::location_secrets_size() const {
  return _internal_location_secrets_size();
}
inline void CloudConfig::clear_location_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_secrets_.Clear();
}
inline ::viam::app::v1::LocationSecret* CloudConfig::mutable_location_secrets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.location_secrets)
  return _internal_mutable_location_secrets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::LocationSecret>* CloudConfig::mutable_location_secrets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CloudConfig.location_secrets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_location_secrets();
}
inline const ::viam::app::v1::LocationSecret& CloudConfig::location_secrets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.location_secrets)
  return _internal_location_secrets().Get(index);
}
inline ::viam::app::v1::LocationSecret* CloudConfig::add_location_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::LocationSecret* _add = _internal_mutable_location_secrets()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.CloudConfig.location_secrets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::LocationSecret>& CloudConfig::location_secrets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.CloudConfig.location_secrets)
  return _internal_location_secrets();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::LocationSecret>&
CloudConfig::_internal_location_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_secrets_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::LocationSecret>*
CloudConfig::_internal_mutable_location_secrets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.location_secrets_;
}

// string primary_org_id = 10 [json_name = "primaryOrgId"];
inline void CloudConfig::clear_primary_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.primary_org_id_.ClearToEmpty();
}
inline const std::string& CloudConfig::primary_org_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.primary_org_id)
  return _internal_primary_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_primary_org_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.primary_org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.primary_org_id)
}
inline std::string* CloudConfig::mutable_primary_org_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_primary_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.primary_org_id)
  return _s;
}
inline const std::string& CloudConfig::_internal_primary_org_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.primary_org_id_.Get();
}
inline void CloudConfig::_internal_set_primary_org_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.primary_org_id_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_primary_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.primary_org_id_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_primary_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.primary_org_id)
  return _impl_.primary_org_id_.Release();
}
inline void CloudConfig::set_allocated_primary_org_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.primary_org_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.primary_org_id_.IsDefault()) {
          _impl_.primary_org_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.primary_org_id)
}

// string location_id = 11 [json_name = "locationId"];
inline void CloudConfig::clear_location_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& CloudConfig::location_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.location_id)
  return _internal_location_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_location_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.location_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.location_id)
}
inline std::string* CloudConfig::mutable_location_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.location_id)
  return _s;
}
inline const std::string& CloudConfig::_internal_location_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_id_.Get();
}
inline void CloudConfig::_internal_set_location_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.location_id_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_location_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.location_id_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_location_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.location_id)
  return _impl_.location_id_.Release();
}
inline void CloudConfig::set_allocated_location_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_id_.IsDefault()) {
          _impl_.location_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.location_id)
}

// string machine_id = 12 [json_name = "machineId"];
inline void CloudConfig::clear_machine_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.machine_id_.ClearToEmpty();
}
inline const std::string& CloudConfig::machine_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.machine_id)
  return _internal_machine_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloudConfig::set_machine_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.machine_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.machine_id)
}
inline std::string* CloudConfig::mutable_machine_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.machine_id)
  return _s;
}
inline const std::string& CloudConfig::_internal_machine_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.machine_id_.Get();
}
inline void CloudConfig::_internal_set_machine_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.machine_id_.Set(value, GetArena());
}
inline std::string* CloudConfig::_internal_mutable_machine_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.machine_id_.Mutable( GetArena());
}
inline std::string* CloudConfig::release_machine_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.machine_id)
  return _impl_.machine_id_.Release();
}
inline void CloudConfig::set_allocated_machine_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.machine_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.machine_id_.IsDefault()) {
          _impl_.machine_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.machine_id)
}

// -------------------------------------------------------------------

// ComponentConfig

// string name = 1 [json_name = "name"];
inline void ComponentConfig::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ComponentConfig::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ComponentConfig::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.name)
}
inline std::string* ComponentConfig::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.name)
  return _s;
}
inline const std::string& ComponentConfig::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ComponentConfig::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ComponentConfig::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ComponentConfig::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.name)
  return _impl_.name_.Release();
}
inline void ComponentConfig::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.name)
}

// string namespace = 2 [json_name = "namespace"];
inline void ComponentConfig::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& ComponentConfig::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ComponentConfig::set_namespace_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.namespace)
}
inline std::string* ComponentConfig::mutable_namespace_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.namespace)
  return _s;
}
inline const std::string& ComponentConfig::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__.Get();
}
inline void ComponentConfig::_internal_set_namespace_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* ComponentConfig::_internal_mutable_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* ComponentConfig::release_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.namespace)
  return _impl_.namespace__.Release();
}
inline void ComponentConfig::set_allocated_namespace_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.namespace__.IsDefault()) {
          _impl_.namespace__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.namespace)
}

// string type = 3 [json_name = "type"];
inline void ComponentConfig::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ComponentConfig::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ComponentConfig::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.type)
}
inline std::string* ComponentConfig::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.type)
  return _s;
}
inline const std::string& ComponentConfig::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void ComponentConfig::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* ComponentConfig::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* ComponentConfig::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.type)
  return _impl_.type_.Release();
}
inline void ComponentConfig::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.type)
}

// string model = 4 [json_name = "model"];
inline void ComponentConfig::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.ClearToEmpty();
}
inline const std::string& ComponentConfig::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ComponentConfig::set_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.model)
}
inline std::string* ComponentConfig::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.model)
  return _s;
}
inline const std::string& ComponentConfig::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_.Get();
}
inline void ComponentConfig::_internal_set_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(value, GetArena());
}
inline std::string* ComponentConfig::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_.Mutable( GetArena());
}
inline std::string* ComponentConfig::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.model)
  return _impl_.model_.Release();
}
inline void ComponentConfig::set_allocated_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_.IsDefault()) {
          _impl_.model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.model)
}

// .viam.app.v1.Frame frame = 5 [json_name = "frame"];
inline bool ComponentConfig::has_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frame_ != nullptr);
  return value;
}
inline void ComponentConfig::clear_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.frame_ != nullptr) _impl_.frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::Frame& ComponentConfig::_internal_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::Frame* p = _impl_.frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Frame&>(::viam::app::v1::_Frame_default_instance_);
}
inline const ::viam::app::v1::Frame& ComponentConfig::frame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.frame)
  return _internal_frame();
}
inline void ComponentConfig::unsafe_arena_set_allocated_frame(::viam::app::v1::Frame* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.frame_);
  }
  _impl_.frame_ = reinterpret_cast<::viam::app::v1::Frame*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ComponentConfig.frame)
}
inline ::viam::app::v1::Frame* ComponentConfig::release_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::Frame* released = _impl_.frame_;
  _impl_.frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::Frame* ComponentConfig::unsafe_arena_release_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.frame)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::Frame* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Frame* ComponentConfig::_internal_mutable_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Frame>(GetArena());
    _impl_.frame_ = reinterpret_cast<::viam::app::v1::Frame*>(p);
  }
  return _impl_.frame_;
}
inline ::viam::app::v1::Frame* ComponentConfig::mutable_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Frame* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.frame)
  return _msg;
}
inline void ComponentConfig::set_allocated_frame(::viam::app::v1::Frame* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::Frame*>(_impl_.frame_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::Frame*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.frame_ = reinterpret_cast<::viam::app::v1::Frame*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.frame)
}

// repeated string depends_on = 6 [json_name = "dependsOn"];
inline int ComponentConfig::_internal_depends_on_size() const {
  return _internal_depends_on().size();
}
inline int ComponentConfig::depends_on_size() const {
  return _internal_depends_on_size();
}
inline void ComponentConfig::clear_depends_on() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.depends_on_.Clear();
}
inline std::string* ComponentConfig::add_depends_on()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_depends_on()->Add();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ComponentConfig.depends_on)
  return _s;
}
inline const std::string& ComponentConfig::depends_on(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.depends_on)
  return _internal_depends_on().Get(index);
}
inline std::string* ComponentConfig::mutable_depends_on(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.depends_on)
  return _internal_mutable_depends_on()->Mutable(index);
}
inline void ComponentConfig::set_depends_on(int index, const std::string& value) {
  _internal_mutable_depends_on()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::set_depends_on(int index, std::string&& value) {
  _internal_mutable_depends_on()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::set_depends_on(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_depends_on()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::set_depends_on(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_depends_on()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::set_depends_on(int index, absl::string_view value) {
  _internal_mutable_depends_on()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:viam.app.v1.ComponentConfig.depends_on)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ComponentConfig::depends_on() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.ComponentConfig.depends_on)
  return _internal_depends_on();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ComponentConfig::mutable_depends_on() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ComponentConfig.depends_on)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_depends_on();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ComponentConfig::_internal_depends_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depends_on_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ComponentConfig::_internal_mutable_depends_on() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.depends_on_;
}

// repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 7 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
inline int ComponentConfig::_internal_service_configs_size() const {
  return _internal_service_configs().size();
}
inline int ComponentConfig::service_configs_size() const {
  return _internal_service_configs_size();
}
inline void ComponentConfig::clear_service_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.service_configs_.Clear();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ComponentConfig::mutable_service_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.service_configs)
  return _internal_mutable_service_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>* ComponentConfig::mutable_service_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ComponentConfig.service_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_service_configs();
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& ComponentConfig::service_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.service_configs)
  return _internal_service_configs().Get(index);
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ComponentConfig::add_service_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::ResourceLevelServiceConfig* _add = _internal_mutable_service_configs()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.ComponentConfig.service_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>& ComponentConfig::service_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.ComponentConfig.service_configs)
  return _internal_service_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>&
ComponentConfig::_internal_service_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.service_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>*
ComponentConfig::_internal_mutable_service_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.service_configs_;
}

// .google.protobuf.Struct attributes = 8 [json_name = "attributes"];
inline bool ComponentConfig::has_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attributes_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& ComponentConfig::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& ComponentConfig::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.attributes)
  return _internal_attributes();
}
inline void ComponentConfig::unsafe_arena_set_allocated_attributes(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ComponentConfig.attributes)
}
inline ::google::protobuf::Struct* ComponentConfig::release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Struct* released = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* ComponentConfig::unsafe_arena_release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.attributes)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Struct* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* ComponentConfig::_internal_mutable_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.attributes_;
}
inline ::google::protobuf::Struct* ComponentConfig::mutable_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.attributes)
  return _msg;
}
inline void ComponentConfig::set_allocated_attributes(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.attributes)
}

// string api = 9 [json_name = "api"];
inline void ComponentConfig::clear_api() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_.ClearToEmpty();
}
inline const std::string& ComponentConfig::api() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.api)
  return _internal_api();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ComponentConfig::set_api(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.api_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.api)
}
inline std::string* ComponentConfig::mutable_api() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_api();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.api)
  return _s;
}
inline const std::string& ComponentConfig::_internal_api() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.api_.Get();
}
inline void ComponentConfig::_internal_set_api(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.api_.Set(value, GetArena());
}
inline std::string* ComponentConfig::_internal_mutable_api() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.api_.Mutable( GetArena());
}
inline std::string* ComponentConfig::release_api() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.api)
  return _impl_.api_.Release();
}
inline void ComponentConfig::set_allocated_api(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.api_.IsDefault()) {
          _impl_.api_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.api)
}

// .viam.app.v1.LogConfiguration log_configuration = 10 [json_name = "logConfiguration"];
inline bool ComponentConfig::has_log_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.log_configuration_ != nullptr);
  return value;
}
inline void ComponentConfig::clear_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.log_configuration_ != nullptr) _impl_.log_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::viam::app::v1::LogConfiguration& ComponentConfig::_internal_log_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::LogConfiguration* p = _impl_.log_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LogConfiguration&>(::viam::app::v1::_LogConfiguration_default_instance_);
}
inline const ::viam::app::v1::LogConfiguration& ComponentConfig::log_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.log_configuration)
  return _internal_log_configuration();
}
inline void ComponentConfig::unsafe_arena_set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.log_configuration_);
  }
  _impl_.log_configuration_ = reinterpret_cast<::viam::app::v1::LogConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ComponentConfig.log_configuration)
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::release_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::app::v1::LogConfiguration* released = _impl_.log_configuration_;
  _impl_.log_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::unsafe_arena_release_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.log_configuration)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::app::v1::LogConfiguration* temp = _impl_.log_configuration_;
  _impl_.log_configuration_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::_internal_mutable_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.log_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LogConfiguration>(GetArena());
    _impl_.log_configuration_ = reinterpret_cast<::viam::app::v1::LogConfiguration*>(p);
  }
  return _impl_.log_configuration_;
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::mutable_log_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::LogConfiguration* _msg = _internal_mutable_log_configuration();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.log_configuration)
  return _msg;
}
inline void ComponentConfig::set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::LogConfiguration*>(_impl_.log_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::LogConfiguration*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.log_configuration_ = reinterpret_cast<::viam::app::v1::LogConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.log_configuration)
}

// -------------------------------------------------------------------

// ResourceLevelServiceConfig

// string type = 1 [json_name = "type"];
inline void ResourceLevelServiceConfig::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ResourceLevelServiceConfig::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResourceLevelServiceConfig.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResourceLevelServiceConfig::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResourceLevelServiceConfig.type)
}
inline std::string* ResourceLevelServiceConfig::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResourceLevelServiceConfig.type)
  return _s;
}
inline const std::string& ResourceLevelServiceConfig::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void ResourceLevelServiceConfig::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* ResourceLevelServiceConfig::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* ResourceLevelServiceConfig::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ResourceLevelServiceConfig.type)
  return _impl_.type_.Release();
}
inline void ResourceLevelServiceConfig::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResourceLevelServiceConfig.type)
}

// .google.protobuf.Struct attributes = 2 [json_name = "attributes"];
inline bool ResourceLevelServiceConfig::has_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attributes_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& ResourceLevelServiceConfig::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& ResourceLevelServiceConfig::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResourceLevelServiceConfig.attributes)
  return _internal_attributes();
}
inline void ResourceLevelServiceConfig::unsafe_arena_set_allocated_attributes(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ResourceLevelServiceConfig.attributes)
}
inline ::google::protobuf::Struct* ResourceLevelServiceConfig::release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* released = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* ResourceLevelServiceConfig::unsafe_arena_release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ResourceLevelServiceConfig.attributes)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* ResourceLevelServiceConfig::_internal_mutable_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.attributes_;
}
inline ::google::protobuf::Struct* ResourceLevelServiceConfig::mutable_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResourceLevelServiceConfig.attributes)
  return _msg;
}
inline void ResourceLevelServiceConfig::set_allocated_attributes(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResourceLevelServiceConfig.attributes)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessConfig

// string id = 1 [json_name = "id"];
inline void ProcessConfig::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ProcessConfig::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessConfig::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.id)
}
inline std::string* ProcessConfig::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.id)
  return _s;
}
inline const std::string& ProcessConfig::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ProcessConfig::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ProcessConfig::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ProcessConfig::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.id)
  return _impl_.id_.Release();
}
inline void ProcessConfig::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.id)
}

// string name = 2 [json_name = "name"];
inline void ProcessConfig::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ProcessConfig::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessConfig::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.name)
}
inline std::string* ProcessConfig::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.name)
  return _s;
}
inline const std::string& ProcessConfig::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ProcessConfig::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ProcessConfig::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ProcessConfig::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.name)
  return _impl_.name_.Release();
}
inline void ProcessConfig::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.name)
}

// repeated string args = 3 [json_name = "args"];
inline int ProcessConfig::_internal_args_size() const {
  return _internal_args().size();
}
inline int ProcessConfig::args_size() const {
  return _internal_args_size();
}
inline void ProcessConfig::clear_args() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.args_.Clear();
}
inline std::string* ProcessConfig::add_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ProcessConfig.args)
  return _s;
}
inline const std::string& ProcessConfig::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.args)
  return _internal_args().Get(index);
}
inline std::string* ProcessConfig::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.args)
  return _internal_mutable_args()->Mutable(index);
}
inline void ProcessConfig::set_args(int index, const std::string& value) {
  _internal_mutable_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::set_args(int index, std::string&& value) {
  _internal_mutable_args()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::set_args(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::set_args(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_args()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::set_args(int index, absl::string_view value) {
  _internal_mutable_args()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:viam.app.v1.ProcessConfig.args)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcessConfig::args() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.ProcessConfig.args)
  return _internal_args();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProcessConfig::mutable_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ProcessConfig.args)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_args();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcessConfig::_internal_args() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProcessConfig::_internal_mutable_args() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.args_;
}

// string cwd = 4 [json_name = "cwd"];
inline void ProcessConfig::clear_cwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cwd_.ClearToEmpty();
}
inline const std::string& ProcessConfig::cwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.cwd)
  return _internal_cwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessConfig::set_cwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.cwd)
}
inline std::string* ProcessConfig::mutable_cwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cwd();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.cwd)
  return _s;
}
inline const std::string& ProcessConfig::_internal_cwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cwd_.Get();
}
inline void ProcessConfig::_internal_set_cwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cwd_.Set(value, GetArena());
}
inline std::string* ProcessConfig::_internal_mutable_cwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.cwd_.Mutable( GetArena());
}
inline std::string* ProcessConfig::release_cwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.cwd)
  return _impl_.cwd_.Release();
}
inline void ProcessConfig::set_allocated_cwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cwd_.IsDefault()) {
          _impl_.cwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.cwd)
}

// bool one_shot = 5 [json_name = "oneShot"];
inline void ProcessConfig::clear_one_shot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.one_shot_ = false;
}
inline bool ProcessConfig::one_shot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.one_shot)
  return _internal_one_shot();
}
inline void ProcessConfig::set_one_shot(bool value) {
  _internal_set_one_shot(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.one_shot)
}
inline bool ProcessConfig::_internal_one_shot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.one_shot_;
}
inline void ProcessConfig::_internal_set_one_shot(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.one_shot_ = value;
}

// bool log = 6 [json_name = "log"];
inline void ProcessConfig::clear_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_ = false;
}
inline bool ProcessConfig::log() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.log)
  return _internal_log();
}
inline void ProcessConfig::set_log(bool value) {
  _internal_set_log(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.log)
}
inline bool ProcessConfig::_internal_log() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_;
}
inline void ProcessConfig::_internal_set_log(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_ = value;
}

// int32 stop_signal = 7 [json_name = "stopSignal"];
inline void ProcessConfig::clear_stop_signal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_signal_ = 0;
}
inline ::int32_t ProcessConfig::stop_signal() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.stop_signal)
  return _internal_stop_signal();
}
inline void ProcessConfig::set_stop_signal(::int32_t value) {
  _internal_set_stop_signal(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.stop_signal)
}
inline ::int32_t ProcessConfig::_internal_stop_signal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_signal_;
}
inline void ProcessConfig::_internal_set_stop_signal(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stop_signal_ = value;
}

// .google.protobuf.Duration stop_timeout = 8 [json_name = "stopTimeout"];
inline bool ProcessConfig::has_stop_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& ProcessConfig::_internal_stop_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.stop_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& ProcessConfig::stop_timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.stop_timeout)
  return _internal_stop_timeout();
}
inline void ProcessConfig::unsafe_arena_set_allocated_stop_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_timeout_);
  }
  _impl_.stop_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ProcessConfig.stop_timeout)
}
inline ::google::protobuf::Duration* ProcessConfig::release_stop_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.stop_timeout_;
  _impl_.stop_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* ProcessConfig::unsafe_arena_release_stop_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.stop_timeout)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.stop_timeout_;
  _impl_.stop_timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* ProcessConfig::_internal_mutable_stop_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stop_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.stop_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.stop_timeout_;
}
inline ::google::protobuf::Duration* ProcessConfig::mutable_stop_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_stop_timeout();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.stop_timeout)
  return _msg;
}
inline void ProcessConfig::set_allocated_stop_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stop_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.stop_timeout)
}

// map<string, string> env = 9 [json_name = "env"];
inline int ProcessConfig::_internal_env_size() const {
  return _internal_env().size();
}
inline int ProcessConfig::env_size() const {
  return _internal_env_size();
}
inline void ProcessConfig::clear_env() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.env_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ProcessConfig::_internal_env() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.env_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ProcessConfig::env() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:viam.app.v1.ProcessConfig.env)
  return _internal_env();
}
inline ::google::protobuf::Map<std::string, std::string>* ProcessConfig::_internal_mutable_env() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.env_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ProcessConfig::mutable_env() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:viam.app.v1.ProcessConfig.env)
  return _internal_mutable_env();
}

// -------------------------------------------------------------------

// ServiceConfig

// string name = 1 [json_name = "name"];
inline void ServiceConfig::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServiceConfig::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceConfig::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.name)
}
inline std::string* ServiceConfig::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.name)
  return _s;
}
inline const std::string& ServiceConfig::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ServiceConfig::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ServiceConfig::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ServiceConfig::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.name)
  return _impl_.name_.Release();
}
inline void ServiceConfig::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.name)
}

// string namespace = 2 [json_name = "namespace"];
inline void ServiceConfig::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& ServiceConfig::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceConfig::set_namespace_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.namespace)
}
inline std::string* ServiceConfig::mutable_namespace_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.namespace)
  return _s;
}
inline const std::string& ServiceConfig::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__.Get();
}
inline void ServiceConfig::_internal_set_namespace_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* ServiceConfig::_internal_mutable_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* ServiceConfig::release_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.namespace)
  return _impl_.namespace__.Release();
}
inline void ServiceConfig::set_allocated_namespace_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.namespace__.IsDefault()) {
          _impl_.namespace__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.namespace)
}

// string type = 3 [json_name = "type"];
inline void ServiceConfig::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ServiceConfig::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceConfig::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.type)
}
inline std::string* ServiceConfig::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.type)
  return _s;
}
inline const std::string& ServiceConfig::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void ServiceConfig::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* ServiceConfig::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* ServiceConfig::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.type)
  return _impl_.type_.Release();
}
inline void ServiceConfig::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.type)
}

// .google.protobuf.Struct attributes = 4 [json_name = "attributes"];
inline bool ServiceConfig::has_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attributes_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& ServiceConfig::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& ServiceConfig::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.attributes)
  return _internal_attributes();
}
inline void ServiceConfig::unsafe_arena_set_allocated_attributes(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ServiceConfig.attributes)
}
inline ::google::protobuf::Struct* ServiceConfig::release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* released = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* ServiceConfig::unsafe_arena_release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.attributes)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* ServiceConfig::_internal_mutable_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.attributes_;
}
inline ::google::protobuf::Struct* ServiceConfig::mutable_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.attributes)
  return _msg;
}
inline void ServiceConfig::set_allocated_attributes(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.attributes_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.attributes)
}

// repeated string depends_on = 5 [json_name = "dependsOn"];
inline int ServiceConfig::_internal_depends_on_size() const {
  return _internal_depends_on().size();
}
inline int ServiceConfig::depends_on_size() const {
  return _internal_depends_on_size();
}
inline void ServiceConfig::clear_depends_on() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.depends_on_.Clear();
}
inline std::string* ServiceConfig::add_depends_on()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_depends_on()->Add();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ServiceConfig.depends_on)
  return _s;
}
inline const std::string& ServiceConfig::depends_on(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.depends_on)
  return _internal_depends_on().Get(index);
}
inline std::string* ServiceConfig::mutable_depends_on(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.depends_on)
  return _internal_mutable_depends_on()->Mutable(index);
}
inline void ServiceConfig::set_depends_on(int index, const std::string& value) {
  _internal_mutable_depends_on()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::set_depends_on(int index, std::string&& value) {
  _internal_mutable_depends_on()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::set_depends_on(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_depends_on()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::set_depends_on(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_depends_on()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::set_depends_on(int index, absl::string_view value) {
  _internal_mutable_depends_on()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_depends_on()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:viam.app.v1.ServiceConfig.depends_on)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ServiceConfig::depends_on() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.ServiceConfig.depends_on)
  return _internal_depends_on();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ServiceConfig::mutable_depends_on() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ServiceConfig.depends_on)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_depends_on();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ServiceConfig::_internal_depends_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depends_on_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ServiceConfig::_internal_mutable_depends_on() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.depends_on_;
}

// string model = 6 [json_name = "model"];
inline void ServiceConfig::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.ClearToEmpty();
}
inline const std::string& ServiceConfig::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceConfig::set_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.model)
}
inline std::string* ServiceConfig::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.model)
  return _s;
}
inline const std::string& ServiceConfig::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_.Get();
}
inline void ServiceConfig::_internal_set_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(value, GetArena());
}
inline std::string* ServiceConfig::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_.Mutable( GetArena());
}
inline std::string* ServiceConfig::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.model)
  return _impl_.model_.Release();
}
inline void ServiceConfig::set_allocated_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_.IsDefault()) {
          _impl_.model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.model)
}

// string api = 9 [json_name = "api"];
inline void ServiceConfig::clear_api() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_.ClearToEmpty();
}
inline const std::string& ServiceConfig::api() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.api)
  return _internal_api();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceConfig::set_api(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.api_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.api)
}
inline std::string* ServiceConfig::mutable_api() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_api();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.api)
  return _s;
}
inline const std::string& ServiceConfig::_internal_api() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.api_.Get();
}
inline void ServiceConfig::_internal_set_api(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.api_.Set(value, GetArena());
}
inline std::string* ServiceConfig::_internal_mutable_api() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.api_.Mutable( GetArena());
}
inline std::string* ServiceConfig::release_api() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.api)
  return _impl_.api_.Release();
}
inline void ServiceConfig::set_allocated_api(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.api_.IsDefault()) {
          _impl_.api_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.api)
}

// repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 10 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
inline int ServiceConfig::_internal_service_configs_size() const {
  return _internal_service_configs().size();
}
inline int ServiceConfig::service_configs_size() const {
  return _internal_service_configs_size();
}
inline void ServiceConfig::clear_service_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.service_configs_.Clear();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ServiceConfig::mutable_service_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.service_configs)
  return _internal_mutable_service_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>* ServiceConfig::mutable_service_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ServiceConfig.service_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_service_configs();
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& ServiceConfig::service_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.service_configs)
  return _internal_service_configs().Get(index);
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ServiceConfig::add_service_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::ResourceLevelServiceConfig* _add = _internal_mutable_service_configs()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.ServiceConfig.service_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>& ServiceConfig::service_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.ServiceConfig.service_configs)
  return _internal_service_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>&
ServiceConfig::_internal_service_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.service_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>*
ServiceConfig::_internal_mutable_service_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.service_configs_;
}

// .viam.app.v1.LogConfiguration log_configuration = 11 [json_name = "logConfiguration"];
inline bool ServiceConfig::has_log_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.log_configuration_ != nullptr);
  return value;
}
inline void ServiceConfig::clear_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.log_configuration_ != nullptr) _impl_.log_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::app::v1::LogConfiguration& ServiceConfig::_internal_log_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::LogConfiguration* p = _impl_.log_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LogConfiguration&>(::viam::app::v1::_LogConfiguration_default_instance_);
}
inline const ::viam::app::v1::LogConfiguration& ServiceConfig::log_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.log_configuration)
  return _internal_log_configuration();
}
inline void ServiceConfig::unsafe_arena_set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.log_configuration_);
  }
  _impl_.log_configuration_ = reinterpret_cast<::viam::app::v1::LogConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ServiceConfig.log_configuration)
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::release_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::LogConfiguration* released = _impl_.log_configuration_;
  _impl_.log_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::unsafe_arena_release_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.log_configuration)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::LogConfiguration* temp = _impl_.log_configuration_;
  _impl_.log_configuration_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::_internal_mutable_log_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.log_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LogConfiguration>(GetArena());
    _impl_.log_configuration_ = reinterpret_cast<::viam::app::v1::LogConfiguration*>(p);
  }
  return _impl_.log_configuration_;
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::mutable_log_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::LogConfiguration* _msg = _internal_mutable_log_configuration();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.log_configuration)
  return _msg;
}
inline void ServiceConfig::set_allocated_log_configuration(::viam::app::v1::LogConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::LogConfiguration*>(_impl_.log_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::LogConfiguration*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.log_configuration_ = reinterpret_cast<::viam::app::v1::LogConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.log_configuration)
}

// -------------------------------------------------------------------

// NetworkConfig

// string fqdn = 1 [json_name = "fqdn"];
inline void NetworkConfig::clear_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fqdn_.ClearToEmpty();
}
inline const std::string& NetworkConfig::fqdn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.fqdn)
  return _internal_fqdn();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkConfig::set_fqdn(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fqdn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.fqdn)
}
inline std::string* NetworkConfig::mutable_fqdn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.fqdn)
  return _s;
}
inline const std::string& NetworkConfig::_internal_fqdn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fqdn_.Get();
}
inline void NetworkConfig::_internal_set_fqdn(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fqdn_.Set(value, GetArena());
}
inline std::string* NetworkConfig::_internal_mutable_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fqdn_.Mutable( GetArena());
}
inline std::string* NetworkConfig::release_fqdn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.fqdn)
  return _impl_.fqdn_.Release();
}
inline void NetworkConfig::set_allocated_fqdn(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fqdn_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fqdn_.IsDefault()) {
          _impl_.fqdn_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.fqdn)
}

// string bind_address = 2 [json_name = "bindAddress"];
inline void NetworkConfig::clear_bind_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bind_address_.ClearToEmpty();
}
inline const std::string& NetworkConfig::bind_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.bind_address)
  return _internal_bind_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkConfig::set_bind_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bind_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.bind_address)
}
inline std::string* NetworkConfig::mutable_bind_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bind_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.bind_address)
  return _s;
}
inline const std::string& NetworkConfig::_internal_bind_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bind_address_.Get();
}
inline void NetworkConfig::_internal_set_bind_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bind_address_.Set(value, GetArena());
}
inline std::string* NetworkConfig::_internal_mutable_bind_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.bind_address_.Mutable( GetArena());
}
inline std::string* NetworkConfig::release_bind_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.bind_address)
  return _impl_.bind_address_.Release();
}
inline void NetworkConfig::set_allocated_bind_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bind_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bind_address_.IsDefault()) {
          _impl_.bind_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.bind_address)
}

// string tls_cert_file = 3 [json_name = "tlsCertFile"];
inline void NetworkConfig::clear_tls_cert_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_cert_file_.ClearToEmpty();
}
inline const std::string& NetworkConfig::tls_cert_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.tls_cert_file)
  return _internal_tls_cert_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkConfig::set_tls_cert_file(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_cert_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.tls_cert_file)
}
inline std::string* NetworkConfig::mutable_tls_cert_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tls_cert_file();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.tls_cert_file)
  return _s;
}
inline const std::string& NetworkConfig::_internal_tls_cert_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tls_cert_file_.Get();
}
inline void NetworkConfig::_internal_set_tls_cert_file(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_cert_file_.Set(value, GetArena());
}
inline std::string* NetworkConfig::_internal_mutable_tls_cert_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tls_cert_file_.Mutable( GetArena());
}
inline std::string* NetworkConfig::release_tls_cert_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.tls_cert_file)
  return _impl_.tls_cert_file_.Release();
}
inline void NetworkConfig::set_allocated_tls_cert_file(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_cert_file_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tls_cert_file_.IsDefault()) {
          _impl_.tls_cert_file_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.tls_cert_file)
}

// string tls_key_file = 4 [json_name = "tlsKeyFile"];
inline void NetworkConfig::clear_tls_key_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_key_file_.ClearToEmpty();
}
inline const std::string& NetworkConfig::tls_key_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.tls_key_file)
  return _internal_tls_key_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkConfig::set_tls_key_file(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_key_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.tls_key_file)
}
inline std::string* NetworkConfig::mutable_tls_key_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tls_key_file();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.tls_key_file)
  return _s;
}
inline const std::string& NetworkConfig::_internal_tls_key_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tls_key_file_.Get();
}
inline void NetworkConfig::_internal_set_tls_key_file(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_key_file_.Set(value, GetArena());
}
inline std::string* NetworkConfig::_internal_mutable_tls_key_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tls_key_file_.Mutable( GetArena());
}
inline std::string* NetworkConfig::release_tls_key_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.tls_key_file)
  return _impl_.tls_key_file_.Release();
}
inline void NetworkConfig::set_allocated_tls_key_file(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_key_file_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tls_key_file_.IsDefault()) {
          _impl_.tls_key_file_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.tls_key_file)
}

// .viam.app.v1.SessionsConfig sessions = 5 [json_name = "sessions"];
inline bool NetworkConfig::has_sessions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sessions_ != nullptr);
  return value;
}
inline void NetworkConfig::clear_sessions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sessions_ != nullptr) _impl_.sessions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::SessionsConfig& NetworkConfig::_internal_sessions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::SessionsConfig* p = _impl_.sessions_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::SessionsConfig&>(::viam::app::v1::_SessionsConfig_default_instance_);
}
inline const ::viam::app::v1::SessionsConfig& NetworkConfig::sessions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.sessions)
  return _internal_sessions();
}
inline void NetworkConfig::unsafe_arena_set_allocated_sessions(::viam::app::v1::SessionsConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sessions_);
  }
  _impl_.sessions_ = reinterpret_cast<::viam::app::v1::SessionsConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.NetworkConfig.sessions)
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::release_sessions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::SessionsConfig* released = _impl_.sessions_;
  _impl_.sessions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::unsafe_arena_release_sessions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.sessions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::SessionsConfig* temp = _impl_.sessions_;
  _impl_.sessions_ = nullptr;
  return temp;
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::_internal_mutable_sessions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sessions_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::SessionsConfig>(GetArena());
    _impl_.sessions_ = reinterpret_cast<::viam::app::v1::SessionsConfig*>(p);
  }
  return _impl_.sessions_;
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::mutable_sessions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::SessionsConfig* _msg = _internal_mutable_sessions();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.sessions)
  return _msg;
}
inline void NetworkConfig::set_allocated_sessions(::viam::app::v1::SessionsConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::SessionsConfig*>(_impl_.sessions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::SessionsConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sessions_ = reinterpret_cast<::viam::app::v1::SessionsConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.sessions)
}

// -------------------------------------------------------------------

// SessionsConfig

// .google.protobuf.Duration heartbeat_window = 1 [json_name = "heartbeatWindow"];
inline bool SessionsConfig::has_heartbeat_window() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heartbeat_window_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& SessionsConfig::_internal_heartbeat_window() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.heartbeat_window_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& SessionsConfig::heartbeat_window() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.SessionsConfig.heartbeat_window)
  return _internal_heartbeat_window();
}
inline void SessionsConfig::unsafe_arena_set_allocated_heartbeat_window(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heartbeat_window_);
  }
  _impl_.heartbeat_window_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.SessionsConfig.heartbeat_window)
}
inline ::google::protobuf::Duration* SessionsConfig::release_heartbeat_window() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.heartbeat_window_;
  _impl_.heartbeat_window_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* SessionsConfig::unsafe_arena_release_heartbeat_window() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.SessionsConfig.heartbeat_window)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.heartbeat_window_;
  _impl_.heartbeat_window_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* SessionsConfig::_internal_mutable_heartbeat_window() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.heartbeat_window_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.heartbeat_window_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.heartbeat_window_;
}
inline ::google::protobuf::Duration* SessionsConfig::mutable_heartbeat_window() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_heartbeat_window();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SessionsConfig.heartbeat_window)
  return _msg;
}
inline void SessionsConfig::set_allocated_heartbeat_window(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heartbeat_window_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.heartbeat_window_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SessionsConfig.heartbeat_window)
}

// -------------------------------------------------------------------

// AuthConfig

// repeated .viam.app.v1.AuthHandlerConfig handlers = 1 [json_name = "handlers"];
inline int AuthConfig::_internal_handlers_size() const {
  return _internal_handlers().size();
}
inline int AuthConfig::handlers_size() const {
  return _internal_handlers_size();
}
inline void AuthConfig::clear_handlers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.handlers_.Clear();
}
inline ::viam::app::v1::AuthHandlerConfig* AuthConfig::mutable_handlers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthConfig.handlers)
  return _internal_mutable_handlers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::AuthHandlerConfig>* AuthConfig::mutable_handlers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AuthConfig.handlers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_handlers();
}
inline const ::viam::app::v1::AuthHandlerConfig& AuthConfig::handlers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthConfig.handlers)
  return _internal_handlers().Get(index);
}
inline ::viam::app::v1::AuthHandlerConfig* AuthConfig::add_handlers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::AuthHandlerConfig* _add = _internal_mutable_handlers()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthConfig.handlers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::AuthHandlerConfig>& AuthConfig::handlers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.AuthConfig.handlers)
  return _internal_handlers();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::AuthHandlerConfig>&
AuthConfig::_internal_handlers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.handlers_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::AuthHandlerConfig>*
AuthConfig::_internal_mutable_handlers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.handlers_;
}

// repeated string tls_auth_entities = 2 [json_name = "tlsAuthEntities"];
inline int AuthConfig::_internal_tls_auth_entities_size() const {
  return _internal_tls_auth_entities().size();
}
inline int AuthConfig::tls_auth_entities_size() const {
  return _internal_tls_auth_entities_size();
}
inline void AuthConfig::clear_tls_auth_entities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_auth_entities_.Clear();
}
inline std::string* AuthConfig::add_tls_auth_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tls_auth_entities()->Add();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.AuthConfig.tls_auth_entities)
  return _s;
}
inline const std::string& AuthConfig::tls_auth_entities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthConfig.tls_auth_entities)
  return _internal_tls_auth_entities().Get(index);
}
inline std::string* AuthConfig::mutable_tls_auth_entities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthConfig.tls_auth_entities)
  return _internal_mutable_tls_auth_entities()->Mutable(index);
}
inline void AuthConfig::set_tls_auth_entities(int index, const std::string& value) {
  _internal_mutable_tls_auth_entities()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::set_tls_auth_entities(int index, std::string&& value) {
  _internal_mutable_tls_auth_entities()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::set_tls_auth_entities(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tls_auth_entities()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::set_tls_auth_entities(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tls_auth_entities()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::set_tls_auth_entities(int index, absl::string_view value) {
  _internal_mutable_tls_auth_entities()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tls_auth_entities()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tls_auth_entities()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tls_auth_entities()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tls_auth_entities()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tls_auth_entities()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AuthConfig::tls_auth_entities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.AuthConfig.tls_auth_entities)
  return _internal_tls_auth_entities();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AuthConfig::mutable_tls_auth_entities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AuthConfig.tls_auth_entities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tls_auth_entities();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AuthConfig::_internal_tls_auth_entities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tls_auth_entities_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AuthConfig::_internal_mutable_tls_auth_entities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tls_auth_entities_;
}

// optional .viam.app.v1.ExternalAuthConfig external_auth_config = 3 [json_name = "externalAuthConfig"];
inline bool AuthConfig::has_external_auth_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_auth_config_ != nullptr);
  return value;
}
inline void AuthConfig::clear_external_auth_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.external_auth_config_ != nullptr) _impl_.external_auth_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::ExternalAuthConfig& AuthConfig::_internal_external_auth_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::ExternalAuthConfig* p = _impl_.external_auth_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::ExternalAuthConfig&>(::viam::app::v1::_ExternalAuthConfig_default_instance_);
}
inline const ::viam::app::v1::ExternalAuthConfig& AuthConfig::external_auth_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthConfig.external_auth_config)
  return _internal_external_auth_config();
}
inline void AuthConfig::unsafe_arena_set_allocated_external_auth_config(::viam::app::v1::ExternalAuthConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.external_auth_config_);
  }
  _impl_.external_auth_config_ = reinterpret_cast<::viam::app::v1::ExternalAuthConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.AuthConfig.external_auth_config)
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::release_external_auth_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::ExternalAuthConfig* released = _impl_.external_auth_config_;
  _impl_.external_auth_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::unsafe_arena_release_external_auth_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthConfig.external_auth_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::ExternalAuthConfig* temp = _impl_.external_auth_config_;
  _impl_.external_auth_config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::_internal_mutable_external_auth_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.external_auth_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::ExternalAuthConfig>(GetArena());
    _impl_.external_auth_config_ = reinterpret_cast<::viam::app::v1::ExternalAuthConfig*>(p);
  }
  return _impl_.external_auth_config_;
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::mutable_external_auth_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::ExternalAuthConfig* _msg = _internal_mutable_external_auth_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthConfig.external_auth_config)
  return _msg;
}
inline void AuthConfig::set_allocated_external_auth_config(::viam::app::v1::ExternalAuthConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::ExternalAuthConfig*>(_impl_.external_auth_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::ExternalAuthConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.external_auth_config_ = reinterpret_cast<::viam::app::v1::ExternalAuthConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthConfig.external_auth_config)
}

// -------------------------------------------------------------------

// JWKSFile

// .google.protobuf.Struct json = 1 [json_name = "json"];
inline bool JWKSFile::has_json() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.json_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& JWKSFile::_internal_json() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.json_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& JWKSFile::json() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.JWKSFile.json)
  return _internal_json();
}
inline void JWKSFile::unsafe_arena_set_allocated_json(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.json_);
  }
  _impl_.json_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.JWKSFile.json)
}
inline ::google::protobuf::Struct* JWKSFile::release_json() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* released = _impl_.json_;
  _impl_.json_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* JWKSFile::unsafe_arena_release_json() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.JWKSFile.json)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* temp = _impl_.json_;
  _impl_.json_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* JWKSFile::_internal_mutable_json() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.json_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.json_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.json_;
}
inline ::google::protobuf::Struct* JWKSFile::mutable_json() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.JWKSFile.json)
  return _msg;
}
inline void JWKSFile::set_allocated_json(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.json_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.json_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.JWKSFile.json)
}

// -------------------------------------------------------------------

// ExternalAuthConfig

// .viam.app.v1.JWKSFile jwks = 1 [json_name = "jwks"];
inline bool ExternalAuthConfig::has_jwks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.jwks_ != nullptr);
  return value;
}
inline void ExternalAuthConfig::clear_jwks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.jwks_ != nullptr) _impl_.jwks_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::JWKSFile& ExternalAuthConfig::_internal_jwks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::JWKSFile* p = _impl_.jwks_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::JWKSFile&>(::viam::app::v1::_JWKSFile_default_instance_);
}
inline const ::viam::app::v1::JWKSFile& ExternalAuthConfig::jwks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ExternalAuthConfig.jwks)
  return _internal_jwks();
}
inline void ExternalAuthConfig::unsafe_arena_set_allocated_jwks(::viam::app::v1::JWKSFile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.jwks_);
  }
  _impl_.jwks_ = reinterpret_cast<::viam::app::v1::JWKSFile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ExternalAuthConfig.jwks)
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::release_jwks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::JWKSFile* released = _impl_.jwks_;
  _impl_.jwks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::unsafe_arena_release_jwks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ExternalAuthConfig.jwks)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::JWKSFile* temp = _impl_.jwks_;
  _impl_.jwks_ = nullptr;
  return temp;
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::_internal_mutable_jwks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.jwks_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::JWKSFile>(GetArena());
    _impl_.jwks_ = reinterpret_cast<::viam::app::v1::JWKSFile*>(p);
  }
  return _impl_.jwks_;
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::mutable_jwks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::JWKSFile* _msg = _internal_mutable_jwks();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ExternalAuthConfig.jwks)
  return _msg;
}
inline void ExternalAuthConfig::set_allocated_jwks(::viam::app::v1::JWKSFile* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::JWKSFile*>(_impl_.jwks_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::JWKSFile*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.jwks_ = reinterpret_cast<::viam::app::v1::JWKSFile*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ExternalAuthConfig.jwks)
}

// -------------------------------------------------------------------

// AuthHandlerConfig

// .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
inline void AuthHandlerConfig::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::viam::app::v1::CredentialsType AuthHandlerConfig::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthHandlerConfig.type)
  return _internal_type();
}
inline void AuthHandlerConfig::set_type(::viam::app::v1::CredentialsType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthHandlerConfig.type)
}
inline ::viam::app::v1::CredentialsType AuthHandlerConfig::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::viam::app::v1::CredentialsType>(_impl_.type_);
}
inline void AuthHandlerConfig::_internal_set_type(::viam::app::v1::CredentialsType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .google.protobuf.Struct config = 5 [json_name = "config"];
inline bool AuthHandlerConfig::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline const ::google::protobuf::Struct& AuthHandlerConfig::_internal_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Struct* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Struct&>(::google::protobuf::_Struct_default_instance_);
}
inline const ::google::protobuf::Struct& AuthHandlerConfig::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthHandlerConfig.config)
  return _internal_config();
}
inline void AuthHandlerConfig::unsafe_arena_set_allocated_config(::google::protobuf::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.AuthHandlerConfig.config)
}
inline ::google::protobuf::Struct* AuthHandlerConfig::release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Struct* AuthHandlerConfig::unsafe_arena_release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthHandlerConfig.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Struct* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::google::protobuf::Struct* AuthHandlerConfig::_internal_mutable_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArena());
    _impl_.config_ = reinterpret_cast<::google::protobuf::Struct*>(p);
  }
  return _impl_.config_;
}
inline ::google::protobuf::Struct* AuthHandlerConfig::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Struct* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthHandlerConfig.config)
  return _msg;
}
inline void AuthHandlerConfig::set_allocated_config(::google::protobuf::Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::google::protobuf::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthHandlerConfig.config)
}

// -------------------------------------------------------------------

// Frame

// string parent = 1 [json_name = "parent"];
inline void Frame::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& Frame::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Frame::set_parent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.Frame.parent)
}
inline std::string* Frame::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.parent)
  return _s;
}
inline const std::string& Frame::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_.Get();
}
inline void Frame::_internal_set_parent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* Frame::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* Frame::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.parent)
  return _impl_.parent_.Release();
}
inline void Frame::set_allocated_parent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_.IsDefault()) {
          _impl_.parent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.parent)
}

// .viam.app.v1.Translation translation = 2 [json_name = "translation"];
inline bool Frame::has_translation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.translation_ != nullptr);
  return value;
}
inline void Frame::clear_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.translation_ != nullptr) _impl_.translation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::Translation& Frame::_internal_translation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::Translation* p = _impl_.translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Translation&>(::viam::app::v1::_Translation_default_instance_);
}
inline const ::viam::app::v1::Translation& Frame::translation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.translation)
  return _internal_translation();
}
inline void Frame::unsafe_arena_set_allocated_translation(::viam::app::v1::Translation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.translation_);
  }
  _impl_.translation_ = reinterpret_cast<::viam::app::v1::Translation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Frame.translation)
}
inline ::viam::app::v1::Translation* Frame::release_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::Translation* released = _impl_.translation_;
  _impl_.translation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::Translation* Frame::unsafe_arena_release_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.translation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::Translation* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Translation* Frame::_internal_mutable_translation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Translation>(GetArena());
    _impl_.translation_ = reinterpret_cast<::viam::app::v1::Translation*>(p);
  }
  return _impl_.translation_;
}
inline ::viam::app::v1::Translation* Frame::mutable_translation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Translation* _msg = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.translation)
  return _msg;
}
inline void Frame::set_allocated_translation(::viam::app::v1::Translation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::Translation*>(_impl_.translation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::Translation*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.translation_ = reinterpret_cast<::viam::app::v1::Translation*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.translation)
}

// .viam.app.v1.Orientation orientation = 3 [json_name = "orientation"];
inline bool Frame::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void Frame::clear_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::app::v1::Orientation& Frame::_internal_orientation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::Orientation* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Orientation&>(::viam::app::v1::_Orientation_default_instance_);
}
inline const ::viam::app::v1::Orientation& Frame::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.orientation)
  return _internal_orientation();
}
inline void Frame::unsafe_arena_set_allocated_orientation(::viam::app::v1::Orientation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::viam::app::v1::Orientation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Frame.orientation)
}
inline ::viam::app::v1::Orientation* Frame::release_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::Orientation* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::Orientation* Frame::unsafe_arena_release_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.orientation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::Orientation* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Orientation* Frame::_internal_mutable_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Orientation>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::viam::app::v1::Orientation*>(p);
  }
  return _impl_.orientation_;
}
inline ::viam::app::v1::Orientation* Frame::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Orientation* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.orientation)
  return _msg;
}
inline void Frame::set_allocated_orientation(::viam::app::v1::Orientation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::Orientation*>(_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::Orientation*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_ = reinterpret_cast<::viam::app::v1::Orientation*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.orientation)
}

// .viam.common.v1.Geometry geometry = 4 [json_name = "geometry"];
inline bool Frame::has_geometry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geometry_ != nullptr);
  return value;
}
inline const ::viam::common::v1::Geometry& Frame::_internal_geometry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::common::v1::Geometry* p = _impl_.geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::Geometry&>(::viam::common::v1::_Geometry_default_instance_);
}
inline const ::viam::common::v1::Geometry& Frame::geometry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.geometry)
  return _internal_geometry();
}
inline void Frame::unsafe_arena_set_allocated_geometry(::viam::common::v1::Geometry* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geometry_);
  }
  _impl_.geometry_ = reinterpret_cast<::viam::common::v1::Geometry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Frame.geometry)
}
inline ::viam::common::v1::Geometry* Frame::release_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::Geometry* released = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::common::v1::Geometry* Frame::unsafe_arena_release_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.geometry)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::viam::common::v1::Geometry* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
  return temp;
}
inline ::viam::common::v1::Geometry* Frame::_internal_mutable_geometry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::Geometry>(GetArena());
    _impl_.geometry_ = reinterpret_cast<::viam::common::v1::Geometry*>(p);
  }
  return _impl_.geometry_;
}
inline ::viam::common::v1::Geometry* Frame::mutable_geometry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::common::v1::Geometry* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.geometry)
  return _msg;
}
inline void Frame::set_allocated_geometry(::viam::common::v1::Geometry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geometry_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.geometry_ = reinterpret_cast<::viam::common::v1::Geometry*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.geometry)
}

// -------------------------------------------------------------------

// LogConfiguration

// string level = 1 [json_name = "level"];
inline void LogConfiguration::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_.ClearToEmpty();
}
inline const std::string& LogConfiguration::level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogConfiguration.level)
  return _internal_level();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogConfiguration::set_level(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogConfiguration.level)
}
inline std::string* LogConfiguration::mutable_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogConfiguration.level)
  return _s;
}
inline const std::string& LogConfiguration::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_.Get();
}
inline void LogConfiguration::_internal_set_level(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_.Set(value, GetArena());
}
inline std::string* LogConfiguration::_internal_mutable_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.level_.Mutable( GetArena());
}
inline std::string* LogConfiguration::release_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.LogConfiguration.level)
  return _impl_.level_.Release();
}
inline void LogConfiguration::set_allocated_level(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.level_.IsDefault()) {
          _impl_.level_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogConfiguration.level)
}

// -------------------------------------------------------------------

// Translation

// double x = 1 [json_name = "x"];
inline void Translation::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Translation::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Translation.x)
  return _internal_x();
}
inline void Translation::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Translation.x)
}
inline double Translation::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Translation::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2 [json_name = "y"];
inline void Translation::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Translation::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Translation.y)
  return _internal_y();
}
inline void Translation::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Translation.y)
}
inline double Translation::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Translation::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 3 [json_name = "z"];
inline void Translation::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Translation::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Translation.z)
  return _internal_z();
}
inline void Translation::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Translation.z)
}
inline double Translation::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Translation::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Orientation_NoOrientation

// -------------------------------------------------------------------

// Orientation_OrientationVectorRadians

// double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
inline void Orientation_OrientationVectorRadians::clear_theta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.theta_ = 0;
}
inline double Orientation_OrientationVectorRadians::theta() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.theta)
  return _internal_theta();
}
inline void Orientation_OrientationVectorRadians::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.theta)
}
inline double Orientation_OrientationVectorRadians::_internal_theta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.theta_;
}
inline void Orientation_OrientationVectorRadians::_internal_set_theta(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.theta_ = value;
}

// double x = 2 [json_name = "x"];
inline void Orientation_OrientationVectorRadians::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Orientation_OrientationVectorRadians::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.x)
  return _internal_x();
}
inline void Orientation_OrientationVectorRadians::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.x)
}
inline double Orientation_OrientationVectorRadians::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Orientation_OrientationVectorRadians::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 3 [json_name = "y"];
inline void Orientation_OrientationVectorRadians::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Orientation_OrientationVectorRadians::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.y)
  return _internal_y();
}
inline void Orientation_OrientationVectorRadians::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.y)
}
inline double Orientation_OrientationVectorRadians::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Orientation_OrientationVectorRadians::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 4 [json_name = "z"];
inline void Orientation_OrientationVectorRadians::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Orientation_OrientationVectorRadians::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.z)
  return _internal_z();
}
inline void Orientation_OrientationVectorRadians::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.z)
}
inline double Orientation_OrientationVectorRadians::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Orientation_OrientationVectorRadians::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Orientation_OrientationVectorDegrees

// double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
inline void Orientation_OrientationVectorDegrees::clear_theta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.theta_ = 0;
}
inline double Orientation_OrientationVectorDegrees::theta() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.theta)
  return _internal_theta();
}
inline void Orientation_OrientationVectorDegrees::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.theta)
}
inline double Orientation_OrientationVectorDegrees::_internal_theta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.theta_;
}
inline void Orientation_OrientationVectorDegrees::_internal_set_theta(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.theta_ = value;
}

// double x = 2 [json_name = "x"];
inline void Orientation_OrientationVectorDegrees::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Orientation_OrientationVectorDegrees::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.x)
  return _internal_x();
}
inline void Orientation_OrientationVectorDegrees::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.x)
}
inline double Orientation_OrientationVectorDegrees::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Orientation_OrientationVectorDegrees::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 3 [json_name = "y"];
inline void Orientation_OrientationVectorDegrees::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Orientation_OrientationVectorDegrees::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.y)
  return _internal_y();
}
inline void Orientation_OrientationVectorDegrees::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.y)
}
inline double Orientation_OrientationVectorDegrees::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Orientation_OrientationVectorDegrees::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 4 [json_name = "z"];
inline void Orientation_OrientationVectorDegrees::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Orientation_OrientationVectorDegrees::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.z)
  return _internal_z();
}
inline void Orientation_OrientationVectorDegrees::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.z)
}
inline double Orientation_OrientationVectorDegrees::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Orientation_OrientationVectorDegrees::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Orientation_EulerAngles

// double roll = 1 [json_name = "roll"];
inline void Orientation_EulerAngles::clear_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roll_ = 0;
}
inline double Orientation_EulerAngles::roll() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.EulerAngles.roll)
  return _internal_roll();
}
inline void Orientation_EulerAngles::set_roll(double value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.EulerAngles.roll)
}
inline double Orientation_EulerAngles::_internal_roll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roll_;
}
inline void Orientation_EulerAngles::_internal_set_roll(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.roll_ = value;
}

// double pitch = 2 [json_name = "pitch"];
inline void Orientation_EulerAngles::clear_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pitch_ = 0;
}
inline double Orientation_EulerAngles::pitch() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.EulerAngles.pitch)
  return _internal_pitch();
}
inline void Orientation_EulerAngles::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.EulerAngles.pitch)
}
inline double Orientation_EulerAngles::_internal_pitch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pitch_;
}
inline void Orientation_EulerAngles::_internal_set_pitch(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pitch_ = value;
}

// double yaw = 3 [json_name = "yaw"];
inline void Orientation_EulerAngles::clear_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.yaw_ = 0;
}
inline double Orientation_EulerAngles::yaw() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.EulerAngles.yaw)
  return _internal_yaw();
}
inline void Orientation_EulerAngles::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.EulerAngles.yaw)
}
inline double Orientation_EulerAngles::_internal_yaw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.yaw_;
}
inline void Orientation_EulerAngles::_internal_set_yaw(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.yaw_ = value;
}

// -------------------------------------------------------------------

// Orientation_AxisAngles

// double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
inline void Orientation_AxisAngles::clear_theta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.theta_ = 0;
}
inline double Orientation_AxisAngles::theta() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.theta)
  return _internal_theta();
}
inline void Orientation_AxisAngles::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.theta)
}
inline double Orientation_AxisAngles::_internal_theta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.theta_;
}
inline void Orientation_AxisAngles::_internal_set_theta(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.theta_ = value;
}

// double x = 2 [json_name = "x"];
inline void Orientation_AxisAngles::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Orientation_AxisAngles::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.x)
  return _internal_x();
}
inline void Orientation_AxisAngles::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.x)
}
inline double Orientation_AxisAngles::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Orientation_AxisAngles::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 3 [json_name = "y"];
inline void Orientation_AxisAngles::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Orientation_AxisAngles::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.y)
  return _internal_y();
}
inline void Orientation_AxisAngles::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.y)
}
inline double Orientation_AxisAngles::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Orientation_AxisAngles::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 4 [json_name = "z"];
inline void Orientation_AxisAngles::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Orientation_AxisAngles::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.z)
  return _internal_z();
}
inline void Orientation_AxisAngles::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.z)
}
inline double Orientation_AxisAngles::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Orientation_AxisAngles::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Orientation_Quaternion

// double w = 1 [json_name = "w"];
inline void Orientation_Quaternion::clear_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.w_ = 0;
}
inline double Orientation_Quaternion::w() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.w)
  return _internal_w();
}
inline void Orientation_Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.w)
}
inline double Orientation_Quaternion::_internal_w() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.w_;
}
inline void Orientation_Quaternion::_internal_set_w(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.w_ = value;
}

// double x = 2 [json_name = "x"];
inline void Orientation_Quaternion::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline double Orientation_Quaternion::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.x)
  return _internal_x();
}
inline void Orientation_Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.x)
}
inline double Orientation_Quaternion::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Orientation_Quaternion::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 3 [json_name = "y"];
inline void Orientation_Quaternion::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline double Orientation_Quaternion::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.y)
  return _internal_y();
}
inline void Orientation_Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.y)
}
inline double Orientation_Quaternion::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Orientation_Quaternion::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// double z = 4 [json_name = "z"];
inline void Orientation_Quaternion::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline double Orientation_Quaternion::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.z)
  return _internal_z();
}
inline void Orientation_Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.z)
}
inline double Orientation_Quaternion::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Orientation_Quaternion::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Orientation

// .viam.app.v1.Orientation.NoOrientation no_orientation = 1 [json_name = "noOrientation"];
inline bool Orientation::has_no_orientation() const {
  return type_case() == kNoOrientation;
}
inline bool Orientation::_internal_has_no_orientation() const {
  return type_case() == kNoOrientation;
}
inline void Orientation::set_has_no_orientation() {
  _impl_._oneof_case_[0] = kNoOrientation;
}
inline void Orientation::clear_no_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kNoOrientation) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.no_orientation_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::release_no_orientation() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.no_orientation)
  if (type_case() == kNoOrientation) {
    clear_has_type();
    auto* temp = _impl_.type_.no_orientation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.no_orientation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_NoOrientation& Orientation::_internal_no_orientation() const {
  return type_case() == kNoOrientation ? *_impl_.type_.no_orientation_ : reinterpret_cast<::viam::app::v1::Orientation_NoOrientation&>(::viam::app::v1::_Orientation_NoOrientation_default_instance_);
}
inline const ::viam::app::v1::Orientation_NoOrientation& Orientation::no_orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.no_orientation)
  return _internal_no_orientation();
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::unsafe_arena_release_no_orientation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.no_orientation)
  if (type_case() == kNoOrientation) {
    clear_has_type();
    auto* temp = _impl_.type_.no_orientation_;
    _impl_.type_.no_orientation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_no_orientation(::viam::app::v1::Orientation_NoOrientation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_no_orientation();
    _impl_.type_.no_orientation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.no_orientation)
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::_internal_mutable_no_orientation() {
  if (type_case() != kNoOrientation) {
    clear_type();
    set_has_no_orientation();
    _impl_.type_.no_orientation_ = CreateMaybeMessage<::viam::app::v1::Orientation_NoOrientation>(GetArena());
  }
  return _impl_.type_.no_orientation_;
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::mutable_no_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Orientation_NoOrientation* _msg = _internal_mutable_no_orientation();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.no_orientation)
  return _msg;
}

// .viam.app.v1.Orientation.OrientationVectorRadians vector_radians = 2 [json_name = "vectorRadians"];
inline bool Orientation::has_vector_radians() const {
  return type_case() == kVectorRadians;
}
inline bool Orientation::_internal_has_vector_radians() const {
  return type_case() == kVectorRadians;
}
inline void Orientation::set_has_vector_radians() {
  _impl_._oneof_case_[0] = kVectorRadians;
}
inline void Orientation::clear_vector_radians() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kVectorRadians) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.vector_radians_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::release_vector_radians() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.vector_radians)
  if (type_case() == kVectorRadians) {
    clear_has_type();
    auto* temp = _impl_.type_.vector_radians_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.vector_radians_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_OrientationVectorRadians& Orientation::_internal_vector_radians() const {
  return type_case() == kVectorRadians ? *_impl_.type_.vector_radians_ : reinterpret_cast<::viam::app::v1::Orientation_OrientationVectorRadians&>(::viam::app::v1::_Orientation_OrientationVectorRadians_default_instance_);
}
inline const ::viam::app::v1::Orientation_OrientationVectorRadians& Orientation::vector_radians() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.vector_radians)
  return _internal_vector_radians();
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::unsafe_arena_release_vector_radians() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.vector_radians)
  if (type_case() == kVectorRadians) {
    clear_has_type();
    auto* temp = _impl_.type_.vector_radians_;
    _impl_.type_.vector_radians_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_vector_radians(::viam::app::v1::Orientation_OrientationVectorRadians* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_vector_radians();
    _impl_.type_.vector_radians_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.vector_radians)
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::_internal_mutable_vector_radians() {
  if (type_case() != kVectorRadians) {
    clear_type();
    set_has_vector_radians();
    _impl_.type_.vector_radians_ = CreateMaybeMessage<::viam::app::v1::Orientation_OrientationVectorRadians>(GetArena());
  }
  return _impl_.type_.vector_radians_;
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::mutable_vector_radians() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Orientation_OrientationVectorRadians* _msg = _internal_mutable_vector_radians();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.vector_radians)
  return _msg;
}

// .viam.app.v1.Orientation.OrientationVectorDegrees vector_degrees = 3 [json_name = "vectorDegrees"];
inline bool Orientation::has_vector_degrees() const {
  return type_case() == kVectorDegrees;
}
inline bool Orientation::_internal_has_vector_degrees() const {
  return type_case() == kVectorDegrees;
}
inline void Orientation::set_has_vector_degrees() {
  _impl_._oneof_case_[0] = kVectorDegrees;
}
inline void Orientation::clear_vector_degrees() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kVectorDegrees) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.vector_degrees_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::release_vector_degrees() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.vector_degrees)
  if (type_case() == kVectorDegrees) {
    clear_has_type();
    auto* temp = _impl_.type_.vector_degrees_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.vector_degrees_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_OrientationVectorDegrees& Orientation::_internal_vector_degrees() const {
  return type_case() == kVectorDegrees ? *_impl_.type_.vector_degrees_ : reinterpret_cast<::viam::app::v1::Orientation_OrientationVectorDegrees&>(::viam::app::v1::_Orientation_OrientationVectorDegrees_default_instance_);
}
inline const ::viam::app::v1::Orientation_OrientationVectorDegrees& Orientation::vector_degrees() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.vector_degrees)
  return _internal_vector_degrees();
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::unsafe_arena_release_vector_degrees() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.vector_degrees)
  if (type_case() == kVectorDegrees) {
    clear_has_type();
    auto* temp = _impl_.type_.vector_degrees_;
    _impl_.type_.vector_degrees_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_vector_degrees(::viam::app::v1::Orientation_OrientationVectorDegrees* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_vector_degrees();
    _impl_.type_.vector_degrees_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.vector_degrees)
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::_internal_mutable_vector_degrees() {
  if (type_case() != kVectorDegrees) {
    clear_type();
    set_has_vector_degrees();
    _impl_.type_.vector_degrees_ = CreateMaybeMessage<::viam::app::v1::Orientation_OrientationVectorDegrees>(GetArena());
  }
  return _impl_.type_.vector_degrees_;
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::mutable_vector_degrees() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Orientation_OrientationVectorDegrees* _msg = _internal_mutable_vector_degrees();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.vector_degrees)
  return _msg;
}

// .viam.app.v1.Orientation.EulerAngles euler_angles = 4 [json_name = "eulerAngles"];
inline bool Orientation::has_euler_angles() const {
  return type_case() == kEulerAngles;
}
inline bool Orientation::_internal_has_euler_angles() const {
  return type_case() == kEulerAngles;
}
inline void Orientation::set_has_euler_angles() {
  _impl_._oneof_case_[0] = kEulerAngles;
}
inline void Orientation::clear_euler_angles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kEulerAngles) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.euler_angles_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::release_euler_angles() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.euler_angles)
  if (type_case() == kEulerAngles) {
    clear_has_type();
    auto* temp = _impl_.type_.euler_angles_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_EulerAngles& Orientation::_internal_euler_angles() const {
  return type_case() == kEulerAngles ? *_impl_.type_.euler_angles_ : reinterpret_cast<::viam::app::v1::Orientation_EulerAngles&>(::viam::app::v1::_Orientation_EulerAngles_default_instance_);
}
inline const ::viam::app::v1::Orientation_EulerAngles& Orientation::euler_angles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.euler_angles)
  return _internal_euler_angles();
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::unsafe_arena_release_euler_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.euler_angles)
  if (type_case() == kEulerAngles) {
    clear_has_type();
    auto* temp = _impl_.type_.euler_angles_;
    _impl_.type_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_euler_angles(::viam::app::v1::Orientation_EulerAngles* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_euler_angles();
    _impl_.type_.euler_angles_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.euler_angles)
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::_internal_mutable_euler_angles() {
  if (type_case() != kEulerAngles) {
    clear_type();
    set_has_euler_angles();
    _impl_.type_.euler_angles_ = CreateMaybeMessage<::viam::app::v1::Orientation_EulerAngles>(GetArena());
  }
  return _impl_.type_.euler_angles_;
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::mutable_euler_angles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Orientation_EulerAngles* _msg = _internal_mutable_euler_angles();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.euler_angles)
  return _msg;
}

// .viam.app.v1.Orientation.AxisAngles axis_angles = 5 [json_name = "axisAngles"];
inline bool Orientation::has_axis_angles() const {
  return type_case() == kAxisAngles;
}
inline bool Orientation::_internal_has_axis_angles() const {
  return type_case() == kAxisAngles;
}
inline void Orientation::set_has_axis_angles() {
  _impl_._oneof_case_[0] = kAxisAngles;
}
inline void Orientation::clear_axis_angles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kAxisAngles) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.axis_angles_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::release_axis_angles() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.axis_angles)
  if (type_case() == kAxisAngles) {
    clear_has_type();
    auto* temp = _impl_.type_.axis_angles_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.axis_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_AxisAngles& Orientation::_internal_axis_angles() const {
  return type_case() == kAxisAngles ? *_impl_.type_.axis_angles_ : reinterpret_cast<::viam::app::v1::Orientation_AxisAngles&>(::viam::app::v1::_Orientation_AxisAngles_default_instance_);
}
inline const ::viam::app::v1::Orientation_AxisAngles& Orientation::axis_angles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.axis_angles)
  return _internal_axis_angles();
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::unsafe_arena_release_axis_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.axis_angles)
  if (type_case() == kAxisAngles) {
    clear_has_type();
    auto* temp = _impl_.type_.axis_angles_;
    _impl_.type_.axis_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_axis_angles(::viam::app::v1::Orientation_AxisAngles* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_axis_angles();
    _impl_.type_.axis_angles_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.axis_angles)
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::_internal_mutable_axis_angles() {
  if (type_case() != kAxisAngles) {
    clear_type();
    set_has_axis_angles();
    _impl_.type_.axis_angles_ = CreateMaybeMessage<::viam::app::v1::Orientation_AxisAngles>(GetArena());
  }
  return _impl_.type_.axis_angles_;
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::mutable_axis_angles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Orientation_AxisAngles* _msg = _internal_mutable_axis_angles();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.axis_angles)
  return _msg;
}

// .viam.app.v1.Orientation.Quaternion quaternion = 6 [json_name = "quaternion"];
inline bool Orientation::has_quaternion() const {
  return type_case() == kQuaternion;
}
inline bool Orientation::_internal_has_quaternion() const {
  return type_case() == kQuaternion;
}
inline void Orientation::set_has_quaternion() {
  _impl_._oneof_case_[0] = kQuaternion;
}
inline void Orientation::clear_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kQuaternion) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.quaternion_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::release_quaternion() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.quaternion)
  if (type_case() == kQuaternion) {
    clear_has_type();
    auto* temp = _impl_.type_.quaternion_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_Quaternion& Orientation::_internal_quaternion() const {
  return type_case() == kQuaternion ? *_impl_.type_.quaternion_ : reinterpret_cast<::viam::app::v1::Orientation_Quaternion&>(::viam::app::v1::_Orientation_Quaternion_default_instance_);
}
inline const ::viam::app::v1::Orientation_Quaternion& Orientation::quaternion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.quaternion)
  return _internal_quaternion();
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.quaternion)
  if (type_case() == kQuaternion) {
    clear_has_type();
    auto* temp = _impl_.type_.quaternion_;
    _impl_.type_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_quaternion(::viam::app::v1::Orientation_Quaternion* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_quaternion();
    _impl_.type_.quaternion_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.quaternion)
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::_internal_mutable_quaternion() {
  if (type_case() != kQuaternion) {
    clear_type();
    set_has_quaternion();
    _impl_.type_.quaternion_ = CreateMaybeMessage<::viam::app::v1::Orientation_Quaternion>(GetArena());
  }
  return _impl_.type_.quaternion_;
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::mutable_quaternion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Orientation_Quaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.quaternion)
  return _msg;
}

inline bool Orientation::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Orientation::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Orientation::TypeCase Orientation::type_case() const {
  return Orientation::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoteConfig

// string name = 1 [json_name = "name"];
inline void RemoteConfig::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RemoteConfig::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteConfig::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.name)
}
inline std::string* RemoteConfig::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.name)
  return _s;
}
inline const std::string& RemoteConfig::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RemoteConfig::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RemoteConfig::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RemoteConfig::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.name)
  return _impl_.name_.Release();
}
inline void RemoteConfig::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.name)
}

// string address = 2 [json_name = "address"];
inline void RemoteConfig::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& RemoteConfig::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteConfig::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.address)
}
inline std::string* RemoteConfig::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.address)
  return _s;
}
inline const std::string& RemoteConfig::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void RemoteConfig::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* RemoteConfig::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* RemoteConfig::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.address)
  return _impl_.address_.Release();
}
inline void RemoteConfig::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.address)
}

// .viam.app.v1.Frame frame = 3 [json_name = "frame"];
inline bool RemoteConfig::has_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frame_ != nullptr);
  return value;
}
inline void RemoteConfig::clear_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.frame_ != nullptr) _impl_.frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::Frame& RemoteConfig::_internal_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::Frame* p = _impl_.frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Frame&>(::viam::app::v1::_Frame_default_instance_);
}
inline const ::viam::app::v1::Frame& RemoteConfig::frame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.frame)
  return _internal_frame();
}
inline void RemoteConfig::unsafe_arena_set_allocated_frame(::viam::app::v1::Frame* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.frame_);
  }
  _impl_.frame_ = reinterpret_cast<::viam::app::v1::Frame*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.frame)
}
inline ::viam::app::v1::Frame* RemoteConfig::release_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::Frame* released = _impl_.frame_;
  _impl_.frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::Frame* RemoteConfig::unsafe_arena_release_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.frame)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::Frame* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Frame* RemoteConfig::_internal_mutable_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Frame>(GetArena());
    _impl_.frame_ = reinterpret_cast<::viam::app::v1::Frame*>(p);
  }
  return _impl_.frame_;
}
inline ::viam::app::v1::Frame* RemoteConfig::mutable_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::Frame* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.frame)
  return _msg;
}
inline void RemoteConfig::set_allocated_frame(::viam::app::v1::Frame* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::Frame*>(_impl_.frame_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::Frame*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.frame_ = reinterpret_cast<::viam::app::v1::Frame*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.frame)
}

// .viam.app.v1.RemoteAuth auth = 4 [json_name = "auth"];
inline bool RemoteConfig::has_auth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auth_ != nullptr);
  return value;
}
inline void RemoteConfig::clear_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.auth_ != nullptr) _impl_.auth_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::app::v1::RemoteAuth& RemoteConfig::_internal_auth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::RemoteAuth* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RemoteAuth&>(::viam::app::v1::_RemoteAuth_default_instance_);
}
inline const ::viam::app::v1::RemoteAuth& RemoteConfig::auth() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.auth)
  return _internal_auth();
}
inline void RemoteConfig::unsafe_arena_set_allocated_auth(::viam::app::v1::RemoteAuth* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = reinterpret_cast<::viam::app::v1::RemoteAuth*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.auth)
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::release_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::RemoteAuth* released = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::unsafe_arena_release_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.auth)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::RemoteAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::_internal_mutable_auth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RemoteAuth>(GetArena());
    _impl_.auth_ = reinterpret_cast<::viam::app::v1::RemoteAuth*>(p);
  }
  return _impl_.auth_;
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::mutable_auth() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::RemoteAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.auth)
  return _msg;
}
inline void RemoteConfig::set_allocated_auth(::viam::app::v1::RemoteAuth* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::RemoteAuth*>(_impl_.auth_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::RemoteAuth*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.auth_ = reinterpret_cast<::viam::app::v1::RemoteAuth*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.auth)
}

// string managed_by = 5 [json_name = "managedBy"];
inline void RemoteConfig::clear_managed_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.managed_by_.ClearToEmpty();
}
inline const std::string& RemoteConfig::managed_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.managed_by)
  return _internal_managed_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteConfig::set_managed_by(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.managed_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.managed_by)
}
inline std::string* RemoteConfig::mutable_managed_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_managed_by();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.managed_by)
  return _s;
}
inline const std::string& RemoteConfig::_internal_managed_by() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.managed_by_.Get();
}
inline void RemoteConfig::_internal_set_managed_by(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.managed_by_.Set(value, GetArena());
}
inline std::string* RemoteConfig::_internal_mutable_managed_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.managed_by_.Mutable( GetArena());
}
inline std::string* RemoteConfig::release_managed_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.managed_by)
  return _impl_.managed_by_.Release();
}
inline void RemoteConfig::set_allocated_managed_by(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.managed_by_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.managed_by_.IsDefault()) {
          _impl_.managed_by_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.managed_by)
}

// bool insecure = 6 [json_name = "insecure"];
inline void RemoteConfig::clear_insecure() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.insecure_ = false;
}
inline bool RemoteConfig::insecure() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.insecure)
  return _internal_insecure();
}
inline void RemoteConfig::set_insecure(bool value) {
  _internal_set_insecure(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.insecure)
}
inline bool RemoteConfig::_internal_insecure() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.insecure_;
}
inline void RemoteConfig::_internal_set_insecure(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.insecure_ = value;
}

// .google.protobuf.Duration connection_check_interval = 7 [json_name = "connectionCheckInterval"];
inline bool RemoteConfig::has_connection_check_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connection_check_interval_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RemoteConfig::_internal_connection_check_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.connection_check_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RemoteConfig::connection_check_interval() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.connection_check_interval)
  return _internal_connection_check_interval();
}
inline void RemoteConfig::unsafe_arena_set_allocated_connection_check_interval(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connection_check_interval_);
  }
  _impl_.connection_check_interval_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.connection_check_interval)
}
inline ::google::protobuf::Duration* RemoteConfig::release_connection_check_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* released = _impl_.connection_check_interval_;
  _impl_.connection_check_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RemoteConfig::unsafe_arena_release_connection_check_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.connection_check_interval)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* temp = _impl_.connection_check_interval_;
  _impl_.connection_check_interval_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RemoteConfig::_internal_mutable_connection_check_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.connection_check_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.connection_check_interval_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.connection_check_interval_;
}
inline ::google::protobuf::Duration* RemoteConfig::mutable_connection_check_interval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_connection_check_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.connection_check_interval)
  return _msg;
}
inline void RemoteConfig::set_allocated_connection_check_interval(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connection_check_interval_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.connection_check_interval_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.connection_check_interval)
}

// .google.protobuf.Duration reconnect_interval = 8 [json_name = "reconnectInterval"];
inline bool RemoteConfig::has_reconnect_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reconnect_interval_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RemoteConfig::_internal_reconnect_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.reconnect_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RemoteConfig::reconnect_interval() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.reconnect_interval)
  return _internal_reconnect_interval();
}
inline void RemoteConfig::unsafe_arena_set_allocated_reconnect_interval(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reconnect_interval_);
  }
  _impl_.reconnect_interval_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.reconnect_interval)
}
inline ::google::protobuf::Duration* RemoteConfig::release_reconnect_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* released = _impl_.reconnect_interval_;
  _impl_.reconnect_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RemoteConfig::unsafe_arena_release_reconnect_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.reconnect_interval)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* temp = _impl_.reconnect_interval_;
  _impl_.reconnect_interval_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RemoteConfig::_internal_mutable_reconnect_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.reconnect_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.reconnect_interval_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.reconnect_interval_;
}
inline ::google::protobuf::Duration* RemoteConfig::mutable_reconnect_interval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_reconnect_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.reconnect_interval)
  return _msg;
}
inline void RemoteConfig::set_allocated_reconnect_interval(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reconnect_interval_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.reconnect_interval_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.reconnect_interval)
}

// repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 9 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
inline int RemoteConfig::_internal_service_configs_size() const {
  return _internal_service_configs().size();
}
inline int RemoteConfig::service_configs_size() const {
  return _internal_service_configs_size();
}
inline void RemoteConfig::clear_service_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.service_configs_.Clear();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* RemoteConfig::mutable_service_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.service_configs)
  return _internal_mutable_service_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>* RemoteConfig::mutable_service_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RemoteConfig.service_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_service_configs();
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& RemoteConfig::service_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.service_configs)
  return _internal_service_configs().Get(index);
}
inline ::viam::app::v1::ResourceLevelServiceConfig* RemoteConfig::add_service_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::app::v1::ResourceLevelServiceConfig* _add = _internal_mutable_service_configs()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.RemoteConfig.service_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>& RemoteConfig::service_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.RemoteConfig.service_configs)
  return _internal_service_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>&
RemoteConfig::_internal_service_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.service_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::app::v1::ResourceLevelServiceConfig>*
RemoteConfig::_internal_mutable_service_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.service_configs_;
}

// string secret = 10 [json_name = "secret"];
inline void RemoteConfig::clear_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& RemoteConfig::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteConfig::set_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.secret)
}
inline std::string* RemoteConfig::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.secret)
  return _s;
}
inline const std::string& RemoteConfig::_internal_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secret_.Get();
}
inline void RemoteConfig::_internal_set_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* RemoteConfig::_internal_mutable_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* RemoteConfig::release_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.secret)
  return _impl_.secret_.Release();
}
inline void RemoteConfig::set_allocated_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.secret)
}

// -------------------------------------------------------------------

// RemoteAuth_Credentials

// .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
inline void RemoteAuth_Credentials::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::viam::app::v1::CredentialsType RemoteAuth_Credentials::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.Credentials.type)
  return _internal_type();
}
inline void RemoteAuth_Credentials::set_type(::viam::app::v1::CredentialsType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteAuth.Credentials.type)
}
inline ::viam::app::v1::CredentialsType RemoteAuth_Credentials::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::viam::app::v1::CredentialsType>(_impl_.type_);
}
inline void RemoteAuth_Credentials::_internal_set_type(::viam::app::v1::CredentialsType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string payload = 2 [json_name = "payload"];
inline void RemoteAuth_Credentials::clear_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& RemoteAuth_Credentials::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.Credentials.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteAuth_Credentials::set_payload(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.payload_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteAuth.Credentials.payload)
}
inline std::string* RemoteAuth_Credentials::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteAuth.Credentials.payload)
  return _s;
}
inline const std::string& RemoteAuth_Credentials::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_.Get();
}
inline void RemoteAuth_Credentials::_internal_set_payload(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.payload_.Set(value, GetArena());
}
inline std::string* RemoteAuth_Credentials::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.payload_.Mutable( GetArena());
}
inline std::string* RemoteAuth_Credentials::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteAuth.Credentials.payload)
  return _impl_.payload_.Release();
}
inline void RemoteAuth_Credentials::set_allocated_payload(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteAuth.Credentials.payload)
}

// -------------------------------------------------------------------

// RemoteAuth

// .viam.app.v1.RemoteAuth.Credentials credentials = 1 [json_name = "credentials"];
inline bool RemoteAuth::has_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.credentials_ != nullptr);
  return value;
}
inline void RemoteAuth::clear_credentials() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.credentials_ != nullptr) _impl_.credentials_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::RemoteAuth_Credentials& RemoteAuth::_internal_credentials() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::RemoteAuth_Credentials* p = _impl_.credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RemoteAuth_Credentials&>(::viam::app::v1::_RemoteAuth_Credentials_default_instance_);
}
inline const ::viam::app::v1::RemoteAuth_Credentials& RemoteAuth::credentials() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.credentials)
  return _internal_credentials();
}
inline void RemoteAuth::unsafe_arena_set_allocated_credentials(::viam::app::v1::RemoteAuth_Credentials* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.credentials_);
  }
  _impl_.credentials_ = reinterpret_cast<::viam::app::v1::RemoteAuth_Credentials*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteAuth.credentials)
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::release_credentials() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::RemoteAuth_Credentials* released = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::unsafe_arena_release_credentials() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteAuth.credentials)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::RemoteAuth_Credentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::_internal_mutable_credentials() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RemoteAuth_Credentials>(GetArena());
    _impl_.credentials_ = reinterpret_cast<::viam::app::v1::RemoteAuth_Credentials*>(p);
  }
  return _impl_.credentials_;
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::mutable_credentials() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::RemoteAuth_Credentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteAuth.credentials)
  return _msg;
}
inline void RemoteAuth::set_allocated_credentials(::viam::app::v1::RemoteAuth_Credentials* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::RemoteAuth_Credentials*>(_impl_.credentials_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::RemoteAuth_Credentials*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.credentials_ = reinterpret_cast<::viam::app::v1::RemoteAuth_Credentials*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteAuth.credentials)
}

// string entity = 2 [json_name = "entity"];
inline void RemoteAuth::clear_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_.ClearToEmpty();
}
inline const std::string& RemoteAuth::entity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.entity)
  return _internal_entity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteAuth::set_entity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteAuth.entity)
}
inline std::string* RemoteAuth::mutable_entity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteAuth.entity)
  return _s;
}
inline const std::string& RemoteAuth::_internal_entity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_.Get();
}
inline void RemoteAuth::_internal_set_entity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_.Set(value, GetArena());
}
inline std::string* RemoteAuth::_internal_mutable_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_.Mutable( GetArena());
}
inline std::string* RemoteAuth::release_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteAuth.entity)
  return _impl_.entity_.Release();
}
inline void RemoteAuth::set_allocated_entity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_.IsDefault()) {
          _impl_.entity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteAuth.entity)
}

// -------------------------------------------------------------------

// AgentInfo

// string host = 1 [json_name = "host"];
inline void AgentInfo::clear_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.ClearToEmpty();
}
inline const std::string& AgentInfo::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AgentInfo::set_host(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.host)
}
inline std::string* AgentInfo::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.host)
  return _s;
}
inline const std::string& AgentInfo::_internal_host() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.host_.Get();
}
inline void AgentInfo::_internal_set_host(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(value, GetArena());
}
inline std::string* AgentInfo::_internal_mutable_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* AgentInfo::release_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.host)
  return _impl_.host_.Release();
}
inline void AgentInfo::set_allocated_host(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.host)
}

// string os = 2 [json_name = "os"];
inline void AgentInfo::clear_os() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.os_.ClearToEmpty();
}
inline const std::string& AgentInfo::os() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.os)
  return _internal_os();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AgentInfo::set_os(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.os_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.os)
}
inline std::string* AgentInfo::mutable_os() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.os)
  return _s;
}
inline const std::string& AgentInfo::_internal_os() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.os_.Get();
}
inline void AgentInfo::_internal_set_os(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.os_.Set(value, GetArena());
}
inline std::string* AgentInfo::_internal_mutable_os() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.os_.Mutable( GetArena());
}
inline std::string* AgentInfo::release_os() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.os)
  return _impl_.os_.Release();
}
inline void AgentInfo::set_allocated_os(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.os_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.os_.IsDefault()) {
          _impl_.os_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.os)
}

// repeated string ips = 3 [json_name = "ips"];
inline int AgentInfo::_internal_ips_size() const {
  return _internal_ips().size();
}
inline int AgentInfo::ips_size() const {
  return _internal_ips_size();
}
inline void AgentInfo::clear_ips() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ips_.Clear();
}
inline std::string* AgentInfo::add_ips()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_ips()->Add();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.AgentInfo.ips)
  return _s;
}
inline const std::string& AgentInfo::ips(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.ips)
  return _internal_ips().Get(index);
}
inline std::string* AgentInfo::mutable_ips(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.ips)
  return _internal_mutable_ips()->Mutable(index);
}
inline void AgentInfo::set_ips(int index, const std::string& value) {
  _internal_mutable_ips()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::set_ips(int index, std::string&& value) {
  _internal_mutable_ips()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::set_ips(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ips()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::set_ips(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ips()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::set_ips(int index, absl::string_view value) {
  _internal_mutable_ips()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ips()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ips()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ips()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ips()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ips()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:viam.app.v1.AgentInfo.ips)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AgentInfo::ips() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.AgentInfo.ips)
  return _internal_ips();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AgentInfo::mutable_ips() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AgentInfo.ips)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ips();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AgentInfo::_internal_ips() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ips_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AgentInfo::_internal_mutable_ips() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ips_;
}

// string version = 4 [json_name = "version"];
inline void AgentInfo::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& AgentInfo::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AgentInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.version)
}
inline std::string* AgentInfo::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.version)
  return _s;
}
inline const std::string& AgentInfo::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void AgentInfo::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* AgentInfo::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* AgentInfo::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.version)
  return _impl_.version_.Release();
}
inline void AgentInfo::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.version)
}

// string git_revision = 5 [json_name = "gitRevision"];
inline void AgentInfo::clear_git_revision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.git_revision_.ClearToEmpty();
}
inline const std::string& AgentInfo::git_revision() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.git_revision)
  return _internal_git_revision();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AgentInfo::set_git_revision(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.git_revision_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.git_revision)
}
inline std::string* AgentInfo::mutable_git_revision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_git_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.git_revision)
  return _s;
}
inline const std::string& AgentInfo::_internal_git_revision() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.git_revision_.Get();
}
inline void AgentInfo::_internal_set_git_revision(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.git_revision_.Set(value, GetArena());
}
inline std::string* AgentInfo::_internal_mutable_git_revision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.git_revision_.Mutable( GetArena());
}
inline std::string* AgentInfo::release_git_revision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.git_revision)
  return _impl_.git_revision_.Release();
}
inline void AgentInfo::set_allocated_git_revision(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.git_revision_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.git_revision_.IsDefault()) {
          _impl_.git_revision_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.git_revision)
}

// optional string platform = 6 [json_name = "platform"];
inline bool AgentInfo::has_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AgentInfo::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AgentInfo::platform() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.platform)
  return _internal_platform();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AgentInfo::set_platform(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.platform_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.platform)
}
inline std::string* AgentInfo::mutable_platform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.platform)
  return _s;
}
inline const std::string& AgentInfo::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_.Get();
}
inline void AgentInfo::_internal_set_platform(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.platform_.Set(value, GetArena());
}
inline std::string* AgentInfo::_internal_mutable_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.platform_.Mutable( GetArena());
}
inline std::string* AgentInfo::release_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.platform)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.platform_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.platform_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AgentInfo::set_allocated_platform(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.platform_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_.IsDefault()) {
          _impl_.platform_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.platform)
}

// -------------------------------------------------------------------

// ConfigRequest

// string id = 1 [json_name = "id"];
inline void ConfigRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConfigRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ConfigRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConfigRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ConfigRequest.id)
}
inline std::string* ConfigRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ConfigRequest.id)
  return _s;
}
inline const std::string& ConfigRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ConfigRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ConfigRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ConfigRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ConfigRequest.id)
  return _impl_.id_.Release();
}
inline void ConfigRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ConfigRequest.id)
}

// optional .viam.app.v1.AgentInfo agent_info = 2 [json_name = "agentInfo"];
inline bool ConfigRequest::has_agent_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.agent_info_ != nullptr);
  return value;
}
inline void ConfigRequest::clear_agent_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.agent_info_ != nullptr) _impl_.agent_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::AgentInfo& ConfigRequest::_internal_agent_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::AgentInfo* p = _impl_.agent_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AgentInfo&>(::viam::app::v1::_AgentInfo_default_instance_);
}
inline const ::viam::app::v1::AgentInfo& ConfigRequest::agent_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ConfigRequest.agent_info)
  return _internal_agent_info();
}
inline void ConfigRequest::unsafe_arena_set_allocated_agent_info(::viam::app::v1::AgentInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.agent_info_);
  }
  _impl_.agent_info_ = reinterpret_cast<::viam::app::v1::AgentInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ConfigRequest.agent_info)
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::release_agent_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AgentInfo* released = _impl_.agent_info_;
  _impl_.agent_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::unsafe_arena_release_agent_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ConfigRequest.agent_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AgentInfo* temp = _impl_.agent_info_;
  _impl_.agent_info_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::_internal_mutable_agent_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.agent_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AgentInfo>(GetArena());
    _impl_.agent_info_ = reinterpret_cast<::viam::app::v1::AgentInfo*>(p);
  }
  return _impl_.agent_info_;
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::mutable_agent_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::AgentInfo* _msg = _internal_mutable_agent_info();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ConfigRequest.agent_info)
  return _msg;
}
inline void ConfigRequest::set_allocated_agent_info(::viam::app::v1::AgentInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::AgentInfo*>(_impl_.agent_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::AgentInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.agent_info_ = reinterpret_cast<::viam::app::v1::AgentInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ConfigRequest.agent_info)
}

// -------------------------------------------------------------------

// ConfigResponse

// .viam.app.v1.RobotConfig config = 1 [json_name = "config"];
inline bool ConfigResponse::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void ConfigResponse::clear_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::RobotConfig& ConfigResponse::_internal_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::RobotConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotConfig&>(::viam::app::v1::_RobotConfig_default_instance_);
}
inline const ::viam::app::v1::RobotConfig& ConfigResponse::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ConfigResponse.config)
  return _internal_config();
}
inline void ConfigResponse::unsafe_arena_set_allocated_config(::viam::app::v1::RobotConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::viam::app::v1::RobotConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ConfigResponse.config)
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::RobotConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::unsafe_arena_release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ConfigResponse.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::RobotConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::_internal_mutable_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::viam::app::v1::RobotConfig*>(p);
  }
  return _impl_.config_;
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::RobotConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ConfigResponse.config)
  return _msg;
}
inline void ConfigResponse::set_allocated_config(::viam::app::v1::RobotConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::RobotConfig*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::RobotConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::viam::app::v1::RobotConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ConfigResponse.config)
}

// -------------------------------------------------------------------

// CertificateRequest

// string id = 1 [json_name = "id"];
inline void CertificateRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CertificateRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CertificateRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateRequest.id)
}
inline std::string* CertificateRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateRequest.id)
  return _s;
}
inline const std::string& CertificateRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CertificateRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CertificateRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CertificateRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateRequest.id)
  return _impl_.id_.Release();
}
inline void CertificateRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateRequest.id)
}

// -------------------------------------------------------------------

// CertificateResponse

// string id = 1 [json_name = "id"];
inline void CertificateResponse::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CertificateResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CertificateResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateResponse.id)
}
inline std::string* CertificateResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateResponse.id)
  return _s;
}
inline const std::string& CertificateResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void CertificateResponse::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CertificateResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CertificateResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateResponse.id)
  return _impl_.id_.Release();
}
inline void CertificateResponse::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateResponse.id)
}

// string tls_certificate = 2 [json_name = "tlsCertificate"];
inline void CertificateResponse::clear_tls_certificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_certificate_.ClearToEmpty();
}
inline const std::string& CertificateResponse::tls_certificate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateResponse.tls_certificate)
  return _internal_tls_certificate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CertificateResponse::set_tls_certificate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_certificate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateResponse.tls_certificate)
}
inline std::string* CertificateResponse::mutable_tls_certificate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tls_certificate();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateResponse.tls_certificate)
  return _s;
}
inline const std::string& CertificateResponse::_internal_tls_certificate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tls_certificate_.Get();
}
inline void CertificateResponse::_internal_set_tls_certificate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_certificate_.Set(value, GetArena());
}
inline std::string* CertificateResponse::_internal_mutable_tls_certificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tls_certificate_.Mutable( GetArena());
}
inline std::string* CertificateResponse::release_tls_certificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateResponse.tls_certificate)
  return _impl_.tls_certificate_.Release();
}
inline void CertificateResponse::set_allocated_tls_certificate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_certificate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tls_certificate_.IsDefault()) {
          _impl_.tls_certificate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateResponse.tls_certificate)
}

// string tls_private_key = 3 [json_name = "tlsPrivateKey"];
inline void CertificateResponse::clear_tls_private_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_private_key_.ClearToEmpty();
}
inline const std::string& CertificateResponse::tls_private_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateResponse.tls_private_key)
  return _internal_tls_private_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CertificateResponse::set_tls_private_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_private_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateResponse.tls_private_key)
}
inline std::string* CertificateResponse::mutable_tls_private_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tls_private_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateResponse.tls_private_key)
  return _s;
}
inline const std::string& CertificateResponse::_internal_tls_private_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tls_private_key_.Get();
}
inline void CertificateResponse::_internal_set_tls_private_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_private_key_.Set(value, GetArena());
}
inline std::string* CertificateResponse::_internal_mutable_tls_private_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tls_private_key_.Mutable( GetArena());
}
inline std::string* CertificateResponse::release_tls_private_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateResponse.tls_private_key)
  return _impl_.tls_private_key_.Release();
}
inline void CertificateResponse::set_allocated_tls_private_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_private_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tls_private_key_.IsDefault()) {
          _impl_.tls_private_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateResponse.tls_private_key)
}

// -------------------------------------------------------------------

// LogRequest

// string id = 1 [json_name = "id"];
inline void LogRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& LogRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogRequest.id)
}
inline std::string* LogRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogRequest.id)
  return _s;
}
inline const std::string& LogRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void LogRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* LogRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* LogRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.LogRequest.id)
  return _impl_.id_.Release();
}
inline void LogRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogRequest.id)
}

// repeated .viam.common.v1.LogEntry logs = 2 [json_name = "logs"];
inline int LogRequest::_internal_logs_size() const {
  return _internal_logs().size();
}
inline int LogRequest::logs_size() const {
  return _internal_logs_size();
}
inline ::viam::common::v1::LogEntry* LogRequest::mutable_logs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogRequest.logs)
  return _internal_mutable_logs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::LogEntry>* LogRequest::mutable_logs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.LogRequest.logs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_logs();
}
inline const ::viam::common::v1::LogEntry& LogRequest::logs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogRequest.logs)
  return _internal_logs().Get(index);
}
inline ::viam::common::v1::LogEntry* LogRequest::add_logs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::viam::common::v1::LogEntry* _add = _internal_mutable_logs()->Add();
  // @@protoc_insertion_point(field_add:viam.app.v1.LogRequest.logs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::LogEntry>& LogRequest::logs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:viam.app.v1.LogRequest.logs)
  return _internal_logs();
}
inline const ::google::protobuf::RepeatedPtrField<::viam::common::v1::LogEntry>&
LogRequest::_internal_logs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.logs_;
}
inline ::google::protobuf::RepeatedPtrField<::viam::common::v1::LogEntry>*
LogRequest::_internal_mutable_logs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.logs_;
}

// -------------------------------------------------------------------

// LogResponse

// -------------------------------------------------------------------

// NeedsRestartRequest

// string id = 1 [json_name = "id"];
inline void NeedsRestartRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NeedsRestartRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NeedsRestartRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.NeedsRestartRequest.id)
}
inline std::string* NeedsRestartRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NeedsRestartRequest.id)
  return _s;
}
inline const std::string& NeedsRestartRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void NeedsRestartRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NeedsRestartRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NeedsRestartRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NeedsRestartRequest.id)
  return _impl_.id_.Release();
}
inline void NeedsRestartRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NeedsRestartRequest.id)
}

// -------------------------------------------------------------------

// NeedsRestartResponse

// string id = 1 [json_name = "id"];
inline void NeedsRestartResponse::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NeedsRestartResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NeedsRestartResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.NeedsRestartResponse.id)
}
inline std::string* NeedsRestartResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NeedsRestartResponse.id)
  return _s;
}
inline const std::string& NeedsRestartResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void NeedsRestartResponse::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NeedsRestartResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NeedsRestartResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NeedsRestartResponse.id)
  return _impl_.id_.Release();
}
inline void NeedsRestartResponse::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NeedsRestartResponse.id)
}

// bool must_restart = 2 [json_name = "mustRestart"];
inline void NeedsRestartResponse::clear_must_restart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.must_restart_ = false;
}
inline bool NeedsRestartResponse::must_restart() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartResponse.must_restart)
  return _internal_must_restart();
}
inline void NeedsRestartResponse::set_must_restart(bool value) {
  _internal_set_must_restart(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.NeedsRestartResponse.must_restart)
}
inline bool NeedsRestartResponse::_internal_must_restart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.must_restart_;
}
inline void NeedsRestartResponse::_internal_set_must_restart(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.must_restart_ = value;
}

// .google.protobuf.Duration restart_check_interval = 3 [json_name = "restartCheckInterval"];
inline bool NeedsRestartResponse::has_restart_check_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.restart_check_interval_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& NeedsRestartResponse::_internal_restart_check_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.restart_check_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& NeedsRestartResponse::restart_check_interval() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartResponse.restart_check_interval)
  return _internal_restart_check_interval();
}
inline void NeedsRestartResponse::unsafe_arena_set_allocated_restart_check_interval(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.restart_check_interval_);
  }
  _impl_.restart_check_interval_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.NeedsRestartResponse.restart_check_interval)
}
inline ::google::protobuf::Duration* NeedsRestartResponse::release_restart_check_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.restart_check_interval_;
  _impl_.restart_check_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* NeedsRestartResponse::unsafe_arena_release_restart_check_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.NeedsRestartResponse.restart_check_interval)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.restart_check_interval_;
  _impl_.restart_check_interval_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* NeedsRestartResponse::_internal_mutable_restart_check_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.restart_check_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.restart_check_interval_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.restart_check_interval_;
}
inline ::google::protobuf::Duration* NeedsRestartResponse::mutable_restart_check_interval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_restart_check_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NeedsRestartResponse.restart_check_interval)
  return _msg;
}
inline void NeedsRestartResponse::set_allocated_restart_check_interval(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.restart_check_interval_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.restart_check_interval_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NeedsRestartResponse.restart_check_interval)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModuleConfig

// string name = 1 [json_name = "name"];
inline void ModuleConfig::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModuleConfig::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleConfig::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.name)
}
inline std::string* ModuleConfig::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.name)
  return _s;
}
inline const std::string& ModuleConfig::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ModuleConfig::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ModuleConfig::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ModuleConfig::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.name)
  return _impl_.name_.Release();
}
inline void ModuleConfig::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.name)
}

// string path = 2 [json_name = "path"];
inline void ModuleConfig::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ModuleConfig::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleConfig::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.path)
}
inline std::string* ModuleConfig::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.path)
  return _s;
}
inline const std::string& ModuleConfig::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void ModuleConfig::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* ModuleConfig::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* ModuleConfig::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.path)
  return _impl_.path_.Release();
}
inline void ModuleConfig::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.path)
}

// string log_level = 3 [json_name = "logLevel"];
inline void ModuleConfig::clear_log_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_level_.ClearToEmpty();
}
inline const std::string& ModuleConfig::log_level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.log_level)
  return _internal_log_level();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleConfig::set_log_level(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.log_level)
}
inline std::string* ModuleConfig::mutable_log_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_level();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.log_level)
  return _s;
}
inline const std::string& ModuleConfig::_internal_log_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_level_.Get();
}
inline void ModuleConfig::_internal_set_log_level(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_level_.Set(value, GetArena());
}
inline std::string* ModuleConfig::_internal_mutable_log_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.log_level_.Mutable( GetArena());
}
inline std::string* ModuleConfig::release_log_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.log_level)
  return _impl_.log_level_.Release();
}
inline void ModuleConfig::set_allocated_log_level(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_level_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_level_.IsDefault()) {
          _impl_.log_level_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.log_level)
}

// string type = 4 [json_name = "type"];
inline void ModuleConfig::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ModuleConfig::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleConfig::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.type)
}
inline std::string* ModuleConfig::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.type)
  return _s;
}
inline const std::string& ModuleConfig::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void ModuleConfig::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* ModuleConfig::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* ModuleConfig::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.type)
  return _impl_.type_.Release();
}
inline void ModuleConfig::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.type)
}

// string module_id = 5 [json_name = "moduleId"];
inline void ModuleConfig::clear_module_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.module_id_.ClearToEmpty();
}
inline const std::string& ModuleConfig::module_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.module_id)
  return _internal_module_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModuleConfig::set_module_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.module_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.module_id)
}
inline std::string* ModuleConfig::mutable_module_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.module_id)
  return _s;
}
inline const std::string& ModuleConfig::_internal_module_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.module_id_.Get();
}
inline void ModuleConfig::_internal_set_module_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.module_id_.Set(value, GetArena());
}
inline std::string* ModuleConfig::_internal_mutable_module_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.module_id_.Mutable( GetArena());
}
inline std::string* ModuleConfig::release_module_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.module_id)
  return _impl_.module_id_.Release();
}
inline void ModuleConfig::set_allocated_module_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.module_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.module_id_.IsDefault()) {
          _impl_.module_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.module_id)
}

// map<string, string> env = 6 [json_name = "env"];
inline int ModuleConfig::_internal_env_size() const {
  return _internal_env().size();
}
inline int ModuleConfig::env_size() const {
  return _internal_env_size();
}
inline void ModuleConfig::clear_env() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.env_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModuleConfig::_internal_env() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.env_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModuleConfig::env() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:viam.app.v1.ModuleConfig.env)
  return _internal_env();
}
inline ::google::protobuf::Map<std::string, std::string>* ModuleConfig::_internal_mutable_env() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.env_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModuleConfig::mutable_env() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:viam.app.v1.ModuleConfig.env)
  return _internal_mutable_env();
}

// .viam.app.v1.AppValidationStatus status = 7 [json_name = "status"];
inline bool ModuleConfig::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ModuleConfig::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::AppValidationStatus& ModuleConfig::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::AppValidationStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AppValidationStatus&>(::viam::app::v1::_AppValidationStatus_default_instance_);
}
inline const ::viam::app::v1::AppValidationStatus& ModuleConfig::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.status)
  return _internal_status();
}
inline void ModuleConfig::unsafe_arena_set_allocated_status(::viam::app::v1::AppValidationStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ModuleConfig.status)
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AppValidationStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AppValidationStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AppValidationStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(p);
  }
  return _impl_.status_;
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::AppValidationStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.status)
  return _msg;
}
inline void ModuleConfig::set_allocated_status(::viam::app::v1::AppValidationStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::AppValidationStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.status)
}

// -------------------------------------------------------------------

// PackageConfig

// string name = 1 [json_name = "name"];
inline void PackageConfig::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PackageConfig::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PackageConfig::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.name)
}
inline std::string* PackageConfig::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.name)
  return _s;
}
inline const std::string& PackageConfig::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void PackageConfig::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PackageConfig::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PackageConfig::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.name)
  return _impl_.name_.Release();
}
inline void PackageConfig::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.name)
}

// string package = 2 [json_name = "package"];
inline void PackageConfig::clear_package() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.package_.ClearToEmpty();
}
inline const std::string& PackageConfig::package() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.package)
  return _internal_package();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PackageConfig::set_package(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.package_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.package)
}
inline std::string* PackageConfig::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.package)
  return _s;
}
inline const std::string& PackageConfig::_internal_package() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.package_.Get();
}
inline void PackageConfig::_internal_set_package(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.package_.Set(value, GetArena());
}
inline std::string* PackageConfig::_internal_mutable_package() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.package_.Mutable( GetArena());
}
inline std::string* PackageConfig::release_package() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.package)
  return _impl_.package_.Release();
}
inline void PackageConfig::set_allocated_package(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.package_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.package_.IsDefault()) {
          _impl_.package_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.package)
}

// string version = 3 [json_name = "version"];
inline void PackageConfig::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& PackageConfig::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PackageConfig::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.version)
}
inline std::string* PackageConfig::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.version)
  return _s;
}
inline const std::string& PackageConfig::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void PackageConfig::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* PackageConfig::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* PackageConfig::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.version)
  return _impl_.version_.Release();
}
inline void PackageConfig::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.version)
}

// string type = 4 [json_name = "type"];
inline void PackageConfig::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& PackageConfig::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PackageConfig::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.type)
}
inline std::string* PackageConfig::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.type)
  return _s;
}
inline const std::string& PackageConfig::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void PackageConfig::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* PackageConfig::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* PackageConfig::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.type)
  return _impl_.type_.Release();
}
inline void PackageConfig::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.type)
}

// .viam.app.v1.AppValidationStatus status = 5 [json_name = "status"];
inline bool PackageConfig::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void PackageConfig::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::AppValidationStatus& PackageConfig::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::viam::app::v1::AppValidationStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AppValidationStatus&>(::viam::app::v1::_AppValidationStatus_default_instance_);
}
inline const ::viam::app::v1::AppValidationStatus& PackageConfig::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.status)
  return _internal_status();
}
inline void PackageConfig::unsafe_arena_set_allocated_status(::viam::app::v1::AppValidationStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.PackageConfig.status)
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AppValidationStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AppValidationStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AppValidationStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(p);
  }
  return _impl_.status_;
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::viam::app::v1::AppValidationStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.status)
  return _msg;
}
inline void PackageConfig::set_allocated_status(::viam::app::v1::AppValidationStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::viam::app::v1::AppValidationStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::viam::app::v1::AppValidationStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.status)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace app
}  // namespace viam


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::viam::app::v1::CredentialsType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::viam::app::v1::CredentialsType>() {
  return ::viam::app::v1::CredentialsType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2frobot_2eproto_2epb_2eh
