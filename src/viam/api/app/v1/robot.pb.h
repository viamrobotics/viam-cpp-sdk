// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/v1/robot.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2frobot_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2frobot_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/common.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fv1_2frobot_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fv1_2frobot_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fv1_2frobot_2eproto;
namespace viam {
namespace app {
namespace v1 {
class AgentInfo;
struct AgentInfoDefaultTypeInternal;
extern AgentInfoDefaultTypeInternal _AgentInfo_default_instance_;
class AppValidationStatus;
struct AppValidationStatusDefaultTypeInternal;
extern AppValidationStatusDefaultTypeInternal _AppValidationStatus_default_instance_;
class AuthConfig;
struct AuthConfigDefaultTypeInternal;
extern AuthConfigDefaultTypeInternal _AuthConfig_default_instance_;
class AuthHandlerConfig;
struct AuthHandlerConfigDefaultTypeInternal;
extern AuthHandlerConfigDefaultTypeInternal _AuthHandlerConfig_default_instance_;
class CertificateRequest;
struct CertificateRequestDefaultTypeInternal;
extern CertificateRequestDefaultTypeInternal _CertificateRequest_default_instance_;
class CertificateResponse;
struct CertificateResponseDefaultTypeInternal;
extern CertificateResponseDefaultTypeInternal _CertificateResponse_default_instance_;
class CloudConfig;
struct CloudConfigDefaultTypeInternal;
extern CloudConfigDefaultTypeInternal _CloudConfig_default_instance_;
class ComponentConfig;
struct ComponentConfigDefaultTypeInternal;
extern ComponentConfigDefaultTypeInternal _ComponentConfig_default_instance_;
class ConfigRequest;
struct ConfigRequestDefaultTypeInternal;
extern ConfigRequestDefaultTypeInternal _ConfigRequest_default_instance_;
class ConfigResponse;
struct ConfigResponseDefaultTypeInternal;
extern ConfigResponseDefaultTypeInternal _ConfigResponse_default_instance_;
class ExternalAuthConfig;
struct ExternalAuthConfigDefaultTypeInternal;
extern ExternalAuthConfigDefaultTypeInternal _ExternalAuthConfig_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class JWKSFile;
struct JWKSFileDefaultTypeInternal;
extern JWKSFileDefaultTypeInternal _JWKSFile_default_instance_;
class JobConfig;
struct JobConfigDefaultTypeInternal;
extern JobConfigDefaultTypeInternal _JobConfig_default_instance_;
class LocationSecret;
struct LocationSecretDefaultTypeInternal;
extern LocationSecretDefaultTypeInternal _LocationSecret_default_instance_;
class LogConfiguration;
struct LogConfigurationDefaultTypeInternal;
extern LogConfigurationDefaultTypeInternal _LogConfiguration_default_instance_;
class LogPatternConfig;
struct LogPatternConfigDefaultTypeInternal;
extern LogPatternConfigDefaultTypeInternal _LogPatternConfig_default_instance_;
class LogRequest;
struct LogRequestDefaultTypeInternal;
extern LogRequestDefaultTypeInternal _LogRequest_default_instance_;
class LogResponse;
struct LogResponseDefaultTypeInternal;
extern LogResponseDefaultTypeInternal _LogResponse_default_instance_;
class MaintenanceConfig;
struct MaintenanceConfigDefaultTypeInternal;
extern MaintenanceConfigDefaultTypeInternal _MaintenanceConfig_default_instance_;
class ModuleConfig;
struct ModuleConfigDefaultTypeInternal;
extern ModuleConfigDefaultTypeInternal _ModuleConfig_default_instance_;
class ModuleConfig_EnvEntry_DoNotUse;
struct ModuleConfig_EnvEntry_DoNotUseDefaultTypeInternal;
extern ModuleConfig_EnvEntry_DoNotUseDefaultTypeInternal _ModuleConfig_EnvEntry_DoNotUse_default_instance_;
class NeedsRestartRequest;
struct NeedsRestartRequestDefaultTypeInternal;
extern NeedsRestartRequestDefaultTypeInternal _NeedsRestartRequest_default_instance_;
class NeedsRestartResponse;
struct NeedsRestartResponseDefaultTypeInternal;
extern NeedsRestartResponseDefaultTypeInternal _NeedsRestartResponse_default_instance_;
class NetworkConfig;
struct NetworkConfigDefaultTypeInternal;
extern NetworkConfigDefaultTypeInternal _NetworkConfig_default_instance_;
class Orientation;
struct OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class Orientation_AxisAngles;
struct Orientation_AxisAnglesDefaultTypeInternal;
extern Orientation_AxisAnglesDefaultTypeInternal _Orientation_AxisAngles_default_instance_;
class Orientation_EulerAngles;
struct Orientation_EulerAnglesDefaultTypeInternal;
extern Orientation_EulerAnglesDefaultTypeInternal _Orientation_EulerAngles_default_instance_;
class Orientation_NoOrientation;
struct Orientation_NoOrientationDefaultTypeInternal;
extern Orientation_NoOrientationDefaultTypeInternal _Orientation_NoOrientation_default_instance_;
class Orientation_OrientationVectorDegrees;
struct Orientation_OrientationVectorDegreesDefaultTypeInternal;
extern Orientation_OrientationVectorDegreesDefaultTypeInternal _Orientation_OrientationVectorDegrees_default_instance_;
class Orientation_OrientationVectorRadians;
struct Orientation_OrientationVectorRadiansDefaultTypeInternal;
extern Orientation_OrientationVectorRadiansDefaultTypeInternal _Orientation_OrientationVectorRadians_default_instance_;
class Orientation_Quaternion;
struct Orientation_QuaternionDefaultTypeInternal;
extern Orientation_QuaternionDefaultTypeInternal _Orientation_Quaternion_default_instance_;
class PackageConfig;
struct PackageConfigDefaultTypeInternal;
extern PackageConfigDefaultTypeInternal _PackageConfig_default_instance_;
class ProcessConfig;
struct ProcessConfigDefaultTypeInternal;
extern ProcessConfigDefaultTypeInternal _ProcessConfig_default_instance_;
class ProcessConfig_EnvEntry_DoNotUse;
struct ProcessConfig_EnvEntry_DoNotUseDefaultTypeInternal;
extern ProcessConfig_EnvEntry_DoNotUseDefaultTypeInternal _ProcessConfig_EnvEntry_DoNotUse_default_instance_;
class RemoteAuth;
struct RemoteAuthDefaultTypeInternal;
extern RemoteAuthDefaultTypeInternal _RemoteAuth_default_instance_;
class RemoteAuth_Credentials;
struct RemoteAuth_CredentialsDefaultTypeInternal;
extern RemoteAuth_CredentialsDefaultTypeInternal _RemoteAuth_Credentials_default_instance_;
class RemoteConfig;
struct RemoteConfigDefaultTypeInternal;
extern RemoteConfigDefaultTypeInternal _RemoteConfig_default_instance_;
class ResourceLevelServiceConfig;
struct ResourceLevelServiceConfigDefaultTypeInternal;
extern ResourceLevelServiceConfigDefaultTypeInternal _ResourceLevelServiceConfig_default_instance_;
class RobotConfig;
struct RobotConfigDefaultTypeInternal;
extern RobotConfigDefaultTypeInternal _RobotConfig_default_instance_;
class ServiceConfig;
struct ServiceConfigDefaultTypeInternal;
extern ServiceConfigDefaultTypeInternal _ServiceConfig_default_instance_;
class SessionsConfig;
struct SessionsConfigDefaultTypeInternal;
extern SessionsConfigDefaultTypeInternal _SessionsConfig_default_instance_;
class TrafficTunnelEndpoint;
struct TrafficTunnelEndpointDefaultTypeInternal;
extern TrafficTunnelEndpointDefaultTypeInternal _TrafficTunnelEndpoint_default_instance_;
class Translation;
struct TranslationDefaultTypeInternal;
extern TranslationDefaultTypeInternal _Translation_default_instance_;
}  // namespace v1
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::v1::AgentInfo* Arena::CreateMaybeMessage<::viam::app::v1::AgentInfo>(Arena*);
template<> ::viam::app::v1::AppValidationStatus* Arena::CreateMaybeMessage<::viam::app::v1::AppValidationStatus>(Arena*);
template<> ::viam::app::v1::AuthConfig* Arena::CreateMaybeMessage<::viam::app::v1::AuthConfig>(Arena*);
template<> ::viam::app::v1::AuthHandlerConfig* Arena::CreateMaybeMessage<::viam::app::v1::AuthHandlerConfig>(Arena*);
template<> ::viam::app::v1::CertificateRequest* Arena::CreateMaybeMessage<::viam::app::v1::CertificateRequest>(Arena*);
template<> ::viam::app::v1::CertificateResponse* Arena::CreateMaybeMessage<::viam::app::v1::CertificateResponse>(Arena*);
template<> ::viam::app::v1::CloudConfig* Arena::CreateMaybeMessage<::viam::app::v1::CloudConfig>(Arena*);
template<> ::viam::app::v1::ComponentConfig* Arena::CreateMaybeMessage<::viam::app::v1::ComponentConfig>(Arena*);
template<> ::viam::app::v1::ConfigRequest* Arena::CreateMaybeMessage<::viam::app::v1::ConfigRequest>(Arena*);
template<> ::viam::app::v1::ConfigResponse* Arena::CreateMaybeMessage<::viam::app::v1::ConfigResponse>(Arena*);
template<> ::viam::app::v1::ExternalAuthConfig* Arena::CreateMaybeMessage<::viam::app::v1::ExternalAuthConfig>(Arena*);
template<> ::viam::app::v1::Frame* Arena::CreateMaybeMessage<::viam::app::v1::Frame>(Arena*);
template<> ::viam::app::v1::JWKSFile* Arena::CreateMaybeMessage<::viam::app::v1::JWKSFile>(Arena*);
template<> ::viam::app::v1::JobConfig* Arena::CreateMaybeMessage<::viam::app::v1::JobConfig>(Arena*);
template<> ::viam::app::v1::LocationSecret* Arena::CreateMaybeMessage<::viam::app::v1::LocationSecret>(Arena*);
template<> ::viam::app::v1::LogConfiguration* Arena::CreateMaybeMessage<::viam::app::v1::LogConfiguration>(Arena*);
template<> ::viam::app::v1::LogPatternConfig* Arena::CreateMaybeMessage<::viam::app::v1::LogPatternConfig>(Arena*);
template<> ::viam::app::v1::LogRequest* Arena::CreateMaybeMessage<::viam::app::v1::LogRequest>(Arena*);
template<> ::viam::app::v1::LogResponse* Arena::CreateMaybeMessage<::viam::app::v1::LogResponse>(Arena*);
template<> ::viam::app::v1::MaintenanceConfig* Arena::CreateMaybeMessage<::viam::app::v1::MaintenanceConfig>(Arena*);
template<> ::viam::app::v1::ModuleConfig* Arena::CreateMaybeMessage<::viam::app::v1::ModuleConfig>(Arena*);
template<> ::viam::app::v1::ModuleConfig_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::v1::ModuleConfig_EnvEntry_DoNotUse>(Arena*);
template<> ::viam::app::v1::NeedsRestartRequest* Arena::CreateMaybeMessage<::viam::app::v1::NeedsRestartRequest>(Arena*);
template<> ::viam::app::v1::NeedsRestartResponse* Arena::CreateMaybeMessage<::viam::app::v1::NeedsRestartResponse>(Arena*);
template<> ::viam::app::v1::NetworkConfig* Arena::CreateMaybeMessage<::viam::app::v1::NetworkConfig>(Arena*);
template<> ::viam::app::v1::Orientation* Arena::CreateMaybeMessage<::viam::app::v1::Orientation>(Arena*);
template<> ::viam::app::v1::Orientation_AxisAngles* Arena::CreateMaybeMessage<::viam::app::v1::Orientation_AxisAngles>(Arena*);
template<> ::viam::app::v1::Orientation_EulerAngles* Arena::CreateMaybeMessage<::viam::app::v1::Orientation_EulerAngles>(Arena*);
template<> ::viam::app::v1::Orientation_NoOrientation* Arena::CreateMaybeMessage<::viam::app::v1::Orientation_NoOrientation>(Arena*);
template<> ::viam::app::v1::Orientation_OrientationVectorDegrees* Arena::CreateMaybeMessage<::viam::app::v1::Orientation_OrientationVectorDegrees>(Arena*);
template<> ::viam::app::v1::Orientation_OrientationVectorRadians* Arena::CreateMaybeMessage<::viam::app::v1::Orientation_OrientationVectorRadians>(Arena*);
template<> ::viam::app::v1::Orientation_Quaternion* Arena::CreateMaybeMessage<::viam::app::v1::Orientation_Quaternion>(Arena*);
template<> ::viam::app::v1::PackageConfig* Arena::CreateMaybeMessage<::viam::app::v1::PackageConfig>(Arena*);
template<> ::viam::app::v1::ProcessConfig* Arena::CreateMaybeMessage<::viam::app::v1::ProcessConfig>(Arena*);
template<> ::viam::app::v1::ProcessConfig_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::v1::ProcessConfig_EnvEntry_DoNotUse>(Arena*);
template<> ::viam::app::v1::RemoteAuth* Arena::CreateMaybeMessage<::viam::app::v1::RemoteAuth>(Arena*);
template<> ::viam::app::v1::RemoteAuth_Credentials* Arena::CreateMaybeMessage<::viam::app::v1::RemoteAuth_Credentials>(Arena*);
template<> ::viam::app::v1::RemoteConfig* Arena::CreateMaybeMessage<::viam::app::v1::RemoteConfig>(Arena*);
template<> ::viam::app::v1::ResourceLevelServiceConfig* Arena::CreateMaybeMessage<::viam::app::v1::ResourceLevelServiceConfig>(Arena*);
template<> ::viam::app::v1::RobotConfig* Arena::CreateMaybeMessage<::viam::app::v1::RobotConfig>(Arena*);
template<> ::viam::app::v1::ServiceConfig* Arena::CreateMaybeMessage<::viam::app::v1::ServiceConfig>(Arena*);
template<> ::viam::app::v1::SessionsConfig* Arena::CreateMaybeMessage<::viam::app::v1::SessionsConfig>(Arena*);
template<> ::viam::app::v1::TrafficTunnelEndpoint* Arena::CreateMaybeMessage<::viam::app::v1::TrafficTunnelEndpoint>(Arena*);
template<> ::viam::app::v1::Translation* Arena::CreateMaybeMessage<::viam::app::v1::Translation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace v1 {

enum CredentialsType : int {
  CREDENTIALS_TYPE_UNSPECIFIED = 0,
  CREDENTIALS_TYPE_INTERNAL = 1,
  CREDENTIALS_TYPE_API_KEY = 2,
  CREDENTIALS_TYPE_ROBOT_SECRET = 3,
  CREDENTIALS_TYPE_ROBOT_LOCATION_SECRET = 4,
  CredentialsType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CredentialsType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CredentialsType_IsValid(int value);
constexpr CredentialsType CredentialsType_MIN = CREDENTIALS_TYPE_UNSPECIFIED;
constexpr CredentialsType CredentialsType_MAX = CREDENTIALS_TYPE_ROBOT_LOCATION_SECRET;
constexpr int CredentialsType_ARRAYSIZE = CredentialsType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CredentialsType_descriptor();
template<typename T>
inline const std::string& CredentialsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CredentialsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CredentialsType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CredentialsType_descriptor(), enum_t_value);
}
inline bool CredentialsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CredentialsType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CredentialsType>(
    CredentialsType_descriptor(), name, value);
}
// ===================================================================

class RobotConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotConfig) */ {
 public:
  inline RobotConfig() : RobotConfig(nullptr) {}
  ~RobotConfig() override;
  explicit PROTOBUF_CONSTEXPR RobotConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotConfig(const RobotConfig& from);
  RobotConfig(RobotConfig&& from) noexcept
    : RobotConfig() {
    *this = ::std::move(from);
  }

  inline RobotConfig& operator=(const RobotConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotConfig& operator=(RobotConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotConfig* internal_default_instance() {
    return reinterpret_cast<const RobotConfig*>(
               &_RobotConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RobotConfig& a, RobotConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RobotConfig";
  }
  protected:
  explicit RobotConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemotesFieldNumber = 2,
    kComponentsFieldNumber = 3,
    kProcessesFieldNumber = 4,
    kServicesFieldNumber = 5,
    kModulesFieldNumber = 9,
    kPackagesFieldNumber = 11,
    kOverwriteFragmentStatusFieldNumber = 12,
    kLogFieldNumber = 14,
    kJobsFieldNumber = 18,
    kRevisionFieldNumber = 15,
    kCloudFieldNumber = 1,
    kNetworkFieldNumber = 6,
    kAuthFieldNumber = 7,
    kMaintenanceFieldNumber = 16,
    kDebugFieldNumber = 8,
    kDisablePartialStartFieldNumber = 10,
    kEnableWebProfileFieldNumber = 13,
    kDisableLogDeduplicationFieldNumber = 17,
  };
  // repeated .viam.app.v1.RemoteConfig remotes = 2 [json_name = "remotes"];
  int remotes_size() const;
  private:
  int _internal_remotes_size() const;
  public:
  void clear_remotes();
  ::viam::app::v1::RemoteConfig* mutable_remotes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RemoteConfig >*
      mutable_remotes();
  private:
  const ::viam::app::v1::RemoteConfig& _internal_remotes(int index) const;
  ::viam::app::v1::RemoteConfig* _internal_add_remotes();
  public:
  const ::viam::app::v1::RemoteConfig& remotes(int index) const;
  ::viam::app::v1::RemoteConfig* add_remotes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RemoteConfig >&
      remotes() const;

  // repeated .viam.app.v1.ComponentConfig components = 3 [json_name = "components"];
  int components_size() const;
  private:
  int _internal_components_size() const;
  public:
  void clear_components();
  ::viam::app::v1::ComponentConfig* mutable_components(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ComponentConfig >*
      mutable_components();
  private:
  const ::viam::app::v1::ComponentConfig& _internal_components(int index) const;
  ::viam::app::v1::ComponentConfig* _internal_add_components();
  public:
  const ::viam::app::v1::ComponentConfig& components(int index) const;
  ::viam::app::v1::ComponentConfig* add_components();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ComponentConfig >&
      components() const;

  // repeated .viam.app.v1.ProcessConfig processes = 4 [json_name = "processes"];
  int processes_size() const;
  private:
  int _internal_processes_size() const;
  public:
  void clear_processes();
  ::viam::app::v1::ProcessConfig* mutable_processes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ProcessConfig >*
      mutable_processes();
  private:
  const ::viam::app::v1::ProcessConfig& _internal_processes(int index) const;
  ::viam::app::v1::ProcessConfig* _internal_add_processes();
  public:
  const ::viam::app::v1::ProcessConfig& processes(int index) const;
  ::viam::app::v1::ProcessConfig* add_processes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ProcessConfig >&
      processes() const;

  // repeated .viam.app.v1.ServiceConfig services = 5 [json_name = "services"];
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::viam::app::v1::ServiceConfig* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ServiceConfig >*
      mutable_services();
  private:
  const ::viam::app::v1::ServiceConfig& _internal_services(int index) const;
  ::viam::app::v1::ServiceConfig* _internal_add_services();
  public:
  const ::viam::app::v1::ServiceConfig& services(int index) const;
  ::viam::app::v1::ServiceConfig* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ServiceConfig >&
      services() const;

  // repeated .viam.app.v1.ModuleConfig modules = 9 [json_name = "modules"];
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  ::viam::app::v1::ModuleConfig* mutable_modules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleConfig >*
      mutable_modules();
  private:
  const ::viam::app::v1::ModuleConfig& _internal_modules(int index) const;
  ::viam::app::v1::ModuleConfig* _internal_add_modules();
  public:
  const ::viam::app::v1::ModuleConfig& modules(int index) const;
  ::viam::app::v1::ModuleConfig* add_modules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleConfig >&
      modules() const;

  // repeated .viam.app.v1.PackageConfig packages = 11 [json_name = "packages"];
  int packages_size() const;
  private:
  int _internal_packages_size() const;
  public:
  void clear_packages();
  ::viam::app::v1::PackageConfig* mutable_packages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PackageConfig >*
      mutable_packages();
  private:
  const ::viam::app::v1::PackageConfig& _internal_packages(int index) const;
  ::viam::app::v1::PackageConfig* _internal_add_packages();
  public:
  const ::viam::app::v1::PackageConfig& packages(int index) const;
  ::viam::app::v1::PackageConfig* add_packages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PackageConfig >&
      packages() const;

  // repeated .viam.app.v1.AppValidationStatus overwrite_fragment_status = 12 [json_name = "overwriteFragmentStatus"];
  int overwrite_fragment_status_size() const;
  private:
  int _internal_overwrite_fragment_status_size() const;
  public:
  void clear_overwrite_fragment_status();
  ::viam::app::v1::AppValidationStatus* mutable_overwrite_fragment_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AppValidationStatus >*
      mutable_overwrite_fragment_status();
  private:
  const ::viam::app::v1::AppValidationStatus& _internal_overwrite_fragment_status(int index) const;
  ::viam::app::v1::AppValidationStatus* _internal_add_overwrite_fragment_status();
  public:
  const ::viam::app::v1::AppValidationStatus& overwrite_fragment_status(int index) const;
  ::viam::app::v1::AppValidationStatus* add_overwrite_fragment_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AppValidationStatus >&
      overwrite_fragment_status() const;

  // repeated .viam.app.v1.LogPatternConfig log = 14 [json_name = "log"];
  int log_size() const;
  private:
  int _internal_log_size() const;
  public:
  void clear_log();
  ::viam::app::v1::LogPatternConfig* mutable_log(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogPatternConfig >*
      mutable_log();
  private:
  const ::viam::app::v1::LogPatternConfig& _internal_log(int index) const;
  ::viam::app::v1::LogPatternConfig* _internal_add_log();
  public:
  const ::viam::app::v1::LogPatternConfig& log(int index) const;
  ::viam::app::v1::LogPatternConfig* add_log();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogPatternConfig >&
      log() const;

  // repeated .viam.app.v1.JobConfig jobs = 18 [json_name = "jobs"];
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;
  public:
  void clear_jobs();
  ::viam::app::v1::JobConfig* mutable_jobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::JobConfig >*
      mutable_jobs();
  private:
  const ::viam::app::v1::JobConfig& _internal_jobs(int index) const;
  ::viam::app::v1::JobConfig* _internal_add_jobs();
  public:
  const ::viam::app::v1::JobConfig& jobs(int index) const;
  ::viam::app::v1::JobConfig* add_jobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::JobConfig >&
      jobs() const;

  // string revision = 15 [json_name = "revision"];
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // .viam.app.v1.CloudConfig cloud = 1 [json_name = "cloud"];
  bool has_cloud() const;
  private:
  bool _internal_has_cloud() const;
  public:
  void clear_cloud();
  const ::viam::app::v1::CloudConfig& cloud() const;
  PROTOBUF_NODISCARD ::viam::app::v1::CloudConfig* release_cloud();
  ::viam::app::v1::CloudConfig* mutable_cloud();
  void set_allocated_cloud(::viam::app::v1::CloudConfig* cloud);
  private:
  const ::viam::app::v1::CloudConfig& _internal_cloud() const;
  ::viam::app::v1::CloudConfig* _internal_mutable_cloud();
  public:
  void unsafe_arena_set_allocated_cloud(
      ::viam::app::v1::CloudConfig* cloud);
  ::viam::app::v1::CloudConfig* unsafe_arena_release_cloud();

  // optional .viam.app.v1.NetworkConfig network = 6 [json_name = "network"];
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const ::viam::app::v1::NetworkConfig& network() const;
  PROTOBUF_NODISCARD ::viam::app::v1::NetworkConfig* release_network();
  ::viam::app::v1::NetworkConfig* mutable_network();
  void set_allocated_network(::viam::app::v1::NetworkConfig* network);
  private:
  const ::viam::app::v1::NetworkConfig& _internal_network() const;
  ::viam::app::v1::NetworkConfig* _internal_mutable_network();
  public:
  void unsafe_arena_set_allocated_network(
      ::viam::app::v1::NetworkConfig* network);
  ::viam::app::v1::NetworkConfig* unsafe_arena_release_network();

  // optional .viam.app.v1.AuthConfig auth = 7 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::AuthConfig& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AuthConfig* release_auth();
  ::viam::app::v1::AuthConfig* mutable_auth();
  void set_allocated_auth(::viam::app::v1::AuthConfig* auth);
  private:
  const ::viam::app::v1::AuthConfig& _internal_auth() const;
  ::viam::app::v1::AuthConfig* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::AuthConfig* auth);
  ::viam::app::v1::AuthConfig* unsafe_arena_release_auth();

  // optional .viam.app.v1.MaintenanceConfig maintenance = 16 [json_name = "maintenance"];
  bool has_maintenance() const;
  private:
  bool _internal_has_maintenance() const;
  public:
  void clear_maintenance();
  const ::viam::app::v1::MaintenanceConfig& maintenance() const;
  PROTOBUF_NODISCARD ::viam::app::v1::MaintenanceConfig* release_maintenance();
  ::viam::app::v1::MaintenanceConfig* mutable_maintenance();
  void set_allocated_maintenance(::viam::app::v1::MaintenanceConfig* maintenance);
  private:
  const ::viam::app::v1::MaintenanceConfig& _internal_maintenance() const;
  ::viam::app::v1::MaintenanceConfig* _internal_mutable_maintenance();
  public:
  void unsafe_arena_set_allocated_maintenance(
      ::viam::app::v1::MaintenanceConfig* maintenance);
  ::viam::app::v1::MaintenanceConfig* unsafe_arena_release_maintenance();

  // optional bool debug = 8 [json_name = "debug"];
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  bool debug() const;
  void set_debug(bool value);
  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);
  public:

  // optional bool disable_partial_start = 10 [json_name = "disablePartialStart"];
  bool has_disable_partial_start() const;
  private:
  bool _internal_has_disable_partial_start() const;
  public:
  void clear_disable_partial_start();
  bool disable_partial_start() const;
  void set_disable_partial_start(bool value);
  private:
  bool _internal_disable_partial_start() const;
  void _internal_set_disable_partial_start(bool value);
  public:

  // bool enable_web_profile = 13 [json_name = "enableWebProfile"];
  void clear_enable_web_profile();
  bool enable_web_profile() const;
  void set_enable_web_profile(bool value);
  private:
  bool _internal_enable_web_profile() const;
  void _internal_set_enable_web_profile(bool value);
  public:

  // bool disable_log_deduplication = 17 [json_name = "disableLogDeduplication"];
  void clear_disable_log_deduplication();
  bool disable_log_deduplication() const;
  void set_disable_log_deduplication(bool value);
  private:
  bool _internal_disable_log_deduplication() const;
  void _internal_set_disable_log_deduplication(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RemoteConfig > remotes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ComponentConfig > components_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ProcessConfig > processes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ServiceConfig > services_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleConfig > modules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PackageConfig > packages_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AppValidationStatus > overwrite_fragment_status_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogPatternConfig > log_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::JobConfig > jobs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::viam::app::v1::CloudConfig* cloud_;
  ::viam::app::v1::NetworkConfig* network_;
  ::viam::app::v1::AuthConfig* auth_;
  ::viam::app::v1::MaintenanceConfig* maintenance_;
  bool debug_;
  bool disable_partial_start_;
  bool enable_web_profile_;
  bool disable_log_deduplication_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class LogPatternConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LogPatternConfig) */ {
 public:
  inline LogPatternConfig() : LogPatternConfig(nullptr) {}
  ~LogPatternConfig() override;
  explicit PROTOBUF_CONSTEXPR LogPatternConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogPatternConfig(const LogPatternConfig& from);
  LogPatternConfig(LogPatternConfig&& from) noexcept
    : LogPatternConfig() {
    *this = ::std::move(from);
  }

  inline LogPatternConfig& operator=(const LogPatternConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogPatternConfig& operator=(LogPatternConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogPatternConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogPatternConfig* internal_default_instance() {
    return reinterpret_cast<const LogPatternConfig*>(
               &_LogPatternConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LogPatternConfig& a, LogPatternConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LogPatternConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogPatternConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogPatternConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogPatternConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogPatternConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogPatternConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogPatternConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LogPatternConfig";
  }
  protected:
  explicit LogPatternConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatternFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // string pattern = 1 [json_name = "pattern"];
  void clear_pattern();
  const std::string& pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* pattern);
  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
  std::string* _internal_mutable_pattern();
  public:

  // string level = 2 [json_name = "level"];
  void clear_level();
  const std::string& level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* level);
  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(const std::string& value);
  std::string* _internal_mutable_level();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LogPatternConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class JobConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.JobConfig) */ {
 public:
  inline JobConfig() : JobConfig(nullptr) {}
  ~JobConfig() override;
  explicit PROTOBUF_CONSTEXPR JobConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobConfig(const JobConfig& from);
  JobConfig(JobConfig&& from) noexcept
    : JobConfig() {
    *this = ::std::move(from);
  }

  inline JobConfig& operator=(const JobConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobConfig& operator=(JobConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobConfig* internal_default_instance() {
    return reinterpret_cast<const JobConfig*>(
               &_JobConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(JobConfig& a, JobConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(JobConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JobConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.JobConfig";
  }
  protected:
  explicit JobConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kScheduleFieldNumber = 2,
    kResourceFieldNumber = 3,
    kMethodFieldNumber = 4,
    kCommandFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string schedule = 2 [json_name = "schedule"];
  void clear_schedule();
  const std::string& schedule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schedule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schedule();
  PROTOBUF_NODISCARD std::string* release_schedule();
  void set_allocated_schedule(std::string* schedule);
  private:
  const std::string& _internal_schedule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schedule(const std::string& value);
  std::string* _internal_mutable_schedule();
  public:

  // string resource = 3 [json_name = "resource"];
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // string method = 4 [json_name = "method"];
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .google.protobuf.Struct command = 5 [json_name = "command"];
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::PROTOBUF_NAMESPACE_ID::Struct& command() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_command();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_command();
  void set_allocated_command(::PROTOBUF_NAMESPACE_ID::Struct* command);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_command() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::PROTOBUF_NAMESPACE_ID::Struct* command);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_command();

  // @@protoc_insertion_point(class_scope:viam.app.v1.JobConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schedule_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::Struct* command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class LocationSecret final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationSecret) */ {
 public:
  inline LocationSecret() : LocationSecret(nullptr) {}
  ~LocationSecret() override;
  explicit PROTOBUF_CONSTEXPR LocationSecret(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationSecret(const LocationSecret& from);
  LocationSecret(LocationSecret&& from) noexcept
    : LocationSecret() {
    *this = ::std::move(from);
  }

  inline LocationSecret& operator=(const LocationSecret& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationSecret& operator=(LocationSecret&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationSecret& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationSecret* internal_default_instance() {
    return reinterpret_cast<const LocationSecret*>(
               &_LocationSecret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LocationSecret& a, LocationSecret& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationSecret* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationSecret* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationSecret* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationSecret>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationSecret& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationSecret& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationSecret* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationSecret";
  }
  protected:
  explicit LocationSecret(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSecretFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string secret = 2 [json_name = "secret"];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationSecret)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class AppValidationStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AppValidationStatus) */ {
 public:
  inline AppValidationStatus() : AppValidationStatus(nullptr) {}
  ~AppValidationStatus() override;
  explicit PROTOBUF_CONSTEXPR AppValidationStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppValidationStatus(const AppValidationStatus& from);
  AppValidationStatus(AppValidationStatus&& from) noexcept
    : AppValidationStatus() {
    *this = ::std::move(from);
  }

  inline AppValidationStatus& operator=(const AppValidationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppValidationStatus& operator=(AppValidationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppValidationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppValidationStatus* internal_default_instance() {
    return reinterpret_cast<const AppValidationStatus*>(
               &_AppValidationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AppValidationStatus& a, AppValidationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(AppValidationStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppValidationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppValidationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppValidationStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppValidationStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppValidationStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppValidationStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AppValidationStatus";
  }
  protected:
  explicit AppValidationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AppValidationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class CloudConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CloudConfig) */ {
 public:
  inline CloudConfig() : CloudConfig(nullptr) {}
  ~CloudConfig() override;
  explicit PROTOBUF_CONSTEXPR CloudConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloudConfig(const CloudConfig& from);
  CloudConfig(CloudConfig&& from) noexcept
    : CloudConfig() {
    *this = ::std::move(from);
  }

  inline CloudConfig& operator=(const CloudConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudConfig& operator=(CloudConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloudConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloudConfig* internal_default_instance() {
    return reinterpret_cast<const CloudConfig*>(
               &_CloudConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CloudConfig& a, CloudConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CloudConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloudConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloudConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloudConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloudConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloudConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CloudConfig";
  }
  protected:
  explicit CloudConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationSecretsFieldNumber = 9,
    kIdFieldNumber = 1,
    kFqdnFieldNumber = 2,
    kLocalFqdnFieldNumber = 3,
    kManagedByFieldNumber = 4,
    kSignalingAddressFieldNumber = 5,
    kLocationSecretFieldNumber = 7,
    kSecretFieldNumber = 8,
    kPrimaryOrgIdFieldNumber = 10,
    kLocationIdFieldNumber = 11,
    kMachineIdFieldNumber = 12,
    kSignalingInsecureFieldNumber = 6,
  };
  // repeated .viam.app.v1.LocationSecret location_secrets = 9 [json_name = "locationSecrets"];
  int location_secrets_size() const;
  private:
  int _internal_location_secrets_size() const;
  public:
  void clear_location_secrets();
  ::viam::app::v1::LocationSecret* mutable_location_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSecret >*
      mutable_location_secrets();
  private:
  const ::viam::app::v1::LocationSecret& _internal_location_secrets(int index) const;
  ::viam::app::v1::LocationSecret* _internal_add_location_secrets();
  public:
  const ::viam::app::v1::LocationSecret& location_secrets(int index) const;
  ::viam::app::v1::LocationSecret* add_location_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSecret >&
      location_secrets() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string fqdn = 2 [json_name = "fqdn"];
  void clear_fqdn();
  const std::string& fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fqdn();
  PROTOBUF_NODISCARD std::string* release_fqdn();
  void set_allocated_fqdn(std::string* fqdn);
  private:
  const std::string& _internal_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fqdn(const std::string& value);
  std::string* _internal_mutable_fqdn();
  public:

  // string local_fqdn = 3 [json_name = "localFqdn"];
  void clear_local_fqdn();
  const std::string& local_fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_fqdn();
  PROTOBUF_NODISCARD std::string* release_local_fqdn();
  void set_allocated_local_fqdn(std::string* local_fqdn);
  private:
  const std::string& _internal_local_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_fqdn(const std::string& value);
  std::string* _internal_mutable_local_fqdn();
  public:

  // string managed_by = 4 [json_name = "managedBy"];
  void clear_managed_by();
  const std::string& managed_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_managed_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_managed_by();
  PROTOBUF_NODISCARD std::string* release_managed_by();
  void set_allocated_managed_by(std::string* managed_by);
  private:
  const std::string& _internal_managed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_managed_by(const std::string& value);
  std::string* _internal_mutable_managed_by();
  public:

  // string signaling_address = 5 [json_name = "signalingAddress"];
  void clear_signaling_address();
  const std::string& signaling_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signaling_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signaling_address();
  PROTOBUF_NODISCARD std::string* release_signaling_address();
  void set_allocated_signaling_address(std::string* signaling_address);
  private:
  const std::string& _internal_signaling_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signaling_address(const std::string& value);
  std::string* _internal_mutable_signaling_address();
  public:

  // string location_secret = 7 [json_name = "locationSecret", deprecated = true];
  PROTOBUF_DEPRECATED void clear_location_secret();
  PROTOBUF_DEPRECATED const std::string& location_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_location_secret(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_location_secret();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_location_secret();
  PROTOBUF_DEPRECATED void set_allocated_location_secret(std::string* location_secret);
  private:
  const std::string& _internal_location_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_secret(const std::string& value);
  std::string* _internal_mutable_location_secret();
  public:

  // string secret = 8 [json_name = "secret"];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string primary_org_id = 10 [json_name = "primaryOrgId"];
  void clear_primary_org_id();
  const std::string& primary_org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_org_id();
  PROTOBUF_NODISCARD std::string* release_primary_org_id();
  void set_allocated_primary_org_id(std::string* primary_org_id);
  private:
  const std::string& _internal_primary_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_org_id(const std::string& value);
  std::string* _internal_mutable_primary_org_id();
  public:

  // string location_id = 11 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string machine_id = 12 [json_name = "machineId"];
  void clear_machine_id();
  const std::string& machine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_id();
  PROTOBUF_NODISCARD std::string* release_machine_id();
  void set_allocated_machine_id(std::string* machine_id);
  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(const std::string& value);
  std::string* _internal_mutable_machine_id();
  public:

  // bool signaling_insecure = 6 [json_name = "signalingInsecure"];
  void clear_signaling_insecure();
  bool signaling_insecure() const;
  void set_signaling_insecure(bool value);
  private:
  bool _internal_signaling_insecure() const;
  void _internal_set_signaling_insecure(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CloudConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSecret > location_secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fqdn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_fqdn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr managed_by_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signaling_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
  bool signaling_insecure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ComponentConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ComponentConfig) */ {
 public:
  inline ComponentConfig() : ComponentConfig(nullptr) {}
  ~ComponentConfig() override;
  explicit PROTOBUF_CONSTEXPR ComponentConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComponentConfig(const ComponentConfig& from);
  ComponentConfig(ComponentConfig&& from) noexcept
    : ComponentConfig() {
    *this = ::std::move(from);
  }

  inline ComponentConfig& operator=(const ComponentConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComponentConfig& operator=(ComponentConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComponentConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComponentConfig* internal_default_instance() {
    return reinterpret_cast<const ComponentConfig*>(
               &_ComponentConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ComponentConfig& a, ComponentConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ComponentConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComponentConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComponentConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComponentConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComponentConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComponentConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComponentConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ComponentConfig";
  }
  protected:
  explicit ComponentConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependsOnFieldNumber = 6,
    kServiceConfigsFieldNumber = 7,
    kNameFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kTypeFieldNumber = 3,
    kModelFieldNumber = 4,
    kApiFieldNumber = 9,
    kFrameFieldNumber = 5,
    kAttributesFieldNumber = 8,
    kLogConfigurationFieldNumber = 10,
  };
  // repeated string depends_on = 6 [json_name = "dependsOn"];
  int depends_on_size() const;
  private:
  int _internal_depends_on_size() const;
  public:
  void clear_depends_on();
  const std::string& depends_on(int index) const;
  std::string* mutable_depends_on(int index);
  void set_depends_on(int index, const std::string& value);
  void set_depends_on(int index, std::string&& value);
  void set_depends_on(int index, const char* value);
  void set_depends_on(int index, const char* value, size_t size);
  std::string* add_depends_on();
  void add_depends_on(const std::string& value);
  void add_depends_on(std::string&& value);
  void add_depends_on(const char* value);
  void add_depends_on(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& depends_on() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_depends_on();
  private:
  const std::string& _internal_depends_on(int index) const;
  std::string* _internal_add_depends_on();
  public:

  // repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 7 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
  int service_configs_size() const;
  private:
  int _internal_service_configs_size() const;
  public:
  void clear_service_configs();
  ::viam::app::v1::ResourceLevelServiceConfig* mutable_service_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
      mutable_service_configs();
  private:
  const ::viam::app::v1::ResourceLevelServiceConfig& _internal_service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* _internal_add_service_configs();
  public:
  const ::viam::app::v1::ResourceLevelServiceConfig& service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* add_service_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
      service_configs() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string namespace = 2 [json_name = "namespace"];
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string type = 3 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string model = 4 [json_name = "model"];
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string api = 9 [json_name = "api"];
  void clear_api();
  const std::string& api() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api();
  PROTOBUF_NODISCARD std::string* release_api();
  void set_allocated_api(std::string* api);
  private:
  const std::string& _internal_api() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api(const std::string& value);
  std::string* _internal_mutable_api();
  public:

  // .viam.app.v1.Frame frame = 5 [json_name = "frame"];
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::viam::app::v1::Frame& frame() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Frame* release_frame();
  ::viam::app::v1::Frame* mutable_frame();
  void set_allocated_frame(::viam::app::v1::Frame* frame);
  private:
  const ::viam::app::v1::Frame& _internal_frame() const;
  ::viam::app::v1::Frame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::viam::app::v1::Frame* frame);
  ::viam::app::v1::Frame* unsafe_arena_release_frame();

  // .google.protobuf.Struct attributes = 8 [json_name = "attributes"];
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::PROTOBUF_NAMESPACE_ID::Struct& attributes() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_attributes();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_attributes();
  void set_allocated_attributes(::PROTOBUF_NAMESPACE_ID::Struct* attributes);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::PROTOBUF_NAMESPACE_ID::Struct* attributes);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_attributes();

  // .viam.app.v1.LogConfiguration log_configuration = 10 [json_name = "logConfiguration"];
  bool has_log_configuration() const;
  private:
  bool _internal_has_log_configuration() const;
  public:
  void clear_log_configuration();
  const ::viam::app::v1::LogConfiguration& log_configuration() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LogConfiguration* release_log_configuration();
  ::viam::app::v1::LogConfiguration* mutable_log_configuration();
  void set_allocated_log_configuration(::viam::app::v1::LogConfiguration* log_configuration);
  private:
  const ::viam::app::v1::LogConfiguration& _internal_log_configuration() const;
  ::viam::app::v1::LogConfiguration* _internal_mutable_log_configuration();
  public:
  void unsafe_arena_set_allocated_log_configuration(
      ::viam::app::v1::LogConfiguration* log_configuration);
  ::viam::app::v1::LogConfiguration* unsafe_arena_release_log_configuration();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ComponentConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> depends_on_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig > service_configs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_;
  ::viam::app::v1::Frame* frame_;
  ::PROTOBUF_NAMESPACE_ID::Struct* attributes_;
  ::viam::app::v1::LogConfiguration* log_configuration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ResourceLevelServiceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ResourceLevelServiceConfig) */ {
 public:
  inline ResourceLevelServiceConfig() : ResourceLevelServiceConfig(nullptr) {}
  ~ResourceLevelServiceConfig() override;
  explicit PROTOBUF_CONSTEXPR ResourceLevelServiceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceLevelServiceConfig(const ResourceLevelServiceConfig& from);
  ResourceLevelServiceConfig(ResourceLevelServiceConfig&& from) noexcept
    : ResourceLevelServiceConfig() {
    *this = ::std::move(from);
  }

  inline ResourceLevelServiceConfig& operator=(const ResourceLevelServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceLevelServiceConfig& operator=(ResourceLevelServiceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceLevelServiceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceLevelServiceConfig* internal_default_instance() {
    return reinterpret_cast<const ResourceLevelServiceConfig*>(
               &_ResourceLevelServiceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResourceLevelServiceConfig& a, ResourceLevelServiceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceLevelServiceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceLevelServiceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceLevelServiceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceLevelServiceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceLevelServiceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceLevelServiceConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceLevelServiceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ResourceLevelServiceConfig";
  }
  protected:
  explicit ResourceLevelServiceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // string type = 1 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .google.protobuf.Struct attributes = 2 [json_name = "attributes"];
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::PROTOBUF_NAMESPACE_ID::Struct& attributes() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_attributes();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_attributes();
  void set_allocated_attributes(::PROTOBUF_NAMESPACE_ID::Struct* attributes);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::PROTOBUF_NAMESPACE_ID::Struct* attributes);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ResourceLevelServiceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::Struct* attributes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ProcessConfig_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessConfig_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessConfig_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcessConfig_EnvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessConfig_EnvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessConfig_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessConfig_EnvEntry_DoNotUse& other);
  static const ProcessConfig_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessConfig_EnvEntry_DoNotUse*>(&_ProcessConfig_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.ProcessConfig.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.ProcessConfig.EnvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};

// -------------------------------------------------------------------

class ProcessConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ProcessConfig) */ {
 public:
  inline ProcessConfig() : ProcessConfig(nullptr) {}
  ~ProcessConfig() override;
  explicit PROTOBUF_CONSTEXPR ProcessConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessConfig(const ProcessConfig& from);
  ProcessConfig(ProcessConfig&& from) noexcept
    : ProcessConfig() {
    *this = ::std::move(from);
  }

  inline ProcessConfig& operator=(const ProcessConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessConfig& operator=(ProcessConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessConfig* internal_default_instance() {
    return reinterpret_cast<const ProcessConfig*>(
               &_ProcessConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProcessConfig& a, ProcessConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ProcessConfig";
  }
  protected:
  explicit ProcessConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kEnvFieldNumber = 9,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCwdFieldNumber = 4,
    kUsernameFieldNumber = 10,
    kStopTimeoutFieldNumber = 8,
    kOneShotFieldNumber = 5,
    kLogFieldNumber = 6,
    kStopSignalFieldNumber = 7,
  };
  // repeated string args = 3 [json_name = "args"];
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // map<string, string> env = 9 [json_name = "env"];
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string cwd = 4 [json_name = "cwd"];
  void clear_cwd();
  const std::string& cwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cwd();
  PROTOBUF_NODISCARD std::string* release_cwd();
  void set_allocated_cwd(std::string* cwd);
  private:
  const std::string& _internal_cwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cwd(const std::string& value);
  std::string* _internal_mutable_cwd();
  public:

  // string username = 10 [json_name = "username"];
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .google.protobuf.Duration stop_timeout = 8 [json_name = "stopTimeout"];
  bool has_stop_timeout() const;
  private:
  bool _internal_has_stop_timeout() const;
  public:
  void clear_stop_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& stop_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_stop_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_stop_timeout();
  void set_allocated_stop_timeout(::PROTOBUF_NAMESPACE_ID::Duration* stop_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_stop_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_stop_timeout();
  public:
  void unsafe_arena_set_allocated_stop_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* stop_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_stop_timeout();

  // bool one_shot = 5 [json_name = "oneShot"];
  void clear_one_shot();
  bool one_shot() const;
  void set_one_shot(bool value);
  private:
  bool _internal_one_shot() const;
  void _internal_set_one_shot(bool value);
  public:

  // bool log = 6 [json_name = "log"];
  void clear_log();
  bool log() const;
  void set_log(bool value);
  private:
  bool _internal_log() const;
  void _internal_set_log(bool value);
  public:

  // int32 stop_signal = 7 [json_name = "stopSignal"];
  void clear_stop_signal();
  int32_t stop_signal() const;
  void set_stop_signal(int32_t value);
  private:
  int32_t _internal_stop_signal() const;
  void _internal_set_stop_signal(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ProcessConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ProcessConfig_EnvEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cwd_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::Duration* stop_timeout_;
  bool one_shot_;
  bool log_;
  int32_t stop_signal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ServiceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ServiceConfig) */ {
 public:
  inline ServiceConfig() : ServiceConfig(nullptr) {}
  ~ServiceConfig() override;
  explicit PROTOBUF_CONSTEXPR ServiceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceConfig(const ServiceConfig& from);
  ServiceConfig(ServiceConfig&& from) noexcept
    : ServiceConfig() {
    *this = ::std::move(from);
  }

  inline ServiceConfig& operator=(const ServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceConfig& operator=(ServiceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceConfig* internal_default_instance() {
    return reinterpret_cast<const ServiceConfig*>(
               &_ServiceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ServiceConfig& a, ServiceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ServiceConfig";
  }
  protected:
  explicit ServiceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependsOnFieldNumber = 5,
    kServiceConfigsFieldNumber = 10,
    kNameFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kTypeFieldNumber = 3,
    kModelFieldNumber = 6,
    kApiFieldNumber = 9,
    kAttributesFieldNumber = 4,
    kLogConfigurationFieldNumber = 11,
  };
  // repeated string depends_on = 5 [json_name = "dependsOn"];
  int depends_on_size() const;
  private:
  int _internal_depends_on_size() const;
  public:
  void clear_depends_on();
  const std::string& depends_on(int index) const;
  std::string* mutable_depends_on(int index);
  void set_depends_on(int index, const std::string& value);
  void set_depends_on(int index, std::string&& value);
  void set_depends_on(int index, const char* value);
  void set_depends_on(int index, const char* value, size_t size);
  std::string* add_depends_on();
  void add_depends_on(const std::string& value);
  void add_depends_on(std::string&& value);
  void add_depends_on(const char* value);
  void add_depends_on(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& depends_on() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_depends_on();
  private:
  const std::string& _internal_depends_on(int index) const;
  std::string* _internal_add_depends_on();
  public:

  // repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 10 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
  int service_configs_size() const;
  private:
  int _internal_service_configs_size() const;
  public:
  void clear_service_configs();
  ::viam::app::v1::ResourceLevelServiceConfig* mutable_service_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
      mutable_service_configs();
  private:
  const ::viam::app::v1::ResourceLevelServiceConfig& _internal_service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* _internal_add_service_configs();
  public:
  const ::viam::app::v1::ResourceLevelServiceConfig& service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* add_service_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
      service_configs() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string namespace = 2 [json_name = "namespace"];
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string type = 3 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string model = 6 [json_name = "model"];
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string api = 9 [json_name = "api"];
  void clear_api();
  const std::string& api() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api();
  PROTOBUF_NODISCARD std::string* release_api();
  void set_allocated_api(std::string* api);
  private:
  const std::string& _internal_api() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api(const std::string& value);
  std::string* _internal_mutable_api();
  public:

  // .google.protobuf.Struct attributes = 4 [json_name = "attributes"];
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::PROTOBUF_NAMESPACE_ID::Struct& attributes() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_attributes();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_attributes();
  void set_allocated_attributes(::PROTOBUF_NAMESPACE_ID::Struct* attributes);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::PROTOBUF_NAMESPACE_ID::Struct* attributes);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_attributes();

  // .viam.app.v1.LogConfiguration log_configuration = 11 [json_name = "logConfiguration"];
  bool has_log_configuration() const;
  private:
  bool _internal_has_log_configuration() const;
  public:
  void clear_log_configuration();
  const ::viam::app::v1::LogConfiguration& log_configuration() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LogConfiguration* release_log_configuration();
  ::viam::app::v1::LogConfiguration* mutable_log_configuration();
  void set_allocated_log_configuration(::viam::app::v1::LogConfiguration* log_configuration);
  private:
  const ::viam::app::v1::LogConfiguration& _internal_log_configuration() const;
  ::viam::app::v1::LogConfiguration* _internal_mutable_log_configuration();
  public:
  void unsafe_arena_set_allocated_log_configuration(
      ::viam::app::v1::LogConfiguration* log_configuration);
  ::viam::app::v1::LogConfiguration* unsafe_arena_release_log_configuration();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ServiceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> depends_on_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig > service_configs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_;
  ::PROTOBUF_NAMESPACE_ID::Struct* attributes_;
  ::viam::app::v1::LogConfiguration* log_configuration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class NetworkConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NetworkConfig) */ {
 public:
  inline NetworkConfig() : NetworkConfig(nullptr) {}
  ~NetworkConfig() override;
  explicit PROTOBUF_CONSTEXPR NetworkConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkConfig(const NetworkConfig& from);
  NetworkConfig(NetworkConfig&& from) noexcept
    : NetworkConfig() {
    *this = ::std::move(from);
  }

  inline NetworkConfig& operator=(const NetworkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConfig& operator=(NetworkConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkConfig* internal_default_instance() {
    return reinterpret_cast<const NetworkConfig*>(
               &_NetworkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NetworkConfig& a, NetworkConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetworkConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NetworkConfig";
  }
  protected:
  explicit NetworkConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficTunnelEndpointsFieldNumber = 6,
    kFqdnFieldNumber = 1,
    kBindAddressFieldNumber = 2,
    kTlsCertFileFieldNumber = 3,
    kTlsKeyFileFieldNumber = 4,
    kSessionsFieldNumber = 5,
    kNoTlsFieldNumber = 7,
  };
  // repeated .viam.app.v1.TrafficTunnelEndpoint traffic_tunnel_endpoints = 6 [json_name = "trafficTunnelEndpoints"];
  int traffic_tunnel_endpoints_size() const;
  private:
  int _internal_traffic_tunnel_endpoints_size() const;
  public:
  void clear_traffic_tunnel_endpoints();
  ::viam::app::v1::TrafficTunnelEndpoint* mutable_traffic_tunnel_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::TrafficTunnelEndpoint >*
      mutable_traffic_tunnel_endpoints();
  private:
  const ::viam::app::v1::TrafficTunnelEndpoint& _internal_traffic_tunnel_endpoints(int index) const;
  ::viam::app::v1::TrafficTunnelEndpoint* _internal_add_traffic_tunnel_endpoints();
  public:
  const ::viam::app::v1::TrafficTunnelEndpoint& traffic_tunnel_endpoints(int index) const;
  ::viam::app::v1::TrafficTunnelEndpoint* add_traffic_tunnel_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::TrafficTunnelEndpoint >&
      traffic_tunnel_endpoints() const;

  // string fqdn = 1 [json_name = "fqdn"];
  void clear_fqdn();
  const std::string& fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fqdn();
  PROTOBUF_NODISCARD std::string* release_fqdn();
  void set_allocated_fqdn(std::string* fqdn);
  private:
  const std::string& _internal_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fqdn(const std::string& value);
  std::string* _internal_mutable_fqdn();
  public:

  // string bind_address = 2 [json_name = "bindAddress"];
  void clear_bind_address();
  const std::string& bind_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bind_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bind_address();
  PROTOBUF_NODISCARD std::string* release_bind_address();
  void set_allocated_bind_address(std::string* bind_address);
  private:
  const std::string& _internal_bind_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bind_address(const std::string& value);
  std::string* _internal_mutable_bind_address();
  public:

  // string tls_cert_file = 3 [json_name = "tlsCertFile"];
  void clear_tls_cert_file();
  const std::string& tls_cert_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tls_cert_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tls_cert_file();
  PROTOBUF_NODISCARD std::string* release_tls_cert_file();
  void set_allocated_tls_cert_file(std::string* tls_cert_file);
  private:
  const std::string& _internal_tls_cert_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_cert_file(const std::string& value);
  std::string* _internal_mutable_tls_cert_file();
  public:

  // string tls_key_file = 4 [json_name = "tlsKeyFile"];
  void clear_tls_key_file();
  const std::string& tls_key_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tls_key_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tls_key_file();
  PROTOBUF_NODISCARD std::string* release_tls_key_file();
  void set_allocated_tls_key_file(std::string* tls_key_file);
  private:
  const std::string& _internal_tls_key_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_key_file(const std::string& value);
  std::string* _internal_mutable_tls_key_file();
  public:

  // .viam.app.v1.SessionsConfig sessions = 5 [json_name = "sessions"];
  bool has_sessions() const;
  private:
  bool _internal_has_sessions() const;
  public:
  void clear_sessions();
  const ::viam::app::v1::SessionsConfig& sessions() const;
  PROTOBUF_NODISCARD ::viam::app::v1::SessionsConfig* release_sessions();
  ::viam::app::v1::SessionsConfig* mutable_sessions();
  void set_allocated_sessions(::viam::app::v1::SessionsConfig* sessions);
  private:
  const ::viam::app::v1::SessionsConfig& _internal_sessions() const;
  ::viam::app::v1::SessionsConfig* _internal_mutable_sessions();
  public:
  void unsafe_arena_set_allocated_sessions(
      ::viam::app::v1::SessionsConfig* sessions);
  ::viam::app::v1::SessionsConfig* unsafe_arena_release_sessions();

  // bool no_tls = 7 [json_name = "noTls"];
  void clear_no_tls();
  bool no_tls() const;
  void set_no_tls(bool value);
  private:
  bool _internal_no_tls() const;
  void _internal_set_no_tls(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NetworkConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::TrafficTunnelEndpoint > traffic_tunnel_endpoints_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fqdn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bind_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tls_cert_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tls_key_file_;
  ::viam::app::v1::SessionsConfig* sessions_;
  bool no_tls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class SessionsConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SessionsConfig) */ {
 public:
  inline SessionsConfig() : SessionsConfig(nullptr) {}
  ~SessionsConfig() override;
  explicit PROTOBUF_CONSTEXPR SessionsConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionsConfig(const SessionsConfig& from);
  SessionsConfig(SessionsConfig&& from) noexcept
    : SessionsConfig() {
    *this = ::std::move(from);
  }

  inline SessionsConfig& operator=(const SessionsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionsConfig& operator=(SessionsConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionsConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionsConfig* internal_default_instance() {
    return reinterpret_cast<const SessionsConfig*>(
               &_SessionsConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SessionsConfig& a, SessionsConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionsConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionsConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionsConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionsConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionsConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionsConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionsConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SessionsConfig";
  }
  protected:
  explicit SessionsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatWindowFieldNumber = 1,
  };
  // .google.protobuf.Duration heartbeat_window = 1 [json_name = "heartbeatWindow"];
  bool has_heartbeat_window() const;
  private:
  bool _internal_has_heartbeat_window() const;
  public:
  void clear_heartbeat_window();
  const ::PROTOBUF_NAMESPACE_ID::Duration& heartbeat_window() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_heartbeat_window();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_heartbeat_window();
  void set_allocated_heartbeat_window(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_heartbeat_window() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_heartbeat_window();
  public:
  void unsafe_arena_set_allocated_heartbeat_window(
      ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_heartbeat_window();

  // @@protoc_insertion_point(class_scope:viam.app.v1.SessionsConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class TrafficTunnelEndpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TrafficTunnelEndpoint) */ {
 public:
  inline TrafficTunnelEndpoint() : TrafficTunnelEndpoint(nullptr) {}
  ~TrafficTunnelEndpoint() override;
  explicit PROTOBUF_CONSTEXPR TrafficTunnelEndpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficTunnelEndpoint(const TrafficTunnelEndpoint& from);
  TrafficTunnelEndpoint(TrafficTunnelEndpoint&& from) noexcept
    : TrafficTunnelEndpoint() {
    *this = ::std::move(from);
  }

  inline TrafficTunnelEndpoint& operator=(const TrafficTunnelEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficTunnelEndpoint& operator=(TrafficTunnelEndpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficTunnelEndpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficTunnelEndpoint* internal_default_instance() {
    return reinterpret_cast<const TrafficTunnelEndpoint*>(
               &_TrafficTunnelEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TrafficTunnelEndpoint& a, TrafficTunnelEndpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficTunnelEndpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficTunnelEndpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficTunnelEndpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficTunnelEndpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficTunnelEndpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficTunnelEndpoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficTunnelEndpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TrafficTunnelEndpoint";
  }
  protected:
  explicit TrafficTunnelEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionTimeoutFieldNumber = 2,
    kPortFieldNumber = 1,
  };
  // .google.protobuf.Duration connection_timeout = 2 [json_name = "connectionTimeout"];
  bool has_connection_timeout() const;
  private:
  bool _internal_has_connection_timeout() const;
  public:
  void clear_connection_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& connection_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_connection_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_connection_timeout();
  void set_allocated_connection_timeout(::PROTOBUF_NAMESPACE_ID::Duration* connection_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_connection_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_connection_timeout();
  public:
  void unsafe_arena_set_allocated_connection_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* connection_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_connection_timeout();

  // int32 port = 1 [json_name = "port"];
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.TrafficTunnelEndpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Duration* connection_timeout_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class AuthConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthConfig) */ {
 public:
  inline AuthConfig() : AuthConfig(nullptr) {}
  ~AuthConfig() override;
  explicit PROTOBUF_CONSTEXPR AuthConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthConfig(const AuthConfig& from);
  AuthConfig(AuthConfig&& from) noexcept
    : AuthConfig() {
    *this = ::std::move(from);
  }

  inline AuthConfig& operator=(const AuthConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthConfig& operator=(AuthConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthConfig* internal_default_instance() {
    return reinterpret_cast<const AuthConfig*>(
               &_AuthConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AuthConfig& a, AuthConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AuthConfig";
  }
  protected:
  explicit AuthConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlersFieldNumber = 1,
    kTlsAuthEntitiesFieldNumber = 2,
    kExternalAuthConfigFieldNumber = 3,
  };
  // repeated .viam.app.v1.AuthHandlerConfig handlers = 1 [json_name = "handlers"];
  int handlers_size() const;
  private:
  int _internal_handlers_size() const;
  public:
  void clear_handlers();
  ::viam::app::v1::AuthHandlerConfig* mutable_handlers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig >*
      mutable_handlers();
  private:
  const ::viam::app::v1::AuthHandlerConfig& _internal_handlers(int index) const;
  ::viam::app::v1::AuthHandlerConfig* _internal_add_handlers();
  public:
  const ::viam::app::v1::AuthHandlerConfig& handlers(int index) const;
  ::viam::app::v1::AuthHandlerConfig* add_handlers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig >&
      handlers() const;

  // repeated string tls_auth_entities = 2 [json_name = "tlsAuthEntities"];
  int tls_auth_entities_size() const;
  private:
  int _internal_tls_auth_entities_size() const;
  public:
  void clear_tls_auth_entities();
  const std::string& tls_auth_entities(int index) const;
  std::string* mutable_tls_auth_entities(int index);
  void set_tls_auth_entities(int index, const std::string& value);
  void set_tls_auth_entities(int index, std::string&& value);
  void set_tls_auth_entities(int index, const char* value);
  void set_tls_auth_entities(int index, const char* value, size_t size);
  std::string* add_tls_auth_entities();
  void add_tls_auth_entities(const std::string& value);
  void add_tls_auth_entities(std::string&& value);
  void add_tls_auth_entities(const char* value);
  void add_tls_auth_entities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tls_auth_entities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tls_auth_entities();
  private:
  const std::string& _internal_tls_auth_entities(int index) const;
  std::string* _internal_add_tls_auth_entities();
  public:

  // optional .viam.app.v1.ExternalAuthConfig external_auth_config = 3 [json_name = "externalAuthConfig"];
  bool has_external_auth_config() const;
  private:
  bool _internal_has_external_auth_config() const;
  public:
  void clear_external_auth_config();
  const ::viam::app::v1::ExternalAuthConfig& external_auth_config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::ExternalAuthConfig* release_external_auth_config();
  ::viam::app::v1::ExternalAuthConfig* mutable_external_auth_config();
  void set_allocated_external_auth_config(::viam::app::v1::ExternalAuthConfig* external_auth_config);
  private:
  const ::viam::app::v1::ExternalAuthConfig& _internal_external_auth_config() const;
  ::viam::app::v1::ExternalAuthConfig* _internal_mutable_external_auth_config();
  public:
  void unsafe_arena_set_allocated_external_auth_config(
      ::viam::app::v1::ExternalAuthConfig* external_auth_config);
  ::viam::app::v1::ExternalAuthConfig* unsafe_arena_release_external_auth_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig > handlers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tls_auth_entities_;
  ::viam::app::v1::ExternalAuthConfig* external_auth_config_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class JWKSFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.JWKSFile) */ {
 public:
  inline JWKSFile() : JWKSFile(nullptr) {}
  ~JWKSFile() override;
  explicit PROTOBUF_CONSTEXPR JWKSFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JWKSFile(const JWKSFile& from);
  JWKSFile(JWKSFile&& from) noexcept
    : JWKSFile() {
    *this = ::std::move(from);
  }

  inline JWKSFile& operator=(const JWKSFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline JWKSFile& operator=(JWKSFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JWKSFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const JWKSFile* internal_default_instance() {
    return reinterpret_cast<const JWKSFile*>(
               &_JWKSFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(JWKSFile& a, JWKSFile& b) {
    a.Swap(&b);
  }
  inline void Swap(JWKSFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JWKSFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JWKSFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JWKSFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JWKSFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JWKSFile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JWKSFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.JWKSFile";
  }
  protected:
  explicit JWKSFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonFieldNumber = 1,
  };
  // .google.protobuf.Struct json = 1 [json_name = "json"];
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const ::PROTOBUF_NAMESPACE_ID::Struct& json() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_json();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_json();
  void set_allocated_json(::PROTOBUF_NAMESPACE_ID::Struct* json);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_json() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_json();
  public:
  void unsafe_arena_set_allocated_json(
      ::PROTOBUF_NAMESPACE_ID::Struct* json);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_json();

  // @@protoc_insertion_point(class_scope:viam.app.v1.JWKSFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* json_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ExternalAuthConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ExternalAuthConfig) */ {
 public:
  inline ExternalAuthConfig() : ExternalAuthConfig(nullptr) {}
  ~ExternalAuthConfig() override;
  explicit PROTOBUF_CONSTEXPR ExternalAuthConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalAuthConfig(const ExternalAuthConfig& from);
  ExternalAuthConfig(ExternalAuthConfig&& from) noexcept
    : ExternalAuthConfig() {
    *this = ::std::move(from);
  }

  inline ExternalAuthConfig& operator=(const ExternalAuthConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalAuthConfig& operator=(ExternalAuthConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalAuthConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalAuthConfig* internal_default_instance() {
    return reinterpret_cast<const ExternalAuthConfig*>(
               &_ExternalAuthConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ExternalAuthConfig& a, ExternalAuthConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalAuthConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalAuthConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalAuthConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalAuthConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExternalAuthConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExternalAuthConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalAuthConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ExternalAuthConfig";
  }
  protected:
  explicit ExternalAuthConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJwksFieldNumber = 1,
  };
  // .viam.app.v1.JWKSFile jwks = 1 [json_name = "jwks"];
  bool has_jwks() const;
  private:
  bool _internal_has_jwks() const;
  public:
  void clear_jwks();
  const ::viam::app::v1::JWKSFile& jwks() const;
  PROTOBUF_NODISCARD ::viam::app::v1::JWKSFile* release_jwks();
  ::viam::app::v1::JWKSFile* mutable_jwks();
  void set_allocated_jwks(::viam::app::v1::JWKSFile* jwks);
  private:
  const ::viam::app::v1::JWKSFile& _internal_jwks() const;
  ::viam::app::v1::JWKSFile* _internal_mutable_jwks();
  public:
  void unsafe_arena_set_allocated_jwks(
      ::viam::app::v1::JWKSFile* jwks);
  ::viam::app::v1::JWKSFile* unsafe_arena_release_jwks();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ExternalAuthConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::JWKSFile* jwks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class AuthHandlerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AuthHandlerConfig) */ {
 public:
  inline AuthHandlerConfig() : AuthHandlerConfig(nullptr) {}
  ~AuthHandlerConfig() override;
  explicit PROTOBUF_CONSTEXPR AuthHandlerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthHandlerConfig(const AuthHandlerConfig& from);
  AuthHandlerConfig(AuthHandlerConfig&& from) noexcept
    : AuthHandlerConfig() {
    *this = ::std::move(from);
  }

  inline AuthHandlerConfig& operator=(const AuthHandlerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthHandlerConfig& operator=(AuthHandlerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthHandlerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthHandlerConfig* internal_default_instance() {
    return reinterpret_cast<const AuthHandlerConfig*>(
               &_AuthHandlerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AuthHandlerConfig& a, AuthHandlerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthHandlerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthHandlerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthHandlerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthHandlerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthHandlerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthHandlerConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthHandlerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AuthHandlerConfig";
  }
  protected:
  explicit AuthHandlerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // .google.protobuf.Struct config = 5 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_config();
  void set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_config();

  // .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
  void clear_type();
  ::viam::app::v1::CredentialsType type() const;
  void set_type(::viam::app::v1::CredentialsType value);
  private:
  ::viam::app::v1::CredentialsType _internal_type() const;
  void _internal_set_type(::viam::app::v1::CredentialsType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AuthHandlerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Struct* config_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Frame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kTranslationFieldNumber = 2,
    kOrientationFieldNumber = 3,
    kGeometryFieldNumber = 4,
  };
  // string parent = 1 [json_name = "parent"];
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // .viam.app.v1.Translation translation = 2 [json_name = "translation"];
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const ::viam::app::v1::Translation& translation() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Translation* release_translation();
  ::viam::app::v1::Translation* mutable_translation();
  void set_allocated_translation(::viam::app::v1::Translation* translation);
  private:
  const ::viam::app::v1::Translation& _internal_translation() const;
  ::viam::app::v1::Translation* _internal_mutable_translation();
  public:
  void unsafe_arena_set_allocated_translation(
      ::viam::app::v1::Translation* translation);
  ::viam::app::v1::Translation* unsafe_arena_release_translation();

  // .viam.app.v1.Orientation orientation = 3 [json_name = "orientation"];
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::viam::app::v1::Orientation& orientation() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation* release_orientation();
  ::viam::app::v1::Orientation* mutable_orientation();
  void set_allocated_orientation(::viam::app::v1::Orientation* orientation);
  private:
  const ::viam::app::v1::Orientation& _internal_orientation() const;
  ::viam::app::v1::Orientation* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::viam::app::v1::Orientation* orientation);
  ::viam::app::v1::Orientation* unsafe_arena_release_orientation();

  // .viam.common.v1.Geometry geometry = 4 [json_name = "geometry"];
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::viam::common::v1::Geometry& geometry() const;
  PROTOBUF_NODISCARD ::viam::common::v1::Geometry* release_geometry();
  ::viam::common::v1::Geometry* mutable_geometry();
  void set_allocated_geometry(::viam::common::v1::Geometry* geometry);
  private:
  const ::viam::common::v1::Geometry& _internal_geometry() const;
  ::viam::common::v1::Geometry* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::viam::common::v1::Geometry* geometry);
  ::viam::common::v1::Geometry* unsafe_arena_release_geometry();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::viam::app::v1::Translation* translation_;
  ::viam::app::v1::Orientation* orientation_;
  ::viam::common::v1::Geometry* geometry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class LogConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LogConfiguration) */ {
 public:
  inline LogConfiguration() : LogConfiguration(nullptr) {}
  ~LogConfiguration() override;
  explicit PROTOBUF_CONSTEXPR LogConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogConfiguration(const LogConfiguration& from);
  LogConfiguration(LogConfiguration&& from) noexcept
    : LogConfiguration() {
    *this = ::std::move(from);
  }

  inline LogConfiguration& operator=(const LogConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogConfiguration& operator=(LogConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogConfiguration* internal_default_instance() {
    return reinterpret_cast<const LogConfiguration*>(
               &_LogConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LogConfiguration& a, LogConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(LogConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LogConfiguration";
  }
  protected:
  explicit LogConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // string level = 1 [json_name = "level"];
  void clear_level();
  const std::string& level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* level);
  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(const std::string& value);
  std::string* _internal_mutable_level();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LogConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Translation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Translation) */ {
 public:
  inline Translation() : Translation(nullptr) {}
  ~Translation() override;
  explicit PROTOBUF_CONSTEXPR Translation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Translation(const Translation& from);
  Translation(Translation&& from) noexcept
    : Translation() {
    *this = ::std::move(from);
  }

  inline Translation& operator=(const Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Translation& operator=(Translation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Translation* internal_default_instance() {
    return reinterpret_cast<const Translation*>(
               &_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Translation& a, Translation& b) {
    a.Swap(&b);
  }
  inline void Swap(Translation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Translation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Translation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Translation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Translation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Translation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Translation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Translation";
  }
  protected:
  explicit Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1 [json_name = "x"];
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2 [json_name = "y"];
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3 [json_name = "z"];
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Translation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation_NoOrientation final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.NoOrientation) */ {
 public:
  inline Orientation_NoOrientation() : Orientation_NoOrientation(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Orientation_NoOrientation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation_NoOrientation(const Orientation_NoOrientation& from);
  Orientation_NoOrientation(Orientation_NoOrientation&& from) noexcept
    : Orientation_NoOrientation() {
    *this = ::std::move(from);
  }

  inline Orientation_NoOrientation& operator=(const Orientation_NoOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_NoOrientation& operator=(Orientation_NoOrientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_NoOrientation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_NoOrientation* internal_default_instance() {
    return reinterpret_cast<const Orientation_NoOrientation*>(
               &_Orientation_NoOrientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Orientation_NoOrientation& a, Orientation_NoOrientation& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_NoOrientation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_NoOrientation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_NoOrientation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_NoOrientation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Orientation_NoOrientation& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Orientation_NoOrientation& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Orientation.NoOrientation";
  }
  protected:
  explicit Orientation_NoOrientation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.NoOrientation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation_OrientationVectorRadians final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.OrientationVectorRadians) */ {
 public:
  inline Orientation_OrientationVectorRadians() : Orientation_OrientationVectorRadians(nullptr) {}
  ~Orientation_OrientationVectorRadians() override;
  explicit PROTOBUF_CONSTEXPR Orientation_OrientationVectorRadians(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation_OrientationVectorRadians(const Orientation_OrientationVectorRadians& from);
  Orientation_OrientationVectorRadians(Orientation_OrientationVectorRadians&& from) noexcept
    : Orientation_OrientationVectorRadians() {
    *this = ::std::move(from);
  }

  inline Orientation_OrientationVectorRadians& operator=(const Orientation_OrientationVectorRadians& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_OrientationVectorRadians& operator=(Orientation_OrientationVectorRadians&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_OrientationVectorRadians& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_OrientationVectorRadians* internal_default_instance() {
    return reinterpret_cast<const Orientation_OrientationVectorRadians*>(
               &_Orientation_OrientationVectorRadians_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Orientation_OrientationVectorRadians& a, Orientation_OrientationVectorRadians& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_OrientationVectorRadians* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_OrientationVectorRadians* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_OrientationVectorRadians* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_OrientationVectorRadians>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation_OrientationVectorRadians& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Orientation_OrientationVectorRadians& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation_OrientationVectorRadians* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Orientation.OrientationVectorRadians";
  }
  protected:
  explicit Orientation_OrientationVectorRadians(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThetaFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // double x = 2 [json_name = "x"];
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 3 [json_name = "y"];
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 4 [json_name = "z"];
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.OrientationVectorRadians)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double theta_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation_OrientationVectorDegrees final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.OrientationVectorDegrees) */ {
 public:
  inline Orientation_OrientationVectorDegrees() : Orientation_OrientationVectorDegrees(nullptr) {}
  ~Orientation_OrientationVectorDegrees() override;
  explicit PROTOBUF_CONSTEXPR Orientation_OrientationVectorDegrees(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation_OrientationVectorDegrees(const Orientation_OrientationVectorDegrees& from);
  Orientation_OrientationVectorDegrees(Orientation_OrientationVectorDegrees&& from) noexcept
    : Orientation_OrientationVectorDegrees() {
    *this = ::std::move(from);
  }

  inline Orientation_OrientationVectorDegrees& operator=(const Orientation_OrientationVectorDegrees& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_OrientationVectorDegrees& operator=(Orientation_OrientationVectorDegrees&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_OrientationVectorDegrees& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_OrientationVectorDegrees* internal_default_instance() {
    return reinterpret_cast<const Orientation_OrientationVectorDegrees*>(
               &_Orientation_OrientationVectorDegrees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Orientation_OrientationVectorDegrees& a, Orientation_OrientationVectorDegrees& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_OrientationVectorDegrees* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_OrientationVectorDegrees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_OrientationVectorDegrees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_OrientationVectorDegrees>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation_OrientationVectorDegrees& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Orientation_OrientationVectorDegrees& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation_OrientationVectorDegrees* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Orientation.OrientationVectorDegrees";
  }
  protected:
  explicit Orientation_OrientationVectorDegrees(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThetaFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // double x = 2 [json_name = "x"];
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 3 [json_name = "y"];
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 4 [json_name = "z"];
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.OrientationVectorDegrees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double theta_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation_EulerAngles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.EulerAngles) */ {
 public:
  inline Orientation_EulerAngles() : Orientation_EulerAngles(nullptr) {}
  ~Orientation_EulerAngles() override;
  explicit PROTOBUF_CONSTEXPR Orientation_EulerAngles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation_EulerAngles(const Orientation_EulerAngles& from);
  Orientation_EulerAngles(Orientation_EulerAngles&& from) noexcept
    : Orientation_EulerAngles() {
    *this = ::std::move(from);
  }

  inline Orientation_EulerAngles& operator=(const Orientation_EulerAngles& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_EulerAngles& operator=(Orientation_EulerAngles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_EulerAngles& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_EulerAngles* internal_default_instance() {
    return reinterpret_cast<const Orientation_EulerAngles*>(
               &_Orientation_EulerAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Orientation_EulerAngles& a, Orientation_EulerAngles& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_EulerAngles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_EulerAngles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_EulerAngles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_EulerAngles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation_EulerAngles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Orientation_EulerAngles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation_EulerAngles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Orientation.EulerAngles";
  }
  protected:
  explicit Orientation_EulerAngles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollFieldNumber = 1,
    kPitchFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // double roll = 1 [json_name = "roll"];
  void clear_roll();
  double roll() const;
  void set_roll(double value);
  private:
  double _internal_roll() const;
  void _internal_set_roll(double value);
  public:

  // double pitch = 2 [json_name = "pitch"];
  void clear_pitch();
  double pitch() const;
  void set_pitch(double value);
  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);
  public:

  // double yaw = 3 [json_name = "yaw"];
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.EulerAngles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double roll_;
  double pitch_;
  double yaw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation_AxisAngles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.AxisAngles) */ {
 public:
  inline Orientation_AxisAngles() : Orientation_AxisAngles(nullptr) {}
  ~Orientation_AxisAngles() override;
  explicit PROTOBUF_CONSTEXPR Orientation_AxisAngles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation_AxisAngles(const Orientation_AxisAngles& from);
  Orientation_AxisAngles(Orientation_AxisAngles&& from) noexcept
    : Orientation_AxisAngles() {
    *this = ::std::move(from);
  }

  inline Orientation_AxisAngles& operator=(const Orientation_AxisAngles& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_AxisAngles& operator=(Orientation_AxisAngles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_AxisAngles& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_AxisAngles* internal_default_instance() {
    return reinterpret_cast<const Orientation_AxisAngles*>(
               &_Orientation_AxisAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Orientation_AxisAngles& a, Orientation_AxisAngles& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_AxisAngles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_AxisAngles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_AxisAngles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_AxisAngles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation_AxisAngles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Orientation_AxisAngles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation_AxisAngles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Orientation.AxisAngles";
  }
  protected:
  explicit Orientation_AxisAngles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThetaFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // double x = 2 [json_name = "x"];
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 3 [json_name = "y"];
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 4 [json_name = "z"];
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.AxisAngles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double theta_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation_Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation.Quaternion) */ {
 public:
  inline Orientation_Quaternion() : Orientation_Quaternion(nullptr) {}
  ~Orientation_Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Orientation_Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation_Quaternion(const Orientation_Quaternion& from);
  Orientation_Quaternion(Orientation_Quaternion&& from) noexcept
    : Orientation_Quaternion() {
    *this = ::std::move(from);
  }

  inline Orientation_Quaternion& operator=(const Orientation_Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation_Quaternion& operator=(Orientation_Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation_Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation_Quaternion* internal_default_instance() {
    return reinterpret_cast<const Orientation_Quaternion*>(
               &_Orientation_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Orientation_Quaternion& a, Orientation_Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation_Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation_Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation_Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation_Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation_Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Orientation_Quaternion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation_Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Orientation.Quaternion";
  }
  protected:
  explicit Orientation_Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // double w = 1 [json_name = "w"];
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // double x = 2 [json_name = "x"];
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 3 [json_name = "y"];
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 4 [json_name = "z"];
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double w_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Orientation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Orientation) */ {
 public:
  inline Orientation() : Orientation(nullptr) {}
  ~Orientation() override;
  explicit PROTOBUF_CONSTEXPR Orientation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation(const Orientation& from);
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation& operator=(Orientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kNoOrientation = 1,
    kVectorRadians = 2,
    kVectorDegrees = 3,
    kEulerAngles = 4,
    kAxisAngles = 5,
    kQuaternion = 6,
    TYPE_NOT_SET = 0,
  };

  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orientation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Orientation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Orientation";
  }
  protected:
  explicit Orientation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Orientation_NoOrientation NoOrientation;
  typedef Orientation_OrientationVectorRadians OrientationVectorRadians;
  typedef Orientation_OrientationVectorDegrees OrientationVectorDegrees;
  typedef Orientation_EulerAngles EulerAngles;
  typedef Orientation_AxisAngles AxisAngles;
  typedef Orientation_Quaternion Quaternion;

  // accessors -------------------------------------------------------

  enum : int {
    kNoOrientationFieldNumber = 1,
    kVectorRadiansFieldNumber = 2,
    kVectorDegreesFieldNumber = 3,
    kEulerAnglesFieldNumber = 4,
    kAxisAnglesFieldNumber = 5,
    kQuaternionFieldNumber = 6,
  };
  // .viam.app.v1.Orientation.NoOrientation no_orientation = 1 [json_name = "noOrientation"];
  bool has_no_orientation() const;
  private:
  bool _internal_has_no_orientation() const;
  public:
  void clear_no_orientation();
  const ::viam::app::v1::Orientation_NoOrientation& no_orientation() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_NoOrientation* release_no_orientation();
  ::viam::app::v1::Orientation_NoOrientation* mutable_no_orientation();
  void set_allocated_no_orientation(::viam::app::v1::Orientation_NoOrientation* no_orientation);
  private:
  const ::viam::app::v1::Orientation_NoOrientation& _internal_no_orientation() const;
  ::viam::app::v1::Orientation_NoOrientation* _internal_mutable_no_orientation();
  public:
  void unsafe_arena_set_allocated_no_orientation(
      ::viam::app::v1::Orientation_NoOrientation* no_orientation);
  ::viam::app::v1::Orientation_NoOrientation* unsafe_arena_release_no_orientation();

  // .viam.app.v1.Orientation.OrientationVectorRadians vector_radians = 2 [json_name = "vectorRadians"];
  bool has_vector_radians() const;
  private:
  bool _internal_has_vector_radians() const;
  public:
  void clear_vector_radians();
  const ::viam::app::v1::Orientation_OrientationVectorRadians& vector_radians() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_OrientationVectorRadians* release_vector_radians();
  ::viam::app::v1::Orientation_OrientationVectorRadians* mutable_vector_radians();
  void set_allocated_vector_radians(::viam::app::v1::Orientation_OrientationVectorRadians* vector_radians);
  private:
  const ::viam::app::v1::Orientation_OrientationVectorRadians& _internal_vector_radians() const;
  ::viam::app::v1::Orientation_OrientationVectorRadians* _internal_mutable_vector_radians();
  public:
  void unsafe_arena_set_allocated_vector_radians(
      ::viam::app::v1::Orientation_OrientationVectorRadians* vector_radians);
  ::viam::app::v1::Orientation_OrientationVectorRadians* unsafe_arena_release_vector_radians();

  // .viam.app.v1.Orientation.OrientationVectorDegrees vector_degrees = 3 [json_name = "vectorDegrees"];
  bool has_vector_degrees() const;
  private:
  bool _internal_has_vector_degrees() const;
  public:
  void clear_vector_degrees();
  const ::viam::app::v1::Orientation_OrientationVectorDegrees& vector_degrees() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_OrientationVectorDegrees* release_vector_degrees();
  ::viam::app::v1::Orientation_OrientationVectorDegrees* mutable_vector_degrees();
  void set_allocated_vector_degrees(::viam::app::v1::Orientation_OrientationVectorDegrees* vector_degrees);
  private:
  const ::viam::app::v1::Orientation_OrientationVectorDegrees& _internal_vector_degrees() const;
  ::viam::app::v1::Orientation_OrientationVectorDegrees* _internal_mutable_vector_degrees();
  public:
  void unsafe_arena_set_allocated_vector_degrees(
      ::viam::app::v1::Orientation_OrientationVectorDegrees* vector_degrees);
  ::viam::app::v1::Orientation_OrientationVectorDegrees* unsafe_arena_release_vector_degrees();

  // .viam.app.v1.Orientation.EulerAngles euler_angles = 4 [json_name = "eulerAngles"];
  bool has_euler_angles() const;
  private:
  bool _internal_has_euler_angles() const;
  public:
  void clear_euler_angles();
  const ::viam::app::v1::Orientation_EulerAngles& euler_angles() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_EulerAngles* release_euler_angles();
  ::viam::app::v1::Orientation_EulerAngles* mutable_euler_angles();
  void set_allocated_euler_angles(::viam::app::v1::Orientation_EulerAngles* euler_angles);
  private:
  const ::viam::app::v1::Orientation_EulerAngles& _internal_euler_angles() const;
  ::viam::app::v1::Orientation_EulerAngles* _internal_mutable_euler_angles();
  public:
  void unsafe_arena_set_allocated_euler_angles(
      ::viam::app::v1::Orientation_EulerAngles* euler_angles);
  ::viam::app::v1::Orientation_EulerAngles* unsafe_arena_release_euler_angles();

  // .viam.app.v1.Orientation.AxisAngles axis_angles = 5 [json_name = "axisAngles"];
  bool has_axis_angles() const;
  private:
  bool _internal_has_axis_angles() const;
  public:
  void clear_axis_angles();
  const ::viam::app::v1::Orientation_AxisAngles& axis_angles() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_AxisAngles* release_axis_angles();
  ::viam::app::v1::Orientation_AxisAngles* mutable_axis_angles();
  void set_allocated_axis_angles(::viam::app::v1::Orientation_AxisAngles* axis_angles);
  private:
  const ::viam::app::v1::Orientation_AxisAngles& _internal_axis_angles() const;
  ::viam::app::v1::Orientation_AxisAngles* _internal_mutable_axis_angles();
  public:
  void unsafe_arena_set_allocated_axis_angles(
      ::viam::app::v1::Orientation_AxisAngles* axis_angles);
  ::viam::app::v1::Orientation_AxisAngles* unsafe_arena_release_axis_angles();

  // .viam.app.v1.Orientation.Quaternion quaternion = 6 [json_name = "quaternion"];
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;
  public:
  void clear_quaternion();
  const ::viam::app::v1::Orientation_Quaternion& quaternion() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Orientation_Quaternion* release_quaternion();
  ::viam::app::v1::Orientation_Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::viam::app::v1::Orientation_Quaternion* quaternion);
  private:
  const ::viam::app::v1::Orientation_Quaternion& _internal_quaternion() const;
  ::viam::app::v1::Orientation_Quaternion* _internal_mutable_quaternion();
  public:
  void unsafe_arena_set_allocated_quaternion(
      ::viam::app::v1::Orientation_Quaternion* quaternion);
  ::viam::app::v1::Orientation_Quaternion* unsafe_arena_release_quaternion();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.v1.Orientation)
 private:
  class _Internal;
  void set_has_no_orientation();
  void set_has_vector_radians();
  void set_has_vector_degrees();
  void set_has_euler_angles();
  void set_has_axis_angles();
  void set_has_quaternion();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::viam::app::v1::Orientation_NoOrientation* no_orientation_;
    ::viam::app::v1::Orientation_OrientationVectorRadians* vector_radians_;
    ::viam::app::v1::Orientation_OrientationVectorDegrees* vector_degrees_;
    ::viam::app::v1::Orientation_EulerAngles* euler_angles_;
    ::viam::app::v1::Orientation_AxisAngles* axis_angles_;
    ::viam::app::v1::Orientation_Quaternion* quaternion_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class RemoteConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoteConfig) */ {
 public:
  inline RemoteConfig() : RemoteConfig(nullptr) {}
  ~RemoteConfig() override;
  explicit PROTOBUF_CONSTEXPR RemoteConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteConfig(const RemoteConfig& from);
  RemoteConfig(RemoteConfig&& from) noexcept
    : RemoteConfig() {
    *this = ::std::move(from);
  }

  inline RemoteConfig& operator=(const RemoteConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteConfig& operator=(RemoteConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteConfig* internal_default_instance() {
    return reinterpret_cast<const RemoteConfig*>(
               &_RemoteConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RemoteConfig& a, RemoteConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoteConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RemoteConfig";
  }
  protected:
  explicit RemoteConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceConfigsFieldNumber = 9,
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kManagedByFieldNumber = 5,
    kSecretFieldNumber = 10,
    kFrameFieldNumber = 3,
    kAuthFieldNumber = 4,
    kConnectionCheckIntervalFieldNumber = 7,
    kReconnectIntervalFieldNumber = 8,
    kInsecureFieldNumber = 6,
  };
  // repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 9 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
  int service_configs_size() const;
  private:
  int _internal_service_configs_size() const;
  public:
  void clear_service_configs();
  ::viam::app::v1::ResourceLevelServiceConfig* mutable_service_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
      mutable_service_configs();
  private:
  const ::viam::app::v1::ResourceLevelServiceConfig& _internal_service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* _internal_add_service_configs();
  public:
  const ::viam::app::v1::ResourceLevelServiceConfig& service_configs(int index) const;
  ::viam::app::v1::ResourceLevelServiceConfig* add_service_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
      service_configs() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string address = 2 [json_name = "address"];
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string managed_by = 5 [json_name = "managedBy"];
  void clear_managed_by();
  const std::string& managed_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_managed_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_managed_by();
  PROTOBUF_NODISCARD std::string* release_managed_by();
  void set_allocated_managed_by(std::string* managed_by);
  private:
  const std::string& _internal_managed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_managed_by(const std::string& value);
  std::string* _internal_mutable_managed_by();
  public:

  // string secret = 10 [json_name = "secret"];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // .viam.app.v1.Frame frame = 3 [json_name = "frame"];
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::viam::app::v1::Frame& frame() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Frame* release_frame();
  ::viam::app::v1::Frame* mutable_frame();
  void set_allocated_frame(::viam::app::v1::Frame* frame);
  private:
  const ::viam::app::v1::Frame& _internal_frame() const;
  ::viam::app::v1::Frame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::viam::app::v1::Frame* frame);
  ::viam::app::v1::Frame* unsafe_arena_release_frame();

  // .viam.app.v1.RemoteAuth auth = 4 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::RemoteAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RemoteAuth* release_auth();
  ::viam::app::v1::RemoteAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::RemoteAuth* auth);
  private:
  const ::viam::app::v1::RemoteAuth& _internal_auth() const;
  ::viam::app::v1::RemoteAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::RemoteAuth* auth);
  ::viam::app::v1::RemoteAuth* unsafe_arena_release_auth();

  // .google.protobuf.Duration connection_check_interval = 7 [json_name = "connectionCheckInterval"];
  bool has_connection_check_interval() const;
  private:
  bool _internal_has_connection_check_interval() const;
  public:
  void clear_connection_check_interval();
  const ::PROTOBUF_NAMESPACE_ID::Duration& connection_check_interval() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_connection_check_interval();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_connection_check_interval();
  void set_allocated_connection_check_interval(::PROTOBUF_NAMESPACE_ID::Duration* connection_check_interval);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_connection_check_interval() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_connection_check_interval();
  public:
  void unsafe_arena_set_allocated_connection_check_interval(
      ::PROTOBUF_NAMESPACE_ID::Duration* connection_check_interval);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_connection_check_interval();

  // .google.protobuf.Duration reconnect_interval = 8 [json_name = "reconnectInterval"];
  bool has_reconnect_interval() const;
  private:
  bool _internal_has_reconnect_interval() const;
  public:
  void clear_reconnect_interval();
  const ::PROTOBUF_NAMESPACE_ID::Duration& reconnect_interval() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_reconnect_interval();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_reconnect_interval();
  void set_allocated_reconnect_interval(::PROTOBUF_NAMESPACE_ID::Duration* reconnect_interval);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_reconnect_interval() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_reconnect_interval();
  public:
  void unsafe_arena_set_allocated_reconnect_interval(
      ::PROTOBUF_NAMESPACE_ID::Duration* reconnect_interval);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_reconnect_interval();

  // bool insecure = 6 [json_name = "insecure"];
  void clear_insecure();
  bool insecure() const;
  void set_insecure(bool value);
  private:
  bool _internal_insecure() const;
  void _internal_set_insecure(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoteConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig > service_configs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr managed_by_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::viam::app::v1::Frame* frame_;
  ::viam::app::v1::RemoteAuth* auth_;
  ::PROTOBUF_NAMESPACE_ID::Duration* connection_check_interval_;
  ::PROTOBUF_NAMESPACE_ID::Duration* reconnect_interval_;
  bool insecure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class RemoteAuth_Credentials final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoteAuth.Credentials) */ {
 public:
  inline RemoteAuth_Credentials() : RemoteAuth_Credentials(nullptr) {}
  ~RemoteAuth_Credentials() override;
  explicit PROTOBUF_CONSTEXPR RemoteAuth_Credentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteAuth_Credentials(const RemoteAuth_Credentials& from);
  RemoteAuth_Credentials(RemoteAuth_Credentials&& from) noexcept
    : RemoteAuth_Credentials() {
    *this = ::std::move(from);
  }

  inline RemoteAuth_Credentials& operator=(const RemoteAuth_Credentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteAuth_Credentials& operator=(RemoteAuth_Credentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteAuth_Credentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteAuth_Credentials* internal_default_instance() {
    return reinterpret_cast<const RemoteAuth_Credentials*>(
               &_RemoteAuth_Credentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RemoteAuth_Credentials& a, RemoteAuth_Credentials& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteAuth_Credentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteAuth_Credentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteAuth_Credentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteAuth_Credentials>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteAuth_Credentials& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoteAuth_Credentials& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteAuth_Credentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RemoteAuth.Credentials";
  }
  protected:
  explicit RemoteAuth_Credentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string payload = 2 [json_name = "payload"];
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
  void clear_type();
  ::viam::app::v1::CredentialsType type() const;
  void set_type(::viam::app::v1::CredentialsType value);
  private:
  ::viam::app::v1::CredentialsType _internal_type() const;
  void _internal_set_type(::viam::app::v1::CredentialsType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoteAuth.Credentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class RemoteAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RemoteAuth) */ {
 public:
  inline RemoteAuth() : RemoteAuth(nullptr) {}
  ~RemoteAuth() override;
  explicit PROTOBUF_CONSTEXPR RemoteAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteAuth(const RemoteAuth& from);
  RemoteAuth(RemoteAuth&& from) noexcept
    : RemoteAuth() {
    *this = ::std::move(from);
  }

  inline RemoteAuth& operator=(const RemoteAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteAuth& operator=(RemoteAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteAuth* internal_default_instance() {
    return reinterpret_cast<const RemoteAuth*>(
               &_RemoteAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RemoteAuth& a, RemoteAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoteAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RemoteAuth";
  }
  protected:
  explicit RemoteAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RemoteAuth_Credentials Credentials;

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 2,
    kCredentialsFieldNumber = 1,
  };
  // string entity = 2 [json_name = "entity"];
  void clear_entity();
  const std::string& entity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entity();
  PROTOBUF_NODISCARD std::string* release_entity();
  void set_allocated_entity(std::string* entity);
  private:
  const std::string& _internal_entity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity(const std::string& value);
  std::string* _internal_mutable_entity();
  public:

  // .viam.app.v1.RemoteAuth.Credentials credentials = 1 [json_name = "credentials"];
  bool has_credentials() const;
  private:
  bool _internal_has_credentials() const;
  public:
  void clear_credentials();
  const ::viam::app::v1::RemoteAuth_Credentials& credentials() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RemoteAuth_Credentials* release_credentials();
  ::viam::app::v1::RemoteAuth_Credentials* mutable_credentials();
  void set_allocated_credentials(::viam::app::v1::RemoteAuth_Credentials* credentials);
  private:
  const ::viam::app::v1::RemoteAuth_Credentials& _internal_credentials() const;
  ::viam::app::v1::RemoteAuth_Credentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::viam::app::v1::RemoteAuth_Credentials* credentials);
  ::viam::app::v1::RemoteAuth_Credentials* unsafe_arena_release_credentials();

  // @@protoc_insertion_point(class_scope:viam.app.v1.RemoteAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_;
  ::viam::app::v1::RemoteAuth_Credentials* credentials_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class AgentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.AgentInfo) */ {
 public:
  inline AgentInfo() : AgentInfo(nullptr) {}
  ~AgentInfo() override;
  explicit PROTOBUF_CONSTEXPR AgentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentInfo(const AgentInfo& from);
  AgentInfo(AgentInfo&& from) noexcept
    : AgentInfo() {
    *this = ::std::move(from);
  }

  inline AgentInfo& operator=(const AgentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentInfo& operator=(AgentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentInfo* internal_default_instance() {
    return reinterpret_cast<const AgentInfo*>(
               &_AgentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AgentInfo& a, AgentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AgentInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.AgentInfo";
  }
  protected:
  explicit AgentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsFieldNumber = 3,
    kPlatformTagsFieldNumber = 7,
    kHostFieldNumber = 1,
    kOsFieldNumber = 2,
    kVersionFieldNumber = 4,
    kGitRevisionFieldNumber = 5,
    kPlatformFieldNumber = 6,
  };
  // repeated string ips = 3 [json_name = "ips"];
  int ips_size() const;
  private:
  int _internal_ips_size() const;
  public:
  void clear_ips();
  const std::string& ips(int index) const;
  std::string* mutable_ips(int index);
  void set_ips(int index, const std::string& value);
  void set_ips(int index, std::string&& value);
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, size_t size);
  std::string* add_ips();
  void add_ips(const std::string& value);
  void add_ips(std::string&& value);
  void add_ips(const char* value);
  void add_ips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ips();
  private:
  const std::string& _internal_ips(int index) const;
  std::string* _internal_add_ips();
  public:

  // repeated string platform_tags = 7 [json_name = "platformTags"];
  int platform_tags_size() const;
  private:
  int _internal_platform_tags_size() const;
  public:
  void clear_platform_tags();
  const std::string& platform_tags(int index) const;
  std::string* mutable_platform_tags(int index);
  void set_platform_tags(int index, const std::string& value);
  void set_platform_tags(int index, std::string&& value);
  void set_platform_tags(int index, const char* value);
  void set_platform_tags(int index, const char* value, size_t size);
  std::string* add_platform_tags();
  void add_platform_tags(const std::string& value);
  void add_platform_tags(std::string&& value);
  void add_platform_tags(const char* value);
  void add_platform_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& platform_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_platform_tags();
  private:
  const std::string& _internal_platform_tags(int index) const;
  std::string* _internal_add_platform_tags();
  public:

  // string host = 1 [json_name = "host"];
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string os = 2 [json_name = "os"];
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string version = 4 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string git_revision = 5 [json_name = "gitRevision"];
  void clear_git_revision();
  const std::string& git_revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_git_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_git_revision();
  PROTOBUF_NODISCARD std::string* release_git_revision();
  void set_allocated_git_revision(std::string* git_revision);
  private:
  const std::string& _internal_git_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_git_revision(const std::string& value);
  std::string* _internal_mutable_git_revision();
  public:

  // optional string platform = 6 [json_name = "platform"];
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.AgentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> platform_tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr git_revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ConfigRequest) */ {
 public:
  inline ConfigRequest() : ConfigRequest(nullptr) {}
  ~ConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR ConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigRequest(const ConfigRequest& from);
  ConfigRequest(ConfigRequest&& from) noexcept
    : ConfigRequest() {
    *this = ::std::move(from);
  }

  inline ConfigRequest& operator=(const ConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigRequest& operator=(ConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigRequest*>(
               &_ConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ConfigRequest& a, ConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ConfigRequest";
  }
  protected:
  explicit ConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAgentInfoFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .viam.app.v1.AgentInfo agent_info = 2 [json_name = "agentInfo"];
  bool has_agent_info() const;
  private:
  bool _internal_has_agent_info() const;
  public:
  void clear_agent_info();
  const ::viam::app::v1::AgentInfo& agent_info() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AgentInfo* release_agent_info();
  ::viam::app::v1::AgentInfo* mutable_agent_info();
  void set_allocated_agent_info(::viam::app::v1::AgentInfo* agent_info);
  private:
  const ::viam::app::v1::AgentInfo& _internal_agent_info() const;
  ::viam::app::v1::AgentInfo* _internal_mutable_agent_info();
  public:
  void unsafe_arena_set_allocated_agent_info(
      ::viam::app::v1::AgentInfo* agent_info);
  ::viam::app::v1::AgentInfo* unsafe_arena_release_agent_info();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::viam::app::v1::AgentInfo* agent_info_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ConfigResponse) */ {
 public:
  inline ConfigResponse() : ConfigResponse(nullptr) {}
  ~ConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR ConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigResponse(const ConfigResponse& from);
  ConfigResponse(ConfigResponse&& from) noexcept
    : ConfigResponse() {
    *this = ::std::move(from);
  }

  inline ConfigResponse& operator=(const ConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigResponse& operator=(ConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigResponse*>(
               &_ConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ConfigResponse& a, ConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ConfigResponse";
  }
  protected:
  explicit ConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .viam.app.v1.RobotConfig config = 1 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::viam::app::v1::RobotConfig& config() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotConfig* release_config();
  ::viam::app::v1::RobotConfig* mutable_config();
  void set_allocated_config(::viam::app::v1::RobotConfig* config);
  private:
  const ::viam::app::v1::RobotConfig& _internal_config() const;
  ::viam::app::v1::RobotConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::viam::app::v1::RobotConfig* config);
  ::viam::app::v1::RobotConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.ConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::v1::RobotConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class CertificateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CertificateRequest) */ {
 public:
  inline CertificateRequest() : CertificateRequest(nullptr) {}
  ~CertificateRequest() override;
  explicit PROTOBUF_CONSTEXPR CertificateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateRequest(const CertificateRequest& from);
  CertificateRequest(CertificateRequest&& from) noexcept
    : CertificateRequest() {
    *this = ::std::move(from);
  }

  inline CertificateRequest& operator=(const CertificateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateRequest& operator=(CertificateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateRequest* internal_default_instance() {
    return reinterpret_cast<const CertificateRequest*>(
               &_CertificateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CertificateRequest& a, CertificateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CertificateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CertificateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CertificateRequest";
  }
  protected:
  explicit CertificateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CertificateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class CertificateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CertificateResponse) */ {
 public:
  inline CertificateResponse() : CertificateResponse(nullptr) {}
  ~CertificateResponse() override;
  explicit PROTOBUF_CONSTEXPR CertificateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateResponse(const CertificateResponse& from);
  CertificateResponse(CertificateResponse&& from) noexcept
    : CertificateResponse() {
    *this = ::std::move(from);
  }

  inline CertificateResponse& operator=(const CertificateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateResponse& operator=(CertificateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateResponse* internal_default_instance() {
    return reinterpret_cast<const CertificateResponse*>(
               &_CertificateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CertificateResponse& a, CertificateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CertificateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CertificateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CertificateResponse";
  }
  protected:
  explicit CertificateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTlsCertificateFieldNumber = 2,
    kTlsPrivateKeyFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string tls_certificate = 2 [json_name = "tlsCertificate"];
  void clear_tls_certificate();
  const std::string& tls_certificate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tls_certificate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tls_certificate();
  PROTOBUF_NODISCARD std::string* release_tls_certificate();
  void set_allocated_tls_certificate(std::string* tls_certificate);
  private:
  const std::string& _internal_tls_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_certificate(const std::string& value);
  std::string* _internal_mutable_tls_certificate();
  public:

  // string tls_private_key = 3 [json_name = "tlsPrivateKey"];
  void clear_tls_private_key();
  const std::string& tls_private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tls_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tls_private_key();
  PROTOBUF_NODISCARD std::string* release_tls_private_key();
  void set_allocated_tls_private_key(std::string* tls_private_key);
  private:
  const std::string& _internal_tls_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tls_private_key(const std::string& value);
  std::string* _internal_mutable_tls_private_key();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CertificateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tls_certificate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tls_private_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class LogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LogRequest) */ {
 public:
  inline LogRequest() : LogRequest(nullptr) {}
  ~LogRequest() override;
  explicit PROTOBUF_CONSTEXPR LogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogRequest(const LogRequest& from);
  LogRequest(LogRequest&& from) noexcept
    : LogRequest() {
    *this = ::std::move(from);
  }

  inline LogRequest& operator=(const LogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRequest& operator=(LogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRequest* internal_default_instance() {
    return reinterpret_cast<const LogRequest*>(
               &_LogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(LogRequest& a, LogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LogRequest";
  }
  protected:
  explicit LogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .viam.common.v1.LogEntry logs = 2 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::common::v1::LogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
      mutable_logs();
  private:
  const ::viam::common::v1::LogEntry& _internal_logs(int index) const;
  ::viam::common::v1::LogEntry* _internal_add_logs();
  public:
  const ::viam::common::v1::LogEntry& logs(int index) const;
  ::viam::common::v1::LogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
      logs() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry > logs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class LogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.LogResponse) */ {
 public:
  inline LogResponse() : LogResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogResponse(const LogResponse& from);
  LogResponse(LogResponse&& from) noexcept
    : LogResponse() {
    *this = ::std::move(from);
  }

  inline LogResponse& operator=(const LogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogResponse& operator=(LogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogResponse* internal_default_instance() {
    return reinterpret_cast<const LogResponse*>(
               &_LogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(LogResponse& a, LogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LogResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LogResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LogResponse";
  }
  protected:
  explicit LogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.LogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class NeedsRestartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NeedsRestartRequest) */ {
 public:
  inline NeedsRestartRequest() : NeedsRestartRequest(nullptr) {}
  ~NeedsRestartRequest() override;
  explicit PROTOBUF_CONSTEXPR NeedsRestartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NeedsRestartRequest(const NeedsRestartRequest& from);
  NeedsRestartRequest(NeedsRestartRequest&& from) noexcept
    : NeedsRestartRequest() {
    *this = ::std::move(from);
  }

  inline NeedsRestartRequest& operator=(const NeedsRestartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeedsRestartRequest& operator=(NeedsRestartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeedsRestartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeedsRestartRequest* internal_default_instance() {
    return reinterpret_cast<const NeedsRestartRequest*>(
               &_NeedsRestartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(NeedsRestartRequest& a, NeedsRestartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NeedsRestartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeedsRestartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeedsRestartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeedsRestartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NeedsRestartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NeedsRestartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NeedsRestartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NeedsRestartRequest";
  }
  protected:
  explicit NeedsRestartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NeedsRestartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class NeedsRestartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NeedsRestartResponse) */ {
 public:
  inline NeedsRestartResponse() : NeedsRestartResponse(nullptr) {}
  ~NeedsRestartResponse() override;
  explicit PROTOBUF_CONSTEXPR NeedsRestartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NeedsRestartResponse(const NeedsRestartResponse& from);
  NeedsRestartResponse(NeedsRestartResponse&& from) noexcept
    : NeedsRestartResponse() {
    *this = ::std::move(from);
  }

  inline NeedsRestartResponse& operator=(const NeedsRestartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeedsRestartResponse& operator=(NeedsRestartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeedsRestartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeedsRestartResponse* internal_default_instance() {
    return reinterpret_cast<const NeedsRestartResponse*>(
               &_NeedsRestartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(NeedsRestartResponse& a, NeedsRestartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NeedsRestartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeedsRestartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeedsRestartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeedsRestartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NeedsRestartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NeedsRestartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NeedsRestartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NeedsRestartResponse";
  }
  protected:
  explicit NeedsRestartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRestartCheckIntervalFieldNumber = 3,
    kMustRestartFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Duration restart_check_interval = 3 [json_name = "restartCheckInterval"];
  bool has_restart_check_interval() const;
  private:
  bool _internal_has_restart_check_interval() const;
  public:
  void clear_restart_check_interval();
  const ::PROTOBUF_NAMESPACE_ID::Duration& restart_check_interval() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_restart_check_interval();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_restart_check_interval();
  void set_allocated_restart_check_interval(::PROTOBUF_NAMESPACE_ID::Duration* restart_check_interval);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_restart_check_interval() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_restart_check_interval();
  public:
  void unsafe_arena_set_allocated_restart_check_interval(
      ::PROTOBUF_NAMESPACE_ID::Duration* restart_check_interval);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_restart_check_interval();

  // bool must_restart = 2 [json_name = "mustRestart"];
  void clear_must_restart();
  bool must_restart() const;
  void set_must_restart(bool value);
  private:
  bool _internal_must_restart() const;
  void _internal_set_must_restart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NeedsRestartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::Duration* restart_check_interval_;
  bool must_restart_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModuleConfig_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModuleConfig_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModuleConfig_EnvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModuleConfig_EnvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModuleConfig_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModuleConfig_EnvEntry_DoNotUse& other);
  static const ModuleConfig_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModuleConfig_EnvEntry_DoNotUse*>(&_ModuleConfig_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.ModuleConfig.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.v1.ModuleConfig.EnvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};

// -------------------------------------------------------------------

class ModuleConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ModuleConfig) */ {
 public:
  inline ModuleConfig() : ModuleConfig(nullptr) {}
  ~ModuleConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig(const ModuleConfig& from);
  ModuleConfig(ModuleConfig&& from) noexcept
    : ModuleConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig& operator=(const ModuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig& operator=(ModuleConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig*>(
               &_ModuleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ModuleConfig& a, ModuleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ModuleConfig";
  }
  protected:
  explicit ModuleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 6,
    kNameFieldNumber = 1,
    kPathFieldNumber = 2,
    kLogLevelFieldNumber = 3,
    kTypeFieldNumber = 4,
    kModuleIdFieldNumber = 5,
    kStatusFieldNumber = 7,
    kFirstRunTimeoutFieldNumber = 8,
    kTcpModeFieldNumber = 9,
  };
  // map<string, string> env = 6 [json_name = "env"];
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string path = 2 [json_name = "path"];
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string log_level = 3 [json_name = "logLevel"];
  void clear_log_level();
  const std::string& log_level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log_level();
  PROTOBUF_NODISCARD std::string* release_log_level();
  void set_allocated_log_level(std::string* log_level);
  private:
  const std::string& _internal_log_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_level(const std::string& value);
  std::string* _internal_mutable_log_level();
  public:

  // string type = 4 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string module_id = 5 [json_name = "moduleId"];
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // .viam.app.v1.AppValidationStatus status = 7 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::viam::app::v1::AppValidationStatus& status() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AppValidationStatus* release_status();
  ::viam::app::v1::AppValidationStatus* mutable_status();
  void set_allocated_status(::viam::app::v1::AppValidationStatus* status);
  private:
  const ::viam::app::v1::AppValidationStatus& _internal_status() const;
  ::viam::app::v1::AppValidationStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::viam::app::v1::AppValidationStatus* status);
  ::viam::app::v1::AppValidationStatus* unsafe_arena_release_status();

  // .google.protobuf.Duration first_run_timeout = 8 [json_name = "firstRunTimeout"];
  bool has_first_run_timeout() const;
  private:
  bool _internal_has_first_run_timeout() const;
  public:
  void clear_first_run_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& first_run_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_first_run_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_first_run_timeout();
  void set_allocated_first_run_timeout(::PROTOBUF_NAMESPACE_ID::Duration* first_run_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_first_run_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_first_run_timeout();
  public:
  void unsafe_arena_set_allocated_first_run_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* first_run_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_first_run_timeout();

  // bool tcp_mode = 9 [json_name = "tcpMode"];
  void clear_tcp_mode();
  bool tcp_mode() const;
  void set_tcp_mode(bool value);
  private:
  bool _internal_tcp_mode() const;
  void _internal_set_tcp_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ModuleConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModuleConfig_EnvEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_level_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  ::viam::app::v1::AppValidationStatus* status_;
  ::PROTOBUF_NAMESPACE_ID::Duration* first_run_timeout_;
  bool tcp_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class PackageConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.PackageConfig) */ {
 public:
  inline PackageConfig() : PackageConfig(nullptr) {}
  ~PackageConfig() override;
  explicit PROTOBUF_CONSTEXPR PackageConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackageConfig(const PackageConfig& from);
  PackageConfig(PackageConfig&& from) noexcept
    : PackageConfig() {
    *this = ::std::move(from);
  }

  inline PackageConfig& operator=(const PackageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackageConfig& operator=(PackageConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackageConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackageConfig* internal_default_instance() {
    return reinterpret_cast<const PackageConfig*>(
               &_PackageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PackageConfig& a, PackageConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PackageConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackageConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackageConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackageConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackageConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PackageConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackageConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.PackageConfig";
  }
  protected:
  explicit PackageConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPackageFieldNumber = 2,
    kVersionFieldNumber = 3,
    kTypeFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string package = 2 [json_name = "package"];
  void clear_package();
  const std::string& package() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package();
  PROTOBUF_NODISCARD std::string* release_package();
  void set_allocated_package(std::string* package);
  private:
  const std::string& _internal_package() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package(const std::string& value);
  std::string* _internal_mutable_package();
  public:

  // string version = 3 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string type = 4 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .viam.app.v1.AppValidationStatus status = 5 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::viam::app::v1::AppValidationStatus& status() const;
  PROTOBUF_NODISCARD ::viam::app::v1::AppValidationStatus* release_status();
  ::viam::app::v1::AppValidationStatus* mutable_status();
  void set_allocated_status(::viam::app::v1::AppValidationStatus* status);
  private:
  const ::viam::app::v1::AppValidationStatus& _internal_status() const;
  ::viam::app::v1::AppValidationStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::viam::app::v1::AppValidationStatus* status);
  ::viam::app::v1::AppValidationStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:viam.app.v1.PackageConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::viam::app::v1::AppValidationStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class MaintenanceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MaintenanceConfig) */ {
 public:
  inline MaintenanceConfig() : MaintenanceConfig(nullptr) {}
  ~MaintenanceConfig() override;
  explicit PROTOBUF_CONSTEXPR MaintenanceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaintenanceConfig(const MaintenanceConfig& from);
  MaintenanceConfig(MaintenanceConfig&& from) noexcept
    : MaintenanceConfig() {
    *this = ::std::move(from);
  }

  inline MaintenanceConfig& operator=(const MaintenanceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaintenanceConfig& operator=(MaintenanceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaintenanceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaintenanceConfig* internal_default_instance() {
    return reinterpret_cast<const MaintenanceConfig*>(
               &_MaintenanceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MaintenanceConfig& a, MaintenanceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MaintenanceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaintenanceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaintenanceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaintenanceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaintenanceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MaintenanceConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaintenanceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MaintenanceConfig";
  }
  protected:
  explicit MaintenanceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaintenanceAllowedKeyFieldNumber = 2,
    kSensorNameFieldNumber = 1,
  };
  // string maintenance_allowed_key = 2 [json_name = "maintenanceAllowedKey"];
  void clear_maintenance_allowed_key();
  const std::string& maintenance_allowed_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maintenance_allowed_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maintenance_allowed_key();
  PROTOBUF_NODISCARD std::string* release_maintenance_allowed_key();
  void set_allocated_maintenance_allowed_key(std::string* maintenance_allowed_key);
  private:
  const std::string& _internal_maintenance_allowed_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_allowed_key(const std::string& value);
  std::string* _internal_mutable_maintenance_allowed_key();
  public:

  // .viam.common.v1.ResourceName sensor_name = 1 [json_name = "sensorName"];
  bool has_sensor_name() const;
  private:
  bool _internal_has_sensor_name() const;
  public:
  void clear_sensor_name();
  const ::viam::common::v1::ResourceName& sensor_name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_sensor_name();
  ::viam::common::v1::ResourceName* mutable_sensor_name();
  void set_allocated_sensor_name(::viam::common::v1::ResourceName* sensor_name);
  private:
  const ::viam::common::v1::ResourceName& _internal_sensor_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_sensor_name();
  public:
  void unsafe_arena_set_allocated_sensor_name(
      ::viam::common::v1::ResourceName* sensor_name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_sensor_name();

  // @@protoc_insertion_point(class_scope:viam.app.v1.MaintenanceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_allowed_key_;
  ::viam::common::v1::ResourceName* sensor_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fv1_2frobot_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotConfig

// .viam.app.v1.CloudConfig cloud = 1 [json_name = "cloud"];
inline bool RobotConfig::_internal_has_cloud() const {
  return this != internal_default_instance() && cloud_ != nullptr;
}
inline bool RobotConfig::has_cloud() const {
  return _internal_has_cloud();
}
inline void RobotConfig::clear_cloud() {
  if (GetArenaForAllocation() == nullptr && cloud_ != nullptr) {
    delete cloud_;
  }
  cloud_ = nullptr;
}
inline const ::viam::app::v1::CloudConfig& RobotConfig::_internal_cloud() const {
  const ::viam::app::v1::CloudConfig* p = cloud_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::CloudConfig&>(
      ::viam::app::v1::_CloudConfig_default_instance_);
}
inline const ::viam::app::v1::CloudConfig& RobotConfig::cloud() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.cloud)
  return _internal_cloud();
}
inline void RobotConfig::unsafe_arena_set_allocated_cloud(
    ::viam::app::v1::CloudConfig* cloud) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cloud_);
  }
  cloud_ = cloud;
  if (cloud) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotConfig.cloud)
}
inline ::viam::app::v1::CloudConfig* RobotConfig::release_cloud() {
  
  ::viam::app::v1::CloudConfig* temp = cloud_;
  cloud_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::CloudConfig* RobotConfig::unsafe_arena_release_cloud() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.cloud)
  
  ::viam::app::v1::CloudConfig* temp = cloud_;
  cloud_ = nullptr;
  return temp;
}
inline ::viam::app::v1::CloudConfig* RobotConfig::_internal_mutable_cloud() {
  
  if (cloud_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::CloudConfig>(GetArenaForAllocation());
    cloud_ = p;
  }
  return cloud_;
}
inline ::viam::app::v1::CloudConfig* RobotConfig::mutable_cloud() {
  ::viam::app::v1::CloudConfig* _msg = _internal_mutable_cloud();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.cloud)
  return _msg;
}
inline void RobotConfig::set_allocated_cloud(::viam::app::v1::CloudConfig* cloud) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cloud_;
  }
  if (cloud) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cloud);
    if (message_arena != submessage_arena) {
      cloud = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cloud, submessage_arena);
    }
    
  } else {
    
  }
  cloud_ = cloud;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.cloud)
}

// repeated .viam.app.v1.RemoteConfig remotes = 2 [json_name = "remotes"];
inline int RobotConfig::_internal_remotes_size() const {
  return remotes_.size();
}
inline int RobotConfig::remotes_size() const {
  return _internal_remotes_size();
}
inline void RobotConfig::clear_remotes() {
  remotes_.Clear();
}
inline ::viam::app::v1::RemoteConfig* RobotConfig::mutable_remotes(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.remotes)
  return remotes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RemoteConfig >*
RobotConfig::mutable_remotes() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.remotes)
  return &remotes_;
}
inline const ::viam::app::v1::RemoteConfig& RobotConfig::_internal_remotes(int index) const {
  return remotes_.Get(index);
}
inline const ::viam::app::v1::RemoteConfig& RobotConfig::remotes(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.remotes)
  return _internal_remotes(index);
}
inline ::viam::app::v1::RemoteConfig* RobotConfig::_internal_add_remotes() {
  return remotes_.Add();
}
inline ::viam::app::v1::RemoteConfig* RobotConfig::add_remotes() {
  ::viam::app::v1::RemoteConfig* _add = _internal_add_remotes();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.remotes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RemoteConfig >&
RobotConfig::remotes() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.remotes)
  return remotes_;
}

// repeated .viam.app.v1.ComponentConfig components = 3 [json_name = "components"];
inline int RobotConfig::_internal_components_size() const {
  return components_.size();
}
inline int RobotConfig::components_size() const {
  return _internal_components_size();
}
inline void RobotConfig::clear_components() {
  components_.Clear();
}
inline ::viam::app::v1::ComponentConfig* RobotConfig::mutable_components(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.components)
  return components_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ComponentConfig >*
RobotConfig::mutable_components() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.components)
  return &components_;
}
inline const ::viam::app::v1::ComponentConfig& RobotConfig::_internal_components(int index) const {
  return components_.Get(index);
}
inline const ::viam::app::v1::ComponentConfig& RobotConfig::components(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.components)
  return _internal_components(index);
}
inline ::viam::app::v1::ComponentConfig* RobotConfig::_internal_add_components() {
  return components_.Add();
}
inline ::viam::app::v1::ComponentConfig* RobotConfig::add_components() {
  ::viam::app::v1::ComponentConfig* _add = _internal_add_components();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.components)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ComponentConfig >&
RobotConfig::components() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.components)
  return components_;
}

// repeated .viam.app.v1.ProcessConfig processes = 4 [json_name = "processes"];
inline int RobotConfig::_internal_processes_size() const {
  return processes_.size();
}
inline int RobotConfig::processes_size() const {
  return _internal_processes_size();
}
inline void RobotConfig::clear_processes() {
  processes_.Clear();
}
inline ::viam::app::v1::ProcessConfig* RobotConfig::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.processes)
  return processes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ProcessConfig >*
RobotConfig::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.processes)
  return &processes_;
}
inline const ::viam::app::v1::ProcessConfig& RobotConfig::_internal_processes(int index) const {
  return processes_.Get(index);
}
inline const ::viam::app::v1::ProcessConfig& RobotConfig::processes(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.processes)
  return _internal_processes(index);
}
inline ::viam::app::v1::ProcessConfig* RobotConfig::_internal_add_processes() {
  return processes_.Add();
}
inline ::viam::app::v1::ProcessConfig* RobotConfig::add_processes() {
  ::viam::app::v1::ProcessConfig* _add = _internal_add_processes();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.processes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ProcessConfig >&
RobotConfig::processes() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.processes)
  return processes_;
}

// repeated .viam.app.v1.ServiceConfig services = 5 [json_name = "services"];
inline int RobotConfig::_internal_services_size() const {
  return services_.size();
}
inline int RobotConfig::services_size() const {
  return _internal_services_size();
}
inline void RobotConfig::clear_services() {
  services_.Clear();
}
inline ::viam::app::v1::ServiceConfig* RobotConfig::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.services)
  return services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ServiceConfig >*
RobotConfig::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.services)
  return &services_;
}
inline const ::viam::app::v1::ServiceConfig& RobotConfig::_internal_services(int index) const {
  return services_.Get(index);
}
inline const ::viam::app::v1::ServiceConfig& RobotConfig::services(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.services)
  return _internal_services(index);
}
inline ::viam::app::v1::ServiceConfig* RobotConfig::_internal_add_services() {
  return services_.Add();
}
inline ::viam::app::v1::ServiceConfig* RobotConfig::add_services() {
  ::viam::app::v1::ServiceConfig* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ServiceConfig >&
RobotConfig::services() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.services)
  return services_;
}

// optional .viam.app.v1.NetworkConfig network = 6 [json_name = "network"];
inline bool RobotConfig::_internal_has_network() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || network_ != nullptr);
  return value;
}
inline bool RobotConfig::has_network() const {
  return _internal_has_network();
}
inline void RobotConfig::clear_network() {
  if (network_ != nullptr) network_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::NetworkConfig& RobotConfig::_internal_network() const {
  const ::viam::app::v1::NetworkConfig* p = network_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::NetworkConfig&>(
      ::viam::app::v1::_NetworkConfig_default_instance_);
}
inline const ::viam::app::v1::NetworkConfig& RobotConfig::network() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.network)
  return _internal_network();
}
inline void RobotConfig::unsafe_arena_set_allocated_network(
    ::viam::app::v1::NetworkConfig* network) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_);
  }
  network_ = network;
  if (network) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotConfig.network)
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::release_network() {
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::NetworkConfig* temp = network_;
  network_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::unsafe_arena_release_network() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.network)
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::NetworkConfig* temp = network_;
  network_ = nullptr;
  return temp;
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::_internal_mutable_network() {
  _has_bits_[0] |= 0x00000001u;
  if (network_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::NetworkConfig>(GetArenaForAllocation());
    network_ = p;
  }
  return network_;
}
inline ::viam::app::v1::NetworkConfig* RobotConfig::mutable_network() {
  ::viam::app::v1::NetworkConfig* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.network)
  return _msg;
}
inline void RobotConfig::set_allocated_network(::viam::app::v1::NetworkConfig* network) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete network_;
  }
  if (network) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network);
    if (message_arena != submessage_arena) {
      network = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_ = network;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.network)
}

// optional .viam.app.v1.AuthConfig auth = 7 [json_name = "auth"];
inline bool RobotConfig::_internal_has_auth() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || auth_ != nullptr);
  return value;
}
inline bool RobotConfig::has_auth() const {
  return _internal_has_auth();
}
inline void RobotConfig::clear_auth() {
  if (auth_ != nullptr) auth_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::viam::app::v1::AuthConfig& RobotConfig::_internal_auth() const {
  const ::viam::app::v1::AuthConfig* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AuthConfig&>(
      ::viam::app::v1::_AuthConfig_default_instance_);
}
inline const ::viam::app::v1::AuthConfig& RobotConfig::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.auth)
  return _internal_auth();
}
inline void RobotConfig::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::AuthConfig* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotConfig.auth)
}
inline ::viam::app::v1::AuthConfig* RobotConfig::release_auth() {
  _has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::AuthConfig* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::AuthConfig* RobotConfig::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.auth)
  _has_bits_[0] &= ~0x00000002u;
  ::viam::app::v1::AuthConfig* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AuthConfig* RobotConfig::_internal_mutable_auth() {
  _has_bits_[0] |= 0x00000002u;
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AuthConfig>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::AuthConfig* RobotConfig::mutable_auth() {
  ::viam::app::v1::AuthConfig* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.auth)
  return _msg;
}
inline void RobotConfig::set_allocated_auth(::viam::app::v1::AuthConfig* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.auth)
}

// optional bool debug = 8 [json_name = "debug"];
inline bool RobotConfig::_internal_has_debug() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RobotConfig::has_debug() const {
  return _internal_has_debug();
}
inline void RobotConfig::clear_debug() {
  debug_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RobotConfig::_internal_debug() const {
  return debug_;
}
inline bool RobotConfig::debug() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.debug)
  return _internal_debug();
}
inline void RobotConfig::_internal_set_debug(bool value) {
  _has_bits_[0] |= 0x00000008u;
  debug_ = value;
}
inline void RobotConfig::set_debug(bool value) {
  _internal_set_debug(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.debug)
}

// repeated .viam.app.v1.ModuleConfig modules = 9 [json_name = "modules"];
inline int RobotConfig::_internal_modules_size() const {
  return modules_.size();
}
inline int RobotConfig::modules_size() const {
  return _internal_modules_size();
}
inline void RobotConfig::clear_modules() {
  modules_.Clear();
}
inline ::viam::app::v1::ModuleConfig* RobotConfig::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.modules)
  return modules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleConfig >*
RobotConfig::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.modules)
  return &modules_;
}
inline const ::viam::app::v1::ModuleConfig& RobotConfig::_internal_modules(int index) const {
  return modules_.Get(index);
}
inline const ::viam::app::v1::ModuleConfig& RobotConfig::modules(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.modules)
  return _internal_modules(index);
}
inline ::viam::app::v1::ModuleConfig* RobotConfig::_internal_add_modules() {
  return modules_.Add();
}
inline ::viam::app::v1::ModuleConfig* RobotConfig::add_modules() {
  ::viam::app::v1::ModuleConfig* _add = _internal_add_modules();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.modules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ModuleConfig >&
RobotConfig::modules() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.modules)
  return modules_;
}

// optional bool disable_partial_start = 10 [json_name = "disablePartialStart"];
inline bool RobotConfig::_internal_has_disable_partial_start() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RobotConfig::has_disable_partial_start() const {
  return _internal_has_disable_partial_start();
}
inline void RobotConfig::clear_disable_partial_start() {
  disable_partial_start_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool RobotConfig::_internal_disable_partial_start() const {
  return disable_partial_start_;
}
inline bool RobotConfig::disable_partial_start() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.disable_partial_start)
  return _internal_disable_partial_start();
}
inline void RobotConfig::_internal_set_disable_partial_start(bool value) {
  _has_bits_[0] |= 0x00000010u;
  disable_partial_start_ = value;
}
inline void RobotConfig::set_disable_partial_start(bool value) {
  _internal_set_disable_partial_start(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.disable_partial_start)
}

// repeated .viam.app.v1.PackageConfig packages = 11 [json_name = "packages"];
inline int RobotConfig::_internal_packages_size() const {
  return packages_.size();
}
inline int RobotConfig::packages_size() const {
  return _internal_packages_size();
}
inline void RobotConfig::clear_packages() {
  packages_.Clear();
}
inline ::viam::app::v1::PackageConfig* RobotConfig::mutable_packages(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.packages)
  return packages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PackageConfig >*
RobotConfig::mutable_packages() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.packages)
  return &packages_;
}
inline const ::viam::app::v1::PackageConfig& RobotConfig::_internal_packages(int index) const {
  return packages_.Get(index);
}
inline const ::viam::app::v1::PackageConfig& RobotConfig::packages(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.packages)
  return _internal_packages(index);
}
inline ::viam::app::v1::PackageConfig* RobotConfig::_internal_add_packages() {
  return packages_.Add();
}
inline ::viam::app::v1::PackageConfig* RobotConfig::add_packages() {
  ::viam::app::v1::PackageConfig* _add = _internal_add_packages();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.packages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::PackageConfig >&
RobotConfig::packages() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.packages)
  return packages_;
}

// repeated .viam.app.v1.AppValidationStatus overwrite_fragment_status = 12 [json_name = "overwriteFragmentStatus"];
inline int RobotConfig::_internal_overwrite_fragment_status_size() const {
  return overwrite_fragment_status_.size();
}
inline int RobotConfig::overwrite_fragment_status_size() const {
  return _internal_overwrite_fragment_status_size();
}
inline void RobotConfig::clear_overwrite_fragment_status() {
  overwrite_fragment_status_.Clear();
}
inline ::viam::app::v1::AppValidationStatus* RobotConfig::mutable_overwrite_fragment_status(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return overwrite_fragment_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AppValidationStatus >*
RobotConfig::mutable_overwrite_fragment_status() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return &overwrite_fragment_status_;
}
inline const ::viam::app::v1::AppValidationStatus& RobotConfig::_internal_overwrite_fragment_status(int index) const {
  return overwrite_fragment_status_.Get(index);
}
inline const ::viam::app::v1::AppValidationStatus& RobotConfig::overwrite_fragment_status(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return _internal_overwrite_fragment_status(index);
}
inline ::viam::app::v1::AppValidationStatus* RobotConfig::_internal_add_overwrite_fragment_status() {
  return overwrite_fragment_status_.Add();
}
inline ::viam::app::v1::AppValidationStatus* RobotConfig::add_overwrite_fragment_status() {
  ::viam::app::v1::AppValidationStatus* _add = _internal_add_overwrite_fragment_status();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AppValidationStatus >&
RobotConfig::overwrite_fragment_status() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.overwrite_fragment_status)
  return overwrite_fragment_status_;
}

// bool enable_web_profile = 13 [json_name = "enableWebProfile"];
inline void RobotConfig::clear_enable_web_profile() {
  enable_web_profile_ = false;
}
inline bool RobotConfig::_internal_enable_web_profile() const {
  return enable_web_profile_;
}
inline bool RobotConfig::enable_web_profile() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.enable_web_profile)
  return _internal_enable_web_profile();
}
inline void RobotConfig::_internal_set_enable_web_profile(bool value) {
  
  enable_web_profile_ = value;
}
inline void RobotConfig::set_enable_web_profile(bool value) {
  _internal_set_enable_web_profile(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.enable_web_profile)
}

// repeated .viam.app.v1.LogPatternConfig log = 14 [json_name = "log"];
inline int RobotConfig::_internal_log_size() const {
  return log_.size();
}
inline int RobotConfig::log_size() const {
  return _internal_log_size();
}
inline void RobotConfig::clear_log() {
  log_.Clear();
}
inline ::viam::app::v1::LogPatternConfig* RobotConfig::mutable_log(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.log)
  return log_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogPatternConfig >*
RobotConfig::mutable_log() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.log)
  return &log_;
}
inline const ::viam::app::v1::LogPatternConfig& RobotConfig::_internal_log(int index) const {
  return log_.Get(index);
}
inline const ::viam::app::v1::LogPatternConfig& RobotConfig::log(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.log)
  return _internal_log(index);
}
inline ::viam::app::v1::LogPatternConfig* RobotConfig::_internal_add_log() {
  return log_.Add();
}
inline ::viam::app::v1::LogPatternConfig* RobotConfig::add_log() {
  ::viam::app::v1::LogPatternConfig* _add = _internal_add_log();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.log)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogPatternConfig >&
RobotConfig::log() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.log)
  return log_;
}

// string revision = 15 [json_name = "revision"];
inline void RobotConfig::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& RobotConfig::revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotConfig::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.revision)
}
inline std::string* RobotConfig::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.revision)
  return _s;
}
inline const std::string& RobotConfig::_internal_revision() const {
  return revision_.Get();
}
inline void RobotConfig::_internal_set_revision(const std::string& value) {
  
  revision_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotConfig::_internal_mutable_revision() {
  
  return revision_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotConfig::release_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.revision)
  return revision_.Release();
}
inline void RobotConfig::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault()) {
    revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.revision)
}

// optional .viam.app.v1.MaintenanceConfig maintenance = 16 [json_name = "maintenance"];
inline bool RobotConfig::_internal_has_maintenance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || maintenance_ != nullptr);
  return value;
}
inline bool RobotConfig::has_maintenance() const {
  return _internal_has_maintenance();
}
inline void RobotConfig::clear_maintenance() {
  if (maintenance_ != nullptr) maintenance_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::viam::app::v1::MaintenanceConfig& RobotConfig::_internal_maintenance() const {
  const ::viam::app::v1::MaintenanceConfig* p = maintenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::MaintenanceConfig&>(
      ::viam::app::v1::_MaintenanceConfig_default_instance_);
}
inline const ::viam::app::v1::MaintenanceConfig& RobotConfig::maintenance() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.maintenance)
  return _internal_maintenance();
}
inline void RobotConfig::unsafe_arena_set_allocated_maintenance(
    ::viam::app::v1::MaintenanceConfig* maintenance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maintenance_);
  }
  maintenance_ = maintenance;
  if (maintenance) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotConfig.maintenance)
}
inline ::viam::app::v1::MaintenanceConfig* RobotConfig::release_maintenance() {
  _has_bits_[0] &= ~0x00000004u;
  ::viam::app::v1::MaintenanceConfig* temp = maintenance_;
  maintenance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::MaintenanceConfig* RobotConfig::unsafe_arena_release_maintenance() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotConfig.maintenance)
  _has_bits_[0] &= ~0x00000004u;
  ::viam::app::v1::MaintenanceConfig* temp = maintenance_;
  maintenance_ = nullptr;
  return temp;
}
inline ::viam::app::v1::MaintenanceConfig* RobotConfig::_internal_mutable_maintenance() {
  _has_bits_[0] |= 0x00000004u;
  if (maintenance_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::MaintenanceConfig>(GetArenaForAllocation());
    maintenance_ = p;
  }
  return maintenance_;
}
inline ::viam::app::v1::MaintenanceConfig* RobotConfig::mutable_maintenance() {
  ::viam::app::v1::MaintenanceConfig* _msg = _internal_mutable_maintenance();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.maintenance)
  return _msg;
}
inline void RobotConfig::set_allocated_maintenance(::viam::app::v1::MaintenanceConfig* maintenance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete maintenance_;
  }
  if (maintenance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maintenance);
    if (message_arena != submessage_arena) {
      maintenance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maintenance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  maintenance_ = maintenance;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotConfig.maintenance)
}

// bool disable_log_deduplication = 17 [json_name = "disableLogDeduplication"];
inline void RobotConfig::clear_disable_log_deduplication() {
  disable_log_deduplication_ = false;
}
inline bool RobotConfig::_internal_disable_log_deduplication() const {
  return disable_log_deduplication_;
}
inline bool RobotConfig::disable_log_deduplication() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.disable_log_deduplication)
  return _internal_disable_log_deduplication();
}
inline void RobotConfig::_internal_set_disable_log_deduplication(bool value) {
  
  disable_log_deduplication_ = value;
}
inline void RobotConfig::set_disable_log_deduplication(bool value) {
  _internal_set_disable_log_deduplication(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotConfig.disable_log_deduplication)
}

// repeated .viam.app.v1.JobConfig jobs = 18 [json_name = "jobs"];
inline int RobotConfig::_internal_jobs_size() const {
  return jobs_.size();
}
inline int RobotConfig::jobs_size() const {
  return _internal_jobs_size();
}
inline void RobotConfig::clear_jobs() {
  jobs_.Clear();
}
inline ::viam::app::v1::JobConfig* RobotConfig::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotConfig.jobs)
  return jobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::JobConfig >*
RobotConfig::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotConfig.jobs)
  return &jobs_;
}
inline const ::viam::app::v1::JobConfig& RobotConfig::_internal_jobs(int index) const {
  return jobs_.Get(index);
}
inline const ::viam::app::v1::JobConfig& RobotConfig::jobs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotConfig.jobs)
  return _internal_jobs(index);
}
inline ::viam::app::v1::JobConfig* RobotConfig::_internal_add_jobs() {
  return jobs_.Add();
}
inline ::viam::app::v1::JobConfig* RobotConfig::add_jobs() {
  ::viam::app::v1::JobConfig* _add = _internal_add_jobs();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotConfig.jobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::JobConfig >&
RobotConfig::jobs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotConfig.jobs)
  return jobs_;
}

// -------------------------------------------------------------------

// LogPatternConfig

// string pattern = 1 [json_name = "pattern"];
inline void LogPatternConfig::clear_pattern() {
  pattern_.ClearToEmpty();
}
inline const std::string& LogPatternConfig::pattern() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogPatternConfig.pattern)
  return _internal_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogPatternConfig::set_pattern(ArgT0&& arg0, ArgT... args) {
 
 pattern_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogPatternConfig.pattern)
}
inline std::string* LogPatternConfig::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogPatternConfig.pattern)
  return _s;
}
inline const std::string& LogPatternConfig::_internal_pattern() const {
  return pattern_.Get();
}
inline void LogPatternConfig::_internal_set_pattern(const std::string& value) {
  
  pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* LogPatternConfig::_internal_mutable_pattern() {
  
  return pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* LogPatternConfig::release_pattern() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogPatternConfig.pattern)
  return pattern_.Release();
}
inline void LogPatternConfig::set_allocated_pattern(std::string* pattern) {
  if (pattern != nullptr) {
    
  } else {
    
  }
  pattern_.SetAllocated(pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pattern_.IsDefault()) {
    pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogPatternConfig.pattern)
}

// string level = 2 [json_name = "level"];
inline void LogPatternConfig::clear_level() {
  level_.ClearToEmpty();
}
inline const std::string& LogPatternConfig::level() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogPatternConfig.level)
  return _internal_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogPatternConfig::set_level(ArgT0&& arg0, ArgT... args) {
 
 level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogPatternConfig.level)
}
inline std::string* LogPatternConfig::mutable_level() {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogPatternConfig.level)
  return _s;
}
inline const std::string& LogPatternConfig::_internal_level() const {
  return level_.Get();
}
inline void LogPatternConfig::_internal_set_level(const std::string& value) {
  
  level_.Set(value, GetArenaForAllocation());
}
inline std::string* LogPatternConfig::_internal_mutable_level() {
  
  return level_.Mutable(GetArenaForAllocation());
}
inline std::string* LogPatternConfig::release_level() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogPatternConfig.level)
  return level_.Release();
}
inline void LogPatternConfig::set_allocated_level(std::string* level) {
  if (level != nullptr) {
    
  } else {
    
  }
  level_.SetAllocated(level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (level_.IsDefault()) {
    level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogPatternConfig.level)
}

// -------------------------------------------------------------------

// JobConfig

// string name = 1 [json_name = "name"];
inline void JobConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& JobConfig::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.JobConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.JobConfig.name)
}
inline std::string* JobConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.JobConfig.name)
  return _s;
}
inline const std::string& JobConfig::_internal_name() const {
  return name_.Get();
}
inline void JobConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* JobConfig::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* JobConfig::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.JobConfig.name)
  return name_.Release();
}
inline void JobConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.JobConfig.name)
}

// string schedule = 2 [json_name = "schedule"];
inline void JobConfig::clear_schedule() {
  schedule_.ClearToEmpty();
}
inline const std::string& JobConfig::schedule() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.JobConfig.schedule)
  return _internal_schedule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobConfig::set_schedule(ArgT0&& arg0, ArgT... args) {
 
 schedule_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.JobConfig.schedule)
}
inline std::string* JobConfig::mutable_schedule() {
  std::string* _s = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.JobConfig.schedule)
  return _s;
}
inline const std::string& JobConfig::_internal_schedule() const {
  return schedule_.Get();
}
inline void JobConfig::_internal_set_schedule(const std::string& value) {
  
  schedule_.Set(value, GetArenaForAllocation());
}
inline std::string* JobConfig::_internal_mutable_schedule() {
  
  return schedule_.Mutable(GetArenaForAllocation());
}
inline std::string* JobConfig::release_schedule() {
  // @@protoc_insertion_point(field_release:viam.app.v1.JobConfig.schedule)
  return schedule_.Release();
}
inline void JobConfig::set_allocated_schedule(std::string* schedule) {
  if (schedule != nullptr) {
    
  } else {
    
  }
  schedule_.SetAllocated(schedule, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schedule_.IsDefault()) {
    schedule_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.JobConfig.schedule)
}

// string resource = 3 [json_name = "resource"];
inline void JobConfig::clear_resource() {
  resource_.ClearToEmpty();
}
inline const std::string& JobConfig::resource() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.JobConfig.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobConfig::set_resource(ArgT0&& arg0, ArgT... args) {
 
 resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.JobConfig.resource)
}
inline std::string* JobConfig::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.JobConfig.resource)
  return _s;
}
inline const std::string& JobConfig::_internal_resource() const {
  return resource_.Get();
}
inline void JobConfig::_internal_set_resource(const std::string& value) {
  
  resource_.Set(value, GetArenaForAllocation());
}
inline std::string* JobConfig::_internal_mutable_resource() {
  
  return resource_.Mutable(GetArenaForAllocation());
}
inline std::string* JobConfig::release_resource() {
  // @@protoc_insertion_point(field_release:viam.app.v1.JobConfig.resource)
  return resource_.Release();
}
inline void JobConfig::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_.IsDefault()) {
    resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.JobConfig.resource)
}

// string method = 4 [json_name = "method"];
inline void JobConfig::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& JobConfig::method() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.JobConfig.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobConfig::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.JobConfig.method)
}
inline std::string* JobConfig::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.JobConfig.method)
  return _s;
}
inline const std::string& JobConfig::_internal_method() const {
  return method_.Get();
}
inline void JobConfig::_internal_set_method(const std::string& value) {
  
  method_.Set(value, GetArenaForAllocation());
}
inline std::string* JobConfig::_internal_mutable_method() {
  
  return method_.Mutable(GetArenaForAllocation());
}
inline std::string* JobConfig::release_method() {
  // @@protoc_insertion_point(field_release:viam.app.v1.JobConfig.method)
  return method_.Release();
}
inline void JobConfig::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault()) {
    method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.JobConfig.method)
}

// .google.protobuf.Struct command = 5 [json_name = "command"];
inline bool JobConfig::_internal_has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline bool JobConfig::has_command() const {
  return _internal_has_command();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& JobConfig::_internal_command() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = command_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& JobConfig::command() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.JobConfig.command)
  return _internal_command();
}
inline void JobConfig::unsafe_arena_set_allocated_command(
    ::PROTOBUF_NAMESPACE_ID::Struct* command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.JobConfig.command)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobConfig::release_command() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = command_;
  command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobConfig::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:viam.app.v1.JobConfig.command)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobConfig::_internal_mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    command_ = p;
  }
  return command_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobConfig::mutable_command() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.JobConfig.command)
  return _msg;
}
inline void JobConfig::set_allocated_command(::PROTOBUF_NAMESPACE_ID::Struct* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command));
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.JobConfig.command)
}

// -------------------------------------------------------------------

// LocationSecret

// string id = 1 [json_name = "id"];
inline void LocationSecret::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& LocationSecret::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationSecret.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationSecret::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationSecret.id)
}
inline std::string* LocationSecret::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationSecret.id)
  return _s;
}
inline const std::string& LocationSecret::_internal_id() const {
  return id_.Get();
}
inline void LocationSecret::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationSecret::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationSecret::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationSecret.id)
  return id_.Release();
}
inline void LocationSecret::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationSecret.id)
}

// string secret = 2 [json_name = "secret"];
inline void LocationSecret::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& LocationSecret::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationSecret.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationSecret::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationSecret.secret)
}
inline std::string* LocationSecret::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationSecret.secret)
  return _s;
}
inline const std::string& LocationSecret::_internal_secret() const {
  return secret_.Get();
}
inline void LocationSecret::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationSecret::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationSecret::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationSecret.secret)
  return secret_.Release();
}
inline void LocationSecret::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationSecret.secret)
}

// -------------------------------------------------------------------

// AppValidationStatus

// string error = 1 [json_name = "error"];
inline void AppValidationStatus::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& AppValidationStatus::error() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AppValidationStatus.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppValidationStatus::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AppValidationStatus.error)
}
inline std::string* AppValidationStatus::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AppValidationStatus.error)
  return _s;
}
inline const std::string& AppValidationStatus::_internal_error() const {
  return error_.Get();
}
inline void AppValidationStatus::_internal_set_error(const std::string& value) {
  
  error_.Set(value, GetArenaForAllocation());
}
inline std::string* AppValidationStatus::_internal_mutable_error() {
  
  return error_.Mutable(GetArenaForAllocation());
}
inline std::string* AppValidationStatus::release_error() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AppValidationStatus.error)
  return error_.Release();
}
inline void AppValidationStatus::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault()) {
    error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AppValidationStatus.error)
}

// -------------------------------------------------------------------

// CloudConfig

// string id = 1 [json_name = "id"];
inline void CloudConfig::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CloudConfig::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.id)
}
inline std::string* CloudConfig::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.id)
  return _s;
}
inline const std::string& CloudConfig::_internal_id() const {
  return id_.Get();
}
inline void CloudConfig::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.id)
  return id_.Release();
}
inline void CloudConfig::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.id)
}

// string fqdn = 2 [json_name = "fqdn"];
inline void CloudConfig::clear_fqdn() {
  fqdn_.ClearToEmpty();
}
inline const std::string& CloudConfig::fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.fqdn)
  return _internal_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_fqdn(ArgT0&& arg0, ArgT... args) {
 
 fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.fqdn)
}
inline std::string* CloudConfig::mutable_fqdn() {
  std::string* _s = _internal_mutable_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.fqdn)
  return _s;
}
inline const std::string& CloudConfig::_internal_fqdn() const {
  return fqdn_.Get();
}
inline void CloudConfig::_internal_set_fqdn(const std::string& value) {
  
  fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_fqdn() {
  
  return fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.fqdn)
  return fqdn_.Release();
}
inline void CloudConfig::set_allocated_fqdn(std::string* fqdn) {
  if (fqdn != nullptr) {
    
  } else {
    
  }
  fqdn_.SetAllocated(fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fqdn_.IsDefault()) {
    fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.fqdn)
}

// string local_fqdn = 3 [json_name = "localFqdn"];
inline void CloudConfig::clear_local_fqdn() {
  local_fqdn_.ClearToEmpty();
}
inline const std::string& CloudConfig::local_fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.local_fqdn)
  return _internal_local_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_local_fqdn(ArgT0&& arg0, ArgT... args) {
 
 local_fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.local_fqdn)
}
inline std::string* CloudConfig::mutable_local_fqdn() {
  std::string* _s = _internal_mutable_local_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.local_fqdn)
  return _s;
}
inline const std::string& CloudConfig::_internal_local_fqdn() const {
  return local_fqdn_.Get();
}
inline void CloudConfig::_internal_set_local_fqdn(const std::string& value) {
  
  local_fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_local_fqdn() {
  
  return local_fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_local_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.local_fqdn)
  return local_fqdn_.Release();
}
inline void CloudConfig::set_allocated_local_fqdn(std::string* local_fqdn) {
  if (local_fqdn != nullptr) {
    
  } else {
    
  }
  local_fqdn_.SetAllocated(local_fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (local_fqdn_.IsDefault()) {
    local_fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.local_fqdn)
}

// string managed_by = 4 [json_name = "managedBy"];
inline void CloudConfig::clear_managed_by() {
  managed_by_.ClearToEmpty();
}
inline const std::string& CloudConfig::managed_by() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.managed_by)
  return _internal_managed_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_managed_by(ArgT0&& arg0, ArgT... args) {
 
 managed_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.managed_by)
}
inline std::string* CloudConfig::mutable_managed_by() {
  std::string* _s = _internal_mutable_managed_by();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.managed_by)
  return _s;
}
inline const std::string& CloudConfig::_internal_managed_by() const {
  return managed_by_.Get();
}
inline void CloudConfig::_internal_set_managed_by(const std::string& value) {
  
  managed_by_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_managed_by() {
  
  return managed_by_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_managed_by() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.managed_by)
  return managed_by_.Release();
}
inline void CloudConfig::set_allocated_managed_by(std::string* managed_by) {
  if (managed_by != nullptr) {
    
  } else {
    
  }
  managed_by_.SetAllocated(managed_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (managed_by_.IsDefault()) {
    managed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.managed_by)
}

// string signaling_address = 5 [json_name = "signalingAddress"];
inline void CloudConfig::clear_signaling_address() {
  signaling_address_.ClearToEmpty();
}
inline const std::string& CloudConfig::signaling_address() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.signaling_address)
  return _internal_signaling_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_signaling_address(ArgT0&& arg0, ArgT... args) {
 
 signaling_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.signaling_address)
}
inline std::string* CloudConfig::mutable_signaling_address() {
  std::string* _s = _internal_mutable_signaling_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.signaling_address)
  return _s;
}
inline const std::string& CloudConfig::_internal_signaling_address() const {
  return signaling_address_.Get();
}
inline void CloudConfig::_internal_set_signaling_address(const std::string& value) {
  
  signaling_address_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_signaling_address() {
  
  return signaling_address_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_signaling_address() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.signaling_address)
  return signaling_address_.Release();
}
inline void CloudConfig::set_allocated_signaling_address(std::string* signaling_address) {
  if (signaling_address != nullptr) {
    
  } else {
    
  }
  signaling_address_.SetAllocated(signaling_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signaling_address_.IsDefault()) {
    signaling_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.signaling_address)
}

// bool signaling_insecure = 6 [json_name = "signalingInsecure"];
inline void CloudConfig::clear_signaling_insecure() {
  signaling_insecure_ = false;
}
inline bool CloudConfig::_internal_signaling_insecure() const {
  return signaling_insecure_;
}
inline bool CloudConfig::signaling_insecure() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.signaling_insecure)
  return _internal_signaling_insecure();
}
inline void CloudConfig::_internal_set_signaling_insecure(bool value) {
  
  signaling_insecure_ = value;
}
inline void CloudConfig::set_signaling_insecure(bool value) {
  _internal_set_signaling_insecure(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.signaling_insecure)
}

// string location_secret = 7 [json_name = "locationSecret", deprecated = true];
inline void CloudConfig::clear_location_secret() {
  location_secret_.ClearToEmpty();
}
inline const std::string& CloudConfig::location_secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.location_secret)
  return _internal_location_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_location_secret(ArgT0&& arg0, ArgT... args) {
 
 location_secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.location_secret)
}
inline std::string* CloudConfig::mutable_location_secret() {
  std::string* _s = _internal_mutable_location_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.location_secret)
  return _s;
}
inline const std::string& CloudConfig::_internal_location_secret() const {
  return location_secret_.Get();
}
inline void CloudConfig::_internal_set_location_secret(const std::string& value) {
  
  location_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_location_secret() {
  
  return location_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_location_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.location_secret)
  return location_secret_.Release();
}
inline void CloudConfig::set_allocated_location_secret(std::string* location_secret) {
  if (location_secret != nullptr) {
    
  } else {
    
  }
  location_secret_.SetAllocated(location_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_secret_.IsDefault()) {
    location_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.location_secret)
}

// string secret = 8 [json_name = "secret"];
inline void CloudConfig::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& CloudConfig::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.secret)
}
inline std::string* CloudConfig::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.secret)
  return _s;
}
inline const std::string& CloudConfig::_internal_secret() const {
  return secret_.Get();
}
inline void CloudConfig::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.secret)
  return secret_.Release();
}
inline void CloudConfig::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.secret)
}

// repeated .viam.app.v1.LocationSecret location_secrets = 9 [json_name = "locationSecrets"];
inline int CloudConfig::_internal_location_secrets_size() const {
  return location_secrets_.size();
}
inline int CloudConfig::location_secrets_size() const {
  return _internal_location_secrets_size();
}
inline void CloudConfig::clear_location_secrets() {
  location_secrets_.Clear();
}
inline ::viam::app::v1::LocationSecret* CloudConfig::mutable_location_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.location_secrets)
  return location_secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSecret >*
CloudConfig::mutable_location_secrets() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.CloudConfig.location_secrets)
  return &location_secrets_;
}
inline const ::viam::app::v1::LocationSecret& CloudConfig::_internal_location_secrets(int index) const {
  return location_secrets_.Get(index);
}
inline const ::viam::app::v1::LocationSecret& CloudConfig::location_secrets(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.location_secrets)
  return _internal_location_secrets(index);
}
inline ::viam::app::v1::LocationSecret* CloudConfig::_internal_add_location_secrets() {
  return location_secrets_.Add();
}
inline ::viam::app::v1::LocationSecret* CloudConfig::add_location_secrets() {
  ::viam::app::v1::LocationSecret* _add = _internal_add_location_secrets();
  // @@protoc_insertion_point(field_add:viam.app.v1.CloudConfig.location_secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LocationSecret >&
CloudConfig::location_secrets() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.CloudConfig.location_secrets)
  return location_secrets_;
}

// string primary_org_id = 10 [json_name = "primaryOrgId"];
inline void CloudConfig::clear_primary_org_id() {
  primary_org_id_.ClearToEmpty();
}
inline const std::string& CloudConfig::primary_org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.primary_org_id)
  return _internal_primary_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_primary_org_id(ArgT0&& arg0, ArgT... args) {
 
 primary_org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.primary_org_id)
}
inline std::string* CloudConfig::mutable_primary_org_id() {
  std::string* _s = _internal_mutable_primary_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.primary_org_id)
  return _s;
}
inline const std::string& CloudConfig::_internal_primary_org_id() const {
  return primary_org_id_.Get();
}
inline void CloudConfig::_internal_set_primary_org_id(const std::string& value) {
  
  primary_org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_primary_org_id() {
  
  return primary_org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_primary_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.primary_org_id)
  return primary_org_id_.Release();
}
inline void CloudConfig::set_allocated_primary_org_id(std::string* primary_org_id) {
  if (primary_org_id != nullptr) {
    
  } else {
    
  }
  primary_org_id_.SetAllocated(primary_org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (primary_org_id_.IsDefault()) {
    primary_org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.primary_org_id)
}

// string location_id = 11 [json_name = "locationId"];
inline void CloudConfig::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& CloudConfig::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.location_id)
}
inline std::string* CloudConfig::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.location_id)
  return _s;
}
inline const std::string& CloudConfig::_internal_location_id() const {
  return location_id_.Get();
}
inline void CloudConfig::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.location_id)
  return location_id_.Release();
}
inline void CloudConfig::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.location_id)
}

// string machine_id = 12 [json_name = "machineId"];
inline void CloudConfig::clear_machine_id() {
  machine_id_.ClearToEmpty();
}
inline const std::string& CloudConfig::machine_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CloudConfig.machine_id)
  return _internal_machine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudConfig::set_machine_id(ArgT0&& arg0, ArgT... args) {
 
 machine_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CloudConfig.machine_id)
}
inline std::string* CloudConfig::mutable_machine_id() {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CloudConfig.machine_id)
  return _s;
}
inline const std::string& CloudConfig::_internal_machine_id() const {
  return machine_id_.Get();
}
inline void CloudConfig::_internal_set_machine_id(const std::string& value) {
  
  machine_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudConfig::_internal_mutable_machine_id() {
  
  return machine_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudConfig::release_machine_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CloudConfig.machine_id)
  return machine_id_.Release();
}
inline void CloudConfig::set_allocated_machine_id(std::string* machine_id) {
  if (machine_id != nullptr) {
    
  } else {
    
  }
  machine_id_.SetAllocated(machine_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (machine_id_.IsDefault()) {
    machine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CloudConfig.machine_id)
}

// -------------------------------------------------------------------

// ComponentConfig

// string name = 1 [json_name = "name"];
inline void ComponentConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ComponentConfig::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComponentConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.name)
}
inline std::string* ComponentConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.name)
  return _s;
}
inline const std::string& ComponentConfig::_internal_name() const {
  return name_.Get();
}
inline void ComponentConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ComponentConfig::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ComponentConfig::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.name)
  return name_.Release();
}
inline void ComponentConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.name)
}

// string namespace = 2 [json_name = "namespace"];
inline void ComponentConfig::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& ComponentConfig::namespace_() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComponentConfig::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.namespace)
}
inline std::string* ComponentConfig::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.namespace)
  return _s;
}
inline const std::string& ComponentConfig::_internal_namespace_() const {
  return namespace__.Get();
}
inline void ComponentConfig::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* ComponentConfig::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* ComponentConfig::release_namespace_() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.namespace)
  return namespace__.Release();
}
inline void ComponentConfig::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault()) {
    namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.namespace)
}

// string type = 3 [json_name = "type"];
inline void ComponentConfig::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ComponentConfig::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComponentConfig::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.type)
}
inline std::string* ComponentConfig::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.type)
  return _s;
}
inline const std::string& ComponentConfig::_internal_type() const {
  return type_.Get();
}
inline void ComponentConfig::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* ComponentConfig::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* ComponentConfig::release_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.type)
  return type_.Release();
}
inline void ComponentConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.type)
}

// string model = 4 [json_name = "model"];
inline void ComponentConfig::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& ComponentConfig::model() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComponentConfig::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.model)
}
inline std::string* ComponentConfig::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.model)
  return _s;
}
inline const std::string& ComponentConfig::_internal_model() const {
  return model_.Get();
}
inline void ComponentConfig::_internal_set_model(const std::string& value) {
  
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* ComponentConfig::_internal_mutable_model() {
  
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* ComponentConfig::release_model() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.model)
  return model_.Release();
}
inline void ComponentConfig::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.model)
}

// .viam.app.v1.Frame frame = 5 [json_name = "frame"];
inline bool ComponentConfig::_internal_has_frame() const {
  return this != internal_default_instance() && frame_ != nullptr;
}
inline bool ComponentConfig::has_frame() const {
  return _internal_has_frame();
}
inline void ComponentConfig::clear_frame() {
  if (GetArenaForAllocation() == nullptr && frame_ != nullptr) {
    delete frame_;
  }
  frame_ = nullptr;
}
inline const ::viam::app::v1::Frame& ComponentConfig::_internal_frame() const {
  const ::viam::app::v1::Frame* p = frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Frame&>(
      ::viam::app::v1::_Frame_default_instance_);
}
inline const ::viam::app::v1::Frame& ComponentConfig::frame() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.frame)
  return _internal_frame();
}
inline void ComponentConfig::unsafe_arena_set_allocated_frame(
    ::viam::app::v1::Frame* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ComponentConfig.frame)
}
inline ::viam::app::v1::Frame* ComponentConfig::release_frame() {
  
  ::viam::app::v1::Frame* temp = frame_;
  frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Frame* ComponentConfig::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.frame)
  
  ::viam::app::v1::Frame* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Frame* ComponentConfig::_internal_mutable_frame() {
  
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Frame>(GetArenaForAllocation());
    frame_ = p;
  }
  return frame_;
}
inline ::viam::app::v1::Frame* ComponentConfig::mutable_frame() {
  ::viam::app::v1::Frame* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.frame)
  return _msg;
}
inline void ComponentConfig::set_allocated_frame(::viam::app::v1::Frame* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.frame)
}

// repeated string depends_on = 6 [json_name = "dependsOn"];
inline int ComponentConfig::_internal_depends_on_size() const {
  return depends_on_.size();
}
inline int ComponentConfig::depends_on_size() const {
  return _internal_depends_on_size();
}
inline void ComponentConfig::clear_depends_on() {
  depends_on_.Clear();
}
inline std::string* ComponentConfig::add_depends_on() {
  std::string* _s = _internal_add_depends_on();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ComponentConfig.depends_on)
  return _s;
}
inline const std::string& ComponentConfig::_internal_depends_on(int index) const {
  return depends_on_.Get(index);
}
inline const std::string& ComponentConfig::depends_on(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.depends_on)
  return _internal_depends_on(index);
}
inline std::string* ComponentConfig::mutable_depends_on(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.depends_on)
  return depends_on_.Mutable(index);
}
inline void ComponentConfig::set_depends_on(int index, const std::string& value) {
  depends_on_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::set_depends_on(int index, std::string&& value) {
  depends_on_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::set_depends_on(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  depends_on_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::set_depends_on(int index, const char* value, size_t size) {
  depends_on_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ComponentConfig.depends_on)
}
inline std::string* ComponentConfig::_internal_add_depends_on() {
  return depends_on_.Add();
}
inline void ComponentConfig::add_depends_on(const std::string& value) {
  depends_on_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(std::string&& value) {
  depends_on_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  depends_on_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ComponentConfig.depends_on)
}
inline void ComponentConfig::add_depends_on(const char* value, size_t size) {
  depends_on_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ComponentConfig.depends_on)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ComponentConfig::depends_on() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ComponentConfig.depends_on)
  return depends_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ComponentConfig::mutable_depends_on() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ComponentConfig.depends_on)
  return &depends_on_;
}

// repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 7 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
inline int ComponentConfig::_internal_service_configs_size() const {
  return service_configs_.size();
}
inline int ComponentConfig::service_configs_size() const {
  return _internal_service_configs_size();
}
inline void ComponentConfig::clear_service_configs() {
  service_configs_.Clear();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ComponentConfig::mutable_service_configs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.service_configs)
  return service_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
ComponentConfig::mutable_service_configs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ComponentConfig.service_configs)
  return &service_configs_;
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& ComponentConfig::_internal_service_configs(int index) const {
  return service_configs_.Get(index);
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& ComponentConfig::service_configs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.service_configs)
  return _internal_service_configs(index);
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ComponentConfig::_internal_add_service_configs() {
  return service_configs_.Add();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ComponentConfig::add_service_configs() {
  ::viam::app::v1::ResourceLevelServiceConfig* _add = _internal_add_service_configs();
  // @@protoc_insertion_point(field_add:viam.app.v1.ComponentConfig.service_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
ComponentConfig::service_configs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ComponentConfig.service_configs)
  return service_configs_;
}

// .google.protobuf.Struct attributes = 8 [json_name = "attributes"];
inline bool ComponentConfig::_internal_has_attributes() const {
  return this != internal_default_instance() && attributes_ != nullptr;
}
inline bool ComponentConfig::has_attributes() const {
  return _internal_has_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ComponentConfig::_internal_attributes() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ComponentConfig::attributes() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.attributes)
  return _internal_attributes();
}
inline void ComponentConfig::unsafe_arena_set_allocated_attributes(
    ::PROTOBUF_NAMESPACE_ID::Struct* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ComponentConfig.attributes)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ComponentConfig::release_attributes() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ComponentConfig::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.attributes)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ComponentConfig::_internal_mutable_attributes() {
  
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ComponentConfig::mutable_attributes() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.attributes)
  return _msg;
}
inline void ComponentConfig::set_allocated_attributes(::PROTOBUF_NAMESPACE_ID::Struct* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes));
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.attributes)
}

// string api = 9 [json_name = "api"];
inline void ComponentConfig::clear_api() {
  api_.ClearToEmpty();
}
inline const std::string& ComponentConfig::api() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.api)
  return _internal_api();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComponentConfig::set_api(ArgT0&& arg0, ArgT... args) {
 
 api_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ComponentConfig.api)
}
inline std::string* ComponentConfig::mutable_api() {
  std::string* _s = _internal_mutable_api();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.api)
  return _s;
}
inline const std::string& ComponentConfig::_internal_api() const {
  return api_.Get();
}
inline void ComponentConfig::_internal_set_api(const std::string& value) {
  
  api_.Set(value, GetArenaForAllocation());
}
inline std::string* ComponentConfig::_internal_mutable_api() {
  
  return api_.Mutable(GetArenaForAllocation());
}
inline std::string* ComponentConfig::release_api() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.api)
  return api_.Release();
}
inline void ComponentConfig::set_allocated_api(std::string* api) {
  if (api != nullptr) {
    
  } else {
    
  }
  api_.SetAllocated(api, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_.IsDefault()) {
    api_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.api)
}

// .viam.app.v1.LogConfiguration log_configuration = 10 [json_name = "logConfiguration"];
inline bool ComponentConfig::_internal_has_log_configuration() const {
  return this != internal_default_instance() && log_configuration_ != nullptr;
}
inline bool ComponentConfig::has_log_configuration() const {
  return _internal_has_log_configuration();
}
inline void ComponentConfig::clear_log_configuration() {
  if (GetArenaForAllocation() == nullptr && log_configuration_ != nullptr) {
    delete log_configuration_;
  }
  log_configuration_ = nullptr;
}
inline const ::viam::app::v1::LogConfiguration& ComponentConfig::_internal_log_configuration() const {
  const ::viam::app::v1::LogConfiguration* p = log_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LogConfiguration&>(
      ::viam::app::v1::_LogConfiguration_default_instance_);
}
inline const ::viam::app::v1::LogConfiguration& ComponentConfig::log_configuration() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ComponentConfig.log_configuration)
  return _internal_log_configuration();
}
inline void ComponentConfig::unsafe_arena_set_allocated_log_configuration(
    ::viam::app::v1::LogConfiguration* log_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_configuration_);
  }
  log_configuration_ = log_configuration;
  if (log_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ComponentConfig.log_configuration)
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::release_log_configuration() {
  
  ::viam::app::v1::LogConfiguration* temp = log_configuration_;
  log_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::unsafe_arena_release_log_configuration() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ComponentConfig.log_configuration)
  
  ::viam::app::v1::LogConfiguration* temp = log_configuration_;
  log_configuration_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::_internal_mutable_log_configuration() {
  
  if (log_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LogConfiguration>(GetArenaForAllocation());
    log_configuration_ = p;
  }
  return log_configuration_;
}
inline ::viam::app::v1::LogConfiguration* ComponentConfig::mutable_log_configuration() {
  ::viam::app::v1::LogConfiguration* _msg = _internal_mutable_log_configuration();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ComponentConfig.log_configuration)
  return _msg;
}
inline void ComponentConfig::set_allocated_log_configuration(::viam::app::v1::LogConfiguration* log_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete log_configuration_;
  }
  if (log_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log_configuration);
    if (message_arena != submessage_arena) {
      log_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_configuration, submessage_arena);
    }
    
  } else {
    
  }
  log_configuration_ = log_configuration;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ComponentConfig.log_configuration)
}

// -------------------------------------------------------------------

// ResourceLevelServiceConfig

// string type = 1 [json_name = "type"];
inline void ResourceLevelServiceConfig::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ResourceLevelServiceConfig::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResourceLevelServiceConfig.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceLevelServiceConfig::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ResourceLevelServiceConfig.type)
}
inline std::string* ResourceLevelServiceConfig::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResourceLevelServiceConfig.type)
  return _s;
}
inline const std::string& ResourceLevelServiceConfig::_internal_type() const {
  return type_.Get();
}
inline void ResourceLevelServiceConfig::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceLevelServiceConfig::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceLevelServiceConfig::release_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResourceLevelServiceConfig.type)
  return type_.Release();
}
inline void ResourceLevelServiceConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResourceLevelServiceConfig.type)
}

// .google.protobuf.Struct attributes = 2 [json_name = "attributes"];
inline bool ResourceLevelServiceConfig::_internal_has_attributes() const {
  return this != internal_default_instance() && attributes_ != nullptr;
}
inline bool ResourceLevelServiceConfig::has_attributes() const {
  return _internal_has_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ResourceLevelServiceConfig::_internal_attributes() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ResourceLevelServiceConfig::attributes() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ResourceLevelServiceConfig.attributes)
  return _internal_attributes();
}
inline void ResourceLevelServiceConfig::unsafe_arena_set_allocated_attributes(
    ::PROTOBUF_NAMESPACE_ID::Struct* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ResourceLevelServiceConfig.attributes)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceLevelServiceConfig::release_attributes() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceLevelServiceConfig::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ResourceLevelServiceConfig.attributes)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceLevelServiceConfig::_internal_mutable_attributes() {
  
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceLevelServiceConfig::mutable_attributes() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ResourceLevelServiceConfig.attributes)
  return _msg;
}
inline void ResourceLevelServiceConfig::set_allocated_attributes(::PROTOBUF_NAMESPACE_ID::Struct* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes));
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ResourceLevelServiceConfig.attributes)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessConfig

// string id = 1 [json_name = "id"];
inline void ProcessConfig::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ProcessConfig::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessConfig::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.id)
}
inline std::string* ProcessConfig::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.id)
  return _s;
}
inline const std::string& ProcessConfig::_internal_id() const {
  return id_.Get();
}
inline void ProcessConfig::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessConfig::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessConfig::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.id)
  return id_.Release();
}
inline void ProcessConfig::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.id)
}

// string name = 2 [json_name = "name"];
inline void ProcessConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ProcessConfig::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.name)
}
inline std::string* ProcessConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.name)
  return _s;
}
inline const std::string& ProcessConfig::_internal_name() const {
  return name_.Get();
}
inline void ProcessConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessConfig::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessConfig::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.name)
  return name_.Release();
}
inline void ProcessConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.name)
}

// repeated string args = 3 [json_name = "args"];
inline int ProcessConfig::_internal_args_size() const {
  return args_.size();
}
inline int ProcessConfig::args_size() const {
  return _internal_args_size();
}
inline void ProcessConfig::clear_args() {
  args_.Clear();
}
inline std::string* ProcessConfig::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ProcessConfig.args)
  return _s;
}
inline const std::string& ProcessConfig::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& ProcessConfig::args(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.args)
  return _internal_args(index);
}
inline std::string* ProcessConfig::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.args)
  return args_.Mutable(index);
}
inline void ProcessConfig::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ProcessConfig.args)
}
inline std::string* ProcessConfig::_internal_add_args() {
  return args_.Add();
}
inline void ProcessConfig::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ProcessConfig.args)
}
inline void ProcessConfig::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ProcessConfig.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessConfig::args() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ProcessConfig.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessConfig::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ProcessConfig.args)
  return &args_;
}

// string cwd = 4 [json_name = "cwd"];
inline void ProcessConfig::clear_cwd() {
  cwd_.ClearToEmpty();
}
inline const std::string& ProcessConfig::cwd() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.cwd)
  return _internal_cwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessConfig::set_cwd(ArgT0&& arg0, ArgT... args) {
 
 cwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.cwd)
}
inline std::string* ProcessConfig::mutable_cwd() {
  std::string* _s = _internal_mutable_cwd();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.cwd)
  return _s;
}
inline const std::string& ProcessConfig::_internal_cwd() const {
  return cwd_.Get();
}
inline void ProcessConfig::_internal_set_cwd(const std::string& value) {
  
  cwd_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessConfig::_internal_mutable_cwd() {
  
  return cwd_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessConfig::release_cwd() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.cwd)
  return cwd_.Release();
}
inline void ProcessConfig::set_allocated_cwd(std::string* cwd) {
  if (cwd != nullptr) {
    
  } else {
    
  }
  cwd_.SetAllocated(cwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cwd_.IsDefault()) {
    cwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.cwd)
}

// bool one_shot = 5 [json_name = "oneShot"];
inline void ProcessConfig::clear_one_shot() {
  one_shot_ = false;
}
inline bool ProcessConfig::_internal_one_shot() const {
  return one_shot_;
}
inline bool ProcessConfig::one_shot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.one_shot)
  return _internal_one_shot();
}
inline void ProcessConfig::_internal_set_one_shot(bool value) {
  
  one_shot_ = value;
}
inline void ProcessConfig::set_one_shot(bool value) {
  _internal_set_one_shot(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.one_shot)
}

// bool log = 6 [json_name = "log"];
inline void ProcessConfig::clear_log() {
  log_ = false;
}
inline bool ProcessConfig::_internal_log() const {
  return log_;
}
inline bool ProcessConfig::log() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.log)
  return _internal_log();
}
inline void ProcessConfig::_internal_set_log(bool value) {
  
  log_ = value;
}
inline void ProcessConfig::set_log(bool value) {
  _internal_set_log(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.log)
}

// int32 stop_signal = 7 [json_name = "stopSignal"];
inline void ProcessConfig::clear_stop_signal() {
  stop_signal_ = 0;
}
inline int32_t ProcessConfig::_internal_stop_signal() const {
  return stop_signal_;
}
inline int32_t ProcessConfig::stop_signal() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.stop_signal)
  return _internal_stop_signal();
}
inline void ProcessConfig::_internal_set_stop_signal(int32_t value) {
  
  stop_signal_ = value;
}
inline void ProcessConfig::set_stop_signal(int32_t value) {
  _internal_set_stop_signal(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.stop_signal)
}

// .google.protobuf.Duration stop_timeout = 8 [json_name = "stopTimeout"];
inline bool ProcessConfig::_internal_has_stop_timeout() const {
  return this != internal_default_instance() && stop_timeout_ != nullptr;
}
inline bool ProcessConfig::has_stop_timeout() const {
  return _internal_has_stop_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ProcessConfig::_internal_stop_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = stop_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ProcessConfig::stop_timeout() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.stop_timeout)
  return _internal_stop_timeout();
}
inline void ProcessConfig::unsafe_arena_set_allocated_stop_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* stop_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_timeout_);
  }
  stop_timeout_ = stop_timeout;
  if (stop_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ProcessConfig.stop_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ProcessConfig::release_stop_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = stop_timeout_;
  stop_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ProcessConfig::unsafe_arena_release_stop_timeout() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.stop_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = stop_timeout_;
  stop_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ProcessConfig::_internal_mutable_stop_timeout() {
  
  if (stop_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    stop_timeout_ = p;
  }
  return stop_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ProcessConfig::mutable_stop_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_stop_timeout();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.stop_timeout)
  return _msg;
}
inline void ProcessConfig::set_allocated_stop_timeout(::PROTOBUF_NAMESPACE_ID::Duration* stop_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_timeout_);
  }
  if (stop_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_timeout));
    if (message_arena != submessage_arena) {
      stop_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_timeout, submessage_arena);
    }
    
  } else {
    
  }
  stop_timeout_ = stop_timeout;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.stop_timeout)
}

// map<string, string> env = 9 [json_name = "env"];
inline int ProcessConfig::_internal_env_size() const {
  return env_.size();
}
inline int ProcessConfig::env_size() const {
  return _internal_env_size();
}
inline void ProcessConfig::clear_env() {
  env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessConfig::_internal_env() const {
  return env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessConfig::env() const {
  // @@protoc_insertion_point(field_map:viam.app.v1.ProcessConfig.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessConfig::_internal_mutable_env() {
  return env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessConfig::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.v1.ProcessConfig.env)
  return _internal_mutable_env();
}

// string username = 10 [json_name = "username"];
inline void ProcessConfig::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ProcessConfig::username() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ProcessConfig.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessConfig::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ProcessConfig.username)
}
inline std::string* ProcessConfig::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ProcessConfig.username)
  return _s;
}
inline const std::string& ProcessConfig::_internal_username() const {
  return username_.Get();
}
inline void ProcessConfig::_internal_set_username(const std::string& value) {
  
  username_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessConfig::_internal_mutable_username() {
  
  return username_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessConfig::release_username() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ProcessConfig.username)
  return username_.Release();
}
inline void ProcessConfig::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault()) {
    username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ProcessConfig.username)
}

// -------------------------------------------------------------------

// ServiceConfig

// string name = 1 [json_name = "name"];
inline void ServiceConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServiceConfig::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.name)
}
inline std::string* ServiceConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.name)
  return _s;
}
inline const std::string& ServiceConfig::_internal_name() const {
  return name_.Get();
}
inline void ServiceConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceConfig::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceConfig::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.name)
  return name_.Release();
}
inline void ServiceConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.name)
}

// string namespace = 2 [json_name = "namespace"];
inline void ServiceConfig::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& ServiceConfig::namespace_() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceConfig::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.namespace)
}
inline std::string* ServiceConfig::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.namespace)
  return _s;
}
inline const std::string& ServiceConfig::_internal_namespace_() const {
  return namespace__.Get();
}
inline void ServiceConfig::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceConfig::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceConfig::release_namespace_() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.namespace)
  return namespace__.Release();
}
inline void ServiceConfig::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault()) {
    namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.namespace)
}

// string type = 3 [json_name = "type"];
inline void ServiceConfig::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ServiceConfig::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceConfig::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.type)
}
inline std::string* ServiceConfig::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.type)
  return _s;
}
inline const std::string& ServiceConfig::_internal_type() const {
  return type_.Get();
}
inline void ServiceConfig::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceConfig::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceConfig::release_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.type)
  return type_.Release();
}
inline void ServiceConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.type)
}

// .google.protobuf.Struct attributes = 4 [json_name = "attributes"];
inline bool ServiceConfig::_internal_has_attributes() const {
  return this != internal_default_instance() && attributes_ != nullptr;
}
inline bool ServiceConfig::has_attributes() const {
  return _internal_has_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ServiceConfig::_internal_attributes() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ServiceConfig::attributes() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.attributes)
  return _internal_attributes();
}
inline void ServiceConfig::unsafe_arena_set_allocated_attributes(
    ::PROTOBUF_NAMESPACE_ID::Struct* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ServiceConfig.attributes)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ServiceConfig::release_attributes() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ServiceConfig::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.attributes)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ServiceConfig::_internal_mutable_attributes() {
  
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ServiceConfig::mutable_attributes() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.attributes)
  return _msg;
}
inline void ServiceConfig::set_allocated_attributes(::PROTOBUF_NAMESPACE_ID::Struct* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes));
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.attributes)
}

// repeated string depends_on = 5 [json_name = "dependsOn"];
inline int ServiceConfig::_internal_depends_on_size() const {
  return depends_on_.size();
}
inline int ServiceConfig::depends_on_size() const {
  return _internal_depends_on_size();
}
inline void ServiceConfig::clear_depends_on() {
  depends_on_.Clear();
}
inline std::string* ServiceConfig::add_depends_on() {
  std::string* _s = _internal_add_depends_on();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.ServiceConfig.depends_on)
  return _s;
}
inline const std::string& ServiceConfig::_internal_depends_on(int index) const {
  return depends_on_.Get(index);
}
inline const std::string& ServiceConfig::depends_on(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.depends_on)
  return _internal_depends_on(index);
}
inline std::string* ServiceConfig::mutable_depends_on(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.depends_on)
  return depends_on_.Mutable(index);
}
inline void ServiceConfig::set_depends_on(int index, const std::string& value) {
  depends_on_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::set_depends_on(int index, std::string&& value) {
  depends_on_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::set_depends_on(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  depends_on_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::set_depends_on(int index, const char* value, size_t size) {
  depends_on_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.ServiceConfig.depends_on)
}
inline std::string* ServiceConfig::_internal_add_depends_on() {
  return depends_on_.Add();
}
inline void ServiceConfig::add_depends_on(const std::string& value) {
  depends_on_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(std::string&& value) {
  depends_on_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  depends_on_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.ServiceConfig.depends_on)
}
inline void ServiceConfig::add_depends_on(const char* value, size_t size) {
  depends_on_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.ServiceConfig.depends_on)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServiceConfig::depends_on() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ServiceConfig.depends_on)
  return depends_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServiceConfig::mutable_depends_on() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ServiceConfig.depends_on)
  return &depends_on_;
}

// string model = 6 [json_name = "model"];
inline void ServiceConfig::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& ServiceConfig::model() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceConfig::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.model)
}
inline std::string* ServiceConfig::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.model)
  return _s;
}
inline const std::string& ServiceConfig::_internal_model() const {
  return model_.Get();
}
inline void ServiceConfig::_internal_set_model(const std::string& value) {
  
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceConfig::_internal_mutable_model() {
  
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceConfig::release_model() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.model)
  return model_.Release();
}
inline void ServiceConfig::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.model)
}

// string api = 9 [json_name = "api"];
inline void ServiceConfig::clear_api() {
  api_.ClearToEmpty();
}
inline const std::string& ServiceConfig::api() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.api)
  return _internal_api();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceConfig::set_api(ArgT0&& arg0, ArgT... args) {
 
 api_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ServiceConfig.api)
}
inline std::string* ServiceConfig::mutable_api() {
  std::string* _s = _internal_mutable_api();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.api)
  return _s;
}
inline const std::string& ServiceConfig::_internal_api() const {
  return api_.Get();
}
inline void ServiceConfig::_internal_set_api(const std::string& value) {
  
  api_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceConfig::_internal_mutable_api() {
  
  return api_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceConfig::release_api() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.api)
  return api_.Release();
}
inline void ServiceConfig::set_allocated_api(std::string* api) {
  if (api != nullptr) {
    
  } else {
    
  }
  api_.SetAllocated(api, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_.IsDefault()) {
    api_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.api)
}

// repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 10 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
inline int ServiceConfig::_internal_service_configs_size() const {
  return service_configs_.size();
}
inline int ServiceConfig::service_configs_size() const {
  return _internal_service_configs_size();
}
inline void ServiceConfig::clear_service_configs() {
  service_configs_.Clear();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ServiceConfig::mutable_service_configs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.service_configs)
  return service_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
ServiceConfig::mutable_service_configs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ServiceConfig.service_configs)
  return &service_configs_;
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& ServiceConfig::_internal_service_configs(int index) const {
  return service_configs_.Get(index);
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& ServiceConfig::service_configs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.service_configs)
  return _internal_service_configs(index);
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ServiceConfig::_internal_add_service_configs() {
  return service_configs_.Add();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* ServiceConfig::add_service_configs() {
  ::viam::app::v1::ResourceLevelServiceConfig* _add = _internal_add_service_configs();
  // @@protoc_insertion_point(field_add:viam.app.v1.ServiceConfig.service_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
ServiceConfig::service_configs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ServiceConfig.service_configs)
  return service_configs_;
}

// .viam.app.v1.LogConfiguration log_configuration = 11 [json_name = "logConfiguration"];
inline bool ServiceConfig::_internal_has_log_configuration() const {
  return this != internal_default_instance() && log_configuration_ != nullptr;
}
inline bool ServiceConfig::has_log_configuration() const {
  return _internal_has_log_configuration();
}
inline void ServiceConfig::clear_log_configuration() {
  if (GetArenaForAllocation() == nullptr && log_configuration_ != nullptr) {
    delete log_configuration_;
  }
  log_configuration_ = nullptr;
}
inline const ::viam::app::v1::LogConfiguration& ServiceConfig::_internal_log_configuration() const {
  const ::viam::app::v1::LogConfiguration* p = log_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LogConfiguration&>(
      ::viam::app::v1::_LogConfiguration_default_instance_);
}
inline const ::viam::app::v1::LogConfiguration& ServiceConfig::log_configuration() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ServiceConfig.log_configuration)
  return _internal_log_configuration();
}
inline void ServiceConfig::unsafe_arena_set_allocated_log_configuration(
    ::viam::app::v1::LogConfiguration* log_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_configuration_);
  }
  log_configuration_ = log_configuration;
  if (log_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ServiceConfig.log_configuration)
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::release_log_configuration() {
  
  ::viam::app::v1::LogConfiguration* temp = log_configuration_;
  log_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::unsafe_arena_release_log_configuration() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ServiceConfig.log_configuration)
  
  ::viam::app::v1::LogConfiguration* temp = log_configuration_;
  log_configuration_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::_internal_mutable_log_configuration() {
  
  if (log_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LogConfiguration>(GetArenaForAllocation());
    log_configuration_ = p;
  }
  return log_configuration_;
}
inline ::viam::app::v1::LogConfiguration* ServiceConfig::mutable_log_configuration() {
  ::viam::app::v1::LogConfiguration* _msg = _internal_mutable_log_configuration();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ServiceConfig.log_configuration)
  return _msg;
}
inline void ServiceConfig::set_allocated_log_configuration(::viam::app::v1::LogConfiguration* log_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete log_configuration_;
  }
  if (log_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log_configuration);
    if (message_arena != submessage_arena) {
      log_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_configuration, submessage_arena);
    }
    
  } else {
    
  }
  log_configuration_ = log_configuration;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ServiceConfig.log_configuration)
}

// -------------------------------------------------------------------

// NetworkConfig

// string fqdn = 1 [json_name = "fqdn"];
inline void NetworkConfig::clear_fqdn() {
  fqdn_.ClearToEmpty();
}
inline const std::string& NetworkConfig::fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.fqdn)
  return _internal_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_fqdn(ArgT0&& arg0, ArgT... args) {
 
 fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.fqdn)
}
inline std::string* NetworkConfig::mutable_fqdn() {
  std::string* _s = _internal_mutable_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.fqdn)
  return _s;
}
inline const std::string& NetworkConfig::_internal_fqdn() const {
  return fqdn_.Get();
}
inline void NetworkConfig::_internal_set_fqdn(const std::string& value) {
  
  fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_fqdn() {
  
  return fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.fqdn)
  return fqdn_.Release();
}
inline void NetworkConfig::set_allocated_fqdn(std::string* fqdn) {
  if (fqdn != nullptr) {
    
  } else {
    
  }
  fqdn_.SetAllocated(fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fqdn_.IsDefault()) {
    fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.fqdn)
}

// string bind_address = 2 [json_name = "bindAddress"];
inline void NetworkConfig::clear_bind_address() {
  bind_address_.ClearToEmpty();
}
inline const std::string& NetworkConfig::bind_address() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.bind_address)
  return _internal_bind_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_bind_address(ArgT0&& arg0, ArgT... args) {
 
 bind_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.bind_address)
}
inline std::string* NetworkConfig::mutable_bind_address() {
  std::string* _s = _internal_mutable_bind_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.bind_address)
  return _s;
}
inline const std::string& NetworkConfig::_internal_bind_address() const {
  return bind_address_.Get();
}
inline void NetworkConfig::_internal_set_bind_address(const std::string& value) {
  
  bind_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_bind_address() {
  
  return bind_address_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_bind_address() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.bind_address)
  return bind_address_.Release();
}
inline void NetworkConfig::set_allocated_bind_address(std::string* bind_address) {
  if (bind_address != nullptr) {
    
  } else {
    
  }
  bind_address_.SetAllocated(bind_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bind_address_.IsDefault()) {
    bind_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.bind_address)
}

// string tls_cert_file = 3 [json_name = "tlsCertFile"];
inline void NetworkConfig::clear_tls_cert_file() {
  tls_cert_file_.ClearToEmpty();
}
inline const std::string& NetworkConfig::tls_cert_file() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.tls_cert_file)
  return _internal_tls_cert_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_tls_cert_file(ArgT0&& arg0, ArgT... args) {
 
 tls_cert_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.tls_cert_file)
}
inline std::string* NetworkConfig::mutable_tls_cert_file() {
  std::string* _s = _internal_mutable_tls_cert_file();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.tls_cert_file)
  return _s;
}
inline const std::string& NetworkConfig::_internal_tls_cert_file() const {
  return tls_cert_file_.Get();
}
inline void NetworkConfig::_internal_set_tls_cert_file(const std::string& value) {
  
  tls_cert_file_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_tls_cert_file() {
  
  return tls_cert_file_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_tls_cert_file() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.tls_cert_file)
  return tls_cert_file_.Release();
}
inline void NetworkConfig::set_allocated_tls_cert_file(std::string* tls_cert_file) {
  if (tls_cert_file != nullptr) {
    
  } else {
    
  }
  tls_cert_file_.SetAllocated(tls_cert_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tls_cert_file_.IsDefault()) {
    tls_cert_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.tls_cert_file)
}

// string tls_key_file = 4 [json_name = "tlsKeyFile"];
inline void NetworkConfig::clear_tls_key_file() {
  tls_key_file_.ClearToEmpty();
}
inline const std::string& NetworkConfig::tls_key_file() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.tls_key_file)
  return _internal_tls_key_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_tls_key_file(ArgT0&& arg0, ArgT... args) {
 
 tls_key_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.tls_key_file)
}
inline std::string* NetworkConfig::mutable_tls_key_file() {
  std::string* _s = _internal_mutable_tls_key_file();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.tls_key_file)
  return _s;
}
inline const std::string& NetworkConfig::_internal_tls_key_file() const {
  return tls_key_file_.Get();
}
inline void NetworkConfig::_internal_set_tls_key_file(const std::string& value) {
  
  tls_key_file_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_tls_key_file() {
  
  return tls_key_file_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_tls_key_file() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.tls_key_file)
  return tls_key_file_.Release();
}
inline void NetworkConfig::set_allocated_tls_key_file(std::string* tls_key_file) {
  if (tls_key_file != nullptr) {
    
  } else {
    
  }
  tls_key_file_.SetAllocated(tls_key_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tls_key_file_.IsDefault()) {
    tls_key_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.tls_key_file)
}

// .viam.app.v1.SessionsConfig sessions = 5 [json_name = "sessions"];
inline bool NetworkConfig::_internal_has_sessions() const {
  return this != internal_default_instance() && sessions_ != nullptr;
}
inline bool NetworkConfig::has_sessions() const {
  return _internal_has_sessions();
}
inline void NetworkConfig::clear_sessions() {
  if (GetArenaForAllocation() == nullptr && sessions_ != nullptr) {
    delete sessions_;
  }
  sessions_ = nullptr;
}
inline const ::viam::app::v1::SessionsConfig& NetworkConfig::_internal_sessions() const {
  const ::viam::app::v1::SessionsConfig* p = sessions_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::SessionsConfig&>(
      ::viam::app::v1::_SessionsConfig_default_instance_);
}
inline const ::viam::app::v1::SessionsConfig& NetworkConfig::sessions() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.sessions)
  return _internal_sessions();
}
inline void NetworkConfig::unsafe_arena_set_allocated_sessions(
    ::viam::app::v1::SessionsConfig* sessions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sessions_);
  }
  sessions_ = sessions;
  if (sessions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.NetworkConfig.sessions)
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::release_sessions() {
  
  ::viam::app::v1::SessionsConfig* temp = sessions_;
  sessions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::unsafe_arena_release_sessions() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NetworkConfig.sessions)
  
  ::viam::app::v1::SessionsConfig* temp = sessions_;
  sessions_ = nullptr;
  return temp;
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::_internal_mutable_sessions() {
  
  if (sessions_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::SessionsConfig>(GetArenaForAllocation());
    sessions_ = p;
  }
  return sessions_;
}
inline ::viam::app::v1::SessionsConfig* NetworkConfig::mutable_sessions() {
  ::viam::app::v1::SessionsConfig* _msg = _internal_mutable_sessions();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.sessions)
  return _msg;
}
inline void NetworkConfig::set_allocated_sessions(::viam::app::v1::SessionsConfig* sessions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sessions_;
  }
  if (sessions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sessions);
    if (message_arena != submessage_arena) {
      sessions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sessions, submessage_arena);
    }
    
  } else {
    
  }
  sessions_ = sessions;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NetworkConfig.sessions)
}

// repeated .viam.app.v1.TrafficTunnelEndpoint traffic_tunnel_endpoints = 6 [json_name = "trafficTunnelEndpoints"];
inline int NetworkConfig::_internal_traffic_tunnel_endpoints_size() const {
  return traffic_tunnel_endpoints_.size();
}
inline int NetworkConfig::traffic_tunnel_endpoints_size() const {
  return _internal_traffic_tunnel_endpoints_size();
}
inline void NetworkConfig::clear_traffic_tunnel_endpoints() {
  traffic_tunnel_endpoints_.Clear();
}
inline ::viam::app::v1::TrafficTunnelEndpoint* NetworkConfig::mutable_traffic_tunnel_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NetworkConfig.traffic_tunnel_endpoints)
  return traffic_tunnel_endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::TrafficTunnelEndpoint >*
NetworkConfig::mutable_traffic_tunnel_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.NetworkConfig.traffic_tunnel_endpoints)
  return &traffic_tunnel_endpoints_;
}
inline const ::viam::app::v1::TrafficTunnelEndpoint& NetworkConfig::_internal_traffic_tunnel_endpoints(int index) const {
  return traffic_tunnel_endpoints_.Get(index);
}
inline const ::viam::app::v1::TrafficTunnelEndpoint& NetworkConfig::traffic_tunnel_endpoints(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.traffic_tunnel_endpoints)
  return _internal_traffic_tunnel_endpoints(index);
}
inline ::viam::app::v1::TrafficTunnelEndpoint* NetworkConfig::_internal_add_traffic_tunnel_endpoints() {
  return traffic_tunnel_endpoints_.Add();
}
inline ::viam::app::v1::TrafficTunnelEndpoint* NetworkConfig::add_traffic_tunnel_endpoints() {
  ::viam::app::v1::TrafficTunnelEndpoint* _add = _internal_add_traffic_tunnel_endpoints();
  // @@protoc_insertion_point(field_add:viam.app.v1.NetworkConfig.traffic_tunnel_endpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::TrafficTunnelEndpoint >&
NetworkConfig::traffic_tunnel_endpoints() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.NetworkConfig.traffic_tunnel_endpoints)
  return traffic_tunnel_endpoints_;
}

// bool no_tls = 7 [json_name = "noTls"];
inline void NetworkConfig::clear_no_tls() {
  no_tls_ = false;
}
inline bool NetworkConfig::_internal_no_tls() const {
  return no_tls_;
}
inline bool NetworkConfig::no_tls() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NetworkConfig.no_tls)
  return _internal_no_tls();
}
inline void NetworkConfig::_internal_set_no_tls(bool value) {
  
  no_tls_ = value;
}
inline void NetworkConfig::set_no_tls(bool value) {
  _internal_set_no_tls(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.NetworkConfig.no_tls)
}

// -------------------------------------------------------------------

// SessionsConfig

// .google.protobuf.Duration heartbeat_window = 1 [json_name = "heartbeatWindow"];
inline bool SessionsConfig::_internal_has_heartbeat_window() const {
  return this != internal_default_instance() && heartbeat_window_ != nullptr;
}
inline bool SessionsConfig::has_heartbeat_window() const {
  return _internal_has_heartbeat_window();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SessionsConfig::_internal_heartbeat_window() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = heartbeat_window_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SessionsConfig::heartbeat_window() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SessionsConfig.heartbeat_window)
  return _internal_heartbeat_window();
}
inline void SessionsConfig::unsafe_arena_set_allocated_heartbeat_window(
    ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_window_);
  }
  heartbeat_window_ = heartbeat_window;
  if (heartbeat_window) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.SessionsConfig.heartbeat_window)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SessionsConfig::release_heartbeat_window() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = heartbeat_window_;
  heartbeat_window_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SessionsConfig::unsafe_arena_release_heartbeat_window() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SessionsConfig.heartbeat_window)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = heartbeat_window_;
  heartbeat_window_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SessionsConfig::_internal_mutable_heartbeat_window() {
  
  if (heartbeat_window_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    heartbeat_window_ = p;
  }
  return heartbeat_window_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SessionsConfig::mutable_heartbeat_window() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_heartbeat_window();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SessionsConfig.heartbeat_window)
  return _msg;
}
inline void SessionsConfig::set_allocated_heartbeat_window(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_window_);
  }
  if (heartbeat_window) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_window));
    if (message_arena != submessage_arena) {
      heartbeat_window = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_window, submessage_arena);
    }
    
  } else {
    
  }
  heartbeat_window_ = heartbeat_window;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SessionsConfig.heartbeat_window)
}

// -------------------------------------------------------------------

// TrafficTunnelEndpoint

// int32 port = 1 [json_name = "port"];
inline void TrafficTunnelEndpoint::clear_port() {
  port_ = 0;
}
inline int32_t TrafficTunnelEndpoint::_internal_port() const {
  return port_;
}
inline int32_t TrafficTunnelEndpoint::port() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TrafficTunnelEndpoint.port)
  return _internal_port();
}
inline void TrafficTunnelEndpoint::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void TrafficTunnelEndpoint::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.TrafficTunnelEndpoint.port)
}

// .google.protobuf.Duration connection_timeout = 2 [json_name = "connectionTimeout"];
inline bool TrafficTunnelEndpoint::_internal_has_connection_timeout() const {
  return this != internal_default_instance() && connection_timeout_ != nullptr;
}
inline bool TrafficTunnelEndpoint::has_connection_timeout() const {
  return _internal_has_connection_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TrafficTunnelEndpoint::_internal_connection_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = connection_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TrafficTunnelEndpoint::connection_timeout() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TrafficTunnelEndpoint.connection_timeout)
  return _internal_connection_timeout();
}
inline void TrafficTunnelEndpoint::unsafe_arena_set_allocated_connection_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* connection_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_timeout_);
  }
  connection_timeout_ = connection_timeout;
  if (connection_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.TrafficTunnelEndpoint.connection_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TrafficTunnelEndpoint::release_connection_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = connection_timeout_;
  connection_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TrafficTunnelEndpoint::unsafe_arena_release_connection_timeout() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TrafficTunnelEndpoint.connection_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = connection_timeout_;
  connection_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TrafficTunnelEndpoint::_internal_mutable_connection_timeout() {
  
  if (connection_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    connection_timeout_ = p;
  }
  return connection_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TrafficTunnelEndpoint::mutable_connection_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_connection_timeout();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TrafficTunnelEndpoint.connection_timeout)
  return _msg;
}
inline void TrafficTunnelEndpoint::set_allocated_connection_timeout(::PROTOBUF_NAMESPACE_ID::Duration* connection_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_timeout_);
  }
  if (connection_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_timeout));
    if (message_arena != submessage_arena) {
      connection_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_timeout, submessage_arena);
    }
    
  } else {
    
  }
  connection_timeout_ = connection_timeout;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TrafficTunnelEndpoint.connection_timeout)
}

// -------------------------------------------------------------------

// AuthConfig

// repeated .viam.app.v1.AuthHandlerConfig handlers = 1 [json_name = "handlers"];
inline int AuthConfig::_internal_handlers_size() const {
  return handlers_.size();
}
inline int AuthConfig::handlers_size() const {
  return _internal_handlers_size();
}
inline void AuthConfig::clear_handlers() {
  handlers_.Clear();
}
inline ::viam::app::v1::AuthHandlerConfig* AuthConfig::mutable_handlers(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthConfig.handlers)
  return handlers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig >*
AuthConfig::mutable_handlers() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AuthConfig.handlers)
  return &handlers_;
}
inline const ::viam::app::v1::AuthHandlerConfig& AuthConfig::_internal_handlers(int index) const {
  return handlers_.Get(index);
}
inline const ::viam::app::v1::AuthHandlerConfig& AuthConfig::handlers(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthConfig.handlers)
  return _internal_handlers(index);
}
inline ::viam::app::v1::AuthHandlerConfig* AuthConfig::_internal_add_handlers() {
  return handlers_.Add();
}
inline ::viam::app::v1::AuthHandlerConfig* AuthConfig::add_handlers() {
  ::viam::app::v1::AuthHandlerConfig* _add = _internal_add_handlers();
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthConfig.handlers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::AuthHandlerConfig >&
AuthConfig::handlers() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.AuthConfig.handlers)
  return handlers_;
}

// repeated string tls_auth_entities = 2 [json_name = "tlsAuthEntities"];
inline int AuthConfig::_internal_tls_auth_entities_size() const {
  return tls_auth_entities_.size();
}
inline int AuthConfig::tls_auth_entities_size() const {
  return _internal_tls_auth_entities_size();
}
inline void AuthConfig::clear_tls_auth_entities() {
  tls_auth_entities_.Clear();
}
inline std::string* AuthConfig::add_tls_auth_entities() {
  std::string* _s = _internal_add_tls_auth_entities();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.AuthConfig.tls_auth_entities)
  return _s;
}
inline const std::string& AuthConfig::_internal_tls_auth_entities(int index) const {
  return tls_auth_entities_.Get(index);
}
inline const std::string& AuthConfig::tls_auth_entities(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthConfig.tls_auth_entities)
  return _internal_tls_auth_entities(index);
}
inline std::string* AuthConfig::mutable_tls_auth_entities(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthConfig.tls_auth_entities)
  return tls_auth_entities_.Mutable(index);
}
inline void AuthConfig::set_tls_auth_entities(int index, const std::string& value) {
  tls_auth_entities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::set_tls_auth_entities(int index, std::string&& value) {
  tls_auth_entities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::set_tls_auth_entities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tls_auth_entities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::set_tls_auth_entities(int index, const char* value, size_t size) {
  tls_auth_entities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline std::string* AuthConfig::_internal_add_tls_auth_entities() {
  return tls_auth_entities_.Add();
}
inline void AuthConfig::add_tls_auth_entities(const std::string& value) {
  tls_auth_entities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(std::string&& value) {
  tls_auth_entities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tls_auth_entities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline void AuthConfig::add_tls_auth_entities(const char* value, size_t size) {
  tls_auth_entities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.AuthConfig.tls_auth_entities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthConfig::tls_auth_entities() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.AuthConfig.tls_auth_entities)
  return tls_auth_entities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AuthConfig::mutable_tls_auth_entities() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AuthConfig.tls_auth_entities)
  return &tls_auth_entities_;
}

// optional .viam.app.v1.ExternalAuthConfig external_auth_config = 3 [json_name = "externalAuthConfig"];
inline bool AuthConfig::_internal_has_external_auth_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || external_auth_config_ != nullptr);
  return value;
}
inline bool AuthConfig::has_external_auth_config() const {
  return _internal_has_external_auth_config();
}
inline void AuthConfig::clear_external_auth_config() {
  if (external_auth_config_ != nullptr) external_auth_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::ExternalAuthConfig& AuthConfig::_internal_external_auth_config() const {
  const ::viam::app::v1::ExternalAuthConfig* p = external_auth_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::ExternalAuthConfig&>(
      ::viam::app::v1::_ExternalAuthConfig_default_instance_);
}
inline const ::viam::app::v1::ExternalAuthConfig& AuthConfig::external_auth_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthConfig.external_auth_config)
  return _internal_external_auth_config();
}
inline void AuthConfig::unsafe_arena_set_allocated_external_auth_config(
    ::viam::app::v1::ExternalAuthConfig* external_auth_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(external_auth_config_);
  }
  external_auth_config_ = external_auth_config;
  if (external_auth_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.AuthConfig.external_auth_config)
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::release_external_auth_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::ExternalAuthConfig* temp = external_auth_config_;
  external_auth_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::unsafe_arena_release_external_auth_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthConfig.external_auth_config)
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::ExternalAuthConfig* temp = external_auth_config_;
  external_auth_config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::_internal_mutable_external_auth_config() {
  _has_bits_[0] |= 0x00000001u;
  if (external_auth_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::ExternalAuthConfig>(GetArenaForAllocation());
    external_auth_config_ = p;
  }
  return external_auth_config_;
}
inline ::viam::app::v1::ExternalAuthConfig* AuthConfig::mutable_external_auth_config() {
  ::viam::app::v1::ExternalAuthConfig* _msg = _internal_mutable_external_auth_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthConfig.external_auth_config)
  return _msg;
}
inline void AuthConfig::set_allocated_external_auth_config(::viam::app::v1::ExternalAuthConfig* external_auth_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete external_auth_config_;
  }
  if (external_auth_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_auth_config);
    if (message_arena != submessage_arena) {
      external_auth_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_auth_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  external_auth_config_ = external_auth_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthConfig.external_auth_config)
}

// -------------------------------------------------------------------

// JWKSFile

// .google.protobuf.Struct json = 1 [json_name = "json"];
inline bool JWKSFile::_internal_has_json() const {
  return this != internal_default_instance() && json_ != nullptr;
}
inline bool JWKSFile::has_json() const {
  return _internal_has_json();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& JWKSFile::_internal_json() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = json_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& JWKSFile::json() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.JWKSFile.json)
  return _internal_json();
}
inline void JWKSFile::unsafe_arena_set_allocated_json(
    ::PROTOBUF_NAMESPACE_ID::Struct* json) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(json_);
  }
  json_ = json;
  if (json) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.JWKSFile.json)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JWKSFile::release_json() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = json_;
  json_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JWKSFile::unsafe_arena_release_json() {
  // @@protoc_insertion_point(field_release:viam.app.v1.JWKSFile.json)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = json_;
  json_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JWKSFile::_internal_mutable_json() {
  
  if (json_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    json_ = p;
  }
  return json_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JWKSFile::mutable_json() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.JWKSFile.json)
  return _msg;
}
inline void JWKSFile::set_allocated_json(::PROTOBUF_NAMESPACE_ID::Struct* json) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(json_);
  }
  if (json) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(json));
    if (message_arena != submessage_arena) {
      json = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, json, submessage_arena);
    }
    
  } else {
    
  }
  json_ = json;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.JWKSFile.json)
}

// -------------------------------------------------------------------

// ExternalAuthConfig

// .viam.app.v1.JWKSFile jwks = 1 [json_name = "jwks"];
inline bool ExternalAuthConfig::_internal_has_jwks() const {
  return this != internal_default_instance() && jwks_ != nullptr;
}
inline bool ExternalAuthConfig::has_jwks() const {
  return _internal_has_jwks();
}
inline void ExternalAuthConfig::clear_jwks() {
  if (GetArenaForAllocation() == nullptr && jwks_ != nullptr) {
    delete jwks_;
  }
  jwks_ = nullptr;
}
inline const ::viam::app::v1::JWKSFile& ExternalAuthConfig::_internal_jwks() const {
  const ::viam::app::v1::JWKSFile* p = jwks_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::JWKSFile&>(
      ::viam::app::v1::_JWKSFile_default_instance_);
}
inline const ::viam::app::v1::JWKSFile& ExternalAuthConfig::jwks() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ExternalAuthConfig.jwks)
  return _internal_jwks();
}
inline void ExternalAuthConfig::unsafe_arena_set_allocated_jwks(
    ::viam::app::v1::JWKSFile* jwks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(jwks_);
  }
  jwks_ = jwks;
  if (jwks) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ExternalAuthConfig.jwks)
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::release_jwks() {
  
  ::viam::app::v1::JWKSFile* temp = jwks_;
  jwks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::unsafe_arena_release_jwks() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ExternalAuthConfig.jwks)
  
  ::viam::app::v1::JWKSFile* temp = jwks_;
  jwks_ = nullptr;
  return temp;
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::_internal_mutable_jwks() {
  
  if (jwks_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::JWKSFile>(GetArenaForAllocation());
    jwks_ = p;
  }
  return jwks_;
}
inline ::viam::app::v1::JWKSFile* ExternalAuthConfig::mutable_jwks() {
  ::viam::app::v1::JWKSFile* _msg = _internal_mutable_jwks();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ExternalAuthConfig.jwks)
  return _msg;
}
inline void ExternalAuthConfig::set_allocated_jwks(::viam::app::v1::JWKSFile* jwks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete jwks_;
  }
  if (jwks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(jwks);
    if (message_arena != submessage_arena) {
      jwks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, jwks, submessage_arena);
    }
    
  } else {
    
  }
  jwks_ = jwks;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ExternalAuthConfig.jwks)
}

// -------------------------------------------------------------------

// AuthHandlerConfig

// .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
inline void AuthHandlerConfig::clear_type() {
  type_ = 0;
}
inline ::viam::app::v1::CredentialsType AuthHandlerConfig::_internal_type() const {
  return static_cast< ::viam::app::v1::CredentialsType >(type_);
}
inline ::viam::app::v1::CredentialsType AuthHandlerConfig::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthHandlerConfig.type)
  return _internal_type();
}
inline void AuthHandlerConfig::_internal_set_type(::viam::app::v1::CredentialsType value) {
  
  type_ = value;
}
inline void AuthHandlerConfig::set_type(::viam::app::v1::CredentialsType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AuthHandlerConfig.type)
}

// .google.protobuf.Struct config = 5 [json_name = "config"];
inline bool AuthHandlerConfig::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool AuthHandlerConfig::has_config() const {
  return _internal_has_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AuthHandlerConfig::_internal_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AuthHandlerConfig::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AuthHandlerConfig.config)
  return _internal_config();
}
inline void AuthHandlerConfig::unsafe_arena_set_allocated_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.AuthHandlerConfig.config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuthHandlerConfig::release_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuthHandlerConfig::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AuthHandlerConfig.config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuthHandlerConfig::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuthHandlerConfig::mutable_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AuthHandlerConfig.config)
  return _msg;
}
inline void AuthHandlerConfig::set_allocated_config(::PROTOBUF_NAMESPACE_ID::Struct* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AuthHandlerConfig.config)
}

// -------------------------------------------------------------------

// Frame

// string parent = 1 [json_name = "parent"];
inline void Frame::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& Frame::parent() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Frame.parent)
}
inline std::string* Frame::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.parent)
  return _s;
}
inline const std::string& Frame::_internal_parent() const {
  return parent_.Get();
}
inline void Frame::_internal_set_parent(const std::string& value) {
  
  parent_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_parent() {
  
  return parent_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_parent() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.parent)
  return parent_.Release();
}
inline void Frame::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault()) {
    parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.parent)
}

// .viam.app.v1.Translation translation = 2 [json_name = "translation"];
inline bool Frame::_internal_has_translation() const {
  return this != internal_default_instance() && translation_ != nullptr;
}
inline bool Frame::has_translation() const {
  return _internal_has_translation();
}
inline void Frame::clear_translation() {
  if (GetArenaForAllocation() == nullptr && translation_ != nullptr) {
    delete translation_;
  }
  translation_ = nullptr;
}
inline const ::viam::app::v1::Translation& Frame::_internal_translation() const {
  const ::viam::app::v1::Translation* p = translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Translation&>(
      ::viam::app::v1::_Translation_default_instance_);
}
inline const ::viam::app::v1::Translation& Frame::translation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.translation)
  return _internal_translation();
}
inline void Frame::unsafe_arena_set_allocated_translation(
    ::viam::app::v1::Translation* translation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(translation_);
  }
  translation_ = translation;
  if (translation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Frame.translation)
}
inline ::viam::app::v1::Translation* Frame::release_translation() {
  
  ::viam::app::v1::Translation* temp = translation_;
  translation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Translation* Frame::unsafe_arena_release_translation() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.translation)
  
  ::viam::app::v1::Translation* temp = translation_;
  translation_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Translation* Frame::_internal_mutable_translation() {
  
  if (translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Translation>(GetArenaForAllocation());
    translation_ = p;
  }
  return translation_;
}
inline ::viam::app::v1::Translation* Frame::mutable_translation() {
  ::viam::app::v1::Translation* _msg = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.translation)
  return _msg;
}
inline void Frame::set_allocated_translation(::viam::app::v1::Translation* translation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete translation_;
  }
  if (translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(translation);
    if (message_arena != submessage_arena) {
      translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    
  } else {
    
  }
  translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.translation)
}

// .viam.app.v1.Orientation orientation = 3 [json_name = "orientation"];
inline bool Frame::_internal_has_orientation() const {
  return this != internal_default_instance() && orientation_ != nullptr;
}
inline bool Frame::has_orientation() const {
  return _internal_has_orientation();
}
inline void Frame::clear_orientation() {
  if (GetArenaForAllocation() == nullptr && orientation_ != nullptr) {
    delete orientation_;
  }
  orientation_ = nullptr;
}
inline const ::viam::app::v1::Orientation& Frame::_internal_orientation() const {
  const ::viam::app::v1::Orientation* p = orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Orientation&>(
      ::viam::app::v1::_Orientation_default_instance_);
}
inline const ::viam::app::v1::Orientation& Frame::orientation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.orientation)
  return _internal_orientation();
}
inline void Frame::unsafe_arena_set_allocated_orientation(
    ::viam::app::v1::Orientation* orientation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Frame.orientation)
}
inline ::viam::app::v1::Orientation* Frame::release_orientation() {
  
  ::viam::app::v1::Orientation* temp = orientation_;
  orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Orientation* Frame::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.orientation)
  
  ::viam::app::v1::Orientation* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Orientation* Frame::_internal_mutable_orientation() {
  
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Orientation>(GetArenaForAllocation());
    orientation_ = p;
  }
  return orientation_;
}
inline ::viam::app::v1::Orientation* Frame::mutable_orientation() {
  ::viam::app::v1::Orientation* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.orientation)
  return _msg;
}
inline void Frame::set_allocated_orientation(::viam::app::v1::Orientation* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.orientation)
}

// .viam.common.v1.Geometry geometry = 4 [json_name = "geometry"];
inline bool Frame::_internal_has_geometry() const {
  return this != internal_default_instance() && geometry_ != nullptr;
}
inline bool Frame::has_geometry() const {
  return _internal_has_geometry();
}
inline const ::viam::common::v1::Geometry& Frame::_internal_geometry() const {
  const ::viam::common::v1::Geometry* p = geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::Geometry&>(
      ::viam::common::v1::_Geometry_default_instance_);
}
inline const ::viam::common::v1::Geometry& Frame::geometry() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Frame.geometry)
  return _internal_geometry();
}
inline void Frame::unsafe_arena_set_allocated_geometry(
    ::viam::common::v1::Geometry* geometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Frame.geometry)
}
inline ::viam::common::v1::Geometry* Frame::release_geometry() {
  
  ::viam::common::v1::Geometry* temp = geometry_;
  geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::Geometry* Frame::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Frame.geometry)
  
  ::viam::common::v1::Geometry* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::viam::common::v1::Geometry* Frame::_internal_mutable_geometry() {
  
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::Geometry>(GetArenaForAllocation());
    geometry_ = p;
  }
  return geometry_;
}
inline ::viam::common::v1::Geometry* Frame::mutable_geometry() {
  ::viam::common::v1::Geometry* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Frame.geometry)
  return _msg;
}
inline void Frame::set_allocated_geometry(::viam::common::v1::Geometry* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry));
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    
  } else {
    
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Frame.geometry)
}

// -------------------------------------------------------------------

// LogConfiguration

// string level = 1 [json_name = "level"];
inline void LogConfiguration::clear_level() {
  level_.ClearToEmpty();
}
inline const std::string& LogConfiguration::level() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogConfiguration.level)
  return _internal_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogConfiguration::set_level(ArgT0&& arg0, ArgT... args) {
 
 level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogConfiguration.level)
}
inline std::string* LogConfiguration::mutable_level() {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogConfiguration.level)
  return _s;
}
inline const std::string& LogConfiguration::_internal_level() const {
  return level_.Get();
}
inline void LogConfiguration::_internal_set_level(const std::string& value) {
  
  level_.Set(value, GetArenaForAllocation());
}
inline std::string* LogConfiguration::_internal_mutable_level() {
  
  return level_.Mutable(GetArenaForAllocation());
}
inline std::string* LogConfiguration::release_level() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogConfiguration.level)
  return level_.Release();
}
inline void LogConfiguration::set_allocated_level(std::string* level) {
  if (level != nullptr) {
    
  } else {
    
  }
  level_.SetAllocated(level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (level_.IsDefault()) {
    level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogConfiguration.level)
}

// -------------------------------------------------------------------

// Translation

// double x = 1 [json_name = "x"];
inline void Translation::clear_x() {
  x_ = 0;
}
inline double Translation::_internal_x() const {
  return x_;
}
inline double Translation::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Translation.x)
  return _internal_x();
}
inline void Translation::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Translation::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Translation.x)
}

// double y = 2 [json_name = "y"];
inline void Translation::clear_y() {
  y_ = 0;
}
inline double Translation::_internal_y() const {
  return y_;
}
inline double Translation::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Translation.y)
  return _internal_y();
}
inline void Translation::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Translation::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Translation.y)
}

// double z = 3 [json_name = "z"];
inline void Translation::clear_z() {
  z_ = 0;
}
inline double Translation::_internal_z() const {
  return z_;
}
inline double Translation::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Translation.z)
  return _internal_z();
}
inline void Translation::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Translation::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Translation.z)
}

// -------------------------------------------------------------------

// Orientation_NoOrientation

// -------------------------------------------------------------------

// Orientation_OrientationVectorRadians

// double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
inline void Orientation_OrientationVectorRadians::clear_theta() {
  theta_ = 0;
}
inline double Orientation_OrientationVectorRadians::_internal_theta() const {
  return theta_;
}
inline double Orientation_OrientationVectorRadians::theta() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.theta)
  return _internal_theta();
}
inline void Orientation_OrientationVectorRadians::_internal_set_theta(double value) {
  
  theta_ = value;
}
inline void Orientation_OrientationVectorRadians::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.theta)
}

// double x = 2 [json_name = "x"];
inline void Orientation_OrientationVectorRadians::clear_x() {
  x_ = 0;
}
inline double Orientation_OrientationVectorRadians::_internal_x() const {
  return x_;
}
inline double Orientation_OrientationVectorRadians::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.x)
  return _internal_x();
}
inline void Orientation_OrientationVectorRadians::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Orientation_OrientationVectorRadians::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.x)
}

// double y = 3 [json_name = "y"];
inline void Orientation_OrientationVectorRadians::clear_y() {
  y_ = 0;
}
inline double Orientation_OrientationVectorRadians::_internal_y() const {
  return y_;
}
inline double Orientation_OrientationVectorRadians::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.y)
  return _internal_y();
}
inline void Orientation_OrientationVectorRadians::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Orientation_OrientationVectorRadians::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.y)
}

// double z = 4 [json_name = "z"];
inline void Orientation_OrientationVectorRadians::clear_z() {
  z_ = 0;
}
inline double Orientation_OrientationVectorRadians::_internal_z() const {
  return z_;
}
inline double Orientation_OrientationVectorRadians::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorRadians.z)
  return _internal_z();
}
inline void Orientation_OrientationVectorRadians::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Orientation_OrientationVectorRadians::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorRadians.z)
}

// -------------------------------------------------------------------

// Orientation_OrientationVectorDegrees

// double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
inline void Orientation_OrientationVectorDegrees::clear_theta() {
  theta_ = 0;
}
inline double Orientation_OrientationVectorDegrees::_internal_theta() const {
  return theta_;
}
inline double Orientation_OrientationVectorDegrees::theta() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.theta)
  return _internal_theta();
}
inline void Orientation_OrientationVectorDegrees::_internal_set_theta(double value) {
  
  theta_ = value;
}
inline void Orientation_OrientationVectorDegrees::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.theta)
}

// double x = 2 [json_name = "x"];
inline void Orientation_OrientationVectorDegrees::clear_x() {
  x_ = 0;
}
inline double Orientation_OrientationVectorDegrees::_internal_x() const {
  return x_;
}
inline double Orientation_OrientationVectorDegrees::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.x)
  return _internal_x();
}
inline void Orientation_OrientationVectorDegrees::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Orientation_OrientationVectorDegrees::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.x)
}

// double y = 3 [json_name = "y"];
inline void Orientation_OrientationVectorDegrees::clear_y() {
  y_ = 0;
}
inline double Orientation_OrientationVectorDegrees::_internal_y() const {
  return y_;
}
inline double Orientation_OrientationVectorDegrees::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.y)
  return _internal_y();
}
inline void Orientation_OrientationVectorDegrees::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Orientation_OrientationVectorDegrees::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.y)
}

// double z = 4 [json_name = "z"];
inline void Orientation_OrientationVectorDegrees::clear_z() {
  z_ = 0;
}
inline double Orientation_OrientationVectorDegrees::_internal_z() const {
  return z_;
}
inline double Orientation_OrientationVectorDegrees::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.OrientationVectorDegrees.z)
  return _internal_z();
}
inline void Orientation_OrientationVectorDegrees::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Orientation_OrientationVectorDegrees::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.OrientationVectorDegrees.z)
}

// -------------------------------------------------------------------

// Orientation_EulerAngles

// double roll = 1 [json_name = "roll"];
inline void Orientation_EulerAngles::clear_roll() {
  roll_ = 0;
}
inline double Orientation_EulerAngles::_internal_roll() const {
  return roll_;
}
inline double Orientation_EulerAngles::roll() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.EulerAngles.roll)
  return _internal_roll();
}
inline void Orientation_EulerAngles::_internal_set_roll(double value) {
  
  roll_ = value;
}
inline void Orientation_EulerAngles::set_roll(double value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.EulerAngles.roll)
}

// double pitch = 2 [json_name = "pitch"];
inline void Orientation_EulerAngles::clear_pitch() {
  pitch_ = 0;
}
inline double Orientation_EulerAngles::_internal_pitch() const {
  return pitch_;
}
inline double Orientation_EulerAngles::pitch() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.EulerAngles.pitch)
  return _internal_pitch();
}
inline void Orientation_EulerAngles::_internal_set_pitch(double value) {
  
  pitch_ = value;
}
inline void Orientation_EulerAngles::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.EulerAngles.pitch)
}

// double yaw = 3 [json_name = "yaw"];
inline void Orientation_EulerAngles::clear_yaw() {
  yaw_ = 0;
}
inline double Orientation_EulerAngles::_internal_yaw() const {
  return yaw_;
}
inline double Orientation_EulerAngles::yaw() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.EulerAngles.yaw)
  return _internal_yaw();
}
inline void Orientation_EulerAngles::_internal_set_yaw(double value) {
  
  yaw_ = value;
}
inline void Orientation_EulerAngles::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.EulerAngles.yaw)
}

// -------------------------------------------------------------------

// Orientation_AxisAngles

// double theta = 1 [json_name = "theta", (.tagger.v1.tags) = "json:\"th\""];
inline void Orientation_AxisAngles::clear_theta() {
  theta_ = 0;
}
inline double Orientation_AxisAngles::_internal_theta() const {
  return theta_;
}
inline double Orientation_AxisAngles::theta() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.theta)
  return _internal_theta();
}
inline void Orientation_AxisAngles::_internal_set_theta(double value) {
  
  theta_ = value;
}
inline void Orientation_AxisAngles::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.theta)
}

// double x = 2 [json_name = "x"];
inline void Orientation_AxisAngles::clear_x() {
  x_ = 0;
}
inline double Orientation_AxisAngles::_internal_x() const {
  return x_;
}
inline double Orientation_AxisAngles::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.x)
  return _internal_x();
}
inline void Orientation_AxisAngles::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Orientation_AxisAngles::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.x)
}

// double y = 3 [json_name = "y"];
inline void Orientation_AxisAngles::clear_y() {
  y_ = 0;
}
inline double Orientation_AxisAngles::_internal_y() const {
  return y_;
}
inline double Orientation_AxisAngles::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.y)
  return _internal_y();
}
inline void Orientation_AxisAngles::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Orientation_AxisAngles::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.y)
}

// double z = 4 [json_name = "z"];
inline void Orientation_AxisAngles::clear_z() {
  z_ = 0;
}
inline double Orientation_AxisAngles::_internal_z() const {
  return z_;
}
inline double Orientation_AxisAngles::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.AxisAngles.z)
  return _internal_z();
}
inline void Orientation_AxisAngles::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Orientation_AxisAngles::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.AxisAngles.z)
}

// -------------------------------------------------------------------

// Orientation_Quaternion

// double w = 1 [json_name = "w"];
inline void Orientation_Quaternion::clear_w() {
  w_ = 0;
}
inline double Orientation_Quaternion::_internal_w() const {
  return w_;
}
inline double Orientation_Quaternion::w() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.w)
  return _internal_w();
}
inline void Orientation_Quaternion::_internal_set_w(double value) {
  
  w_ = value;
}
inline void Orientation_Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.w)
}

// double x = 2 [json_name = "x"];
inline void Orientation_Quaternion::clear_x() {
  x_ = 0;
}
inline double Orientation_Quaternion::_internal_x() const {
  return x_;
}
inline double Orientation_Quaternion::x() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.x)
  return _internal_x();
}
inline void Orientation_Quaternion::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Orientation_Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.x)
}

// double y = 3 [json_name = "y"];
inline void Orientation_Quaternion::clear_y() {
  y_ = 0;
}
inline double Orientation_Quaternion::_internal_y() const {
  return y_;
}
inline double Orientation_Quaternion::y() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.y)
  return _internal_y();
}
inline void Orientation_Quaternion::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Orientation_Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.y)
}

// double z = 4 [json_name = "z"];
inline void Orientation_Quaternion::clear_z() {
  z_ = 0;
}
inline double Orientation_Quaternion::_internal_z() const {
  return z_;
}
inline double Orientation_Quaternion::z() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.Quaternion.z)
  return _internal_z();
}
inline void Orientation_Quaternion::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Orientation_Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Orientation.Quaternion.z)
}

// -------------------------------------------------------------------

// Orientation

// .viam.app.v1.Orientation.NoOrientation no_orientation = 1 [json_name = "noOrientation"];
inline bool Orientation::_internal_has_no_orientation() const {
  return type_case() == kNoOrientation;
}
inline bool Orientation::has_no_orientation() const {
  return _internal_has_no_orientation();
}
inline void Orientation::set_has_no_orientation() {
  _oneof_case_[0] = kNoOrientation;
}
inline void Orientation::clear_no_orientation() {
  if (_internal_has_no_orientation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.no_orientation_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::release_no_orientation() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.no_orientation)
  if (_internal_has_no_orientation()) {
    clear_has_type();
    ::viam::app::v1::Orientation_NoOrientation* temp = type_.no_orientation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.no_orientation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_NoOrientation& Orientation::_internal_no_orientation() const {
  return _internal_has_no_orientation()
      ? *type_.no_orientation_
      : reinterpret_cast< ::viam::app::v1::Orientation_NoOrientation&>(::viam::app::v1::_Orientation_NoOrientation_default_instance_);
}
inline const ::viam::app::v1::Orientation_NoOrientation& Orientation::no_orientation() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.no_orientation)
  return _internal_no_orientation();
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::unsafe_arena_release_no_orientation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.no_orientation)
  if (_internal_has_no_orientation()) {
    clear_has_type();
    ::viam::app::v1::Orientation_NoOrientation* temp = type_.no_orientation_;
    type_.no_orientation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_no_orientation(::viam::app::v1::Orientation_NoOrientation* no_orientation) {
  clear_type();
  if (no_orientation) {
    set_has_no_orientation();
    type_.no_orientation_ = no_orientation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.no_orientation)
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::_internal_mutable_no_orientation() {
  if (!_internal_has_no_orientation()) {
    clear_type();
    set_has_no_orientation();
    type_.no_orientation_ = CreateMaybeMessage< ::viam::app::v1::Orientation_NoOrientation >(GetArenaForAllocation());
  }
  return type_.no_orientation_;
}
inline ::viam::app::v1::Orientation_NoOrientation* Orientation::mutable_no_orientation() {
  ::viam::app::v1::Orientation_NoOrientation* _msg = _internal_mutable_no_orientation();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.no_orientation)
  return _msg;
}

// .viam.app.v1.Orientation.OrientationVectorRadians vector_radians = 2 [json_name = "vectorRadians"];
inline bool Orientation::_internal_has_vector_radians() const {
  return type_case() == kVectorRadians;
}
inline bool Orientation::has_vector_radians() const {
  return _internal_has_vector_radians();
}
inline void Orientation::set_has_vector_radians() {
  _oneof_case_[0] = kVectorRadians;
}
inline void Orientation::clear_vector_radians() {
  if (_internal_has_vector_radians()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.vector_radians_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::release_vector_radians() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.vector_radians)
  if (_internal_has_vector_radians()) {
    clear_has_type();
    ::viam::app::v1::Orientation_OrientationVectorRadians* temp = type_.vector_radians_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.vector_radians_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_OrientationVectorRadians& Orientation::_internal_vector_radians() const {
  return _internal_has_vector_radians()
      ? *type_.vector_radians_
      : reinterpret_cast< ::viam::app::v1::Orientation_OrientationVectorRadians&>(::viam::app::v1::_Orientation_OrientationVectorRadians_default_instance_);
}
inline const ::viam::app::v1::Orientation_OrientationVectorRadians& Orientation::vector_radians() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.vector_radians)
  return _internal_vector_radians();
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::unsafe_arena_release_vector_radians() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.vector_radians)
  if (_internal_has_vector_radians()) {
    clear_has_type();
    ::viam::app::v1::Orientation_OrientationVectorRadians* temp = type_.vector_radians_;
    type_.vector_radians_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_vector_radians(::viam::app::v1::Orientation_OrientationVectorRadians* vector_radians) {
  clear_type();
  if (vector_radians) {
    set_has_vector_radians();
    type_.vector_radians_ = vector_radians;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.vector_radians)
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::_internal_mutable_vector_radians() {
  if (!_internal_has_vector_radians()) {
    clear_type();
    set_has_vector_radians();
    type_.vector_radians_ = CreateMaybeMessage< ::viam::app::v1::Orientation_OrientationVectorRadians >(GetArenaForAllocation());
  }
  return type_.vector_radians_;
}
inline ::viam::app::v1::Orientation_OrientationVectorRadians* Orientation::mutable_vector_radians() {
  ::viam::app::v1::Orientation_OrientationVectorRadians* _msg = _internal_mutable_vector_radians();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.vector_radians)
  return _msg;
}

// .viam.app.v1.Orientation.OrientationVectorDegrees vector_degrees = 3 [json_name = "vectorDegrees"];
inline bool Orientation::_internal_has_vector_degrees() const {
  return type_case() == kVectorDegrees;
}
inline bool Orientation::has_vector_degrees() const {
  return _internal_has_vector_degrees();
}
inline void Orientation::set_has_vector_degrees() {
  _oneof_case_[0] = kVectorDegrees;
}
inline void Orientation::clear_vector_degrees() {
  if (_internal_has_vector_degrees()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.vector_degrees_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::release_vector_degrees() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.vector_degrees)
  if (_internal_has_vector_degrees()) {
    clear_has_type();
    ::viam::app::v1::Orientation_OrientationVectorDegrees* temp = type_.vector_degrees_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.vector_degrees_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_OrientationVectorDegrees& Orientation::_internal_vector_degrees() const {
  return _internal_has_vector_degrees()
      ? *type_.vector_degrees_
      : reinterpret_cast< ::viam::app::v1::Orientation_OrientationVectorDegrees&>(::viam::app::v1::_Orientation_OrientationVectorDegrees_default_instance_);
}
inline const ::viam::app::v1::Orientation_OrientationVectorDegrees& Orientation::vector_degrees() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.vector_degrees)
  return _internal_vector_degrees();
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::unsafe_arena_release_vector_degrees() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.vector_degrees)
  if (_internal_has_vector_degrees()) {
    clear_has_type();
    ::viam::app::v1::Orientation_OrientationVectorDegrees* temp = type_.vector_degrees_;
    type_.vector_degrees_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_vector_degrees(::viam::app::v1::Orientation_OrientationVectorDegrees* vector_degrees) {
  clear_type();
  if (vector_degrees) {
    set_has_vector_degrees();
    type_.vector_degrees_ = vector_degrees;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.vector_degrees)
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::_internal_mutable_vector_degrees() {
  if (!_internal_has_vector_degrees()) {
    clear_type();
    set_has_vector_degrees();
    type_.vector_degrees_ = CreateMaybeMessage< ::viam::app::v1::Orientation_OrientationVectorDegrees >(GetArenaForAllocation());
  }
  return type_.vector_degrees_;
}
inline ::viam::app::v1::Orientation_OrientationVectorDegrees* Orientation::mutable_vector_degrees() {
  ::viam::app::v1::Orientation_OrientationVectorDegrees* _msg = _internal_mutable_vector_degrees();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.vector_degrees)
  return _msg;
}

// .viam.app.v1.Orientation.EulerAngles euler_angles = 4 [json_name = "eulerAngles"];
inline bool Orientation::_internal_has_euler_angles() const {
  return type_case() == kEulerAngles;
}
inline bool Orientation::has_euler_angles() const {
  return _internal_has_euler_angles();
}
inline void Orientation::set_has_euler_angles() {
  _oneof_case_[0] = kEulerAngles;
}
inline void Orientation::clear_euler_angles() {
  if (_internal_has_euler_angles()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.euler_angles_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::release_euler_angles() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.euler_angles)
  if (_internal_has_euler_angles()) {
    clear_has_type();
    ::viam::app::v1::Orientation_EulerAngles* temp = type_.euler_angles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_EulerAngles& Orientation::_internal_euler_angles() const {
  return _internal_has_euler_angles()
      ? *type_.euler_angles_
      : reinterpret_cast< ::viam::app::v1::Orientation_EulerAngles&>(::viam::app::v1::_Orientation_EulerAngles_default_instance_);
}
inline const ::viam::app::v1::Orientation_EulerAngles& Orientation::euler_angles() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.euler_angles)
  return _internal_euler_angles();
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::unsafe_arena_release_euler_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.euler_angles)
  if (_internal_has_euler_angles()) {
    clear_has_type();
    ::viam::app::v1::Orientation_EulerAngles* temp = type_.euler_angles_;
    type_.euler_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_euler_angles(::viam::app::v1::Orientation_EulerAngles* euler_angles) {
  clear_type();
  if (euler_angles) {
    set_has_euler_angles();
    type_.euler_angles_ = euler_angles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.euler_angles)
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::_internal_mutable_euler_angles() {
  if (!_internal_has_euler_angles()) {
    clear_type();
    set_has_euler_angles();
    type_.euler_angles_ = CreateMaybeMessage< ::viam::app::v1::Orientation_EulerAngles >(GetArenaForAllocation());
  }
  return type_.euler_angles_;
}
inline ::viam::app::v1::Orientation_EulerAngles* Orientation::mutable_euler_angles() {
  ::viam::app::v1::Orientation_EulerAngles* _msg = _internal_mutable_euler_angles();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.euler_angles)
  return _msg;
}

// .viam.app.v1.Orientation.AxisAngles axis_angles = 5 [json_name = "axisAngles"];
inline bool Orientation::_internal_has_axis_angles() const {
  return type_case() == kAxisAngles;
}
inline bool Orientation::has_axis_angles() const {
  return _internal_has_axis_angles();
}
inline void Orientation::set_has_axis_angles() {
  _oneof_case_[0] = kAxisAngles;
}
inline void Orientation::clear_axis_angles() {
  if (_internal_has_axis_angles()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.axis_angles_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::release_axis_angles() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.axis_angles)
  if (_internal_has_axis_angles()) {
    clear_has_type();
    ::viam::app::v1::Orientation_AxisAngles* temp = type_.axis_angles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.axis_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_AxisAngles& Orientation::_internal_axis_angles() const {
  return _internal_has_axis_angles()
      ? *type_.axis_angles_
      : reinterpret_cast< ::viam::app::v1::Orientation_AxisAngles&>(::viam::app::v1::_Orientation_AxisAngles_default_instance_);
}
inline const ::viam::app::v1::Orientation_AxisAngles& Orientation::axis_angles() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.axis_angles)
  return _internal_axis_angles();
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::unsafe_arena_release_axis_angles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.axis_angles)
  if (_internal_has_axis_angles()) {
    clear_has_type();
    ::viam::app::v1::Orientation_AxisAngles* temp = type_.axis_angles_;
    type_.axis_angles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_axis_angles(::viam::app::v1::Orientation_AxisAngles* axis_angles) {
  clear_type();
  if (axis_angles) {
    set_has_axis_angles();
    type_.axis_angles_ = axis_angles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.axis_angles)
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::_internal_mutable_axis_angles() {
  if (!_internal_has_axis_angles()) {
    clear_type();
    set_has_axis_angles();
    type_.axis_angles_ = CreateMaybeMessage< ::viam::app::v1::Orientation_AxisAngles >(GetArenaForAllocation());
  }
  return type_.axis_angles_;
}
inline ::viam::app::v1::Orientation_AxisAngles* Orientation::mutable_axis_angles() {
  ::viam::app::v1::Orientation_AxisAngles* _msg = _internal_mutable_axis_angles();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.axis_angles)
  return _msg;
}

// .viam.app.v1.Orientation.Quaternion quaternion = 6 [json_name = "quaternion"];
inline bool Orientation::_internal_has_quaternion() const {
  return type_case() == kQuaternion;
}
inline bool Orientation::has_quaternion() const {
  return _internal_has_quaternion();
}
inline void Orientation::set_has_quaternion() {
  _oneof_case_[0] = kQuaternion;
}
inline void Orientation::clear_quaternion() {
  if (_internal_has_quaternion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.quaternion_;
    }
    clear_has_type();
  }
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::release_quaternion() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Orientation.quaternion)
  if (_internal_has_quaternion()) {
    clear_has_type();
    ::viam::app::v1::Orientation_Quaternion* temp = type_.quaternion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::v1::Orientation_Quaternion& Orientation::_internal_quaternion() const {
  return _internal_has_quaternion()
      ? *type_.quaternion_
      : reinterpret_cast< ::viam::app::v1::Orientation_Quaternion&>(::viam::app::v1::_Orientation_Quaternion_default_instance_);
}
inline const ::viam::app::v1::Orientation_Quaternion& Orientation::quaternion() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Orientation.quaternion)
  return _internal_quaternion();
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.v1.Orientation.quaternion)
  if (_internal_has_quaternion()) {
    clear_has_type();
    ::viam::app::v1::Orientation_Quaternion* temp = type_.quaternion_;
    type_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Orientation::unsafe_arena_set_allocated_quaternion(::viam::app::v1::Orientation_Quaternion* quaternion) {
  clear_type();
  if (quaternion) {
    set_has_quaternion();
    type_.quaternion_ = quaternion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Orientation.quaternion)
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::_internal_mutable_quaternion() {
  if (!_internal_has_quaternion()) {
    clear_type();
    set_has_quaternion();
    type_.quaternion_ = CreateMaybeMessage< ::viam::app::v1::Orientation_Quaternion >(GetArenaForAllocation());
  }
  return type_.quaternion_;
}
inline ::viam::app::v1::Orientation_Quaternion* Orientation::mutable_quaternion() {
  ::viam::app::v1::Orientation_Quaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Orientation.quaternion)
  return _msg;
}

inline bool Orientation::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Orientation::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Orientation::TypeCase Orientation::type_case() const {
  return Orientation::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoteConfig

// string name = 1 [json_name = "name"];
inline void RemoteConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RemoteConfig::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.name)
}
inline std::string* RemoteConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.name)
  return _s;
}
inline const std::string& RemoteConfig::_internal_name() const {
  return name_.Get();
}
inline void RemoteConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteConfig::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteConfig::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.name)
  return name_.Release();
}
inline void RemoteConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.name)
}

// string address = 2 [json_name = "address"];
inline void RemoteConfig::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& RemoteConfig::address() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteConfig::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.address)
}
inline std::string* RemoteConfig::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.address)
  return _s;
}
inline const std::string& RemoteConfig::_internal_address() const {
  return address_.Get();
}
inline void RemoteConfig::_internal_set_address(const std::string& value) {
  
  address_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteConfig::_internal_mutable_address() {
  
  return address_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteConfig::release_address() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.address)
  return address_.Release();
}
inline void RemoteConfig::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault()) {
    address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.address)
}

// .viam.app.v1.Frame frame = 3 [json_name = "frame"];
inline bool RemoteConfig::_internal_has_frame() const {
  return this != internal_default_instance() && frame_ != nullptr;
}
inline bool RemoteConfig::has_frame() const {
  return _internal_has_frame();
}
inline void RemoteConfig::clear_frame() {
  if (GetArenaForAllocation() == nullptr && frame_ != nullptr) {
    delete frame_;
  }
  frame_ = nullptr;
}
inline const ::viam::app::v1::Frame& RemoteConfig::_internal_frame() const {
  const ::viam::app::v1::Frame* p = frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Frame&>(
      ::viam::app::v1::_Frame_default_instance_);
}
inline const ::viam::app::v1::Frame& RemoteConfig::frame() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.frame)
  return _internal_frame();
}
inline void RemoteConfig::unsafe_arena_set_allocated_frame(
    ::viam::app::v1::Frame* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.frame)
}
inline ::viam::app::v1::Frame* RemoteConfig::release_frame() {
  
  ::viam::app::v1::Frame* temp = frame_;
  frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Frame* RemoteConfig::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.frame)
  
  ::viam::app::v1::Frame* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Frame* RemoteConfig::_internal_mutable_frame() {
  
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Frame>(GetArenaForAllocation());
    frame_ = p;
  }
  return frame_;
}
inline ::viam::app::v1::Frame* RemoteConfig::mutable_frame() {
  ::viam::app::v1::Frame* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.frame)
  return _msg;
}
inline void RemoteConfig::set_allocated_frame(::viam::app::v1::Frame* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.frame)
}

// .viam.app.v1.RemoteAuth auth = 4 [json_name = "auth"];
inline bool RemoteConfig::_internal_has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline bool RemoteConfig::has_auth() const {
  return _internal_has_auth();
}
inline void RemoteConfig::clear_auth() {
  if (GetArenaForAllocation() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::viam::app::v1::RemoteAuth& RemoteConfig::_internal_auth() const {
  const ::viam::app::v1::RemoteAuth* p = auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RemoteAuth&>(
      ::viam::app::v1::_RemoteAuth_default_instance_);
}
inline const ::viam::app::v1::RemoteAuth& RemoteConfig::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.auth)
  return _internal_auth();
}
inline void RemoteConfig::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::RemoteAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_);
  }
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.auth)
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::release_auth() {
  
  ::viam::app::v1::RemoteAuth* temp = auth_;
  auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.auth)
  
  ::viam::app::v1::RemoteAuth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::_internal_mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RemoteAuth>(GetArenaForAllocation());
    auth_ = p;
  }
  return auth_;
}
inline ::viam::app::v1::RemoteAuth* RemoteConfig::mutable_auth() {
  ::viam::app::v1::RemoteAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.auth)
  return _msg;
}
inline void RemoteConfig::set_allocated_auth(::viam::app::v1::RemoteAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.auth)
}

// string managed_by = 5 [json_name = "managedBy"];
inline void RemoteConfig::clear_managed_by() {
  managed_by_.ClearToEmpty();
}
inline const std::string& RemoteConfig::managed_by() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.managed_by)
  return _internal_managed_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteConfig::set_managed_by(ArgT0&& arg0, ArgT... args) {
 
 managed_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.managed_by)
}
inline std::string* RemoteConfig::mutable_managed_by() {
  std::string* _s = _internal_mutable_managed_by();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.managed_by)
  return _s;
}
inline const std::string& RemoteConfig::_internal_managed_by() const {
  return managed_by_.Get();
}
inline void RemoteConfig::_internal_set_managed_by(const std::string& value) {
  
  managed_by_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteConfig::_internal_mutable_managed_by() {
  
  return managed_by_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteConfig::release_managed_by() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.managed_by)
  return managed_by_.Release();
}
inline void RemoteConfig::set_allocated_managed_by(std::string* managed_by) {
  if (managed_by != nullptr) {
    
  } else {
    
  }
  managed_by_.SetAllocated(managed_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (managed_by_.IsDefault()) {
    managed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.managed_by)
}

// bool insecure = 6 [json_name = "insecure"];
inline void RemoteConfig::clear_insecure() {
  insecure_ = false;
}
inline bool RemoteConfig::_internal_insecure() const {
  return insecure_;
}
inline bool RemoteConfig::insecure() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.insecure)
  return _internal_insecure();
}
inline void RemoteConfig::_internal_set_insecure(bool value) {
  
  insecure_ = value;
}
inline void RemoteConfig::set_insecure(bool value) {
  _internal_set_insecure(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.insecure)
}

// .google.protobuf.Duration connection_check_interval = 7 [json_name = "connectionCheckInterval"];
inline bool RemoteConfig::_internal_has_connection_check_interval() const {
  return this != internal_default_instance() && connection_check_interval_ != nullptr;
}
inline bool RemoteConfig::has_connection_check_interval() const {
  return _internal_has_connection_check_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& RemoteConfig::_internal_connection_check_interval() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = connection_check_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& RemoteConfig::connection_check_interval() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.connection_check_interval)
  return _internal_connection_check_interval();
}
inline void RemoteConfig::unsafe_arena_set_allocated_connection_check_interval(
    ::PROTOBUF_NAMESPACE_ID::Duration* connection_check_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_check_interval_);
  }
  connection_check_interval_ = connection_check_interval;
  if (connection_check_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.connection_check_interval)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::release_connection_check_interval() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = connection_check_interval_;
  connection_check_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::unsafe_arena_release_connection_check_interval() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.connection_check_interval)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = connection_check_interval_;
  connection_check_interval_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::_internal_mutable_connection_check_interval() {
  
  if (connection_check_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    connection_check_interval_ = p;
  }
  return connection_check_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::mutable_connection_check_interval() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_connection_check_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.connection_check_interval)
  return _msg;
}
inline void RemoteConfig::set_allocated_connection_check_interval(::PROTOBUF_NAMESPACE_ID::Duration* connection_check_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_check_interval_);
  }
  if (connection_check_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_check_interval));
    if (message_arena != submessage_arena) {
      connection_check_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_check_interval, submessage_arena);
    }
    
  } else {
    
  }
  connection_check_interval_ = connection_check_interval;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.connection_check_interval)
}

// .google.protobuf.Duration reconnect_interval = 8 [json_name = "reconnectInterval"];
inline bool RemoteConfig::_internal_has_reconnect_interval() const {
  return this != internal_default_instance() && reconnect_interval_ != nullptr;
}
inline bool RemoteConfig::has_reconnect_interval() const {
  return _internal_has_reconnect_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& RemoteConfig::_internal_reconnect_interval() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = reconnect_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& RemoteConfig::reconnect_interval() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.reconnect_interval)
  return _internal_reconnect_interval();
}
inline void RemoteConfig::unsafe_arena_set_allocated_reconnect_interval(
    ::PROTOBUF_NAMESPACE_ID::Duration* reconnect_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reconnect_interval_);
  }
  reconnect_interval_ = reconnect_interval;
  if (reconnect_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteConfig.reconnect_interval)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::release_reconnect_interval() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = reconnect_interval_;
  reconnect_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::unsafe_arena_release_reconnect_interval() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.reconnect_interval)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = reconnect_interval_;
  reconnect_interval_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::_internal_mutable_reconnect_interval() {
  
  if (reconnect_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    reconnect_interval_ = p;
  }
  return reconnect_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* RemoteConfig::mutable_reconnect_interval() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_reconnect_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.reconnect_interval)
  return _msg;
}
inline void RemoteConfig::set_allocated_reconnect_interval(::PROTOBUF_NAMESPACE_ID::Duration* reconnect_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reconnect_interval_);
  }
  if (reconnect_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reconnect_interval));
    if (message_arena != submessage_arena) {
      reconnect_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reconnect_interval, submessage_arena);
    }
    
  } else {
    
  }
  reconnect_interval_ = reconnect_interval;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.reconnect_interval)
}

// repeated .viam.app.v1.ResourceLevelServiceConfig service_configs = 9 [json_name = "serviceConfigs", (.tagger.v1.tags) = "json:\"service_config\""];
inline int RemoteConfig::_internal_service_configs_size() const {
  return service_configs_.size();
}
inline int RemoteConfig::service_configs_size() const {
  return _internal_service_configs_size();
}
inline void RemoteConfig::clear_service_configs() {
  service_configs_.Clear();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* RemoteConfig::mutable_service_configs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.service_configs)
  return service_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >*
RemoteConfig::mutable_service_configs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RemoteConfig.service_configs)
  return &service_configs_;
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& RemoteConfig::_internal_service_configs(int index) const {
  return service_configs_.Get(index);
}
inline const ::viam::app::v1::ResourceLevelServiceConfig& RemoteConfig::service_configs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.service_configs)
  return _internal_service_configs(index);
}
inline ::viam::app::v1::ResourceLevelServiceConfig* RemoteConfig::_internal_add_service_configs() {
  return service_configs_.Add();
}
inline ::viam::app::v1::ResourceLevelServiceConfig* RemoteConfig::add_service_configs() {
  ::viam::app::v1::ResourceLevelServiceConfig* _add = _internal_add_service_configs();
  // @@protoc_insertion_point(field_add:viam.app.v1.RemoteConfig.service_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::ResourceLevelServiceConfig >&
RemoteConfig::service_configs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RemoteConfig.service_configs)
  return service_configs_;
}

// string secret = 10 [json_name = "secret"];
inline void RemoteConfig::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& RemoteConfig::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteConfig.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteConfig::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteConfig.secret)
}
inline std::string* RemoteConfig::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteConfig.secret)
  return _s;
}
inline const std::string& RemoteConfig::_internal_secret() const {
  return secret_.Get();
}
inline void RemoteConfig::_internal_set_secret(const std::string& value) {
  
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteConfig::_internal_mutable_secret() {
  
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteConfig::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteConfig.secret)
  return secret_.Release();
}
inline void RemoteConfig::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteConfig.secret)
}

// -------------------------------------------------------------------

// RemoteAuth_Credentials

// .viam.app.v1.CredentialsType type = 1 [json_name = "type"];
inline void RemoteAuth_Credentials::clear_type() {
  type_ = 0;
}
inline ::viam::app::v1::CredentialsType RemoteAuth_Credentials::_internal_type() const {
  return static_cast< ::viam::app::v1::CredentialsType >(type_);
}
inline ::viam::app::v1::CredentialsType RemoteAuth_Credentials::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.Credentials.type)
  return _internal_type();
}
inline void RemoteAuth_Credentials::_internal_set_type(::viam::app::v1::CredentialsType value) {
  
  type_ = value;
}
inline void RemoteAuth_Credentials::set_type(::viam::app::v1::CredentialsType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteAuth.Credentials.type)
}

// string payload = 2 [json_name = "payload"];
inline void RemoteAuth_Credentials::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& RemoteAuth_Credentials::payload() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.Credentials.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteAuth_Credentials::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteAuth.Credentials.payload)
}
inline std::string* RemoteAuth_Credentials::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteAuth.Credentials.payload)
  return _s;
}
inline const std::string& RemoteAuth_Credentials::_internal_payload() const {
  return payload_.Get();
}
inline void RemoteAuth_Credentials::_internal_set_payload(const std::string& value) {
  
  payload_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteAuth_Credentials::_internal_mutable_payload() {
  
  return payload_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteAuth_Credentials::release_payload() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteAuth.Credentials.payload)
  return payload_.Release();
}
inline void RemoteAuth_Credentials::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault()) {
    payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteAuth.Credentials.payload)
}

// -------------------------------------------------------------------

// RemoteAuth

// .viam.app.v1.RemoteAuth.Credentials credentials = 1 [json_name = "credentials"];
inline bool RemoteAuth::_internal_has_credentials() const {
  return this != internal_default_instance() && credentials_ != nullptr;
}
inline bool RemoteAuth::has_credentials() const {
  return _internal_has_credentials();
}
inline void RemoteAuth::clear_credentials() {
  if (GetArenaForAllocation() == nullptr && credentials_ != nullptr) {
    delete credentials_;
  }
  credentials_ = nullptr;
}
inline const ::viam::app::v1::RemoteAuth_Credentials& RemoteAuth::_internal_credentials() const {
  const ::viam::app::v1::RemoteAuth_Credentials* p = credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RemoteAuth_Credentials&>(
      ::viam::app::v1::_RemoteAuth_Credentials_default_instance_);
}
inline const ::viam::app::v1::RemoteAuth_Credentials& RemoteAuth::credentials() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.credentials)
  return _internal_credentials();
}
inline void RemoteAuth::unsafe_arena_set_allocated_credentials(
    ::viam::app::v1::RemoteAuth_Credentials* credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(credentials_);
  }
  credentials_ = credentials;
  if (credentials) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RemoteAuth.credentials)
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::release_credentials() {
  
  ::viam::app::v1::RemoteAuth_Credentials* temp = credentials_;
  credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteAuth.credentials)
  
  ::viam::app::v1::RemoteAuth_Credentials* temp = credentials_;
  credentials_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::_internal_mutable_credentials() {
  
  if (credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RemoteAuth_Credentials>(GetArenaForAllocation());
    credentials_ = p;
  }
  return credentials_;
}
inline ::viam::app::v1::RemoteAuth_Credentials* RemoteAuth::mutable_credentials() {
  ::viam::app::v1::RemoteAuth_Credentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteAuth.credentials)
  return _msg;
}
inline void RemoteAuth::set_allocated_credentials(::viam::app::v1::RemoteAuth_Credentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete credentials_;
  }
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credentials);
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    
  } else {
    
  }
  credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteAuth.credentials)
}

// string entity = 2 [json_name = "entity"];
inline void RemoteAuth::clear_entity() {
  entity_.ClearToEmpty();
}
inline const std::string& RemoteAuth::entity() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RemoteAuth.entity)
  return _internal_entity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteAuth::set_entity(ArgT0&& arg0, ArgT... args) {
 
 entity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RemoteAuth.entity)
}
inline std::string* RemoteAuth::mutable_entity() {
  std::string* _s = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RemoteAuth.entity)
  return _s;
}
inline const std::string& RemoteAuth::_internal_entity() const {
  return entity_.Get();
}
inline void RemoteAuth::_internal_set_entity(const std::string& value) {
  
  entity_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteAuth::_internal_mutable_entity() {
  
  return entity_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteAuth::release_entity() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RemoteAuth.entity)
  return entity_.Release();
}
inline void RemoteAuth::set_allocated_entity(std::string* entity) {
  if (entity != nullptr) {
    
  } else {
    
  }
  entity_.SetAllocated(entity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entity_.IsDefault()) {
    entity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RemoteAuth.entity)
}

// -------------------------------------------------------------------

// AgentInfo

// string host = 1 [json_name = "host"];
inline void AgentInfo::clear_host() {
  host_.ClearToEmpty();
}
inline const std::string& AgentInfo::host() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentInfo::set_host(ArgT0&& arg0, ArgT... args) {
 
 host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.host)
}
inline std::string* AgentInfo::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.host)
  return _s;
}
inline const std::string& AgentInfo::_internal_host() const {
  return host_.Get();
}
inline void AgentInfo::_internal_set_host(const std::string& value) {
  
  host_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentInfo::_internal_mutable_host() {
  
  return host_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentInfo::release_host() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.host)
  return host_.Release();
}
inline void AgentInfo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault()) {
    host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.host)
}

// string os = 2 [json_name = "os"];
inline void AgentInfo::clear_os() {
  os_.ClearToEmpty();
}
inline const std::string& AgentInfo::os() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentInfo::set_os(ArgT0&& arg0, ArgT... args) {
 
 os_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.os)
}
inline std::string* AgentInfo::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.os)
  return _s;
}
inline const std::string& AgentInfo::_internal_os() const {
  return os_.Get();
}
inline void AgentInfo::_internal_set_os(const std::string& value) {
  
  os_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentInfo::_internal_mutable_os() {
  
  return os_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentInfo::release_os() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.os)
  return os_.Release();
}
inline void AgentInfo::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  os_.SetAllocated(os, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault()) {
    os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.os)
}

// repeated string ips = 3 [json_name = "ips"];
inline int AgentInfo::_internal_ips_size() const {
  return ips_.size();
}
inline int AgentInfo::ips_size() const {
  return _internal_ips_size();
}
inline void AgentInfo::clear_ips() {
  ips_.Clear();
}
inline std::string* AgentInfo::add_ips() {
  std::string* _s = _internal_add_ips();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.AgentInfo.ips)
  return _s;
}
inline const std::string& AgentInfo::_internal_ips(int index) const {
  return ips_.Get(index);
}
inline const std::string& AgentInfo::ips(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.ips)
  return _internal_ips(index);
}
inline std::string* AgentInfo::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.ips)
  return ips_.Mutable(index);
}
inline void AgentInfo::set_ips(int index, const std::string& value) {
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::set_ips(int index, std::string&& value) {
  ips_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::set_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.AgentInfo.ips)
}
inline std::string* AgentInfo::_internal_add_ips() {
  return ips_.Add();
}
inline void AgentInfo::add_ips(const std::string& value) {
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(std::string&& value) {
  ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.AgentInfo.ips)
}
inline void AgentInfo::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.AgentInfo.ips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AgentInfo::ips() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.AgentInfo.ips)
  return ips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AgentInfo::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AgentInfo.ips)
  return &ips_;
}

// string version = 4 [json_name = "version"];
inline void AgentInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& AgentInfo::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.version)
}
inline std::string* AgentInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.version)
  return _s;
}
inline const std::string& AgentInfo::_internal_version() const {
  return version_.Get();
}
inline void AgentInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentInfo::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentInfo::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.version)
  return version_.Release();
}
inline void AgentInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.version)
}

// string git_revision = 5 [json_name = "gitRevision"];
inline void AgentInfo::clear_git_revision() {
  git_revision_.ClearToEmpty();
}
inline const std::string& AgentInfo::git_revision() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.git_revision)
  return _internal_git_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentInfo::set_git_revision(ArgT0&& arg0, ArgT... args) {
 
 git_revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.git_revision)
}
inline std::string* AgentInfo::mutable_git_revision() {
  std::string* _s = _internal_mutable_git_revision();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.git_revision)
  return _s;
}
inline const std::string& AgentInfo::_internal_git_revision() const {
  return git_revision_.Get();
}
inline void AgentInfo::_internal_set_git_revision(const std::string& value) {
  
  git_revision_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentInfo::_internal_mutable_git_revision() {
  
  return git_revision_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentInfo::release_git_revision() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.git_revision)
  return git_revision_.Release();
}
inline void AgentInfo::set_allocated_git_revision(std::string* git_revision) {
  if (git_revision != nullptr) {
    
  } else {
    
  }
  git_revision_.SetAllocated(git_revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (git_revision_.IsDefault()) {
    git_revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.git_revision)
}

// optional string platform = 6 [json_name = "platform"];
inline bool AgentInfo::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AgentInfo::has_platform() const {
  return _internal_has_platform();
}
inline void AgentInfo::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AgentInfo::platform() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentInfo::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.platform)
}
inline std::string* AgentInfo::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.platform)
  return _s;
}
inline const std::string& AgentInfo::_internal_platform() const {
  return platform_.Get();
}
inline void AgentInfo::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentInfo::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000001u;
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentInfo::release_platform() {
  // @@protoc_insertion_point(field_release:viam.app.v1.AgentInfo.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = platform_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AgentInfo::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.AgentInfo.platform)
}

// repeated string platform_tags = 7 [json_name = "platformTags"];
inline int AgentInfo::_internal_platform_tags_size() const {
  return platform_tags_.size();
}
inline int AgentInfo::platform_tags_size() const {
  return _internal_platform_tags_size();
}
inline void AgentInfo::clear_platform_tags() {
  platform_tags_.Clear();
}
inline std::string* AgentInfo::add_platform_tags() {
  std::string* _s = _internal_add_platform_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.v1.AgentInfo.platform_tags)
  return _s;
}
inline const std::string& AgentInfo::_internal_platform_tags(int index) const {
  return platform_tags_.Get(index);
}
inline const std::string& AgentInfo::platform_tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.AgentInfo.platform_tags)
  return _internal_platform_tags(index);
}
inline std::string* AgentInfo::mutable_platform_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.AgentInfo.platform_tags)
  return platform_tags_.Mutable(index);
}
inline void AgentInfo::set_platform_tags(int index, const std::string& value) {
  platform_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.platform_tags)
}
inline void AgentInfo::set_platform_tags(int index, std::string&& value) {
  platform_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.v1.AgentInfo.platform_tags)
}
inline void AgentInfo::set_platform_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platform_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.v1.AgentInfo.platform_tags)
}
inline void AgentInfo::set_platform_tags(int index, const char* value, size_t size) {
  platform_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.v1.AgentInfo.platform_tags)
}
inline std::string* AgentInfo::_internal_add_platform_tags() {
  return platform_tags_.Add();
}
inline void AgentInfo::add_platform_tags(const std::string& value) {
  platform_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.v1.AgentInfo.platform_tags)
}
inline void AgentInfo::add_platform_tags(std::string&& value) {
  platform_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.v1.AgentInfo.platform_tags)
}
inline void AgentInfo::add_platform_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  platform_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.v1.AgentInfo.platform_tags)
}
inline void AgentInfo::add_platform_tags(const char* value, size_t size) {
  platform_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.v1.AgentInfo.platform_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AgentInfo::platform_tags() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.AgentInfo.platform_tags)
  return platform_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AgentInfo::mutable_platform_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.AgentInfo.platform_tags)
  return &platform_tags_;
}

// -------------------------------------------------------------------

// ConfigRequest

// string id = 1 [json_name = "id"];
inline void ConfigRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ConfigRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ConfigRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ConfigRequest.id)
}
inline std::string* ConfigRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ConfigRequest.id)
  return _s;
}
inline const std::string& ConfigRequest::_internal_id() const {
  return id_.Get();
}
inline void ConfigRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ConfigRequest.id)
  return id_.Release();
}
inline void ConfigRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ConfigRequest.id)
}

// optional .viam.app.v1.AgentInfo agent_info = 2 [json_name = "agentInfo"];
inline bool ConfigRequest::_internal_has_agent_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || agent_info_ != nullptr);
  return value;
}
inline bool ConfigRequest::has_agent_info() const {
  return _internal_has_agent_info();
}
inline void ConfigRequest::clear_agent_info() {
  if (agent_info_ != nullptr) agent_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::app::v1::AgentInfo& ConfigRequest::_internal_agent_info() const {
  const ::viam::app::v1::AgentInfo* p = agent_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AgentInfo&>(
      ::viam::app::v1::_AgentInfo_default_instance_);
}
inline const ::viam::app::v1::AgentInfo& ConfigRequest::agent_info() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ConfigRequest.agent_info)
  return _internal_agent_info();
}
inline void ConfigRequest::unsafe_arena_set_allocated_agent_info(
    ::viam::app::v1::AgentInfo* agent_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(agent_info_);
  }
  agent_info_ = agent_info;
  if (agent_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ConfigRequest.agent_info)
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::release_agent_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AgentInfo* temp = agent_info_;
  agent_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::unsafe_arena_release_agent_info() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ConfigRequest.agent_info)
  _has_bits_[0] &= ~0x00000001u;
  ::viam::app::v1::AgentInfo* temp = agent_info_;
  agent_info_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::_internal_mutable_agent_info() {
  _has_bits_[0] |= 0x00000001u;
  if (agent_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AgentInfo>(GetArenaForAllocation());
    agent_info_ = p;
  }
  return agent_info_;
}
inline ::viam::app::v1::AgentInfo* ConfigRequest::mutable_agent_info() {
  ::viam::app::v1::AgentInfo* _msg = _internal_mutable_agent_info();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ConfigRequest.agent_info)
  return _msg;
}
inline void ConfigRequest::set_allocated_agent_info(::viam::app::v1::AgentInfo* agent_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete agent_info_;
  }
  if (agent_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(agent_info);
    if (message_arena != submessage_arena) {
      agent_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agent_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  agent_info_ = agent_info;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ConfigRequest.agent_info)
}

// -------------------------------------------------------------------

// ConfigResponse

// .viam.app.v1.RobotConfig config = 1 [json_name = "config"];
inline bool ConfigResponse::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool ConfigResponse::has_config() const {
  return _internal_has_config();
}
inline void ConfigResponse::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::viam::app::v1::RobotConfig& ConfigResponse::_internal_config() const {
  const ::viam::app::v1::RobotConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotConfig&>(
      ::viam::app::v1::_RobotConfig_default_instance_);
}
inline const ::viam::app::v1::RobotConfig& ConfigResponse::config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ConfigResponse.config)
  return _internal_config();
}
inline void ConfigResponse::unsafe_arena_set_allocated_config(
    ::viam::app::v1::RobotConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ConfigResponse.config)
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::release_config() {
  
  ::viam::app::v1::RobotConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ConfigResponse.config)
  
  ::viam::app::v1::RobotConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::viam::app::v1::RobotConfig* ConfigResponse::mutable_config() {
  ::viam::app::v1::RobotConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ConfigResponse.config)
  return _msg;
}
inline void ConfigResponse::set_allocated_config(::viam::app::v1::RobotConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ConfigResponse.config)
}

// -------------------------------------------------------------------

// CertificateRequest

// string id = 1 [json_name = "id"];
inline void CertificateRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CertificateRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertificateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateRequest.id)
}
inline std::string* CertificateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateRequest.id)
  return _s;
}
inline const std::string& CertificateRequest::_internal_id() const {
  return id_.Get();
}
inline void CertificateRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CertificateRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CertificateRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateRequest.id)
  return id_.Release();
}
inline void CertificateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateRequest.id)
}

// -------------------------------------------------------------------

// CertificateResponse

// string id = 1 [json_name = "id"];
inline void CertificateResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CertificateResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertificateResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateResponse.id)
}
inline std::string* CertificateResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateResponse.id)
  return _s;
}
inline const std::string& CertificateResponse::_internal_id() const {
  return id_.Get();
}
inline void CertificateResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CertificateResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CertificateResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateResponse.id)
  return id_.Release();
}
inline void CertificateResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateResponse.id)
}

// string tls_certificate = 2 [json_name = "tlsCertificate"];
inline void CertificateResponse::clear_tls_certificate() {
  tls_certificate_.ClearToEmpty();
}
inline const std::string& CertificateResponse::tls_certificate() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateResponse.tls_certificate)
  return _internal_tls_certificate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertificateResponse::set_tls_certificate(ArgT0&& arg0, ArgT... args) {
 
 tls_certificate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateResponse.tls_certificate)
}
inline std::string* CertificateResponse::mutable_tls_certificate() {
  std::string* _s = _internal_mutable_tls_certificate();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateResponse.tls_certificate)
  return _s;
}
inline const std::string& CertificateResponse::_internal_tls_certificate() const {
  return tls_certificate_.Get();
}
inline void CertificateResponse::_internal_set_tls_certificate(const std::string& value) {
  
  tls_certificate_.Set(value, GetArenaForAllocation());
}
inline std::string* CertificateResponse::_internal_mutable_tls_certificate() {
  
  return tls_certificate_.Mutable(GetArenaForAllocation());
}
inline std::string* CertificateResponse::release_tls_certificate() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateResponse.tls_certificate)
  return tls_certificate_.Release();
}
inline void CertificateResponse::set_allocated_tls_certificate(std::string* tls_certificate) {
  if (tls_certificate != nullptr) {
    
  } else {
    
  }
  tls_certificate_.SetAllocated(tls_certificate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tls_certificate_.IsDefault()) {
    tls_certificate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateResponse.tls_certificate)
}

// string tls_private_key = 3 [json_name = "tlsPrivateKey"];
inline void CertificateResponse::clear_tls_private_key() {
  tls_private_key_.ClearToEmpty();
}
inline const std::string& CertificateResponse::tls_private_key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CertificateResponse.tls_private_key)
  return _internal_tls_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertificateResponse::set_tls_private_key(ArgT0&& arg0, ArgT... args) {
 
 tls_private_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CertificateResponse.tls_private_key)
}
inline std::string* CertificateResponse::mutable_tls_private_key() {
  std::string* _s = _internal_mutable_tls_private_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CertificateResponse.tls_private_key)
  return _s;
}
inline const std::string& CertificateResponse::_internal_tls_private_key() const {
  return tls_private_key_.Get();
}
inline void CertificateResponse::_internal_set_tls_private_key(const std::string& value) {
  
  tls_private_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CertificateResponse::_internal_mutable_tls_private_key() {
  
  return tls_private_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CertificateResponse::release_tls_private_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CertificateResponse.tls_private_key)
  return tls_private_key_.Release();
}
inline void CertificateResponse::set_allocated_tls_private_key(std::string* tls_private_key) {
  if (tls_private_key != nullptr) {
    
  } else {
    
  }
  tls_private_key_.SetAllocated(tls_private_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tls_private_key_.IsDefault()) {
    tls_private_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CertificateResponse.tls_private_key)
}

// -------------------------------------------------------------------

// LogRequest

// string id = 1 [json_name = "id"];
inline void LogRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& LogRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogRequest.id)
}
inline std::string* LogRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogRequest.id)
  return _s;
}
inline const std::string& LogRequest::_internal_id() const {
  return id_.Get();
}
inline void LogRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* LogRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* LogRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogRequest.id)
  return id_.Release();
}
inline void LogRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogRequest.id)
}

// repeated .viam.common.v1.LogEntry logs = 2 [json_name = "logs"];
inline int LogRequest::_internal_logs_size() const {
  return logs_.size();
}
inline int LogRequest::logs_size() const {
  return _internal_logs_size();
}
inline ::viam::common::v1::LogEntry* LogRequest::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogRequest.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >*
LogRequest::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.LogRequest.logs)
  return &logs_;
}
inline const ::viam::common::v1::LogEntry& LogRequest::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::viam::common::v1::LogEntry& LogRequest::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogRequest.logs)
  return _internal_logs(index);
}
inline ::viam::common::v1::LogEntry* LogRequest::_internal_add_logs() {
  return logs_.Add();
}
inline ::viam::common::v1::LogEntry* LogRequest::add_logs() {
  ::viam::common::v1::LogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.v1.LogRequest.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::LogEntry >&
LogRequest::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.LogRequest.logs)
  return logs_;
}

// -------------------------------------------------------------------

// LogResponse

// -------------------------------------------------------------------

// NeedsRestartRequest

// string id = 1 [json_name = "id"];
inline void NeedsRestartRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& NeedsRestartRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NeedsRestartRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NeedsRestartRequest.id)
}
inline std::string* NeedsRestartRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NeedsRestartRequest.id)
  return _s;
}
inline const std::string& NeedsRestartRequest::_internal_id() const {
  return id_.Get();
}
inline void NeedsRestartRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* NeedsRestartRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* NeedsRestartRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NeedsRestartRequest.id)
  return id_.Release();
}
inline void NeedsRestartRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NeedsRestartRequest.id)
}

// -------------------------------------------------------------------

// NeedsRestartResponse

// string id = 1 [json_name = "id"];
inline void NeedsRestartResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& NeedsRestartResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NeedsRestartResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NeedsRestartResponse.id)
}
inline std::string* NeedsRestartResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NeedsRestartResponse.id)
  return _s;
}
inline const std::string& NeedsRestartResponse::_internal_id() const {
  return id_.Get();
}
inline void NeedsRestartResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* NeedsRestartResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* NeedsRestartResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NeedsRestartResponse.id)
  return id_.Release();
}
inline void NeedsRestartResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NeedsRestartResponse.id)
}

// bool must_restart = 2 [json_name = "mustRestart"];
inline void NeedsRestartResponse::clear_must_restart() {
  must_restart_ = false;
}
inline bool NeedsRestartResponse::_internal_must_restart() const {
  return must_restart_;
}
inline bool NeedsRestartResponse::must_restart() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartResponse.must_restart)
  return _internal_must_restart();
}
inline void NeedsRestartResponse::_internal_set_must_restart(bool value) {
  
  must_restart_ = value;
}
inline void NeedsRestartResponse::set_must_restart(bool value) {
  _internal_set_must_restart(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.NeedsRestartResponse.must_restart)
}

// .google.protobuf.Duration restart_check_interval = 3 [json_name = "restartCheckInterval"];
inline bool NeedsRestartResponse::_internal_has_restart_check_interval() const {
  return this != internal_default_instance() && restart_check_interval_ != nullptr;
}
inline bool NeedsRestartResponse::has_restart_check_interval() const {
  return _internal_has_restart_check_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& NeedsRestartResponse::_internal_restart_check_interval() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = restart_check_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& NeedsRestartResponse::restart_check_interval() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NeedsRestartResponse.restart_check_interval)
  return _internal_restart_check_interval();
}
inline void NeedsRestartResponse::unsafe_arena_set_allocated_restart_check_interval(
    ::PROTOBUF_NAMESPACE_ID::Duration* restart_check_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(restart_check_interval_);
  }
  restart_check_interval_ = restart_check_interval;
  if (restart_check_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.NeedsRestartResponse.restart_check_interval)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NeedsRestartResponse::release_restart_check_interval() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = restart_check_interval_;
  restart_check_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NeedsRestartResponse::unsafe_arena_release_restart_check_interval() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NeedsRestartResponse.restart_check_interval)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = restart_check_interval_;
  restart_check_interval_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NeedsRestartResponse::_internal_mutable_restart_check_interval() {
  
  if (restart_check_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    restart_check_interval_ = p;
  }
  return restart_check_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* NeedsRestartResponse::mutable_restart_check_interval() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_restart_check_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NeedsRestartResponse.restart_check_interval)
  return _msg;
}
inline void NeedsRestartResponse::set_allocated_restart_check_interval(::PROTOBUF_NAMESPACE_ID::Duration* restart_check_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(restart_check_interval_);
  }
  if (restart_check_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(restart_check_interval));
    if (message_arena != submessage_arena) {
      restart_check_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, restart_check_interval, submessage_arena);
    }
    
  } else {
    
  }
  restart_check_interval_ = restart_check_interval;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NeedsRestartResponse.restart_check_interval)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModuleConfig

// string name = 1 [json_name = "name"];
inline void ModuleConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModuleConfig::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.name)
}
inline std::string* ModuleConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.name)
  return _s;
}
inline const std::string& ModuleConfig::_internal_name() const {
  return name_.Get();
}
inline void ModuleConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.name)
  return name_.Release();
}
inline void ModuleConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.name)
}

// string path = 2 [json_name = "path"];
inline void ModuleConfig::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& ModuleConfig::path() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.path)
}
inline std::string* ModuleConfig::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.path)
  return _s;
}
inline const std::string& ModuleConfig::_internal_path() const {
  return path_.Get();
}
inline void ModuleConfig::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig::release_path() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.path)
  return path_.Release();
}
inline void ModuleConfig::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.path)
}

// string log_level = 3 [json_name = "logLevel"];
inline void ModuleConfig::clear_log_level() {
  log_level_.ClearToEmpty();
}
inline const std::string& ModuleConfig::log_level() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.log_level)
  return _internal_log_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig::set_log_level(ArgT0&& arg0, ArgT... args) {
 
 log_level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.log_level)
}
inline std::string* ModuleConfig::mutable_log_level() {
  std::string* _s = _internal_mutable_log_level();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.log_level)
  return _s;
}
inline const std::string& ModuleConfig::_internal_log_level() const {
  return log_level_.Get();
}
inline void ModuleConfig::_internal_set_log_level(const std::string& value) {
  
  log_level_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig::_internal_mutable_log_level() {
  
  return log_level_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig::release_log_level() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.log_level)
  return log_level_.Release();
}
inline void ModuleConfig::set_allocated_log_level(std::string* log_level) {
  if (log_level != nullptr) {
    
  } else {
    
  }
  log_level_.SetAllocated(log_level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_level_.IsDefault()) {
    log_level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.log_level)
}

// string type = 4 [json_name = "type"];
inline void ModuleConfig::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ModuleConfig::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.type)
}
inline std::string* ModuleConfig::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.type)
  return _s;
}
inline const std::string& ModuleConfig::_internal_type() const {
  return type_.Get();
}
inline void ModuleConfig::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig::release_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.type)
  return type_.Release();
}
inline void ModuleConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.type)
}

// string module_id = 5 [json_name = "moduleId"];
inline void ModuleConfig::clear_module_id() {
  module_id_.ClearToEmpty();
}
inline const std::string& ModuleConfig::module_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.module_id)
}
inline std::string* ModuleConfig::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.module_id)
  return _s;
}
inline const std::string& ModuleConfig::_internal_module_id() const {
  return module_id_.Get();
}
inline void ModuleConfig::_internal_set_module_id(const std::string& value) {
  
  module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig::_internal_mutable_module_id() {
  
  return module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig::release_module_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.module_id)
  return module_id_.Release();
}
inline void ModuleConfig::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (module_id_.IsDefault()) {
    module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.module_id)
}

// map<string, string> env = 6 [json_name = "env"];
inline int ModuleConfig::_internal_env_size() const {
  return env_.size();
}
inline int ModuleConfig::env_size() const {
  return _internal_env_size();
}
inline void ModuleConfig::clear_env() {
  env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModuleConfig::_internal_env() const {
  return env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModuleConfig::env() const {
  // @@protoc_insertion_point(field_map:viam.app.v1.ModuleConfig.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModuleConfig::_internal_mutable_env() {
  return env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModuleConfig::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.v1.ModuleConfig.env)
  return _internal_mutable_env();
}

// .viam.app.v1.AppValidationStatus status = 7 [json_name = "status"];
inline bool ModuleConfig::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ModuleConfig::has_status() const {
  return _internal_has_status();
}
inline void ModuleConfig::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::viam::app::v1::AppValidationStatus& ModuleConfig::_internal_status() const {
  const ::viam::app::v1::AppValidationStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AppValidationStatus&>(
      ::viam::app::v1::_AppValidationStatus_default_instance_);
}
inline const ::viam::app::v1::AppValidationStatus& ModuleConfig::status() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.status)
  return _internal_status();
}
inline void ModuleConfig::unsafe_arena_set_allocated_status(
    ::viam::app::v1::AppValidationStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ModuleConfig.status)
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::release_status() {
  
  ::viam::app::v1::AppValidationStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.status)
  
  ::viam::app::v1::AppValidationStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AppValidationStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::viam::app::v1::AppValidationStatus* ModuleConfig::mutable_status() {
  ::viam::app::v1::AppValidationStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.status)
  return _msg;
}
inline void ModuleConfig::set_allocated_status(::viam::app::v1::AppValidationStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.status)
}

// .google.protobuf.Duration first_run_timeout = 8 [json_name = "firstRunTimeout"];
inline bool ModuleConfig::_internal_has_first_run_timeout() const {
  return this != internal_default_instance() && first_run_timeout_ != nullptr;
}
inline bool ModuleConfig::has_first_run_timeout() const {
  return _internal_has_first_run_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ModuleConfig::_internal_first_run_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = first_run_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ModuleConfig::first_run_timeout() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.first_run_timeout)
  return _internal_first_run_timeout();
}
inline void ModuleConfig::unsafe_arena_set_allocated_first_run_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* first_run_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_run_timeout_);
  }
  first_run_timeout_ = first_run_timeout;
  if (first_run_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.ModuleConfig.first_run_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ModuleConfig::release_first_run_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = first_run_timeout_;
  first_run_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ModuleConfig::unsafe_arena_release_first_run_timeout() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ModuleConfig.first_run_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = first_run_timeout_;
  first_run_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ModuleConfig::_internal_mutable_first_run_timeout() {
  
  if (first_run_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    first_run_timeout_ = p;
  }
  return first_run_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ModuleConfig::mutable_first_run_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_first_run_timeout();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ModuleConfig.first_run_timeout)
  return _msg;
}
inline void ModuleConfig::set_allocated_first_run_timeout(::PROTOBUF_NAMESPACE_ID::Duration* first_run_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_run_timeout_);
  }
  if (first_run_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_run_timeout));
    if (message_arena != submessage_arena) {
      first_run_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_run_timeout, submessage_arena);
    }
    
  } else {
    
  }
  first_run_timeout_ = first_run_timeout;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ModuleConfig.first_run_timeout)
}

// bool tcp_mode = 9 [json_name = "tcpMode"];
inline void ModuleConfig::clear_tcp_mode() {
  tcp_mode_ = false;
}
inline bool ModuleConfig::_internal_tcp_mode() const {
  return tcp_mode_;
}
inline bool ModuleConfig::tcp_mode() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ModuleConfig.tcp_mode)
  return _internal_tcp_mode();
}
inline void ModuleConfig::_internal_set_tcp_mode(bool value) {
  
  tcp_mode_ = value;
}
inline void ModuleConfig::set_tcp_mode(bool value) {
  _internal_set_tcp_mode(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.ModuleConfig.tcp_mode)
}

// -------------------------------------------------------------------

// PackageConfig

// string name = 1 [json_name = "name"];
inline void PackageConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PackageConfig::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackageConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.name)
}
inline std::string* PackageConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.name)
  return _s;
}
inline const std::string& PackageConfig::_internal_name() const {
  return name_.Get();
}
inline void PackageConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* PackageConfig::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* PackageConfig::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.name)
  return name_.Release();
}
inline void PackageConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.name)
}

// string package = 2 [json_name = "package"];
inline void PackageConfig::clear_package() {
  package_.ClearToEmpty();
}
inline const std::string& PackageConfig::package() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.package)
  return _internal_package();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackageConfig::set_package(ArgT0&& arg0, ArgT... args) {
 
 package_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.package)
}
inline std::string* PackageConfig::mutable_package() {
  std::string* _s = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.package)
  return _s;
}
inline const std::string& PackageConfig::_internal_package() const {
  return package_.Get();
}
inline void PackageConfig::_internal_set_package(const std::string& value) {
  
  package_.Set(value, GetArenaForAllocation());
}
inline std::string* PackageConfig::_internal_mutable_package() {
  
  return package_.Mutable(GetArenaForAllocation());
}
inline std::string* PackageConfig::release_package() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.package)
  return package_.Release();
}
inline void PackageConfig::set_allocated_package(std::string* package) {
  if (package != nullptr) {
    
  } else {
    
  }
  package_.SetAllocated(package, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (package_.IsDefault()) {
    package_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.package)
}

// string version = 3 [json_name = "version"];
inline void PackageConfig::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& PackageConfig::version() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackageConfig::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.version)
}
inline std::string* PackageConfig::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.version)
  return _s;
}
inline const std::string& PackageConfig::_internal_version() const {
  return version_.Get();
}
inline void PackageConfig::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* PackageConfig::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* PackageConfig::release_version() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.version)
  return version_.Release();
}
inline void PackageConfig::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.version)
}

// string type = 4 [json_name = "type"];
inline void PackageConfig::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& PackageConfig::type() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackageConfig::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.PackageConfig.type)
}
inline std::string* PackageConfig::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.type)
  return _s;
}
inline const std::string& PackageConfig::_internal_type() const {
  return type_.Get();
}
inline void PackageConfig::_internal_set_type(const std::string& value) {
  
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* PackageConfig::_internal_mutable_type() {
  
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* PackageConfig::release_type() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.type)
  return type_.Release();
}
inline void PackageConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.type)
}

// .viam.app.v1.AppValidationStatus status = 5 [json_name = "status"];
inline bool PackageConfig::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool PackageConfig::has_status() const {
  return _internal_has_status();
}
inline void PackageConfig::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::viam::app::v1::AppValidationStatus& PackageConfig::_internal_status() const {
  const ::viam::app::v1::AppValidationStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::AppValidationStatus&>(
      ::viam::app::v1::_AppValidationStatus_default_instance_);
}
inline const ::viam::app::v1::AppValidationStatus& PackageConfig::status() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.PackageConfig.status)
  return _internal_status();
}
inline void PackageConfig::unsafe_arena_set_allocated_status(
    ::viam::app::v1::AppValidationStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.PackageConfig.status)
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::release_status() {
  
  ::viam::app::v1::AppValidationStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:viam.app.v1.PackageConfig.status)
  
  ::viam::app::v1::AppValidationStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::AppValidationStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::viam::app::v1::AppValidationStatus* PackageConfig::mutable_status() {
  ::viam::app::v1::AppValidationStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.PackageConfig.status)
  return _msg;
}
inline void PackageConfig::set_allocated_status(::viam::app::v1::AppValidationStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.PackageConfig.status)
}

// -------------------------------------------------------------------

// MaintenanceConfig

// .viam.common.v1.ResourceName sensor_name = 1 [json_name = "sensorName"];
inline bool MaintenanceConfig::_internal_has_sensor_name() const {
  return this != internal_default_instance() && sensor_name_ != nullptr;
}
inline bool MaintenanceConfig::has_sensor_name() const {
  return _internal_has_sensor_name();
}
inline const ::viam::common::v1::ResourceName& MaintenanceConfig::_internal_sensor_name() const {
  const ::viam::common::v1::ResourceName* p = sensor_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& MaintenanceConfig::sensor_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MaintenanceConfig.sensor_name)
  return _internal_sensor_name();
}
inline void MaintenanceConfig::unsafe_arena_set_allocated_sensor_name(
    ::viam::common::v1::ResourceName* sensor_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_name_);
  }
  sensor_name_ = sensor_name;
  if (sensor_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.MaintenanceConfig.sensor_name)
}
inline ::viam::common::v1::ResourceName* MaintenanceConfig::release_sensor_name() {
  
  ::viam::common::v1::ResourceName* temp = sensor_name_;
  sensor_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* MaintenanceConfig::unsafe_arena_release_sensor_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MaintenanceConfig.sensor_name)
  
  ::viam::common::v1::ResourceName* temp = sensor_name_;
  sensor_name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* MaintenanceConfig::_internal_mutable_sensor_name() {
  
  if (sensor_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    sensor_name_ = p;
  }
  return sensor_name_;
}
inline ::viam::common::v1::ResourceName* MaintenanceConfig::mutable_sensor_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_sensor_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MaintenanceConfig.sensor_name)
  return _msg;
}
inline void MaintenanceConfig::set_allocated_sensor_name(::viam::common::v1::ResourceName* sensor_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_name_);
  }
  if (sensor_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_name));
    if (message_arena != submessage_arena) {
      sensor_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_name, submessage_arena);
    }
    
  } else {
    
  }
  sensor_name_ = sensor_name;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MaintenanceConfig.sensor_name)
}

// string maintenance_allowed_key = 2 [json_name = "maintenanceAllowedKey"];
inline void MaintenanceConfig::clear_maintenance_allowed_key() {
  maintenance_allowed_key_.ClearToEmpty();
}
inline const std::string& MaintenanceConfig::maintenance_allowed_key() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MaintenanceConfig.maintenance_allowed_key)
  return _internal_maintenance_allowed_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MaintenanceConfig::set_maintenance_allowed_key(ArgT0&& arg0, ArgT... args) {
 
 maintenance_allowed_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MaintenanceConfig.maintenance_allowed_key)
}
inline std::string* MaintenanceConfig::mutable_maintenance_allowed_key() {
  std::string* _s = _internal_mutable_maintenance_allowed_key();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MaintenanceConfig.maintenance_allowed_key)
  return _s;
}
inline const std::string& MaintenanceConfig::_internal_maintenance_allowed_key() const {
  return maintenance_allowed_key_.Get();
}
inline void MaintenanceConfig::_internal_set_maintenance_allowed_key(const std::string& value) {
  
  maintenance_allowed_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MaintenanceConfig::_internal_mutable_maintenance_allowed_key() {
  
  return maintenance_allowed_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MaintenanceConfig::release_maintenance_allowed_key() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MaintenanceConfig.maintenance_allowed_key)
  return maintenance_allowed_key_.Release();
}
inline void MaintenanceConfig::set_allocated_maintenance_allowed_key(std::string* maintenance_allowed_key) {
  if (maintenance_allowed_key != nullptr) {
    
  } else {
    
  }
  maintenance_allowed_key_.SetAllocated(maintenance_allowed_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (maintenance_allowed_key_.IsDefault()) {
    maintenance_allowed_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MaintenanceConfig.maintenance_allowed_key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::v1::CredentialsType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::CredentialsType>() {
  return ::viam::app::v1::CredentialsType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2frobot_2eproto
