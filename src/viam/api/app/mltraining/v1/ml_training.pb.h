// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/mltraining/v1/ml_training.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fmltraining_2fv1_2fml_5ftraining_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fmltraining_2fv1_2fml_5ftraining_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/rpc/status.pb.h"
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fmltraining_2fv1_2fml_5ftraining_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
namespace viam {
namespace app {
namespace mltraining {
namespace v1 {
class CancelTrainingJobRequest;
struct CancelTrainingJobRequestDefaultTypeInternal;
extern CancelTrainingJobRequestDefaultTypeInternal _CancelTrainingJobRequest_default_instance_;
class CancelTrainingJobResponse;
struct CancelTrainingJobResponseDefaultTypeInternal;
extern CancelTrainingJobResponseDefaultTypeInternal _CancelTrainingJobResponse_default_instance_;
class DeleteCompletedTrainingJobRequest;
struct DeleteCompletedTrainingJobRequestDefaultTypeInternal;
extern DeleteCompletedTrainingJobRequestDefaultTypeInternal _DeleteCompletedTrainingJobRequest_default_instance_;
class DeleteCompletedTrainingJobResponse;
struct DeleteCompletedTrainingJobResponseDefaultTypeInternal;
extern DeleteCompletedTrainingJobResponseDefaultTypeInternal _DeleteCompletedTrainingJobResponse_default_instance_;
class GetTrainingJobLogsRequest;
struct GetTrainingJobLogsRequestDefaultTypeInternal;
extern GetTrainingJobLogsRequestDefaultTypeInternal _GetTrainingJobLogsRequest_default_instance_;
class GetTrainingJobLogsResponse;
struct GetTrainingJobLogsResponseDefaultTypeInternal;
extern GetTrainingJobLogsResponseDefaultTypeInternal _GetTrainingJobLogsResponse_default_instance_;
class GetTrainingJobRequest;
struct GetTrainingJobRequestDefaultTypeInternal;
extern GetTrainingJobRequestDefaultTypeInternal _GetTrainingJobRequest_default_instance_;
class GetTrainingJobResponse;
struct GetTrainingJobResponseDefaultTypeInternal;
extern GetTrainingJobResponseDefaultTypeInternal _GetTrainingJobResponse_default_instance_;
class ListTrainingJobsRequest;
struct ListTrainingJobsRequestDefaultTypeInternal;
extern ListTrainingJobsRequestDefaultTypeInternal _ListTrainingJobsRequest_default_instance_;
class ListTrainingJobsResponse;
struct ListTrainingJobsResponseDefaultTypeInternal;
extern ListTrainingJobsResponseDefaultTypeInternal _ListTrainingJobsResponse_default_instance_;
class SubmitCustomTrainingJobRequest;
struct SubmitCustomTrainingJobRequestDefaultTypeInternal;
extern SubmitCustomTrainingJobRequestDefaultTypeInternal _SubmitCustomTrainingJobRequest_default_instance_;
class SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse;
struct SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUseDefaultTypeInternal;
extern SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUseDefaultTypeInternal _SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse_default_instance_;
class SubmitCustomTrainingJobResponse;
struct SubmitCustomTrainingJobResponseDefaultTypeInternal;
extern SubmitCustomTrainingJobResponseDefaultTypeInternal _SubmitCustomTrainingJobResponse_default_instance_;
class SubmitTrainingJobRequest;
struct SubmitTrainingJobRequestDefaultTypeInternal;
extern SubmitTrainingJobRequestDefaultTypeInternal _SubmitTrainingJobRequest_default_instance_;
class SubmitTrainingJobResponse;
struct SubmitTrainingJobResponseDefaultTypeInternal;
extern SubmitTrainingJobResponseDefaultTypeInternal _SubmitTrainingJobResponse_default_instance_;
class TrainingJobLogEntry;
struct TrainingJobLogEntryDefaultTypeInternal;
extern TrainingJobLogEntryDefaultTypeInternal _TrainingJobLogEntry_default_instance_;
class TrainingJobMetadata;
struct TrainingJobMetadataDefaultTypeInternal;
extern TrainingJobMetadataDefaultTypeInternal _TrainingJobMetadata_default_instance_;
class TrainingJobMetadata_ArgumentsEntry_DoNotUse;
struct TrainingJobMetadata_ArgumentsEntry_DoNotUseDefaultTypeInternal;
extern TrainingJobMetadata_ArgumentsEntry_DoNotUseDefaultTypeInternal _TrainingJobMetadata_ArgumentsEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace mltraining
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::mltraining::v1::CancelTrainingJobRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::CancelTrainingJobRequest>(Arena*);
template<> ::viam::app::mltraining::v1::CancelTrainingJobResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::CancelTrainingJobResponse>(Arena*);
template<> ::viam::app::mltraining::v1::DeleteCompletedTrainingJobRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::DeleteCompletedTrainingJobRequest>(Arena*);
template<> ::viam::app::mltraining::v1::DeleteCompletedTrainingJobResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::DeleteCompletedTrainingJobResponse>(Arena*);
template<> ::viam::app::mltraining::v1::GetTrainingJobLogsRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::GetTrainingJobLogsRequest>(Arena*);
template<> ::viam::app::mltraining::v1::GetTrainingJobLogsResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::GetTrainingJobLogsResponse>(Arena*);
template<> ::viam::app::mltraining::v1::GetTrainingJobRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::GetTrainingJobRequest>(Arena*);
template<> ::viam::app::mltraining::v1::GetTrainingJobResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::GetTrainingJobResponse>(Arena*);
template<> ::viam::app::mltraining::v1::ListTrainingJobsRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::ListTrainingJobsRequest>(Arena*);
template<> ::viam::app::mltraining::v1::ListTrainingJobsResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::ListTrainingJobsResponse>(Arena*);
template<> ::viam::app::mltraining::v1::SubmitCustomTrainingJobRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::SubmitCustomTrainingJobRequest>(Arena*);
template<> ::viam::app::mltraining::v1::SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse>(Arena*);
template<> ::viam::app::mltraining::v1::SubmitCustomTrainingJobResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::SubmitCustomTrainingJobResponse>(Arena*);
template<> ::viam::app::mltraining::v1::SubmitTrainingJobRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::SubmitTrainingJobRequest>(Arena*);
template<> ::viam::app::mltraining::v1::SubmitTrainingJobResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::SubmitTrainingJobResponse>(Arena*);
template<> ::viam::app::mltraining::v1::TrainingJobLogEntry* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJobLogEntry>(Arena*);
template<> ::viam::app::mltraining::v1::TrainingJobMetadata* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJobMetadata>(Arena*);
template<> ::viam::app::mltraining::v1::TrainingJobMetadata_ArgumentsEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJobMetadata_ArgumentsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace mltraining {
namespace v1 {

enum ModelType : int {
  MODEL_TYPE_UNSPECIFIED = 0,
  MODEL_TYPE_SINGLE_LABEL_CLASSIFICATION = 1,
  MODEL_TYPE_MULTI_LABEL_CLASSIFICATION = 2,
  MODEL_TYPE_OBJECT_DETECTION = 3,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = MODEL_TYPE_UNSPECIFIED;
constexpr ModelType ModelType_MAX = MODEL_TYPE_OBJECT_DETECTION;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelType_descriptor();
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelType_descriptor(), enum_t_value);
}
inline bool ModelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelType>(
    ModelType_descriptor(), name, value);
}
enum ModelFramework : int {
  MODEL_FRAMEWORK_UNSPECIFIED = 0,
  MODEL_FRAMEWORK_TFLITE = 1,
  MODEL_FRAMEWORK_TENSORFLOW = 2,
  MODEL_FRAMEWORK_PYTORCH = 3,
  MODEL_FRAMEWORK_ONNX = 4,
  ModelFramework_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelFramework_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelFramework_IsValid(int value);
constexpr ModelFramework ModelFramework_MIN = MODEL_FRAMEWORK_UNSPECIFIED;
constexpr ModelFramework ModelFramework_MAX = MODEL_FRAMEWORK_ONNX;
constexpr int ModelFramework_ARRAYSIZE = ModelFramework_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelFramework_descriptor();
template<typename T>
inline const std::string& ModelFramework_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelFramework>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelFramework_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelFramework_descriptor(), enum_t_value);
}
inline bool ModelFramework_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelFramework* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelFramework>(
    ModelFramework_descriptor(), name, value);
}
enum TrainingStatus : int {
  TRAINING_STATUS_UNSPECIFIED = 0,
  TRAINING_STATUS_PENDING = 1,
  TRAINING_STATUS_IN_PROGRESS = 2,
  TRAINING_STATUS_COMPLETED = 3,
  TRAINING_STATUS_FAILED = 4,
  TRAINING_STATUS_CANCELED = 5,
  TRAINING_STATUS_CANCELING = 6,
  TrainingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrainingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrainingStatus_IsValid(int value);
constexpr TrainingStatus TrainingStatus_MIN = TRAINING_STATUS_UNSPECIFIED;
constexpr TrainingStatus TrainingStatus_MAX = TRAINING_STATUS_CANCELING;
constexpr int TrainingStatus_ARRAYSIZE = TrainingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrainingStatus_descriptor();
template<typename T>
inline const std::string& TrainingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrainingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrainingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrainingStatus_descriptor(), enum_t_value);
}
inline bool TrainingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrainingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrainingStatus>(
    TrainingStatus_descriptor(), name, value);
}
// ===================================================================

class SubmitTrainingJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.SubmitTrainingJobRequest) */ {
 public:
  inline SubmitTrainingJobRequest() : SubmitTrainingJobRequest(nullptr) {}
  ~SubmitTrainingJobRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitTrainingJobRequest(const SubmitTrainingJobRequest& from);
  SubmitTrainingJobRequest(SubmitTrainingJobRequest&& from) noexcept
    : SubmitTrainingJobRequest() {
    *this = ::std::move(from);
  }

  inline SubmitTrainingJobRequest& operator=(const SubmitTrainingJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitTrainingJobRequest& operator=(SubmitTrainingJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitTrainingJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitTrainingJobRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitTrainingJobRequest*>(
               &_SubmitTrainingJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SubmitTrainingJobRequest& a, SubmitTrainingJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitTrainingJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitTrainingJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitTrainingJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitTrainingJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitTrainingJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubmitTrainingJobRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitTrainingJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.SubmitTrainingJobRequest";
  }
  protected:
  explicit SubmitTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 6,
    kOrganizationIdFieldNumber = 2,
    kModelNameFieldNumber = 3,
    kModelVersionFieldNumber = 4,
    kDatasetIdFieldNumber = 7,
    kModelTypeFieldNumber = 5,
    kModelFrameworkFieldNumber = 8,
  };
  // repeated string tags = 6 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string organization_id = 2 [json_name = "organizationId", (.tagger.v1.tags) = "bson:\"organization_id\" json:\"organization_id\""];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string model_name = 3 [json_name = "modelName", (.tagger.v1.tags) = "bson:\"model_name\" json:\"model_name\""];
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 4 [json_name = "modelVersion", (.tagger.v1.tags) = "bson:\"model_version\" json:\"model_version\""];
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string dataset_id = 7 [json_name = "datasetId", (.tagger.v1.tags) = "bson:\"dataset_id\" json:\"dataset_id\""];
  void clear_dataset_id();
  const std::string& dataset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dataset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dataset_id();
  PROTOBUF_NODISCARD std::string* release_dataset_id();
  void set_allocated_dataset_id(std::string* dataset_id);
  private:
  const std::string& _internal_dataset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_id(const std::string& value);
  std::string* _internal_mutable_dataset_id();
  public:

  // .viam.app.mltraining.v1.ModelType model_type = 5 [json_name = "modelType", (.tagger.v1.tags) = "bson:\"model_type\" json:\"model_type\""];
  void clear_model_type();
  ::viam::app::mltraining::v1::ModelType model_type() const;
  void set_model_type(::viam::app::mltraining::v1::ModelType value);
  private:
  ::viam::app::mltraining::v1::ModelType _internal_model_type() const;
  void _internal_set_model_type(::viam::app::mltraining::v1::ModelType value);
  public:

  // .viam.app.mltraining.v1.ModelFramework model_framework = 8 [json_name = "modelFramework", (.tagger.v1.tags) = "bson:\"model_framework\" json:\"model_framework\""];
  void clear_model_framework();
  ::viam::app::mltraining::v1::ModelFramework model_framework() const;
  void set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  private:
  ::viam::app::mltraining::v1::ModelFramework _internal_model_framework() const;
  void _internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.SubmitTrainingJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_id_;
  int model_type_;
  int model_framework_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class SubmitTrainingJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.SubmitTrainingJobResponse) */ {
 public:
  inline SubmitTrainingJobResponse() : SubmitTrainingJobResponse(nullptr) {}
  ~SubmitTrainingJobResponse() override;
  explicit PROTOBUF_CONSTEXPR SubmitTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitTrainingJobResponse(const SubmitTrainingJobResponse& from);
  SubmitTrainingJobResponse(SubmitTrainingJobResponse&& from) noexcept
    : SubmitTrainingJobResponse() {
    *this = ::std::move(from);
  }

  inline SubmitTrainingJobResponse& operator=(const SubmitTrainingJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitTrainingJobResponse& operator=(SubmitTrainingJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitTrainingJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitTrainingJobResponse* internal_default_instance() {
    return reinterpret_cast<const SubmitTrainingJobResponse*>(
               &_SubmitTrainingJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubmitTrainingJobResponse& a, SubmitTrainingJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitTrainingJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitTrainingJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitTrainingJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitTrainingJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitTrainingJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubmitTrainingJobResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitTrainingJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.SubmitTrainingJobResponse";
  }
  protected:
  explicit SubmitTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.SubmitTrainingJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse& other);
  static const SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse*>(&_SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.ArgumentsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.ArgumentsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};

// -------------------------------------------------------------------

class SubmitCustomTrainingJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest) */ {
 public:
  inline SubmitCustomTrainingJobRequest() : SubmitCustomTrainingJobRequest(nullptr) {}
  ~SubmitCustomTrainingJobRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitCustomTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitCustomTrainingJobRequest(const SubmitCustomTrainingJobRequest& from);
  SubmitCustomTrainingJobRequest(SubmitCustomTrainingJobRequest&& from) noexcept
    : SubmitCustomTrainingJobRequest() {
    *this = ::std::move(from);
  }

  inline SubmitCustomTrainingJobRequest& operator=(const SubmitCustomTrainingJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitCustomTrainingJobRequest& operator=(SubmitCustomTrainingJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitCustomTrainingJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitCustomTrainingJobRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitCustomTrainingJobRequest*>(
               &_SubmitCustomTrainingJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubmitCustomTrainingJobRequest& a, SubmitCustomTrainingJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitCustomTrainingJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitCustomTrainingJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitCustomTrainingJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitCustomTrainingJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitCustomTrainingJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubmitCustomTrainingJobRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitCustomTrainingJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.SubmitCustomTrainingJobRequest";
  }
  protected:
  explicit SubmitCustomTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 7,
    kDatasetIdFieldNumber = 1,
    kRegistryItemIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 3,
    kModelNameFieldNumber = 4,
    kModelVersionFieldNumber = 5,
    kRegistryItemVersionFieldNumber = 6,
  };
  // map<string, string> arguments = 7 [json_name = "arguments"];
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_arguments();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_arguments();

  // string dataset_id = 1 [json_name = "datasetId", (.tagger.v1.tags) = "bson:\"dataset_id\" json:\"dataset_id\""];
  void clear_dataset_id();
  const std::string& dataset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dataset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dataset_id();
  PROTOBUF_NODISCARD std::string* release_dataset_id();
  void set_allocated_dataset_id(std::string* dataset_id);
  private:
  const std::string& _internal_dataset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_id(const std::string& value);
  std::string* _internal_mutable_dataset_id();
  public:

  // string registry_item_id = 2 [json_name = "registryItemId", (.tagger.v1.tags) = "bson:\"registry_item_id\" json:\"registry_item_id\""];
  void clear_registry_item_id();
  const std::string& registry_item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_registry_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_registry_item_id();
  PROTOBUF_NODISCARD std::string* release_registry_item_id();
  void set_allocated_registry_item_id(std::string* registry_item_id);
  private:
  const std::string& _internal_registry_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registry_item_id(const std::string& value);
  std::string* _internal_mutable_registry_item_id();
  public:

  // string organization_id = 3 [json_name = "organizationId", (.tagger.v1.tags) = "bson:\"organization_id\" json:\"organization_id\""];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string model_name = 4 [json_name = "modelName", (.tagger.v1.tags) = "bson:\"model_name\" json:\"model_name\""];
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 5 [json_name = "modelVersion", (.tagger.v1.tags) = "bson:\"model_version\" json:\"model_version\""];
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string registry_item_version = 6 [json_name = "registryItemVersion", (.tagger.v1.tags) = "bson:\"registry_item_version\" json:\"registry_item_version\""];
  void clear_registry_item_version();
  const std::string& registry_item_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_registry_item_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_registry_item_version();
  PROTOBUF_NODISCARD std::string* release_registry_item_version();
  void set_allocated_registry_item_version(std::string* registry_item_version);
  private:
  const std::string& _internal_registry_item_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registry_item_version(const std::string& value);
  std::string* _internal_mutable_registry_item_version();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SubmitCustomTrainingJobRequest_ArgumentsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registry_item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registry_item_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class SubmitCustomTrainingJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.SubmitCustomTrainingJobResponse) */ {
 public:
  inline SubmitCustomTrainingJobResponse() : SubmitCustomTrainingJobResponse(nullptr) {}
  ~SubmitCustomTrainingJobResponse() override;
  explicit PROTOBUF_CONSTEXPR SubmitCustomTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitCustomTrainingJobResponse(const SubmitCustomTrainingJobResponse& from);
  SubmitCustomTrainingJobResponse(SubmitCustomTrainingJobResponse&& from) noexcept
    : SubmitCustomTrainingJobResponse() {
    *this = ::std::move(from);
  }

  inline SubmitCustomTrainingJobResponse& operator=(const SubmitCustomTrainingJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitCustomTrainingJobResponse& operator=(SubmitCustomTrainingJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitCustomTrainingJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitCustomTrainingJobResponse* internal_default_instance() {
    return reinterpret_cast<const SubmitCustomTrainingJobResponse*>(
               &_SubmitCustomTrainingJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubmitCustomTrainingJobResponse& a, SubmitCustomTrainingJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitCustomTrainingJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitCustomTrainingJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitCustomTrainingJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitCustomTrainingJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitCustomTrainingJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubmitCustomTrainingJobResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitCustomTrainingJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.SubmitCustomTrainingJobResponse";
  }
  protected:
  explicit SubmitCustomTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.SubmitCustomTrainingJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class GetTrainingJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.GetTrainingJobRequest) */ {
 public:
  inline GetTrainingJobRequest() : GetTrainingJobRequest(nullptr) {}
  ~GetTrainingJobRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTrainingJobRequest(const GetTrainingJobRequest& from);
  GetTrainingJobRequest(GetTrainingJobRequest&& from) noexcept
    : GetTrainingJobRequest() {
    *this = ::std::move(from);
  }

  inline GetTrainingJobRequest& operator=(const GetTrainingJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrainingJobRequest& operator=(GetTrainingJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTrainingJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTrainingJobRequest* internal_default_instance() {
    return reinterpret_cast<const GetTrainingJobRequest*>(
               &_GetTrainingJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetTrainingJobRequest& a, GetTrainingJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrainingJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrainingJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTrainingJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTrainingJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTrainingJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTrainingJobRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrainingJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.GetTrainingJobRequest";
  }
  protected:
  explicit GetTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.GetTrainingJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class GetTrainingJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.GetTrainingJobResponse) */ {
 public:
  inline GetTrainingJobResponse() : GetTrainingJobResponse(nullptr) {}
  ~GetTrainingJobResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTrainingJobResponse(const GetTrainingJobResponse& from);
  GetTrainingJobResponse(GetTrainingJobResponse&& from) noexcept
    : GetTrainingJobResponse() {
    *this = ::std::move(from);
  }

  inline GetTrainingJobResponse& operator=(const GetTrainingJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrainingJobResponse& operator=(GetTrainingJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTrainingJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTrainingJobResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrainingJobResponse*>(
               &_GetTrainingJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetTrainingJobResponse& a, GetTrainingJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrainingJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrainingJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTrainingJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTrainingJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTrainingJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTrainingJobResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrainingJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.GetTrainingJobResponse";
  }
  protected:
  explicit GetTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // .viam.app.mltraining.v1.TrainingJobMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::mltraining::v1::TrainingJobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::mltraining::v1::TrainingJobMetadata* release_metadata();
  ::viam::app::mltraining::v1::TrainingJobMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::mltraining::v1::TrainingJobMetadata* metadata);
  private:
  const ::viam::app::mltraining::v1::TrainingJobMetadata& _internal_metadata() const;
  ::viam::app::mltraining::v1::TrainingJobMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::mltraining::v1::TrainingJobMetadata* metadata);
  ::viam::app::mltraining::v1::TrainingJobMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.GetTrainingJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::mltraining::v1::TrainingJobMetadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class ListTrainingJobsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.ListTrainingJobsRequest) */ {
 public:
  inline ListTrainingJobsRequest() : ListTrainingJobsRequest(nullptr) {}
  ~ListTrainingJobsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListTrainingJobsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTrainingJobsRequest(const ListTrainingJobsRequest& from);
  ListTrainingJobsRequest(ListTrainingJobsRequest&& from) noexcept
    : ListTrainingJobsRequest() {
    *this = ::std::move(from);
  }

  inline ListTrainingJobsRequest& operator=(const ListTrainingJobsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTrainingJobsRequest& operator=(ListTrainingJobsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTrainingJobsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTrainingJobsRequest* internal_default_instance() {
    return reinterpret_cast<const ListTrainingJobsRequest*>(
               &_ListTrainingJobsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListTrainingJobsRequest& a, ListTrainingJobsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTrainingJobsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTrainingJobsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTrainingJobsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTrainingJobsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTrainingJobsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTrainingJobsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTrainingJobsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.ListTrainingJobsRequest";
  }
  protected:
  explicit ListTrainingJobsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // .viam.app.mltraining.v1.TrainingStatus status = 2 [json_name = "status"];
  void clear_status();
  ::viam::app::mltraining::v1::TrainingStatus status() const;
  void set_status(::viam::app::mltraining::v1::TrainingStatus value);
  private:
  ::viam::app::mltraining::v1::TrainingStatus _internal_status() const;
  void _internal_set_status(::viam::app::mltraining::v1::TrainingStatus value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.ListTrainingJobsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class ListTrainingJobsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.ListTrainingJobsResponse) */ {
 public:
  inline ListTrainingJobsResponse() : ListTrainingJobsResponse(nullptr) {}
  ~ListTrainingJobsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListTrainingJobsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTrainingJobsResponse(const ListTrainingJobsResponse& from);
  ListTrainingJobsResponse(ListTrainingJobsResponse&& from) noexcept
    : ListTrainingJobsResponse() {
    *this = ::std::move(from);
  }

  inline ListTrainingJobsResponse& operator=(const ListTrainingJobsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTrainingJobsResponse& operator=(ListTrainingJobsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTrainingJobsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTrainingJobsResponse* internal_default_instance() {
    return reinterpret_cast<const ListTrainingJobsResponse*>(
               &_ListTrainingJobsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListTrainingJobsResponse& a, ListTrainingJobsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTrainingJobsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTrainingJobsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTrainingJobsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTrainingJobsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTrainingJobsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTrainingJobsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTrainingJobsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.ListTrainingJobsResponse";
  }
  protected:
  explicit ListTrainingJobsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 1,
  };
  // repeated .viam.app.mltraining.v1.TrainingJobMetadata jobs = 1 [json_name = "jobs"];
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;
  public:
  void clear_jobs();
  ::viam::app::mltraining::v1::TrainingJobMetadata* mutable_jobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobMetadata >*
      mutable_jobs();
  private:
  const ::viam::app::mltraining::v1::TrainingJobMetadata& _internal_jobs(int index) const;
  ::viam::app::mltraining::v1::TrainingJobMetadata* _internal_add_jobs();
  public:
  const ::viam::app::mltraining::v1::TrainingJobMetadata& jobs(int index) const;
  ::viam::app::mltraining::v1::TrainingJobMetadata* add_jobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobMetadata >&
      jobs() const;

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.ListTrainingJobsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobMetadata > jobs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class TrainingJobMetadata_ArgumentsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TrainingJobMetadata_ArgumentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TrainingJobMetadata_ArgumentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TrainingJobMetadata_ArgumentsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TrainingJobMetadata_ArgumentsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TrainingJobMetadata_ArgumentsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TrainingJobMetadata_ArgumentsEntry_DoNotUse& other);
  static const TrainingJobMetadata_ArgumentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TrainingJobMetadata_ArgumentsEntry_DoNotUse*>(&_TrainingJobMetadata_ArgumentsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.mltraining.v1.TrainingJobMetadata.ArgumentsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.mltraining.v1.TrainingJobMetadata.ArgumentsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};

// -------------------------------------------------------------------

class TrainingJobMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.TrainingJobMetadata) */ {
 public:
  inline TrainingJobMetadata() : TrainingJobMetadata(nullptr) {}
  ~TrainingJobMetadata() override;
  explicit PROTOBUF_CONSTEXPR TrainingJobMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainingJobMetadata(const TrainingJobMetadata& from);
  TrainingJobMetadata(TrainingJobMetadata&& from) noexcept
    : TrainingJobMetadata() {
    *this = ::std::move(from);
  }

  inline TrainingJobMetadata& operator=(const TrainingJobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingJobMetadata& operator=(TrainingJobMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingJobMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingJobMetadata* internal_default_instance() {
    return reinterpret_cast<const TrainingJobMetadata*>(
               &_TrainingJobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TrainingJobMetadata& a, TrainingJobMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainingJobMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingJobMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingJobMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingJobMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrainingJobMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrainingJobMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainingJobMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.TrainingJobMetadata";
  }
  protected:
  explicit TrainingJobMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 16,
    kArgumentsFieldNumber = 21,
    kSyncedModelIdFieldNumber = 5,
    kIdFieldNumber = 7,
    kDatasetIdFieldNumber = 11,
    kOrganizationIdFieldNumber = 12,
    kModelNameFieldNumber = 13,
    kModelVersionFieldNumber = 14,
    kRegistryItemIdFieldNumber = 19,
    kRegistryItemVersionFieldNumber = 20,
    kCreatedOnFieldNumber = 3,
    kLastModifiedFieldNumber = 4,
    kErrorStatusFieldNumber = 8,
    kTrainingStartedFieldNumber = 9,
    kTrainingEndedFieldNumber = 10,
    kStatusFieldNumber = 2,
    kModelTypeFieldNumber = 15,
    kModelFrameworkFieldNumber = 17,
    kIsCustomJobFieldNumber = 18,
  };
  // repeated string tags = 16 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // map<string, string> arguments = 21 [json_name = "arguments", (.tagger.v1.tags) = "bson:\"arguments\" json:\"arguments\""];
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_arguments();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_arguments();

  // string synced_model_id = 5 [json_name = "syncedModelId", (.tagger.v1.tags) = "bson:\"synced_model_id\" json:\"synced_model_id\""];
  void clear_synced_model_id();
  const std::string& synced_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_synced_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_synced_model_id();
  PROTOBUF_NODISCARD std::string* release_synced_model_id();
  void set_allocated_synced_model_id(std::string* synced_model_id);
  private:
  const std::string& _internal_synced_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_synced_model_id(const std::string& value);
  std::string* _internal_mutable_synced_model_id();
  public:

  // string id = 7 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string dataset_id = 11 [json_name = "datasetId", (.tagger.v1.tags) = "bson:\"dataset_id\" json:\"dataset_id\""];
  void clear_dataset_id();
  const std::string& dataset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dataset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dataset_id();
  PROTOBUF_NODISCARD std::string* release_dataset_id();
  void set_allocated_dataset_id(std::string* dataset_id);
  private:
  const std::string& _internal_dataset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_id(const std::string& value);
  std::string* _internal_mutable_dataset_id();
  public:

  // string organization_id = 12 [json_name = "organizationId", (.tagger.v1.tags) = "bson:\"organization_id\" json:\"organization_id\""];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string model_name = 13 [json_name = "modelName", (.tagger.v1.tags) = "bson:\"model_name\" json:\"model_name\""];
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 14 [json_name = "modelVersion", (.tagger.v1.tags) = "bson:\"model_version\" json:\"model_version\""];
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // string registry_item_id = 19 [json_name = "registryItemId", (.tagger.v1.tags) = "bson:\"registry_item_id\" json:\"registry_item_id\""];
  void clear_registry_item_id();
  const std::string& registry_item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_registry_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_registry_item_id();
  PROTOBUF_NODISCARD std::string* release_registry_item_id();
  void set_allocated_registry_item_id(std::string* registry_item_id);
  private:
  const std::string& _internal_registry_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registry_item_id(const std::string& value);
  std::string* _internal_mutable_registry_item_id();
  public:

  // string registry_item_version = 20 [json_name = "registryItemVersion", (.tagger.v1.tags) = "bson:\"registry_item_version\" json:\"registry_item_version\""];
  void clear_registry_item_version();
  const std::string& registry_item_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_registry_item_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_registry_item_version();
  PROTOBUF_NODISCARD std::string* release_registry_item_version();
  void set_allocated_registry_item_version(std::string* registry_item_version);
  private:
  const std::string& _internal_registry_item_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registry_item_version(const std::string& value);
  std::string* _internal_mutable_registry_item_version();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .google.protobuf.Timestamp last_modified = 4 [json_name = "lastModified", (.tagger.v1.tags) = "bson:\"last_modified\" json:\"last_modified\""];
  bool has_last_modified() const;
  private:
  bool _internal_has_last_modified() const;
  public:
  void clear_last_modified();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_modified() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_modified();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_modified();
  void set_allocated_last_modified(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_modified() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_modified();
  public:
  void unsafe_arena_set_allocated_last_modified(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_modified();

  // .google.rpc.Status error_status = 8 [json_name = "errorStatus", (.tagger.v1.tags) = "bson:\"error_status\" json:\"error_status\""];
  bool has_error_status() const;
  private:
  bool _internal_has_error_status() const;
  public:
  void clear_error_status();
  const ::google::rpc::Status& error_status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_error_status();
  ::google::rpc::Status* mutable_error_status();
  void set_allocated_error_status(::google::rpc::Status* error_status);
  private:
  const ::google::rpc::Status& _internal_error_status() const;
  ::google::rpc::Status* _internal_mutable_error_status();
  public:
  void unsafe_arena_set_allocated_error_status(
      ::google::rpc::Status* error_status);
  ::google::rpc::Status* unsafe_arena_release_error_status();

  // .google.protobuf.Timestamp training_started = 9 [json_name = "trainingStarted", (.tagger.v1.tags) = "bson:\"training_started\" json:\"training_started\""];
  bool has_training_started() const;
  private:
  bool _internal_has_training_started() const;
  public:
  void clear_training_started();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& training_started() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_training_started();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_training_started();
  void set_allocated_training_started(::PROTOBUF_NAMESPACE_ID::Timestamp* training_started);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_training_started() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_training_started();
  public:
  void unsafe_arena_set_allocated_training_started(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* training_started);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_training_started();

  // .google.protobuf.Timestamp training_ended = 10 [json_name = "trainingEnded", (.tagger.v1.tags) = "bson:\"training_ended\" json:\"training_ended\""];
  bool has_training_ended() const;
  private:
  bool _internal_has_training_ended() const;
  public:
  void clear_training_ended();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& training_ended() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_training_ended();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_training_ended();
  void set_allocated_training_ended(::PROTOBUF_NAMESPACE_ID::Timestamp* training_ended);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_training_ended() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_training_ended();
  public:
  void unsafe_arena_set_allocated_training_ended(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* training_ended);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_training_ended();

  // .viam.app.mltraining.v1.TrainingStatus status = 2 [json_name = "status", (.tagger.v1.tags) = "bson:\"status\" json:\"status\""];
  void clear_status();
  ::viam::app::mltraining::v1::TrainingStatus status() const;
  void set_status(::viam::app::mltraining::v1::TrainingStatus value);
  private:
  ::viam::app::mltraining::v1::TrainingStatus _internal_status() const;
  void _internal_set_status(::viam::app::mltraining::v1::TrainingStatus value);
  public:

  // .viam.app.mltraining.v1.ModelType model_type = 15 [json_name = "modelType", (.tagger.v1.tags) = "bson:\"model_type\" json:\"model_type\""];
  void clear_model_type();
  ::viam::app::mltraining::v1::ModelType model_type() const;
  void set_model_type(::viam::app::mltraining::v1::ModelType value);
  private:
  ::viam::app::mltraining::v1::ModelType _internal_model_type() const;
  void _internal_set_model_type(::viam::app::mltraining::v1::ModelType value);
  public:

  // .viam.app.mltraining.v1.ModelFramework model_framework = 17 [json_name = "modelFramework", (.tagger.v1.tags) = "bson:\"model_framework\" json:\"model_framework\""];
  void clear_model_framework();
  ::viam::app::mltraining::v1::ModelFramework model_framework() const;
  void set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  private:
  ::viam::app::mltraining::v1::ModelFramework _internal_model_framework() const;
  void _internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value);
  public:

  // bool is_custom_job = 18 [json_name = "isCustomJob", (.tagger.v1.tags) = "bson:\"is_custom_job\" json:\"is_custom_job\""];
  void clear_is_custom_job();
  bool is_custom_job() const;
  void set_is_custom_job(bool value);
  private:
  bool _internal_is_custom_job() const;
  void _internal_set_is_custom_job(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.TrainingJobMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TrainingJobMetadata_ArgumentsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr synced_model_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registry_item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registry_item_version_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_;
  ::google::rpc::Status* error_status_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* training_started_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* training_ended_;
  int status_;
  int model_type_;
  int model_framework_;
  bool is_custom_job_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class CancelTrainingJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.CancelTrainingJobRequest) */ {
 public:
  inline CancelTrainingJobRequest() : CancelTrainingJobRequest(nullptr) {}
  ~CancelTrainingJobRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelTrainingJobRequest(const CancelTrainingJobRequest& from);
  CancelTrainingJobRequest(CancelTrainingJobRequest&& from) noexcept
    : CancelTrainingJobRequest() {
    *this = ::std::move(from);
  }

  inline CancelTrainingJobRequest& operator=(const CancelTrainingJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelTrainingJobRequest& operator=(CancelTrainingJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelTrainingJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelTrainingJobRequest* internal_default_instance() {
    return reinterpret_cast<const CancelTrainingJobRequest*>(
               &_CancelTrainingJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CancelTrainingJobRequest& a, CancelTrainingJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelTrainingJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelTrainingJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelTrainingJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelTrainingJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelTrainingJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelTrainingJobRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelTrainingJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.CancelTrainingJobRequest";
  }
  protected:
  explicit CancelTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.CancelTrainingJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class CancelTrainingJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.CancelTrainingJobResponse) */ {
 public:
  inline CancelTrainingJobResponse() : CancelTrainingJobResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CancelTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelTrainingJobResponse(const CancelTrainingJobResponse& from);
  CancelTrainingJobResponse(CancelTrainingJobResponse&& from) noexcept
    : CancelTrainingJobResponse() {
    *this = ::std::move(from);
  }

  inline CancelTrainingJobResponse& operator=(const CancelTrainingJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelTrainingJobResponse& operator=(CancelTrainingJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelTrainingJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelTrainingJobResponse* internal_default_instance() {
    return reinterpret_cast<const CancelTrainingJobResponse*>(
               &_CancelTrainingJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CancelTrainingJobResponse& a, CancelTrainingJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelTrainingJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelTrainingJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelTrainingJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelTrainingJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelTrainingJobResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelTrainingJobResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.CancelTrainingJobResponse";
  }
  protected:
  explicit CancelTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.CancelTrainingJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class DeleteCompletedTrainingJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest) */ {
 public:
  inline DeleteCompletedTrainingJobRequest() : DeleteCompletedTrainingJobRequest(nullptr) {}
  ~DeleteCompletedTrainingJobRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteCompletedTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCompletedTrainingJobRequest(const DeleteCompletedTrainingJobRequest& from);
  DeleteCompletedTrainingJobRequest(DeleteCompletedTrainingJobRequest&& from) noexcept
    : DeleteCompletedTrainingJobRequest() {
    *this = ::std::move(from);
  }

  inline DeleteCompletedTrainingJobRequest& operator=(const DeleteCompletedTrainingJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCompletedTrainingJobRequest& operator=(DeleteCompletedTrainingJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCompletedTrainingJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCompletedTrainingJobRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteCompletedTrainingJobRequest*>(
               &_DeleteCompletedTrainingJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteCompletedTrainingJobRequest& a, DeleteCompletedTrainingJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCompletedTrainingJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCompletedTrainingJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteCompletedTrainingJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteCompletedTrainingJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteCompletedTrainingJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteCompletedTrainingJobRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteCompletedTrainingJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest";
  }
  protected:
  explicit DeleteCompletedTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class DeleteCompletedTrainingJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.DeleteCompletedTrainingJobResponse) */ {
 public:
  inline DeleteCompletedTrainingJobResponse() : DeleteCompletedTrainingJobResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteCompletedTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCompletedTrainingJobResponse(const DeleteCompletedTrainingJobResponse& from);
  DeleteCompletedTrainingJobResponse(DeleteCompletedTrainingJobResponse&& from) noexcept
    : DeleteCompletedTrainingJobResponse() {
    *this = ::std::move(from);
  }

  inline DeleteCompletedTrainingJobResponse& operator=(const DeleteCompletedTrainingJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCompletedTrainingJobResponse& operator=(DeleteCompletedTrainingJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCompletedTrainingJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCompletedTrainingJobResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteCompletedTrainingJobResponse*>(
               &_DeleteCompletedTrainingJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteCompletedTrainingJobResponse& a, DeleteCompletedTrainingJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCompletedTrainingJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCompletedTrainingJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteCompletedTrainingJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteCompletedTrainingJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteCompletedTrainingJobResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteCompletedTrainingJobResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.DeleteCompletedTrainingJobResponse";
  }
  protected:
  explicit DeleteCompletedTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.DeleteCompletedTrainingJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class TrainingJobLogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.TrainingJobLogEntry) */ {
 public:
  inline TrainingJobLogEntry() : TrainingJobLogEntry(nullptr) {}
  ~TrainingJobLogEntry() override;
  explicit PROTOBUF_CONSTEXPR TrainingJobLogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainingJobLogEntry(const TrainingJobLogEntry& from);
  TrainingJobLogEntry(TrainingJobLogEntry&& from) noexcept
    : TrainingJobLogEntry() {
    *this = ::std::move(from);
  }

  inline TrainingJobLogEntry& operator=(const TrainingJobLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingJobLogEntry& operator=(TrainingJobLogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingJobLogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingJobLogEntry* internal_default_instance() {
    return reinterpret_cast<const TrainingJobLogEntry*>(
               &_TrainingJobLogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TrainingJobLogEntry& a, TrainingJobLogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainingJobLogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingJobLogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingJobLogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingJobLogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrainingJobLogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrainingJobLogEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainingJobLogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.TrainingJobLogEntry";
  }
  protected:
  explicit TrainingJobLogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kMessageFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // string level = 1 [json_name = "level"];
  void clear_level();
  const std::string& level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* level);
  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(const std::string& value);
  std::string* _internal_mutable_level();
  public:

  // string message = 3 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp time = 2 [json_name = "time"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.TrainingJobLogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class GetTrainingJobLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.GetTrainingJobLogsRequest) */ {
 public:
  inline GetTrainingJobLogsRequest() : GetTrainingJobLogsRequest(nullptr) {}
  ~GetTrainingJobLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTrainingJobLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTrainingJobLogsRequest(const GetTrainingJobLogsRequest& from);
  GetTrainingJobLogsRequest(GetTrainingJobLogsRequest&& from) noexcept
    : GetTrainingJobLogsRequest() {
    *this = ::std::move(from);
  }

  inline GetTrainingJobLogsRequest& operator=(const GetTrainingJobLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrainingJobLogsRequest& operator=(GetTrainingJobLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTrainingJobLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTrainingJobLogsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTrainingJobLogsRequest*>(
               &_GetTrainingJobLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetTrainingJobLogsRequest& a, GetTrainingJobLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrainingJobLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrainingJobLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTrainingJobLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTrainingJobLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTrainingJobLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTrainingJobLogsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrainingJobLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.GetTrainingJobLogsRequest";
  }
  protected:
  explicit GetTrainingJobLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPageTokenFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string page_token = 2 [json_name = "pageToken"];
  bool has_page_token() const;
  private:
  bool _internal_has_page_token() const;
  public:
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.GetTrainingJobLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class GetTrainingJobLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.GetTrainingJobLogsResponse) */ {
 public:
  inline GetTrainingJobLogsResponse() : GetTrainingJobLogsResponse(nullptr) {}
  ~GetTrainingJobLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTrainingJobLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTrainingJobLogsResponse(const GetTrainingJobLogsResponse& from);
  GetTrainingJobLogsResponse(GetTrainingJobLogsResponse&& from) noexcept
    : GetTrainingJobLogsResponse() {
    *this = ::std::move(from);
  }

  inline GetTrainingJobLogsResponse& operator=(const GetTrainingJobLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrainingJobLogsResponse& operator=(GetTrainingJobLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTrainingJobLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTrainingJobLogsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrainingJobLogsResponse*>(
               &_GetTrainingJobLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetTrainingJobLogsResponse& a, GetTrainingJobLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrainingJobLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrainingJobLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTrainingJobLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTrainingJobLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTrainingJobLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTrainingJobLogsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrainingJobLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.GetTrainingJobLogsResponse";
  }
  protected:
  explicit GetTrainingJobLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .viam.app.mltraining.v1.TrainingJobLogEntry logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::app::mltraining::v1::TrainingJobLogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobLogEntry >*
      mutable_logs();
  private:
  const ::viam::app::mltraining::v1::TrainingJobLogEntry& _internal_logs(int index) const;
  ::viam::app::mltraining::v1::TrainingJobLogEntry* _internal_add_logs();
  public:
  const ::viam::app::mltraining::v1::TrainingJobLogEntry& logs(int index) const;
  ::viam::app::mltraining::v1::TrainingJobLogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobLogEntry >&
      logs() const;

  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.GetTrainingJobLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobLogEntry > logs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubmitTrainingJobRequest

// string dataset_id = 7 [json_name = "datasetId", (.tagger.v1.tags) = "bson:\"dataset_id\" json:\"dataset_id\""];
inline void SubmitTrainingJobRequest::clear_dataset_id() {
  dataset_id_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobRequest::dataset_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.dataset_id)
  return _internal_dataset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobRequest::set_dataset_id(ArgT0&& arg0, ArgT... args) {
 
 dataset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.dataset_id)
}
inline std::string* SubmitTrainingJobRequest::mutable_dataset_id() {
  std::string* _s = _internal_mutable_dataset_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.dataset_id)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_dataset_id() const {
  return dataset_id_.Get();
}
inline void SubmitTrainingJobRequest::_internal_set_dataset_id(const std::string& value) {
  
  dataset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::_internal_mutable_dataset_id() {
  
  return dataset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::release_dataset_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.dataset_id)
  return dataset_id_.Release();
}
inline void SubmitTrainingJobRequest::set_allocated_dataset_id(std::string* dataset_id) {
  if (dataset_id != nullptr) {
    
  } else {
    
  }
  dataset_id_.SetAllocated(dataset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dataset_id_.IsDefault()) {
    dataset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.dataset_id)
}

// string organization_id = 2 [json_name = "organizationId", (.tagger.v1.tags) = "bson:\"organization_id\" json:\"organization_id\""];
inline void SubmitTrainingJobRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
}
inline std::string* SubmitTrainingJobRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void SubmitTrainingJobRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
  return organization_id_.Release();
}
inline void SubmitTrainingJobRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
}

// string model_name = 3 [json_name = "modelName", (.tagger.v1.tags) = "bson:\"model_name\" json:\"model_name\""];
inline void SubmitTrainingJobRequest::clear_model_name() {
  model_name_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobRequest::model_name() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
}
inline std::string* SubmitTrainingJobRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_model_name() const {
  return model_name_.Get();
}
inline void SubmitTrainingJobRequest::_internal_set_model_name(const std::string& value) {
  
  model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::_internal_mutable_model_name() {
  
  return model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
  return model_name_.Release();
}
inline void SubmitTrainingJobRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_name_.IsDefault()) {
    model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
}

// string model_version = 4 [json_name = "modelVersion", (.tagger.v1.tags) = "bson:\"model_version\" json:\"model_version\""];
inline void SubmitTrainingJobRequest::clear_model_version() {
  model_version_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobRequest::model_version() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobRequest::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
}
inline std::string* SubmitTrainingJobRequest::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_model_version() const {
  return model_version_.Get();
}
inline void SubmitTrainingJobRequest::_internal_set_model_version(const std::string& value) {
  
  model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::_internal_mutable_model_version() {
  
  return model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::release_model_version() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
  return model_version_.Release();
}
inline void SubmitTrainingJobRequest::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_version_.IsDefault()) {
    model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
}

// .viam.app.mltraining.v1.ModelType model_type = 5 [json_name = "modelType", (.tagger.v1.tags) = "bson:\"model_type\" json:\"model_type\""];
inline void SubmitTrainingJobRequest::clear_model_type() {
  model_type_ = 0;
}
inline ::viam::app::mltraining::v1::ModelType SubmitTrainingJobRequest::_internal_model_type() const {
  return static_cast< ::viam::app::mltraining::v1::ModelType >(model_type_);
}
inline ::viam::app::mltraining::v1::ModelType SubmitTrainingJobRequest::model_type() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_type)
  return _internal_model_type();
}
inline void SubmitTrainingJobRequest::_internal_set_model_type(::viam::app::mltraining::v1::ModelType value) {
  
  model_type_ = value;
}
inline void SubmitTrainingJobRequest::set_model_type(::viam::app::mltraining::v1::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_type)
}

// .viam.app.mltraining.v1.ModelFramework model_framework = 8 [json_name = "modelFramework", (.tagger.v1.tags) = "bson:\"model_framework\" json:\"model_framework\""];
inline void SubmitTrainingJobRequest::clear_model_framework() {
  model_framework_ = 0;
}
inline ::viam::app::mltraining::v1::ModelFramework SubmitTrainingJobRequest::_internal_model_framework() const {
  return static_cast< ::viam::app::mltraining::v1::ModelFramework >(model_framework_);
}
inline ::viam::app::mltraining::v1::ModelFramework SubmitTrainingJobRequest::model_framework() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_framework)
  return _internal_model_framework();
}
inline void SubmitTrainingJobRequest::_internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  
  model_framework_ = value;
}
inline void SubmitTrainingJobRequest::set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  _internal_set_model_framework(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_framework)
}

// repeated string tags = 6 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
inline int SubmitTrainingJobRequest::_internal_tags_size() const {
  return tags_.size();
}
inline int SubmitTrainingJobRequest::tags_size() const {
  return _internal_tags_size();
}
inline void SubmitTrainingJobRequest::clear_tags() {
  tags_.Clear();
}
inline std::string* SubmitTrainingJobRequest::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& SubmitTrainingJobRequest::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return _internal_tags(index);
}
inline std::string* SubmitTrainingJobRequest::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return tags_.Mutable(index);
}
inline void SubmitTrainingJobRequest::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline std::string* SubmitTrainingJobRequest::_internal_add_tags() {
  return tags_.Add();
}
inline void SubmitTrainingJobRequest::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubmitTrainingJobRequest::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubmitTrainingJobRequest::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// SubmitTrainingJobResponse

// string id = 1 [json_name = "id"];
inline void SubmitTrainingJobResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
}
inline std::string* SubmitTrainingJobResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
  return _s;
}
inline const std::string& SubmitTrainingJobResponse::_internal_id() const {
  return id_.Get();
}
inline void SubmitTrainingJobResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
  return id_.Release();
}
inline void SubmitTrainingJobResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SubmitCustomTrainingJobRequest

// string dataset_id = 1 [json_name = "datasetId", (.tagger.v1.tags) = "bson:\"dataset_id\" json:\"dataset_id\""];
inline void SubmitCustomTrainingJobRequest::clear_dataset_id() {
  dataset_id_.ClearToEmpty();
}
inline const std::string& SubmitCustomTrainingJobRequest::dataset_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.dataset_id)
  return _internal_dataset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitCustomTrainingJobRequest::set_dataset_id(ArgT0&& arg0, ArgT... args) {
 
 dataset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.dataset_id)
}
inline std::string* SubmitCustomTrainingJobRequest::mutable_dataset_id() {
  std::string* _s = _internal_mutable_dataset_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.dataset_id)
  return _s;
}
inline const std::string& SubmitCustomTrainingJobRequest::_internal_dataset_id() const {
  return dataset_id_.Get();
}
inline void SubmitCustomTrainingJobRequest::_internal_set_dataset_id(const std::string& value) {
  
  dataset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::_internal_mutable_dataset_id() {
  
  return dataset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::release_dataset_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.dataset_id)
  return dataset_id_.Release();
}
inline void SubmitCustomTrainingJobRequest::set_allocated_dataset_id(std::string* dataset_id) {
  if (dataset_id != nullptr) {
    
  } else {
    
  }
  dataset_id_.SetAllocated(dataset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dataset_id_.IsDefault()) {
    dataset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.dataset_id)
}

// string registry_item_id = 2 [json_name = "registryItemId", (.tagger.v1.tags) = "bson:\"registry_item_id\" json:\"registry_item_id\""];
inline void SubmitCustomTrainingJobRequest::clear_registry_item_id() {
  registry_item_id_.ClearToEmpty();
}
inline const std::string& SubmitCustomTrainingJobRequest::registry_item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_id)
  return _internal_registry_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitCustomTrainingJobRequest::set_registry_item_id(ArgT0&& arg0, ArgT... args) {
 
 registry_item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_id)
}
inline std::string* SubmitCustomTrainingJobRequest::mutable_registry_item_id() {
  std::string* _s = _internal_mutable_registry_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_id)
  return _s;
}
inline const std::string& SubmitCustomTrainingJobRequest::_internal_registry_item_id() const {
  return registry_item_id_.Get();
}
inline void SubmitCustomTrainingJobRequest::_internal_set_registry_item_id(const std::string& value) {
  
  registry_item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::_internal_mutable_registry_item_id() {
  
  return registry_item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::release_registry_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_id)
  return registry_item_id_.Release();
}
inline void SubmitCustomTrainingJobRequest::set_allocated_registry_item_id(std::string* registry_item_id) {
  if (registry_item_id != nullptr) {
    
  } else {
    
  }
  registry_item_id_.SetAllocated(registry_item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (registry_item_id_.IsDefault()) {
    registry_item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_id)
}

// string registry_item_version = 6 [json_name = "registryItemVersion", (.tagger.v1.tags) = "bson:\"registry_item_version\" json:\"registry_item_version\""];
inline void SubmitCustomTrainingJobRequest::clear_registry_item_version() {
  registry_item_version_.ClearToEmpty();
}
inline const std::string& SubmitCustomTrainingJobRequest::registry_item_version() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_version)
  return _internal_registry_item_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitCustomTrainingJobRequest::set_registry_item_version(ArgT0&& arg0, ArgT... args) {
 
 registry_item_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_version)
}
inline std::string* SubmitCustomTrainingJobRequest::mutable_registry_item_version() {
  std::string* _s = _internal_mutable_registry_item_version();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_version)
  return _s;
}
inline const std::string& SubmitCustomTrainingJobRequest::_internal_registry_item_version() const {
  return registry_item_version_.Get();
}
inline void SubmitCustomTrainingJobRequest::_internal_set_registry_item_version(const std::string& value) {
  
  registry_item_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::_internal_mutable_registry_item_version() {
  
  return registry_item_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::release_registry_item_version() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_version)
  return registry_item_version_.Release();
}
inline void SubmitCustomTrainingJobRequest::set_allocated_registry_item_version(std::string* registry_item_version) {
  if (registry_item_version != nullptr) {
    
  } else {
    
  }
  registry_item_version_.SetAllocated(registry_item_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (registry_item_version_.IsDefault()) {
    registry_item_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.registry_item_version)
}

// string organization_id = 3 [json_name = "organizationId", (.tagger.v1.tags) = "bson:\"organization_id\" json:\"organization_id\""];
inline void SubmitCustomTrainingJobRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& SubmitCustomTrainingJobRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitCustomTrainingJobRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.organization_id)
}
inline std::string* SubmitCustomTrainingJobRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.organization_id)
  return _s;
}
inline const std::string& SubmitCustomTrainingJobRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void SubmitCustomTrainingJobRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.organization_id)
  return organization_id_.Release();
}
inline void SubmitCustomTrainingJobRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.organization_id)
}

// string model_name = 4 [json_name = "modelName", (.tagger.v1.tags) = "bson:\"model_name\" json:\"model_name\""];
inline void SubmitCustomTrainingJobRequest::clear_model_name() {
  model_name_.ClearToEmpty();
}
inline const std::string& SubmitCustomTrainingJobRequest::model_name() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitCustomTrainingJobRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_name)
}
inline std::string* SubmitCustomTrainingJobRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_name)
  return _s;
}
inline const std::string& SubmitCustomTrainingJobRequest::_internal_model_name() const {
  return model_name_.Get();
}
inline void SubmitCustomTrainingJobRequest::_internal_set_model_name(const std::string& value) {
  
  model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::_internal_mutable_model_name() {
  
  return model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_name)
  return model_name_.Release();
}
inline void SubmitCustomTrainingJobRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_name_.IsDefault()) {
    model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_name)
}

// string model_version = 5 [json_name = "modelVersion", (.tagger.v1.tags) = "bson:\"model_version\" json:\"model_version\""];
inline void SubmitCustomTrainingJobRequest::clear_model_version() {
  model_version_.ClearToEmpty();
}
inline const std::string& SubmitCustomTrainingJobRequest::model_version() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitCustomTrainingJobRequest::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_version)
}
inline std::string* SubmitCustomTrainingJobRequest::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_version)
  return _s;
}
inline const std::string& SubmitCustomTrainingJobRequest::_internal_model_version() const {
  return model_version_.Get();
}
inline void SubmitCustomTrainingJobRequest::_internal_set_model_version(const std::string& value) {
  
  model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::_internal_mutable_model_version() {
  
  return model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobRequest::release_model_version() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_version)
  return model_version_.Release();
}
inline void SubmitCustomTrainingJobRequest::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_version_.IsDefault()) {
    model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.model_version)
}

// map<string, string> arguments = 7 [json_name = "arguments"];
inline int SubmitCustomTrainingJobRequest::_internal_arguments_size() const {
  return arguments_.size();
}
inline int SubmitCustomTrainingJobRequest::arguments_size() const {
  return _internal_arguments_size();
}
inline void SubmitCustomTrainingJobRequest::clear_arguments() {
  arguments_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SubmitCustomTrainingJobRequest::_internal_arguments() const {
  return arguments_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SubmitCustomTrainingJobRequest::arguments() const {
  // @@protoc_insertion_point(field_map:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.arguments)
  return _internal_arguments();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SubmitCustomTrainingJobRequest::_internal_mutable_arguments() {
  return arguments_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SubmitCustomTrainingJobRequest::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.mltraining.v1.SubmitCustomTrainingJobRequest.arguments)
  return _internal_mutable_arguments();
}

// -------------------------------------------------------------------

// SubmitCustomTrainingJobResponse

// string id = 1 [json_name = "id"];
inline void SubmitCustomTrainingJobResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SubmitCustomTrainingJobResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitCustomTrainingJobResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitCustomTrainingJobResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitCustomTrainingJobResponse.id)
}
inline std::string* SubmitCustomTrainingJobResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitCustomTrainingJobResponse.id)
  return _s;
}
inline const std::string& SubmitCustomTrainingJobResponse::_internal_id() const {
  return id_.Get();
}
inline void SubmitCustomTrainingJobResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitCustomTrainingJobResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitCustomTrainingJobResponse.id)
  return id_.Release();
}
inline void SubmitCustomTrainingJobResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitCustomTrainingJobResponse.id)
}

// -------------------------------------------------------------------

// GetTrainingJobRequest

// string id = 1 [json_name = "id"];
inline void GetTrainingJobRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetTrainingJobRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTrainingJobRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.GetTrainingJobRequest.id)
}
inline std::string* GetTrainingJobRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobRequest.id)
  return _s;
}
inline const std::string& GetTrainingJobRequest::_internal_id() const {
  return id_.Get();
}
inline void GetTrainingJobRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTrainingJobRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTrainingJobRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobRequest.id)
  return id_.Release();
}
inline void GetTrainingJobRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobRequest.id)
}

// -------------------------------------------------------------------

// GetTrainingJobResponse

// .viam.app.mltraining.v1.TrainingJobMetadata metadata = 1 [json_name = "metadata"];
inline bool GetTrainingJobResponse::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool GetTrainingJobResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline void GetTrainingJobResponse::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& GetTrainingJobResponse::_internal_metadata() const {
  const ::viam::app::mltraining::v1::TrainingJobMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::mltraining::v1::TrainingJobMetadata&>(
      ::viam::app::mltraining::v1::_TrainingJobMetadata_default_instance_);
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& GetTrainingJobResponse::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
  return _internal_metadata();
}
inline void GetTrainingJobResponse::unsafe_arena_set_allocated_metadata(
    ::viam::app::mltraining::v1::TrainingJobMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::release_metadata() {
  
  ::viam::app::mltraining::v1::TrainingJobMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
  
  ::viam::app::mltraining::v1::TrainingJobMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJobMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::mutable_metadata() {
  ::viam::app::mltraining::v1::TrainingJobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
  return _msg;
}
inline void GetTrainingJobResponse::set_allocated_metadata(::viam::app::mltraining::v1::TrainingJobMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
}

// -------------------------------------------------------------------

// ListTrainingJobsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListTrainingJobsRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ListTrainingJobsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.ListTrainingJobsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTrainingJobsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.ListTrainingJobsRequest.organization_id)
}
inline std::string* ListTrainingJobsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.ListTrainingJobsRequest.organization_id)
  return _s;
}
inline const std::string& ListTrainingJobsRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ListTrainingJobsRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTrainingJobsRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTrainingJobsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.ListTrainingJobsRequest.organization_id)
  return organization_id_.Release();
}
inline void ListTrainingJobsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.ListTrainingJobsRequest.organization_id)
}

// .viam.app.mltraining.v1.TrainingStatus status = 2 [json_name = "status"];
inline void ListTrainingJobsRequest::clear_status() {
  status_ = 0;
}
inline ::viam::app::mltraining::v1::TrainingStatus ListTrainingJobsRequest::_internal_status() const {
  return static_cast< ::viam::app::mltraining::v1::TrainingStatus >(status_);
}
inline ::viam::app::mltraining::v1::TrainingStatus ListTrainingJobsRequest::status() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.ListTrainingJobsRequest.status)
  return _internal_status();
}
inline void ListTrainingJobsRequest::_internal_set_status(::viam::app::mltraining::v1::TrainingStatus value) {
  
  status_ = value;
}
inline void ListTrainingJobsRequest::set_status(::viam::app::mltraining::v1::TrainingStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.ListTrainingJobsRequest.status)
}

// -------------------------------------------------------------------

// ListTrainingJobsResponse

// repeated .viam.app.mltraining.v1.TrainingJobMetadata jobs = 1 [json_name = "jobs"];
inline int ListTrainingJobsResponse::_internal_jobs_size() const {
  return jobs_.size();
}
inline int ListTrainingJobsResponse::jobs_size() const {
  return _internal_jobs_size();
}
inline void ListTrainingJobsResponse::clear_jobs() {
  jobs_.Clear();
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* ListTrainingJobsResponse::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.ListTrainingJobsResponse.jobs)
  return jobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobMetadata >*
ListTrainingJobsResponse::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.mltraining.v1.ListTrainingJobsResponse.jobs)
  return &jobs_;
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& ListTrainingJobsResponse::_internal_jobs(int index) const {
  return jobs_.Get(index);
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& ListTrainingJobsResponse::jobs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.ListTrainingJobsResponse.jobs)
  return _internal_jobs(index);
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* ListTrainingJobsResponse::_internal_add_jobs() {
  return jobs_.Add();
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* ListTrainingJobsResponse::add_jobs() {
  ::viam::app::mltraining::v1::TrainingJobMetadata* _add = _internal_add_jobs();
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.ListTrainingJobsResponse.jobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobMetadata >&
ListTrainingJobsResponse::jobs() const {
  // @@protoc_insertion_point(field_list:viam.app.mltraining.v1.ListTrainingJobsResponse.jobs)
  return jobs_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TrainingJobMetadata

// string id = 7 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void TrainingJobMetadata::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.id)
}
inline std::string* TrainingJobMetadata::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.id)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_id() const {
  return id_.Get();
}
inline void TrainingJobMetadata::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.id)
  return id_.Release();
}
inline void TrainingJobMetadata::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.id)
}

// string dataset_id = 11 [json_name = "datasetId", (.tagger.v1.tags) = "bson:\"dataset_id\" json:\"dataset_id\""];
inline void TrainingJobMetadata::clear_dataset_id() {
  dataset_id_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::dataset_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.dataset_id)
  return _internal_dataset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_dataset_id(ArgT0&& arg0, ArgT... args) {
 
 dataset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.dataset_id)
}
inline std::string* TrainingJobMetadata::mutable_dataset_id() {
  std::string* _s = _internal_mutable_dataset_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.dataset_id)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_dataset_id() const {
  return dataset_id_.Get();
}
inline void TrainingJobMetadata::_internal_set_dataset_id(const std::string& value) {
  
  dataset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_dataset_id() {
  
  return dataset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_dataset_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.dataset_id)
  return dataset_id_.Release();
}
inline void TrainingJobMetadata::set_allocated_dataset_id(std::string* dataset_id) {
  if (dataset_id != nullptr) {
    
  } else {
    
  }
  dataset_id_.SetAllocated(dataset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dataset_id_.IsDefault()) {
    dataset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.dataset_id)
}

// string organization_id = 12 [json_name = "organizationId", (.tagger.v1.tags) = "bson:\"organization_id\" json:\"organization_id\""];
inline void TrainingJobMetadata::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.organization_id)
}
inline std::string* TrainingJobMetadata::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.organization_id)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void TrainingJobMetadata::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.organization_id)
  return organization_id_.Release();
}
inline void TrainingJobMetadata::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (organization_id_.IsDefault()) {
    organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.organization_id)
}

// string model_name = 13 [json_name = "modelName", (.tagger.v1.tags) = "bson:\"model_name\" json:\"model_name\""];
inline void TrainingJobMetadata::clear_model_name() {
  model_name_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::model_name() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.model_name)
}
inline std::string* TrainingJobMetadata::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.model_name)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_model_name() const {
  return model_name_.Get();
}
inline void TrainingJobMetadata::_internal_set_model_name(const std::string& value) {
  
  model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_model_name() {
  
  return model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_model_name() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.model_name)
  return model_name_.Release();
}
inline void TrainingJobMetadata::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_name_.IsDefault()) {
    model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.model_name)
}

// string model_version = 14 [json_name = "modelVersion", (.tagger.v1.tags) = "bson:\"model_version\" json:\"model_version\""];
inline void TrainingJobMetadata::clear_model_version() {
  model_version_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::model_version() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.model_version)
}
inline std::string* TrainingJobMetadata::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.model_version)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_model_version() const {
  return model_version_.Get();
}
inline void TrainingJobMetadata::_internal_set_model_version(const std::string& value) {
  
  model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_model_version() {
  
  return model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_model_version() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.model_version)
  return model_version_.Release();
}
inline void TrainingJobMetadata::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_version_.IsDefault()) {
    model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.model_version)
}

// .viam.app.mltraining.v1.ModelType model_type = 15 [json_name = "modelType", (.tagger.v1.tags) = "bson:\"model_type\" json:\"model_type\""];
inline void TrainingJobMetadata::clear_model_type() {
  model_type_ = 0;
}
inline ::viam::app::mltraining::v1::ModelType TrainingJobMetadata::_internal_model_type() const {
  return static_cast< ::viam::app::mltraining::v1::ModelType >(model_type_);
}
inline ::viam::app::mltraining::v1::ModelType TrainingJobMetadata::model_type() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.model_type)
  return _internal_model_type();
}
inline void TrainingJobMetadata::_internal_set_model_type(::viam::app::mltraining::v1::ModelType value) {
  
  model_type_ = value;
}
inline void TrainingJobMetadata::set_model_type(::viam::app::mltraining::v1::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.model_type)
}

// .viam.app.mltraining.v1.ModelFramework model_framework = 17 [json_name = "modelFramework", (.tagger.v1.tags) = "bson:\"model_framework\" json:\"model_framework\""];
inline void TrainingJobMetadata::clear_model_framework() {
  model_framework_ = 0;
}
inline ::viam::app::mltraining::v1::ModelFramework TrainingJobMetadata::_internal_model_framework() const {
  return static_cast< ::viam::app::mltraining::v1::ModelFramework >(model_framework_);
}
inline ::viam::app::mltraining::v1::ModelFramework TrainingJobMetadata::model_framework() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.model_framework)
  return _internal_model_framework();
}
inline void TrainingJobMetadata::_internal_set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  
  model_framework_ = value;
}
inline void TrainingJobMetadata::set_model_framework(::viam::app::mltraining::v1::ModelFramework value) {
  _internal_set_model_framework(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.model_framework)
}

// bool is_custom_job = 18 [json_name = "isCustomJob", (.tagger.v1.tags) = "bson:\"is_custom_job\" json:\"is_custom_job\""];
inline void TrainingJobMetadata::clear_is_custom_job() {
  is_custom_job_ = false;
}
inline bool TrainingJobMetadata::_internal_is_custom_job() const {
  return is_custom_job_;
}
inline bool TrainingJobMetadata::is_custom_job() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.is_custom_job)
  return _internal_is_custom_job();
}
inline void TrainingJobMetadata::_internal_set_is_custom_job(bool value) {
  
  is_custom_job_ = value;
}
inline void TrainingJobMetadata::set_is_custom_job(bool value) {
  _internal_set_is_custom_job(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.is_custom_job)
}

// string registry_item_id = 19 [json_name = "registryItemId", (.tagger.v1.tags) = "bson:\"registry_item_id\" json:\"registry_item_id\""];
inline void TrainingJobMetadata::clear_registry_item_id() {
  registry_item_id_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::registry_item_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_id)
  return _internal_registry_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_registry_item_id(ArgT0&& arg0, ArgT... args) {
 
 registry_item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_id)
}
inline std::string* TrainingJobMetadata::mutable_registry_item_id() {
  std::string* _s = _internal_mutable_registry_item_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_id)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_registry_item_id() const {
  return registry_item_id_.Get();
}
inline void TrainingJobMetadata::_internal_set_registry_item_id(const std::string& value) {
  
  registry_item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_registry_item_id() {
  
  return registry_item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_registry_item_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_id)
  return registry_item_id_.Release();
}
inline void TrainingJobMetadata::set_allocated_registry_item_id(std::string* registry_item_id) {
  if (registry_item_id != nullptr) {
    
  } else {
    
  }
  registry_item_id_.SetAllocated(registry_item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (registry_item_id_.IsDefault()) {
    registry_item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_id)
}

// string registry_item_version = 20 [json_name = "registryItemVersion", (.tagger.v1.tags) = "bson:\"registry_item_version\" json:\"registry_item_version\""];
inline void TrainingJobMetadata::clear_registry_item_version() {
  registry_item_version_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::registry_item_version() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_version)
  return _internal_registry_item_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_registry_item_version(ArgT0&& arg0, ArgT... args) {
 
 registry_item_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_version)
}
inline std::string* TrainingJobMetadata::mutable_registry_item_version() {
  std::string* _s = _internal_mutable_registry_item_version();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_version)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_registry_item_version() const {
  return registry_item_version_.Get();
}
inline void TrainingJobMetadata::_internal_set_registry_item_version(const std::string& value) {
  
  registry_item_version_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_registry_item_version() {
  
  return registry_item_version_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_registry_item_version() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_version)
  return registry_item_version_.Release();
}
inline void TrainingJobMetadata::set_allocated_registry_item_version(std::string* registry_item_version) {
  if (registry_item_version != nullptr) {
    
  } else {
    
  }
  registry_item_version_.SetAllocated(registry_item_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (registry_item_version_.IsDefault()) {
    registry_item_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.registry_item_version)
}

// .viam.app.mltraining.v1.TrainingStatus status = 2 [json_name = "status", (.tagger.v1.tags) = "bson:\"status\" json:\"status\""];
inline void TrainingJobMetadata::clear_status() {
  status_ = 0;
}
inline ::viam::app::mltraining::v1::TrainingStatus TrainingJobMetadata::_internal_status() const {
  return static_cast< ::viam::app::mltraining::v1::TrainingStatus >(status_);
}
inline ::viam::app::mltraining::v1::TrainingStatus TrainingJobMetadata::status() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.status)
  return _internal_status();
}
inline void TrainingJobMetadata::_internal_set_status(::viam::app::mltraining::v1::TrainingStatus value) {
  
  status_ = value;
}
inline void TrainingJobMetadata::set_status(::viam::app::mltraining::v1::TrainingStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.status)
}

// .google.rpc.Status error_status = 8 [json_name = "errorStatus", (.tagger.v1.tags) = "bson:\"error_status\" json:\"error_status\""];
inline bool TrainingJobMetadata::_internal_has_error_status() const {
  return this != internal_default_instance() && error_status_ != nullptr;
}
inline bool TrainingJobMetadata::has_error_status() const {
  return _internal_has_error_status();
}
inline const ::google::rpc::Status& TrainingJobMetadata::_internal_error_status() const {
  const ::google::rpc::Status* p = error_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& TrainingJobMetadata::error_status() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.error_status)
  return _internal_error_status();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_error_status(
    ::google::rpc::Status* error_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_status_);
  }
  error_status_ = error_status;
  if (error_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.error_status)
}
inline ::google::rpc::Status* TrainingJobMetadata::release_error_status() {
  
  ::google::rpc::Status* temp = error_status_;
  error_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* TrainingJobMetadata::unsafe_arena_release_error_status() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.error_status)
  
  ::google::rpc::Status* temp = error_status_;
  error_status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* TrainingJobMetadata::_internal_mutable_error_status() {
  
  if (error_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    error_status_ = p;
  }
  return error_status_;
}
inline ::google::rpc::Status* TrainingJobMetadata::mutable_error_status() {
  ::google::rpc::Status* _msg = _internal_mutable_error_status();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.error_status)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_error_status(::google::rpc::Status* error_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_status_);
  }
  if (error_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_status));
    if (message_arena != submessage_arena) {
      error_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_status, submessage_arena);
    }
    
  } else {
    
  }
  error_status_ = error_status;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.error_status)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
inline bool TrainingJobMetadata::_internal_has_created_on() const {
  return this != internal_default_instance() && created_on_ != nullptr;
}
inline bool TrainingJobMetadata::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
  return _internal_created_on();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_on_;
  created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::_internal_mutable_created_on() {
  
  if (created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_on_ = p;
  }
  return created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
}

// .google.protobuf.Timestamp last_modified = 4 [json_name = "lastModified", (.tagger.v1.tags) = "bson:\"last_modified\" json:\"last_modified\""];
inline bool TrainingJobMetadata::_internal_has_last_modified() const {
  return this != internal_default_instance() && last_modified_ != nullptr;
}
inline bool TrainingJobMetadata::has_last_modified() const {
  return _internal_has_last_modified();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::_internal_last_modified() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_modified_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::last_modified() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
  return _internal_last_modified();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_last_modified(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  last_modified_ = last_modified;
  if (last_modified) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::release_last_modified() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::unsafe_arena_release_last_modified() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_modified_;
  last_modified_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::_internal_mutable_last_modified() {
  
  if (last_modified_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_modified_ = p;
  }
  return last_modified_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::mutable_last_modified() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_last_modified(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified_);
  }
  if (last_modified) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified));
    if (message_arena != submessage_arena) {
      last_modified = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_modified_ = last_modified;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
}

// .google.protobuf.Timestamp training_started = 9 [json_name = "trainingStarted", (.tagger.v1.tags) = "bson:\"training_started\" json:\"training_started\""];
inline bool TrainingJobMetadata::_internal_has_training_started() const {
  return this != internal_default_instance() && training_started_ != nullptr;
}
inline bool TrainingJobMetadata::has_training_started() const {
  return _internal_has_training_started();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::_internal_training_started() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = training_started_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::training_started() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.training_started)
  return _internal_training_started();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_training_started(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* training_started) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_started_);
  }
  training_started_ = training_started;
  if (training_started) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.training_started)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::release_training_started() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = training_started_;
  training_started_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::unsafe_arena_release_training_started() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.training_started)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = training_started_;
  training_started_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::_internal_mutable_training_started() {
  
  if (training_started_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    training_started_ = p;
  }
  return training_started_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::mutable_training_started() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_training_started();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.training_started)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_training_started(::PROTOBUF_NAMESPACE_ID::Timestamp* training_started) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_started_);
  }
  if (training_started) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_started));
    if (message_arena != submessage_arena) {
      training_started = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, training_started, submessage_arena);
    }
    
  } else {
    
  }
  training_started_ = training_started;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.training_started)
}

// .google.protobuf.Timestamp training_ended = 10 [json_name = "trainingEnded", (.tagger.v1.tags) = "bson:\"training_ended\" json:\"training_ended\""];
inline bool TrainingJobMetadata::_internal_has_training_ended() const {
  return this != internal_default_instance() && training_ended_ != nullptr;
}
inline bool TrainingJobMetadata::has_training_ended() const {
  return _internal_has_training_ended();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::_internal_training_ended() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = training_ended_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::training_ended() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.training_ended)
  return _internal_training_ended();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_training_ended(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* training_ended) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_ended_);
  }
  training_ended_ = training_ended;
  if (training_ended) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.training_ended)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::release_training_ended() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = training_ended_;
  training_ended_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::unsafe_arena_release_training_ended() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.training_ended)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = training_ended_;
  training_ended_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::_internal_mutable_training_ended() {
  
  if (training_ended_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    training_ended_ = p;
  }
  return training_ended_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::mutable_training_ended() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_training_ended();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.training_ended)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_training_ended(::PROTOBUF_NAMESPACE_ID::Timestamp* training_ended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_ended_);
  }
  if (training_ended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_ended));
    if (message_arena != submessage_arena) {
      training_ended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, training_ended, submessage_arena);
    }
    
  } else {
    
  }
  training_ended_ = training_ended;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.training_ended)
}

// string synced_model_id = 5 [json_name = "syncedModelId", (.tagger.v1.tags) = "bson:\"synced_model_id\" json:\"synced_model_id\""];
inline void TrainingJobMetadata::clear_synced_model_id() {
  synced_model_id_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::synced_model_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
  return _internal_synced_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_synced_model_id(ArgT0&& arg0, ArgT... args) {
 
 synced_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
}
inline std::string* TrainingJobMetadata::mutable_synced_model_id() {
  std::string* _s = _internal_mutable_synced_model_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_synced_model_id() const {
  return synced_model_id_.Get();
}
inline void TrainingJobMetadata::_internal_set_synced_model_id(const std::string& value) {
  
  synced_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_synced_model_id() {
  
  return synced_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_synced_model_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
  return synced_model_id_.Release();
}
inline void TrainingJobMetadata::set_allocated_synced_model_id(std::string* synced_model_id) {
  if (synced_model_id != nullptr) {
    
  } else {
    
  }
  synced_model_id_.SetAllocated(synced_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (synced_model_id_.IsDefault()) {
    synced_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
}

// repeated string tags = 16 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
inline int TrainingJobMetadata::_internal_tags_size() const {
  return tags_.size();
}
inline int TrainingJobMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void TrainingJobMetadata::clear_tags() {
  tags_.Clear();
}
inline std::string* TrainingJobMetadata::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.mltraining.v1.TrainingJobMetadata.tags)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& TrainingJobMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.tags)
  return _internal_tags(index);
}
inline std::string* TrainingJobMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.tags)
  return tags_.Mutable(index);
}
inline void TrainingJobMetadata::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline void TrainingJobMetadata::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline void TrainingJobMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline void TrainingJobMetadata::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline std::string* TrainingJobMetadata::_internal_add_tags() {
  return tags_.Add();
}
inline void TrainingJobMetadata::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline void TrainingJobMetadata::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline void TrainingJobMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline void TrainingJobMetadata::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.mltraining.v1.TrainingJobMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrainingJobMetadata::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.mltraining.v1.TrainingJobMetadata.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrainingJobMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.mltraining.v1.TrainingJobMetadata.tags)
  return &tags_;
}

// map<string, string> arguments = 21 [json_name = "arguments", (.tagger.v1.tags) = "bson:\"arguments\" json:\"arguments\""];
inline int TrainingJobMetadata::_internal_arguments_size() const {
  return arguments_.size();
}
inline int TrainingJobMetadata::arguments_size() const {
  return _internal_arguments_size();
}
inline void TrainingJobMetadata::clear_arguments() {
  arguments_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TrainingJobMetadata::_internal_arguments() const {
  return arguments_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TrainingJobMetadata::arguments() const {
  // @@protoc_insertion_point(field_map:viam.app.mltraining.v1.TrainingJobMetadata.arguments)
  return _internal_arguments();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TrainingJobMetadata::_internal_mutable_arguments() {
  return arguments_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TrainingJobMetadata::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.mltraining.v1.TrainingJobMetadata.arguments)
  return _internal_mutable_arguments();
}

// -------------------------------------------------------------------

// CancelTrainingJobRequest

// string id = 1 [json_name = "id"];
inline void CancelTrainingJobRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CancelTrainingJobRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.CancelTrainingJobRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelTrainingJobRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.CancelTrainingJobRequest.id)
}
inline std::string* CancelTrainingJobRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.CancelTrainingJobRequest.id)
  return _s;
}
inline const std::string& CancelTrainingJobRequest::_internal_id() const {
  return id_.Get();
}
inline void CancelTrainingJobRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelTrainingJobRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelTrainingJobRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.CancelTrainingJobRequest.id)
  return id_.Release();
}
inline void CancelTrainingJobRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.CancelTrainingJobRequest.id)
}

// -------------------------------------------------------------------

// CancelTrainingJobResponse

// -------------------------------------------------------------------

// DeleteCompletedTrainingJobRequest

// string id = 1 [json_name = "id"];
inline void DeleteCompletedTrainingJobRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteCompletedTrainingJobRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteCompletedTrainingJobRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest.id)
}
inline std::string* DeleteCompletedTrainingJobRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest.id)
  return _s;
}
inline const std::string& DeleteCompletedTrainingJobRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteCompletedTrainingJobRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteCompletedTrainingJobRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteCompletedTrainingJobRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest.id)
  return id_.Release();
}
inline void DeleteCompletedTrainingJobRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.DeleteCompletedTrainingJobRequest.id)
}

// -------------------------------------------------------------------

// DeleteCompletedTrainingJobResponse

// -------------------------------------------------------------------

// TrainingJobLogEntry

// string level = 1 [json_name = "level"];
inline void TrainingJobLogEntry::clear_level() {
  level_.ClearToEmpty();
}
inline const std::string& TrainingJobLogEntry::level() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobLogEntry.level)
  return _internal_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobLogEntry::set_level(ArgT0&& arg0, ArgT... args) {
 
 level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobLogEntry.level)
}
inline std::string* TrainingJobLogEntry::mutable_level() {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobLogEntry.level)
  return _s;
}
inline const std::string& TrainingJobLogEntry::_internal_level() const {
  return level_.Get();
}
inline void TrainingJobLogEntry::_internal_set_level(const std::string& value) {
  
  level_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobLogEntry::_internal_mutable_level() {
  
  return level_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobLogEntry::release_level() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobLogEntry.level)
  return level_.Release();
}
inline void TrainingJobLogEntry::set_allocated_level(std::string* level) {
  if (level != nullptr) {
    
  } else {
    
  }
  level_.SetAllocated(level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (level_.IsDefault()) {
    level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobLogEntry.level)
}

// .google.protobuf.Timestamp time = 2 [json_name = "time"];
inline bool TrainingJobLogEntry::_internal_has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline bool TrainingJobLogEntry::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobLogEntry::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobLogEntry::time() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobLogEntry.time)
  return _internal_time();
}
inline void TrainingJobLogEntry::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobLogEntry.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobLogEntry::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobLogEntry::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobLogEntry.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobLogEntry::_internal_mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobLogEntry::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobLogEntry.time)
  return _msg;
}
inline void TrainingJobLogEntry::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobLogEntry.time)
}

// string message = 3 [json_name = "message"];
inline void TrainingJobLogEntry::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& TrainingJobLogEntry::message() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobLogEntry.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobLogEntry::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobLogEntry.message)
}
inline std::string* TrainingJobLogEntry::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobLogEntry.message)
  return _s;
}
inline const std::string& TrainingJobLogEntry::_internal_message() const {
  return message_.Get();
}
inline void TrainingJobLogEntry::_internal_set_message(const std::string& value) {
  
  message_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobLogEntry::_internal_mutable_message() {
  
  return message_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobLogEntry::release_message() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobLogEntry.message)
  return message_.Release();
}
inline void TrainingJobLogEntry::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobLogEntry.message)
}

// -------------------------------------------------------------------

// GetTrainingJobLogsRequest

// string id = 1 [json_name = "id"];
inline void GetTrainingJobLogsRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetTrainingJobLogsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobLogsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTrainingJobLogsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.GetTrainingJobLogsRequest.id)
}
inline std::string* GetTrainingJobLogsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobLogsRequest.id)
  return _s;
}
inline const std::string& GetTrainingJobLogsRequest::_internal_id() const {
  return id_.Get();
}
inline void GetTrainingJobLogsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTrainingJobLogsRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTrainingJobLogsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobLogsRequest.id)
  return id_.Release();
}
inline void GetTrainingJobLogsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobLogsRequest.id)
}

// optional string page_token = 2 [json_name = "pageToken"];
inline bool GetTrainingJobLogsRequest::_internal_has_page_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetTrainingJobLogsRequest::has_page_token() const {
  return _internal_has_page_token();
}
inline void GetTrainingJobLogsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetTrainingJobLogsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobLogsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTrainingJobLogsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.GetTrainingJobLogsRequest.page_token)
}
inline std::string* GetTrainingJobLogsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobLogsRequest.page_token)
  return _s;
}
inline const std::string& GetTrainingJobLogsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void GetTrainingJobLogsRequest::_internal_set_page_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTrainingJobLogsRequest::_internal_mutable_page_token() {
  _has_bits_[0] |= 0x00000001u;
  return page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTrainingJobLogsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobLogsRequest.page_token)
  if (!_internal_has_page_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetTrainingJobLogsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault()) {
    page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobLogsRequest.page_token)
}

// -------------------------------------------------------------------

// GetTrainingJobLogsResponse

// repeated .viam.app.mltraining.v1.TrainingJobLogEntry logs = 1 [json_name = "logs"];
inline int GetTrainingJobLogsResponse::_internal_logs_size() const {
  return logs_.size();
}
inline int GetTrainingJobLogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline void GetTrainingJobLogsResponse::clear_logs() {
  logs_.Clear();
}
inline ::viam::app::mltraining::v1::TrainingJobLogEntry* GetTrainingJobLogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobLogsResponse.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobLogEntry >*
GetTrainingJobLogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.mltraining.v1.GetTrainingJobLogsResponse.logs)
  return &logs_;
}
inline const ::viam::app::mltraining::v1::TrainingJobLogEntry& GetTrainingJobLogsResponse::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::viam::app::mltraining::v1::TrainingJobLogEntry& GetTrainingJobLogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobLogsResponse.logs)
  return _internal_logs(index);
}
inline ::viam::app::mltraining::v1::TrainingJobLogEntry* GetTrainingJobLogsResponse::_internal_add_logs() {
  return logs_.Add();
}
inline ::viam::app::mltraining::v1::TrainingJobLogEntry* GetTrainingJobLogsResponse::add_logs() {
  ::viam::app::mltraining::v1::TrainingJobLogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.GetTrainingJobLogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::mltraining::v1::TrainingJobLogEntry >&
GetTrainingJobLogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.mltraining.v1.GetTrainingJobLogsResponse.logs)
  return logs_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void GetTrainingJobLogsResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& GetTrainingJobLogsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobLogsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTrainingJobLogsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.GetTrainingJobLogsResponse.next_page_token)
}
inline std::string* GetTrainingJobLogsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobLogsResponse.next_page_token)
  return _s;
}
inline const std::string& GetTrainingJobLogsResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void GetTrainingJobLogsResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTrainingJobLogsResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTrainingJobLogsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobLogsResponse.next_page_token)
  return next_page_token_.Release();
}
inline void GetTrainingJobLogsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobLogsResponse.next_page_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace mltraining
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::mltraining::v1::ModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::mltraining::v1::ModelType>() {
  return ::viam::app::mltraining::v1::ModelType_descriptor();
}
template <> struct is_proto_enum< ::viam::app::mltraining::v1::ModelFramework> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::mltraining::v1::ModelFramework>() {
  return ::viam::app::mltraining::v1::ModelFramework_descriptor();
}
template <> struct is_proto_enum< ::viam::app::mltraining::v1::TrainingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::mltraining::v1::TrainingStatus>() {
  return ::viam::app::mltraining::v1::TrainingStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fmltraining_2fv1_2fml_5ftraining_2eproto
