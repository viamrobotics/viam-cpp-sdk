// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/datasync/v1/data_sync.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fdatasync_2fv1_2fdata_5fsync_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fdatasync_2fv1_2fdata_5fsync_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fdatasync_2fv1_2fdata_5fsync_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
namespace viam {
namespace app {
namespace datasync {
namespace v1 {
class BinaryCapture;
struct BinaryCaptureDefaultTypeInternal;
extern BinaryCaptureDefaultTypeInternal _BinaryCapture_default_instance_;
class BinaryCapture_MethodParametersEntry_DoNotUse;
struct BinaryCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern BinaryCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal _BinaryCapture_MethodParametersEntry_DoNotUse_default_instance_;
class CaptureInterval;
struct CaptureIntervalDefaultTypeInternal;
extern CaptureIntervalDefaultTypeInternal _CaptureInterval_default_instance_;
class DataCaptureMetadata;
struct DataCaptureMetadataDefaultTypeInternal;
extern DataCaptureMetadataDefaultTypeInternal _DataCaptureMetadata_default_instance_;
class DataCaptureMetadata_MethodParametersEntry_DoNotUse;
struct DataCaptureMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern DataCaptureMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal _DataCaptureMetadata_MethodParametersEntry_DoNotUse_default_instance_;
class DataCaptureUploadRequest;
struct DataCaptureUploadRequestDefaultTypeInternal;
extern DataCaptureUploadRequestDefaultTypeInternal _DataCaptureUploadRequest_default_instance_;
class DataCaptureUploadResponse;
struct DataCaptureUploadResponseDefaultTypeInternal;
extern DataCaptureUploadResponseDefaultTypeInternal _DataCaptureUploadResponse_default_instance_;
class FileData;
struct FileDataDefaultTypeInternal;
extern FileDataDefaultTypeInternal _FileData_default_instance_;
class FileUploadRequest;
struct FileUploadRequestDefaultTypeInternal;
extern FileUploadRequestDefaultTypeInternal _FileUploadRequest_default_instance_;
class FileUploadResponse;
struct FileUploadResponseDefaultTypeInternal;
extern FileUploadResponseDefaultTypeInternal _FileUploadResponse_default_instance_;
class SensorData;
struct SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorMetadata;
struct SensorMetadataDefaultTypeInternal;
extern SensorMetadataDefaultTypeInternal _SensorMetadata_default_instance_;
class TabularCapture;
struct TabularCaptureDefaultTypeInternal;
extern TabularCaptureDefaultTypeInternal _TabularCapture_default_instance_;
class TabularCapture_MethodParametersEntry_DoNotUse;
struct TabularCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern TabularCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal _TabularCapture_MethodParametersEntry_DoNotUse_default_instance_;
class UploadMetadata;
struct UploadMetadataDefaultTypeInternal;
extern UploadMetadataDefaultTypeInternal _UploadMetadata_default_instance_;
class UploadMetadata_MethodParametersEntry_DoNotUse;
struct UploadMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern UploadMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal _UploadMetadata_MethodParametersEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace datasync
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::datasync::v1::BinaryCapture* Arena::CreateMaybeMessage<::viam::app::datasync::v1::BinaryCapture>(Arena*);
template<> ::viam::app::datasync::v1::BinaryCapture_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::BinaryCapture_MethodParametersEntry_DoNotUse>(Arena*);
template<> ::viam::app::datasync::v1::CaptureInterval* Arena::CreateMaybeMessage<::viam::app::datasync::v1::CaptureInterval>(Arena*);
template<> ::viam::app::datasync::v1::DataCaptureMetadata* Arena::CreateMaybeMessage<::viam::app::datasync::v1::DataCaptureMetadata>(Arena*);
template<> ::viam::app::datasync::v1::DataCaptureMetadata_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::DataCaptureMetadata_MethodParametersEntry_DoNotUse>(Arena*);
template<> ::viam::app::datasync::v1::DataCaptureUploadRequest* Arena::CreateMaybeMessage<::viam::app::datasync::v1::DataCaptureUploadRequest>(Arena*);
template<> ::viam::app::datasync::v1::DataCaptureUploadResponse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::DataCaptureUploadResponse>(Arena*);
template<> ::viam::app::datasync::v1::FileData* Arena::CreateMaybeMessage<::viam::app::datasync::v1::FileData>(Arena*);
template<> ::viam::app::datasync::v1::FileUploadRequest* Arena::CreateMaybeMessage<::viam::app::datasync::v1::FileUploadRequest>(Arena*);
template<> ::viam::app::datasync::v1::FileUploadResponse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::FileUploadResponse>(Arena*);
template<> ::viam::app::datasync::v1::SensorData* Arena::CreateMaybeMessage<::viam::app::datasync::v1::SensorData>(Arena*);
template<> ::viam::app::datasync::v1::SensorMetadata* Arena::CreateMaybeMessage<::viam::app::datasync::v1::SensorMetadata>(Arena*);
template<> ::viam::app::datasync::v1::TabularCapture* Arena::CreateMaybeMessage<::viam::app::datasync::v1::TabularCapture>(Arena*);
template<> ::viam::app::datasync::v1::TabularCapture_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::TabularCapture_MethodParametersEntry_DoNotUse>(Arena*);
template<> ::viam::app::datasync::v1::UploadMetadata* Arena::CreateMaybeMessage<::viam::app::datasync::v1::UploadMetadata>(Arena*);
template<> ::viam::app::datasync::v1::UploadMetadata_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::UploadMetadata_MethodParametersEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace datasync {
namespace v1 {

enum DataType : int {
  DATA_TYPE_UNSPECIFIED = 0,
  DATA_TYPE_BINARY_SENSOR = 1,
  DATA_TYPE_TABULAR_SENSOR = 2,
  DATA_TYPE_FILE = 3,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = DATA_TYPE_UNSPECIFIED;
constexpr DataType DataType_MAX = DATA_TYPE_FILE;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class DataCaptureUploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.DataCaptureUploadRequest) */ {
 public:
  inline DataCaptureUploadRequest() : DataCaptureUploadRequest(nullptr) {}
  ~DataCaptureUploadRequest() override;
  explicit PROTOBUF_CONSTEXPR DataCaptureUploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataCaptureUploadRequest(const DataCaptureUploadRequest& from);
  DataCaptureUploadRequest(DataCaptureUploadRequest&& from) noexcept
    : DataCaptureUploadRequest() {
    *this = ::std::move(from);
  }

  inline DataCaptureUploadRequest& operator=(const DataCaptureUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCaptureUploadRequest& operator=(DataCaptureUploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataCaptureUploadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataCaptureUploadRequest* internal_default_instance() {
    return reinterpret_cast<const DataCaptureUploadRequest*>(
               &_DataCaptureUploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataCaptureUploadRequest& a, DataCaptureUploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCaptureUploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCaptureUploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataCaptureUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataCaptureUploadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataCaptureUploadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataCaptureUploadRequest& from) {
    DataCaptureUploadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataCaptureUploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.DataCaptureUploadRequest";
  }
  protected:
  explicit DataCaptureUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorContentsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .viam.app.datasync.v1.SensorData sensor_contents = 2 [json_name = "sensorContents"];
  int sensor_contents_size() const;
  private:
  int _internal_sensor_contents_size() const;
  public:
  void clear_sensor_contents();
  ::viam::app::datasync::v1::SensorData* mutable_sensor_contents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::datasync::v1::SensorData >*
      mutable_sensor_contents();
  private:
  const ::viam::app::datasync::v1::SensorData& _internal_sensor_contents(int index) const;
  ::viam::app::datasync::v1::SensorData* _internal_add_sensor_contents();
  public:
  const ::viam::app::datasync::v1::SensorData& sensor_contents(int index) const;
  ::viam::app::datasync::v1::SensorData* add_sensor_contents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::datasync::v1::SensorData >&
      sensor_contents() const;

  // .viam.app.datasync.v1.UploadMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::datasync::v1::UploadMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::UploadMetadata* release_metadata();
  ::viam::app::datasync::v1::UploadMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::datasync::v1::UploadMetadata* metadata);
  private:
  const ::viam::app::datasync::v1::UploadMetadata& _internal_metadata() const;
  ::viam::app::datasync::v1::UploadMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::datasync::v1::UploadMetadata* metadata);
  ::viam::app::datasync::v1::UploadMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.DataCaptureUploadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::datasync::v1::SensorData > sensor_contents_;
    ::viam::app::datasync::v1::UploadMetadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class DataCaptureUploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.DataCaptureUploadResponse) */ {
 public:
  inline DataCaptureUploadResponse() : DataCaptureUploadResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DataCaptureUploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataCaptureUploadResponse(const DataCaptureUploadResponse& from);
  DataCaptureUploadResponse(DataCaptureUploadResponse&& from) noexcept
    : DataCaptureUploadResponse() {
    *this = ::std::move(from);
  }

  inline DataCaptureUploadResponse& operator=(const DataCaptureUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCaptureUploadResponse& operator=(DataCaptureUploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataCaptureUploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataCaptureUploadResponse* internal_default_instance() {
    return reinterpret_cast<const DataCaptureUploadResponse*>(
               &_DataCaptureUploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DataCaptureUploadResponse& a, DataCaptureUploadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCaptureUploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCaptureUploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataCaptureUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataCaptureUploadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataCaptureUploadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataCaptureUploadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.DataCaptureUploadResponse";
  }
  protected:
  explicit DataCaptureUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.DataCaptureUploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class FileUploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.FileUploadRequest) */ {
 public:
  inline FileUploadRequest() : FileUploadRequest(nullptr) {}
  ~FileUploadRequest() override;
  explicit PROTOBUF_CONSTEXPR FileUploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileUploadRequest(const FileUploadRequest& from);
  FileUploadRequest(FileUploadRequest&& from) noexcept
    : FileUploadRequest() {
    *this = ::std::move(from);
  }

  inline FileUploadRequest& operator=(const FileUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileUploadRequest& operator=(FileUploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileUploadRequest& default_instance() {
    return *internal_default_instance();
  }
  enum UploadPacketCase {
    kMetadata = 1,
    kFileContents = 2,
    UPLOAD_PACKET_NOT_SET = 0,
  };

  static inline const FileUploadRequest* internal_default_instance() {
    return reinterpret_cast<const FileUploadRequest*>(
               &_FileUploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileUploadRequest& a, FileUploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileUploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileUploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileUploadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileUploadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileUploadRequest& from) {
    FileUploadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileUploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.FileUploadRequest";
  }
  protected:
  explicit FileUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kFileContentsFieldNumber = 2,
  };
  // .viam.app.datasync.v1.UploadMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::datasync::v1::UploadMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::UploadMetadata* release_metadata();
  ::viam::app::datasync::v1::UploadMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::datasync::v1::UploadMetadata* metadata);
  private:
  const ::viam::app::datasync::v1::UploadMetadata& _internal_metadata() const;
  ::viam::app::datasync::v1::UploadMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::datasync::v1::UploadMetadata* metadata);
  ::viam::app::datasync::v1::UploadMetadata* unsafe_arena_release_metadata();

  // .viam.app.datasync.v1.FileData file_contents = 2 [json_name = "fileContents"];
  bool has_file_contents() const;
  private:
  bool _internal_has_file_contents() const;
  public:
  void clear_file_contents();
  const ::viam::app::datasync::v1::FileData& file_contents() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::FileData* release_file_contents();
  ::viam::app::datasync::v1::FileData* mutable_file_contents();
  void set_allocated_file_contents(::viam::app::datasync::v1::FileData* file_contents);
  private:
  const ::viam::app::datasync::v1::FileData& _internal_file_contents() const;
  ::viam::app::datasync::v1::FileData* _internal_mutable_file_contents();
  public:
  void unsafe_arena_set_allocated_file_contents(
      ::viam::app::datasync::v1::FileData* file_contents);
  ::viam::app::datasync::v1::FileData* unsafe_arena_release_file_contents();

  void clear_upload_packet();
  UploadPacketCase upload_packet_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.FileUploadRequest)
 private:
  class _Internal;
  void set_has_metadata();
  void set_has_file_contents();

  inline bool has_upload_packet() const;
  inline void clear_has_upload_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union UploadPacketUnion {
      constexpr UploadPacketUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::viam::app::datasync::v1::UploadMetadata* metadata_;
      ::viam::app::datasync::v1::FileData* file_contents_;
    } upload_packet_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class FileUploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.FileUploadResponse) */ {
 public:
  inline FileUploadResponse() : FileUploadResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FileUploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileUploadResponse(const FileUploadResponse& from);
  FileUploadResponse(FileUploadResponse&& from) noexcept
    : FileUploadResponse() {
    *this = ::std::move(from);
  }

  inline FileUploadResponse& operator=(const FileUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileUploadResponse& operator=(FileUploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileUploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileUploadResponse* internal_default_instance() {
    return reinterpret_cast<const FileUploadResponse*>(
               &_FileUploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileUploadResponse& a, FileUploadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FileUploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileUploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileUploadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FileUploadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FileUploadResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.FileUploadResponse";
  }
  protected:
  explicit FileUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.FileUploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class SensorMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.SensorMetadata) */ {
 public:
  inline SensorMetadata() : SensorMetadata(nullptr) {}
  ~SensorMetadata() override;
  explicit PROTOBUF_CONSTEXPR SensorMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMetadata(const SensorMetadata& from);
  SensorMetadata(SensorMetadata&& from) noexcept
    : SensorMetadata() {
    *this = ::std::move(from);
  }

  inline SensorMetadata& operator=(const SensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMetadata& operator=(SensorMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMetadata* internal_default_instance() {
    return reinterpret_cast<const SensorMetadata*>(
               &_SensorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SensorMetadata& a, SensorMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorMetadata& from) {
    SensorMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.SensorMetadata";
  }
  protected:
  explicit SensorMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeRequestedFieldNumber = 1,
    kTimeReceivedFieldNumber = 2,
  };
  // .google.protobuf.Timestamp time_requested = 1 [json_name = "timeRequested"];
  bool has_time_requested() const;
  private:
  bool _internal_has_time_requested() const;
  public:
  void clear_time_requested();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_requested() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time_requested();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time_requested();
  void set_allocated_time_requested(::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time_requested() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time_requested();
  public:
  void unsafe_arena_set_allocated_time_requested(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time_requested();

  // .google.protobuf.Timestamp time_received = 2 [json_name = "timeReceived"];
  bool has_time_received() const;
  private:
  bool _internal_has_time_received() const;
  public:
  void clear_time_received();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_received() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time_received();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time_received();
  void set_allocated_time_received(::PROTOBUF_NAMESPACE_ID::Timestamp* time_received);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time_received() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time_received();
  public:
  void unsafe_arena_set_allocated_time_received(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time_received);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time_received();

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.SensorMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_received_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class SensorData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.SensorData) */ {
 public:
  inline SensorData() : SensorData(nullptr) {}
  ~SensorData() override;
  explicit PROTOBUF_CONSTEXPR SensorData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorData(const SensorData& from);
  SensorData(SensorData&& from) noexcept
    : SensorData() {
    *this = ::std::move(from);
  }

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorData& operator=(SensorData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorData& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kStruct = 2,
    kBinary = 3,
    DATA_NOT_SET = 0,
  };

  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
               &_SensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SensorData& a, SensorData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorData& from) {
    SensorData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.SensorData";
  }
  protected:
  explicit SensorData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kStructFieldNumber = 2,
    kBinaryFieldNumber = 3,
  };
  // .viam.app.datasync.v1.SensorMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::datasync::v1::SensorMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::SensorMetadata* release_metadata();
  ::viam::app::datasync::v1::SensorMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::datasync::v1::SensorMetadata* metadata);
  private:
  const ::viam::app::datasync::v1::SensorMetadata& _internal_metadata() const;
  ::viam::app::datasync::v1::SensorMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::datasync::v1::SensorMetadata* metadata);
  ::viam::app::datasync::v1::SensorMetadata* unsafe_arena_release_metadata();

  // .google.protobuf.Struct struct = 2 [json_name = "struct"];
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::PROTOBUF_NAMESPACE_ID::Struct& struct_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_struct_();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_struct_();
  void set_allocated_struct_(::PROTOBUF_NAMESPACE_ID::Struct* struct_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_struct_() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::PROTOBUF_NAMESPACE_ID::Struct* struct_);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_struct_();

  // bytes binary = 3 [json_name = "binary"];
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const std::string& binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary();
  PROTOBUF_NODISCARD std::string* release_binary();
  void set_allocated_binary(std::string* binary);
  private:
  const std::string& _internal_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary(const std::string& value);
  std::string* _internal_mutable_binary();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.SensorData)
 private:
  class _Internal;
  void set_has_struct_();
  void set_has_binary();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::datasync::v1::SensorMetadata* metadata_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Struct* struct__;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class FileData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.FileData) */ {
 public:
  inline FileData() : FileData(nullptr) {}
  ~FileData() override;
  explicit PROTOBUF_CONSTEXPR FileData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileData(const FileData& from);
  FileData(FileData&& from) noexcept
    : FileData() {
    *this = ::std::move(from);
  }

  inline FileData& operator=(const FileData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileData& operator=(FileData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileData* internal_default_instance() {
    return reinterpret_cast<const FileData*>(
               &_FileData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FileData& a, FileData& b) {
    a.Swap(&b);
  }
  inline void Swap(FileData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileData& from) {
    FileData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.FileData";
  }
  protected:
  explicit FileData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1 [json_name = "data"];
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.FileData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class UploadMetadata_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UploadMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UploadMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  UploadMetadata_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UploadMetadata_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UploadMetadata_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UploadMetadata_MethodParametersEntry_DoNotUse& other);
  static const UploadMetadata_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UploadMetadata_MethodParametersEntry_DoNotUse*>(&_UploadMetadata_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.UploadMetadata.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class UploadMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.UploadMetadata) */ {
 public:
  inline UploadMetadata() : UploadMetadata(nullptr) {}
  ~UploadMetadata() override;
  explicit PROTOBUF_CONSTEXPR UploadMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadMetadata(const UploadMetadata& from);
  UploadMetadata(UploadMetadata&& from) noexcept
    : UploadMetadata() {
    *this = ::std::move(from);
  }

  inline UploadMetadata& operator=(const UploadMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadMetadata& operator=(UploadMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadMetadata* internal_default_instance() {
    return reinterpret_cast<const UploadMetadata*>(
               &_UploadMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UploadMetadata& a, UploadMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadMetadata& from) {
    UploadMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.UploadMetadata";
  }
  protected:
  explicit UploadMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMethodParametersFieldNumber = 8,
    kTagsFieldNumber = 10,
    kPartIdFieldNumber = 1,
    kComponentTypeFieldNumber = 2,
    kComponentNameFieldNumber = 3,
    kComponentModelFieldNumber = 4,
    kMethodNameFieldNumber = 5,
    kFileNameFieldNumber = 7,
    kFileExtensionFieldNumber = 9,
    kSessionIdFieldNumber = 11,
    kTypeFieldNumber = 6,
  };
  // map<string, .google.protobuf.Any> method_parameters = 8 [json_name = "methodParameters"];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 10 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string component_type = 2 [json_name = "componentType"];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_name = 3 [json_name = "componentName"];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_model = 4 [json_name = "componentModel"];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 5 [json_name = "methodName"];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string file_name = 7 [json_name = "fileName"];
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string file_extension = 9 [json_name = "fileExtension"];
  void clear_file_extension();
  const std::string& file_extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_extension();
  PROTOBUF_NODISCARD std::string* release_file_extension();
  void set_allocated_file_extension(std::string* file_extension);
  private:
  const std::string& _internal_file_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_extension(const std::string& value);
  std::string* _internal_mutable_file_extension();
  public:

  // string session_id = 11 [json_name = "sessionId"];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .viam.app.datasync.v1.DataType type = 6 [json_name = "type"];
  void clear_type();
  ::viam::app::datasync::v1::DataType type() const;
  void set_type(::viam::app::datasync::v1::DataType value);
  private:
  ::viam::app::datasync::v1::DataType _internal_type() const;
  void _internal_set_type(::viam::app::datasync::v1::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.UploadMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UploadMetadata_MethodParametersEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class CaptureInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.CaptureInterval) */ {
 public:
  inline CaptureInterval() : CaptureInterval(nullptr) {}
  ~CaptureInterval() override;
  explicit PROTOBUF_CONSTEXPR CaptureInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureInterval(const CaptureInterval& from);
  CaptureInterval(CaptureInterval&& from) noexcept
    : CaptureInterval() {
    *this = ::std::move(from);
  }

  inline CaptureInterval& operator=(const CaptureInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureInterval& operator=(CaptureInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureInterval* internal_default_instance() {
    return reinterpret_cast<const CaptureInterval*>(
               &_CaptureInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CaptureInterval& a, CaptureInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureInterval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureInterval& from) {
    CaptureInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.CaptureInterval";
  }
  protected:
  explicit CaptureInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .google.protobuf.Timestamp start = 1 [json_name = "start"];
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start();
  void set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start();

  // .google.protobuf.Timestamp end = 2 [json_name = "end"];
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end();
  void set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.CaptureInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class DataCaptureMetadata_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataCaptureMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataCaptureMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  DataCaptureMetadata_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DataCaptureMetadata_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DataCaptureMetadata_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DataCaptureMetadata_MethodParametersEntry_DoNotUse& other);
  static const DataCaptureMetadata_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataCaptureMetadata_MethodParametersEntry_DoNotUse*>(&_DataCaptureMetadata_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.DataCaptureMetadata.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class DataCaptureMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.DataCaptureMetadata) */ {
 public:
  inline DataCaptureMetadata() : DataCaptureMetadata(nullptr) {}
  ~DataCaptureMetadata() override;
  explicit PROTOBUF_CONSTEXPR DataCaptureMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataCaptureMetadata(const DataCaptureMetadata& from);
  DataCaptureMetadata(DataCaptureMetadata&& from) noexcept
    : DataCaptureMetadata() {
    *this = ::std::move(from);
  }

  inline DataCaptureMetadata& operator=(const DataCaptureMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCaptureMetadata& operator=(DataCaptureMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataCaptureMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataCaptureMetadata* internal_default_instance() {
    return reinterpret_cast<const DataCaptureMetadata*>(
               &_DataCaptureMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DataCaptureMetadata& a, DataCaptureMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCaptureMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCaptureMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataCaptureMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataCaptureMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataCaptureMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataCaptureMetadata& from) {
    DataCaptureMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataCaptureMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.DataCaptureMetadata";
  }
  protected:
  explicit DataCaptureMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMethodParametersFieldNumber = 6,
    kTagsFieldNumber = 8,
    kComponentTypeFieldNumber = 1,
    kComponentNameFieldNumber = 2,
    kComponentModelFieldNumber = 3,
    kMethodNameFieldNumber = 4,
    kFileExtensionFieldNumber = 7,
    kSessionIdFieldNumber = 9,
    kTypeFieldNumber = 5,
  };
  // map<string, .google.protobuf.Any> method_parameters = 6 [json_name = "methodParameters"];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 8 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string component_type = 1 [json_name = "componentType"];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_name = 2 [json_name = "componentName"];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_model = 3 [json_name = "componentModel"];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 4 [json_name = "methodName"];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string file_extension = 7 [json_name = "fileExtension"];
  void clear_file_extension();
  const std::string& file_extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_extension();
  PROTOBUF_NODISCARD std::string* release_file_extension();
  void set_allocated_file_extension(std::string* file_extension);
  private:
  const std::string& _internal_file_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_extension(const std::string& value);
  std::string* _internal_mutable_file_extension();
  public:

  // string session_id = 9 [json_name = "sessionId"];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .viam.app.datasync.v1.DataType type = 5 [json_name = "type"];
  void clear_type();
  ::viam::app::datasync::v1::DataType type() const;
  void set_type(::viam::app::datasync::v1::DataType value);
  private:
  ::viam::app::datasync::v1::DataType _internal_type() const;
  void _internal_set_type(::viam::app::datasync::v1::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.DataCaptureMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DataCaptureMetadata_MethodParametersEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_extension_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class TabularCapture_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TabularCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TabularCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TabularCapture_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TabularCapture_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TabularCapture_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TabularCapture_MethodParametersEntry_DoNotUse& other);
  static const TabularCapture_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TabularCapture_MethodParametersEntry_DoNotUse*>(&_TabularCapture_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.TabularCapture.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class TabularCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.TabularCapture) */ {
 public:
  inline TabularCapture() : TabularCapture(nullptr) {}
  ~TabularCapture() override;
  explicit PROTOBUF_CONSTEXPR TabularCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabularCapture(const TabularCapture& from);
  TabularCapture(TabularCapture&& from) noexcept
    : TabularCapture() {
    *this = ::std::move(from);
  }

  inline TabularCapture& operator=(const TabularCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabularCapture& operator=(TabularCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabularCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabularCapture* internal_default_instance() {
    return reinterpret_cast<const TabularCapture*>(
               &_TabularCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TabularCapture& a, TabularCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(TabularCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabularCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabularCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabularCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabularCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TabularCapture& from) {
    TabularCapture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabularCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.TabularCapture";
  }
  protected:
  explicit TabularCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 11,
    kMethodParametersFieldNumber = 12,
    kTagsFieldNumber = 14,
    kOrgIdFieldNumber = 2,
    kRobotIdFieldNumber = 3,
    kPartIdFieldNumber = 4,
    kLocationIdFieldNumber = 5,
    kComponentNameFieldNumber = 6,
    kComponentTypeFieldNumber = 7,
    kComponentModelFieldNumber = 8,
    kMethodNameFieldNumber = 9,
    kBlobPathFieldNumber = 10,
    kFileIdFieldNumber = 13,
    kSessionIdFieldNumber = 17,
    kMimeTypeFieldNumber = 18,
    kIdFieldNumber = 19,
    kIntervalFieldNumber = 1,
    kFileSizeBytesFieldNumber = 16,
    kMessageCountFieldNumber = 15,
  };
  // repeated string column_names = 11 [json_name = "columnNames", (.tagger.v1.tags) = "bson:\"column_names\" json:\"column_names\""];
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // map<string, .google.protobuf.Any> method_parameters = 12 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 14 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
  void clear_blob_path();
  const std::string& blob_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob_path();
  PROTOBUF_NODISCARD std::string* release_blob_path();
  void set_allocated_blob_path(std::string* blob_path);
  private:
  const std::string& _internal_blob_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob_path(const std::string& value);
  std::string* _internal_mutable_blob_path();
  public:

  // string file_id = 13 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string session_id = 17 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string mime_type = 18 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::viam::app::datasync::v1::CaptureInterval& interval() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::CaptureInterval* release_interval();
  ::viam::app::datasync::v1::CaptureInterval* mutable_interval();
  void set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval);
  private:
  const ::viam::app::datasync::v1::CaptureInterval& _internal_interval() const;
  ::viam::app::datasync::v1::CaptureInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::viam::app::datasync::v1::CaptureInterval* interval);
  ::viam::app::datasync::v1::CaptureInterval* unsafe_arena_release_interval();

  // int64 file_size_bytes = 16 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
  void clear_file_size_bytes();
  int64_t file_size_bytes() const;
  void set_file_size_bytes(int64_t value);
  private:
  int64_t _internal_file_size_bytes() const;
  void _internal_set_file_size_bytes(int64_t value);
  public:

  // int32 message_count = 15 [json_name = "messageCount", (.tagger.v1.tags) = "bson:\"message_count\" json:\"message_count\""];
  void clear_message_count();
  int32_t message_count() const;
  void set_message_count(int32_t value);
  private:
  int32_t _internal_message_count() const;
  void _internal_set_message_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.TabularCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TabularCapture_MethodParametersEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::viam::app::datasync::v1::CaptureInterval* interval_;
    int64_t file_size_bytes_;
    int32_t message_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class BinaryCapture_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BinaryCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BinaryCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BinaryCapture_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BinaryCapture_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BinaryCapture_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BinaryCapture_MethodParametersEntry_DoNotUse& other);
  static const BinaryCapture_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BinaryCapture_MethodParametersEntry_DoNotUse*>(&_BinaryCapture_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.BinaryCapture.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class BinaryCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.BinaryCapture) */ {
 public:
  inline BinaryCapture() : BinaryCapture(nullptr) {}
  ~BinaryCapture() override;
  explicit PROTOBUF_CONSTEXPR BinaryCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryCapture(const BinaryCapture& from);
  BinaryCapture(BinaryCapture&& from) noexcept
    : BinaryCapture() {
    *this = ::std::move(from);
  }

  inline BinaryCapture& operator=(const BinaryCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryCapture& operator=(BinaryCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryCapture* internal_default_instance() {
    return reinterpret_cast<const BinaryCapture*>(
               &_BinaryCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BinaryCapture& a, BinaryCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryCapture& from) {
    BinaryCapture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.BinaryCapture";
  }
  protected:
  explicit BinaryCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMethodParametersFieldNumber = 11,
    kTagsFieldNumber = 13,
    kOrgIdFieldNumber = 2,
    kRobotIdFieldNumber = 3,
    kPartIdFieldNumber = 4,
    kLocationIdFieldNumber = 5,
    kComponentNameFieldNumber = 6,
    kComponentTypeFieldNumber = 7,
    kComponentModelFieldNumber = 8,
    kMethodNameFieldNumber = 9,
    kBlobPathFieldNumber = 10,
    kFileIdFieldNumber = 12,
    kSessionIdFieldNumber = 15,
    kMimeTypeFieldNumber = 16,
    kFileNameFieldNumber = 17,
    kFileExtFieldNumber = 18,
    kIdFieldNumber = 19,
    kIntervalFieldNumber = 1,
    kFileSizeBytesFieldNumber = 14,
  };
  // map<string, .google.protobuf.Any> method_parameters = 11 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 13 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
  void clear_blob_path();
  const std::string& blob_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob_path();
  PROTOBUF_NODISCARD std::string* release_blob_path();
  void set_allocated_blob_path(std::string* blob_path);
  private:
  const std::string& _internal_blob_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob_path(const std::string& value);
  std::string* _internal_mutable_blob_path();
  public:

  // string file_id = 12 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string session_id = 15 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string mime_type = 16 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string file_name = 17 [json_name = "fileName", (.tagger.v1.tags) = "bson:\"file_name\" json:\"file_name\""];
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string file_ext = 18 [json_name = "fileExt", (.tagger.v1.tags) = "bson:\"file_ext\" json:\"file_ext\""];
  void clear_file_ext();
  const std::string& file_ext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_ext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_ext();
  PROTOBUF_NODISCARD std::string* release_file_ext();
  void set_allocated_file_ext(std::string* file_ext);
  private:
  const std::string& _internal_file_ext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_ext(const std::string& value);
  std::string* _internal_mutable_file_ext();
  public:

  // string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::viam::app::datasync::v1::CaptureInterval& interval() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::CaptureInterval* release_interval();
  ::viam::app::datasync::v1::CaptureInterval* mutable_interval();
  void set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval);
  private:
  const ::viam::app::datasync::v1::CaptureInterval& _internal_interval() const;
  ::viam::app::datasync::v1::CaptureInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::viam::app::datasync::v1::CaptureInterval* interval);
  ::viam::app::datasync::v1::CaptureInterval* unsafe_arena_release_interval();

  // int64 file_size_bytes = 14 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
  void clear_file_size_bytes();
  int64_t file_size_bytes() const;
  void set_file_size_bytes(int64_t value);
  private:
  int64_t _internal_file_size_bytes() const;
  void _internal_set_file_size_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.BinaryCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BinaryCapture_MethodParametersEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_ext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::viam::app::datasync::v1::CaptureInterval* interval_;
    int64_t file_size_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataCaptureUploadRequest

// .viam.app.datasync.v1.UploadMetadata metadata = 1 [json_name = "metadata"];
inline bool DataCaptureUploadRequest::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool DataCaptureUploadRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void DataCaptureUploadRequest::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::viam::app::datasync::v1::UploadMetadata& DataCaptureUploadRequest::_internal_metadata() const {
  const ::viam::app::datasync::v1::UploadMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::datasync::v1::UploadMetadata&>(
      ::viam::app::datasync::v1::_UploadMetadata_default_instance_);
}
inline const ::viam::app::datasync::v1::UploadMetadata& DataCaptureUploadRequest::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureUploadRequest.metadata)
  return _internal_metadata();
}
inline void DataCaptureUploadRequest::unsafe_arena_set_allocated_metadata(
    ::viam::app::datasync::v1::UploadMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.DataCaptureUploadRequest.metadata)
}
inline ::viam::app::datasync::v1::UploadMetadata* DataCaptureUploadRequest::release_metadata() {
  
  ::viam::app::datasync::v1::UploadMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::datasync::v1::UploadMetadata* DataCaptureUploadRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureUploadRequest.metadata)
  
  ::viam::app::datasync::v1::UploadMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::viam::app::datasync::v1::UploadMetadata* DataCaptureUploadRequest::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::datasync::v1::UploadMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::viam::app::datasync::v1::UploadMetadata* DataCaptureUploadRequest::mutable_metadata() {
  ::viam::app::datasync::v1::UploadMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureUploadRequest.metadata)
  return _msg;
}
inline void DataCaptureUploadRequest::set_allocated_metadata(::viam::app::datasync::v1::UploadMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureUploadRequest.metadata)
}

// repeated .viam.app.datasync.v1.SensorData sensor_contents = 2 [json_name = "sensorContents"];
inline int DataCaptureUploadRequest::_internal_sensor_contents_size() const {
  return _impl_.sensor_contents_.size();
}
inline int DataCaptureUploadRequest::sensor_contents_size() const {
  return _internal_sensor_contents_size();
}
inline void DataCaptureUploadRequest::clear_sensor_contents() {
  _impl_.sensor_contents_.Clear();
}
inline ::viam::app::datasync::v1::SensorData* DataCaptureUploadRequest::mutable_sensor_contents(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureUploadRequest.sensor_contents)
  return _impl_.sensor_contents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::datasync::v1::SensorData >*
DataCaptureUploadRequest::mutable_sensor_contents() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.DataCaptureUploadRequest.sensor_contents)
  return &_impl_.sensor_contents_;
}
inline const ::viam::app::datasync::v1::SensorData& DataCaptureUploadRequest::_internal_sensor_contents(int index) const {
  return _impl_.sensor_contents_.Get(index);
}
inline const ::viam::app::datasync::v1::SensorData& DataCaptureUploadRequest::sensor_contents(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureUploadRequest.sensor_contents)
  return _internal_sensor_contents(index);
}
inline ::viam::app::datasync::v1::SensorData* DataCaptureUploadRequest::_internal_add_sensor_contents() {
  return _impl_.sensor_contents_.Add();
}
inline ::viam::app::datasync::v1::SensorData* DataCaptureUploadRequest::add_sensor_contents() {
  ::viam::app::datasync::v1::SensorData* _add = _internal_add_sensor_contents();
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.DataCaptureUploadRequest.sensor_contents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::datasync::v1::SensorData >&
DataCaptureUploadRequest::sensor_contents() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.DataCaptureUploadRequest.sensor_contents)
  return _impl_.sensor_contents_;
}

// -------------------------------------------------------------------

// DataCaptureUploadResponse

// -------------------------------------------------------------------

// FileUploadRequest

// .viam.app.datasync.v1.UploadMetadata metadata = 1 [json_name = "metadata"];
inline bool FileUploadRequest::_internal_has_metadata() const {
  return upload_packet_case() == kMetadata;
}
inline bool FileUploadRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void FileUploadRequest::set_has_metadata() {
  _impl_._oneof_case_[0] = kMetadata;
}
inline void FileUploadRequest::clear_metadata() {
  if (_internal_has_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.upload_packet_.metadata_;
    }
    clear_has_upload_packet();
  }
}
inline ::viam::app::datasync::v1::UploadMetadata* FileUploadRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.FileUploadRequest.metadata)
  if (_internal_has_metadata()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::UploadMetadata* temp = _impl_.upload_packet_.metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.upload_packet_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::datasync::v1::UploadMetadata& FileUploadRequest::_internal_metadata() const {
  return _internal_has_metadata()
      ? *_impl_.upload_packet_.metadata_
      : reinterpret_cast< ::viam::app::datasync::v1::UploadMetadata&>(::viam::app::datasync::v1::_UploadMetadata_default_instance_);
}
inline const ::viam::app::datasync::v1::UploadMetadata& FileUploadRequest::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.FileUploadRequest.metadata)
  return _internal_metadata();
}
inline ::viam::app::datasync::v1::UploadMetadata* FileUploadRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.datasync.v1.FileUploadRequest.metadata)
  if (_internal_has_metadata()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::UploadMetadata* temp = _impl_.upload_packet_.metadata_;
    _impl_.upload_packet_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileUploadRequest::unsafe_arena_set_allocated_metadata(::viam::app::datasync::v1::UploadMetadata* metadata) {
  clear_upload_packet();
  if (metadata) {
    set_has_metadata();
    _impl_.upload_packet_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.FileUploadRequest.metadata)
}
inline ::viam::app::datasync::v1::UploadMetadata* FileUploadRequest::_internal_mutable_metadata() {
  if (!_internal_has_metadata()) {
    clear_upload_packet();
    set_has_metadata();
    _impl_.upload_packet_.metadata_ = CreateMaybeMessage< ::viam::app::datasync::v1::UploadMetadata >(GetArenaForAllocation());
  }
  return _impl_.upload_packet_.metadata_;
}
inline ::viam::app::datasync::v1::UploadMetadata* FileUploadRequest::mutable_metadata() {
  ::viam::app::datasync::v1::UploadMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.FileUploadRequest.metadata)
  return _msg;
}

// .viam.app.datasync.v1.FileData file_contents = 2 [json_name = "fileContents"];
inline bool FileUploadRequest::_internal_has_file_contents() const {
  return upload_packet_case() == kFileContents;
}
inline bool FileUploadRequest::has_file_contents() const {
  return _internal_has_file_contents();
}
inline void FileUploadRequest::set_has_file_contents() {
  _impl_._oneof_case_[0] = kFileContents;
}
inline void FileUploadRequest::clear_file_contents() {
  if (_internal_has_file_contents()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.upload_packet_.file_contents_;
    }
    clear_has_upload_packet();
  }
}
inline ::viam::app::datasync::v1::FileData* FileUploadRequest::release_file_contents() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.FileUploadRequest.file_contents)
  if (_internal_has_file_contents()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::FileData* temp = _impl_.upload_packet_.file_contents_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.upload_packet_.file_contents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::datasync::v1::FileData& FileUploadRequest::_internal_file_contents() const {
  return _internal_has_file_contents()
      ? *_impl_.upload_packet_.file_contents_
      : reinterpret_cast< ::viam::app::datasync::v1::FileData&>(::viam::app::datasync::v1::_FileData_default_instance_);
}
inline const ::viam::app::datasync::v1::FileData& FileUploadRequest::file_contents() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.FileUploadRequest.file_contents)
  return _internal_file_contents();
}
inline ::viam::app::datasync::v1::FileData* FileUploadRequest::unsafe_arena_release_file_contents() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.datasync.v1.FileUploadRequest.file_contents)
  if (_internal_has_file_contents()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::FileData* temp = _impl_.upload_packet_.file_contents_;
    _impl_.upload_packet_.file_contents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileUploadRequest::unsafe_arena_set_allocated_file_contents(::viam::app::datasync::v1::FileData* file_contents) {
  clear_upload_packet();
  if (file_contents) {
    set_has_file_contents();
    _impl_.upload_packet_.file_contents_ = file_contents;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.FileUploadRequest.file_contents)
}
inline ::viam::app::datasync::v1::FileData* FileUploadRequest::_internal_mutable_file_contents() {
  if (!_internal_has_file_contents()) {
    clear_upload_packet();
    set_has_file_contents();
    _impl_.upload_packet_.file_contents_ = CreateMaybeMessage< ::viam::app::datasync::v1::FileData >(GetArenaForAllocation());
  }
  return _impl_.upload_packet_.file_contents_;
}
inline ::viam::app::datasync::v1::FileData* FileUploadRequest::mutable_file_contents() {
  ::viam::app::datasync::v1::FileData* _msg = _internal_mutable_file_contents();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.FileUploadRequest.file_contents)
  return _msg;
}

inline bool FileUploadRequest::has_upload_packet() const {
  return upload_packet_case() != UPLOAD_PACKET_NOT_SET;
}
inline void FileUploadRequest::clear_has_upload_packet() {
  _impl_._oneof_case_[0] = UPLOAD_PACKET_NOT_SET;
}
inline FileUploadRequest::UploadPacketCase FileUploadRequest::upload_packet_case() const {
  return FileUploadRequest::UploadPacketCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileUploadResponse

// -------------------------------------------------------------------

// SensorMetadata

// .google.protobuf.Timestamp time_requested = 1 [json_name = "timeRequested"];
inline bool SensorMetadata::_internal_has_time_requested() const {
  return this != internal_default_instance() && _impl_.time_requested_ != nullptr;
}
inline bool SensorMetadata::has_time_requested() const {
  return _internal_has_time_requested();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::_internal_time_requested() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_requested_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::time_requested() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorMetadata.time_requested)
  return _internal_time_requested();
}
inline void SensorMetadata::unsafe_arena_set_allocated_time_requested(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_requested_);
  }
  _impl_.time_requested_ = time_requested;
  if (time_requested) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorMetadata.time_requested)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::release_time_requested() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_requested_;
  _impl_.time_requested_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::unsafe_arena_release_time_requested() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorMetadata.time_requested)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_requested_;
  _impl_.time_requested_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::_internal_mutable_time_requested() {
  
  if (_impl_.time_requested_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_requested_ = p;
  }
  return _impl_.time_requested_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::mutable_time_requested() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time_requested();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorMetadata.time_requested)
  return _msg;
}
inline void SensorMetadata::set_allocated_time_requested(::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_requested_);
  }
  if (time_requested) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_requested));
    if (message_arena != submessage_arena) {
      time_requested = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_requested, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_requested_ = time_requested;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorMetadata.time_requested)
}

// .google.protobuf.Timestamp time_received = 2 [json_name = "timeReceived"];
inline bool SensorMetadata::_internal_has_time_received() const {
  return this != internal_default_instance() && _impl_.time_received_ != nullptr;
}
inline bool SensorMetadata::has_time_received() const {
  return _internal_has_time_received();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::_internal_time_received() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_received_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::time_received() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorMetadata.time_received)
  return _internal_time_received();
}
inline void SensorMetadata::unsafe_arena_set_allocated_time_received(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_received) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_received_);
  }
  _impl_.time_received_ = time_received;
  if (time_received) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorMetadata.time_received)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::release_time_received() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_received_;
  _impl_.time_received_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::unsafe_arena_release_time_received() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorMetadata.time_received)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_received_;
  _impl_.time_received_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::_internal_mutable_time_received() {
  
  if (_impl_.time_received_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_received_ = p;
  }
  return _impl_.time_received_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::mutable_time_received() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time_received();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorMetadata.time_received)
  return _msg;
}
inline void SensorMetadata::set_allocated_time_received(::PROTOBUF_NAMESPACE_ID::Timestamp* time_received) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_received_);
  }
  if (time_received) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_received));
    if (message_arena != submessage_arena) {
      time_received = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_received, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_received_ = time_received;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorMetadata.time_received)
}

// -------------------------------------------------------------------

// SensorData

// .viam.app.datasync.v1.SensorMetadata metadata = 1 [json_name = "metadata"];
inline bool SensorData::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool SensorData::has_metadata() const {
  return _internal_has_metadata();
}
inline void SensorData::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::viam::app::datasync::v1::SensorMetadata& SensorData::_internal_metadata() const {
  const ::viam::app::datasync::v1::SensorMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::datasync::v1::SensorMetadata&>(
      ::viam::app::datasync::v1::_SensorMetadata_default_instance_);
}
inline const ::viam::app::datasync::v1::SensorMetadata& SensorData::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorData.metadata)
  return _internal_metadata();
}
inline void SensorData::unsafe_arena_set_allocated_metadata(
    ::viam::app::datasync::v1::SensorMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorData.metadata)
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::release_metadata() {
  
  ::viam::app::datasync::v1::SensorMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorData.metadata)
  
  ::viam::app::datasync::v1::SensorMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::datasync::v1::SensorMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::mutable_metadata() {
  ::viam::app::datasync::v1::SensorMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorData.metadata)
  return _msg;
}
inline void SensorData::set_allocated_metadata(::viam::app::datasync::v1::SensorMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorData.metadata)
}

// .google.protobuf.Struct struct = 2 [json_name = "struct"];
inline bool SensorData::_internal_has_struct_() const {
  return data_case() == kStruct;
}
inline bool SensorData::has_struct_() const {
  return _internal_has_struct_();
}
inline void SensorData::set_has_struct_() {
  _impl_._oneof_case_[0] = kStruct;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::release_struct_() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorData.struct)
  if (_internal_has_struct_()) {
    clear_has_data();
    ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_.struct__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& SensorData::_internal_struct_() const {
  return _internal_has_struct_()
      ? *_impl_.data_.struct__
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Struct&>(::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& SensorData::struct_() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorData.struct)
  return _internal_struct_();
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.datasync.v1.SensorData.struct)
  if (_internal_has_struct_()) {
    clear_has_data();
    ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_.struct__;
    _impl_.data_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorData::unsafe_arena_set_allocated_struct_(::PROTOBUF_NAMESPACE_ID::Struct* struct_) {
  clear_data();
  if (struct_) {
    set_has_struct_();
    _impl_.data_.struct__ = struct_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorData.struct)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::_internal_mutable_struct_() {
  if (!_internal_has_struct_()) {
    clear_data();
    set_has_struct_();
    _impl_.data_.struct__ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Struct >(GetArenaForAllocation());
  }
  return _impl_.data_.struct__;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::mutable_struct_() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorData.struct)
  return _msg;
}

// bytes binary = 3 [json_name = "binary"];
inline bool SensorData::_internal_has_binary() const {
  return data_case() == kBinary;
}
inline bool SensorData::has_binary() const {
  return _internal_has_binary();
}
inline void SensorData::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void SensorData::clear_binary() {
  if (_internal_has_binary()) {
    _impl_.data_.binary_.Destroy();
    clear_has_data();
  }
}
inline const std::string& SensorData::binary() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorData.binary)
  return _internal_binary();
}
template <typename ArgT0, typename... ArgT>
inline void SensorData::set_binary(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    _impl_.data_.binary_.InitDefault();
  }
  _impl_.data_.binary_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.SensorData.binary)
}
inline std::string* SensorData::mutable_binary() {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorData.binary)
  return _s;
}
inline const std::string& SensorData::_internal_binary() const {
  if (_internal_has_binary()) {
    return _impl_.data_.binary_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SensorData::_internal_set_binary(const std::string& value) {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    _impl_.data_.binary_.InitDefault();
  }
  _impl_.data_.binary_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorData::_internal_mutable_binary() {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    _impl_.data_.binary_.InitDefault();
  }
  return _impl_.data_.binary_.Mutable(      GetArenaForAllocation());
}
inline std::string* SensorData::release_binary() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorData.binary)
  if (_internal_has_binary()) {
    clear_has_data();
    return _impl_.data_.binary_.Release();
  } else {
    return nullptr;
  }
}
inline void SensorData::set_allocated_binary(std::string* binary) {
  if (has_data()) {
    clear_data();
  }
  if (binary != nullptr) {
    set_has_binary();
    _impl_.data_.binary_.InitAllocated(binary, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorData.binary)
}

inline bool SensorData::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SensorData::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline SensorData::DataCase SensorData::data_case() const {
  return SensorData::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileData

// bytes data = 1 [json_name = "data"];
inline void FileData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& FileData::data() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.FileData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileData::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.FileData.data)
}
inline std::string* FileData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.FileData.data)
  return _s;
}
inline const std::string& FileData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void FileData::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* FileData::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* FileData::release_data() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.FileData.data)
  return _impl_.data_.Release();
}
inline void FileData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.FileData.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UploadMetadata

// string part_id = 1 [json_name = "partId"];
inline void UploadMetadata::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& UploadMetadata::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.part_id)
}
inline std::string* UploadMetadata::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.part_id)
  return _s;
}
inline const std::string& UploadMetadata::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void UploadMetadata::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.part_id)
  return _impl_.part_id_.Release();
}
inline void UploadMetadata::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.part_id)
}

// string component_type = 2 [json_name = "componentType"];
inline void UploadMetadata::clear_component_type() {
  _impl_.component_type_.ClearToEmpty();
}
inline const std::string& UploadMetadata::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.component_type)
}
inline std::string* UploadMetadata::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.component_type)
  return _s;
}
inline const std::string& UploadMetadata::_internal_component_type() const {
  return _impl_.component_type_.Get();
}
inline void UploadMetadata::_internal_set_component_type(const std::string& value) {
  
  _impl_.component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_component_type() {
  
  return _impl_.component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.component_type)
  return _impl_.component_type_.Release();
}
inline void UploadMetadata::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  _impl_.component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_type_.IsDefault()) {
    _impl_.component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.component_type)
}

// string component_name = 3 [json_name = "componentName"];
inline void UploadMetadata::clear_component_name() {
  _impl_.component_name_.ClearToEmpty();
}
inline const std::string& UploadMetadata::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.component_name)
}
inline std::string* UploadMetadata::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.component_name)
  return _s;
}
inline const std::string& UploadMetadata::_internal_component_name() const {
  return _impl_.component_name_.Get();
}
inline void UploadMetadata::_internal_set_component_name(const std::string& value) {
  
  _impl_.component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_component_name() {
  
  return _impl_.component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.component_name)
  return _impl_.component_name_.Release();
}
inline void UploadMetadata::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  _impl_.component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_name_.IsDefault()) {
    _impl_.component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.component_name)
}

// string component_model = 4 [json_name = "componentModel"];
inline void UploadMetadata::clear_component_model() {
  _impl_.component_model_.ClearToEmpty();
}
inline const std::string& UploadMetadata::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.component_model)
}
inline std::string* UploadMetadata::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.component_model)
  return _s;
}
inline const std::string& UploadMetadata::_internal_component_model() const {
  return _impl_.component_model_.Get();
}
inline void UploadMetadata::_internal_set_component_model(const std::string& value) {
  
  _impl_.component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_component_model() {
  
  return _impl_.component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.component_model)
  return _impl_.component_model_.Release();
}
inline void UploadMetadata::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  _impl_.component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_model_.IsDefault()) {
    _impl_.component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.component_model)
}

// string method_name = 5 [json_name = "methodName"];
inline void UploadMetadata::clear_method_name() {
  _impl_.method_name_.ClearToEmpty();
}
inline const std::string& UploadMetadata::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.method_name)
}
inline std::string* UploadMetadata::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.method_name)
  return _s;
}
inline const std::string& UploadMetadata::_internal_method_name() const {
  return _impl_.method_name_.Get();
}
inline void UploadMetadata::_internal_set_method_name(const std::string& value) {
  
  _impl_.method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_method_name() {
  
  return _impl_.method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.method_name)
  return _impl_.method_name_.Release();
}
inline void UploadMetadata::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  _impl_.method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_name_.IsDefault()) {
    _impl_.method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.method_name)
}

// .viam.app.datasync.v1.DataType type = 6 [json_name = "type"];
inline void UploadMetadata::clear_type() {
  _impl_.type_ = 0;
}
inline ::viam::app::datasync::v1::DataType UploadMetadata::_internal_type() const {
  return static_cast< ::viam::app::datasync::v1::DataType >(_impl_.type_);
}
inline ::viam::app::datasync::v1::DataType UploadMetadata::type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.type)
  return _internal_type();
}
inline void UploadMetadata::_internal_set_type(::viam::app::datasync::v1::DataType value) {
  
  _impl_.type_ = value;
}
inline void UploadMetadata::set_type(::viam::app::datasync::v1::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.type)
}

// string file_name = 7 [json_name = "fileName"];
inline void UploadMetadata::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& UploadMetadata::file_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.file_name)
}
inline std::string* UploadMetadata::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.file_name)
  return _s;
}
inline const std::string& UploadMetadata::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void UploadMetadata::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_file_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.file_name)
  return _impl_.file_name_.Release();
}
inline void UploadMetadata::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.file_name)
}

// map<string, .google.protobuf.Any> method_parameters = 8 [json_name = "methodParameters"];
inline int UploadMetadata::_internal_method_parameters_size() const {
  return _impl_.method_parameters_.size();
}
inline int UploadMetadata::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
UploadMetadata::_internal_method_parameters() const {
  return _impl_.method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
UploadMetadata::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.UploadMetadata.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
UploadMetadata::_internal_mutable_method_parameters() {
  return _impl_.method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
UploadMetadata::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.UploadMetadata.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_extension = 9 [json_name = "fileExtension"];
inline void UploadMetadata::clear_file_extension() {
  _impl_.file_extension_.ClearToEmpty();
}
inline const std::string& UploadMetadata::file_extension() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.file_extension)
  return _internal_file_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_file_extension(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_extension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.file_extension)
}
inline std::string* UploadMetadata::mutable_file_extension() {
  std::string* _s = _internal_mutable_file_extension();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.file_extension)
  return _s;
}
inline const std::string& UploadMetadata::_internal_file_extension() const {
  return _impl_.file_extension_.Get();
}
inline void UploadMetadata::_internal_set_file_extension(const std::string& value) {
  
  _impl_.file_extension_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_file_extension() {
  
  return _impl_.file_extension_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_file_extension() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.file_extension)
  return _impl_.file_extension_.Release();
}
inline void UploadMetadata::set_allocated_file_extension(std::string* file_extension) {
  if (file_extension != nullptr) {
    
  } else {
    
  }
  _impl_.file_extension_.SetAllocated(file_extension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_extension_.IsDefault()) {
    _impl_.file_extension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.file_extension)
}

// repeated string tags = 10 [json_name = "tags"];
inline int UploadMetadata::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int UploadMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void UploadMetadata::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* UploadMetadata::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.UploadMetadata.tags)
  return _s;
}
inline const std::string& UploadMetadata::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& UploadMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.tags)
  return _internal_tags(index);
}
inline std::string* UploadMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.tags)
  return _impl_.tags_.Mutable(index);
}
inline void UploadMetadata::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.UploadMetadata.tags)
}
inline std::string* UploadMetadata::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void UploadMetadata::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.UploadMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadMetadata::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.UploadMetadata.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.UploadMetadata.tags)
  return &_impl_.tags_;
}

// string session_id = 11 [json_name = "sessionId"];
inline void UploadMetadata::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& UploadMetadata::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.session_id)
}
inline std::string* UploadMetadata::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.session_id)
  return _s;
}
inline const std::string& UploadMetadata::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void UploadMetadata::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.session_id)
  return _impl_.session_id_.Release();
}
inline void UploadMetadata::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.session_id)
}

// -------------------------------------------------------------------

// CaptureInterval

// .google.protobuf.Timestamp start = 1 [json_name = "start"];
inline bool CaptureInterval::_internal_has_start() const {
  return this != internal_default_instance() && _impl_.start_ != nullptr;
}
inline bool CaptureInterval::has_start() const {
  return _internal_has_start();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::_internal_start() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::start() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.CaptureInterval.start)
  return _internal_start();
}
inline void CaptureInterval::unsafe_arena_set_allocated_start(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.CaptureInterval.start)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::release_start() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.CaptureInterval.start)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::_internal_mutable_start() {
  
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::mutable_start() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.CaptureInterval.start)
  return _msg;
}
inline void CaptureInterval::set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.CaptureInterval.start)
}

// .google.protobuf.Timestamp end = 2 [json_name = "end"];
inline bool CaptureInterval::_internal_has_end() const {
  return this != internal_default_instance() && _impl_.end_ != nullptr;
}
inline bool CaptureInterval::has_end() const {
  return _internal_has_end();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::_internal_end() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::end() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.CaptureInterval.end)
  return _internal_end();
}
inline void CaptureInterval::unsafe_arena_set_allocated_end(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.CaptureInterval.end)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::release_end() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.CaptureInterval.end)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::_internal_mutable_end() {
  
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::mutable_end() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.CaptureInterval.end)
  return _msg;
}
inline void CaptureInterval::set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.CaptureInterval.end)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataCaptureMetadata

// string component_type = 1 [json_name = "componentType"];
inline void DataCaptureMetadata::clear_component_type() {
  _impl_.component_type_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.component_type)
}
inline std::string* DataCaptureMetadata::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.component_type)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_component_type() const {
  return _impl_.component_type_.Get();
}
inline void DataCaptureMetadata::_internal_set_component_type(const std::string& value) {
  
  _impl_.component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_component_type() {
  
  return _impl_.component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.component_type)
  return _impl_.component_type_.Release();
}
inline void DataCaptureMetadata::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  _impl_.component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_type_.IsDefault()) {
    _impl_.component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.component_type)
}

// string component_name = 2 [json_name = "componentName"];
inline void DataCaptureMetadata::clear_component_name() {
  _impl_.component_name_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.component_name)
}
inline std::string* DataCaptureMetadata::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.component_name)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_component_name() const {
  return _impl_.component_name_.Get();
}
inline void DataCaptureMetadata::_internal_set_component_name(const std::string& value) {
  
  _impl_.component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_component_name() {
  
  return _impl_.component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.component_name)
  return _impl_.component_name_.Release();
}
inline void DataCaptureMetadata::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  _impl_.component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_name_.IsDefault()) {
    _impl_.component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.component_name)
}

// string component_model = 3 [json_name = "componentModel"];
inline void DataCaptureMetadata::clear_component_model() {
  _impl_.component_model_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.component_model)
}
inline std::string* DataCaptureMetadata::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.component_model)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_component_model() const {
  return _impl_.component_model_.Get();
}
inline void DataCaptureMetadata::_internal_set_component_model(const std::string& value) {
  
  _impl_.component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_component_model() {
  
  return _impl_.component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.component_model)
  return _impl_.component_model_.Release();
}
inline void DataCaptureMetadata::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  _impl_.component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_model_.IsDefault()) {
    _impl_.component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.component_model)
}

// string method_name = 4 [json_name = "methodName"];
inline void DataCaptureMetadata::clear_method_name() {
  _impl_.method_name_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.method_name)
}
inline std::string* DataCaptureMetadata::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.method_name)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_method_name() const {
  return _impl_.method_name_.Get();
}
inline void DataCaptureMetadata::_internal_set_method_name(const std::string& value) {
  
  _impl_.method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_method_name() {
  
  return _impl_.method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.method_name)
  return _impl_.method_name_.Release();
}
inline void DataCaptureMetadata::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  _impl_.method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_name_.IsDefault()) {
    _impl_.method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.method_name)
}

// .viam.app.datasync.v1.DataType type = 5 [json_name = "type"];
inline void DataCaptureMetadata::clear_type() {
  _impl_.type_ = 0;
}
inline ::viam::app::datasync::v1::DataType DataCaptureMetadata::_internal_type() const {
  return static_cast< ::viam::app::datasync::v1::DataType >(_impl_.type_);
}
inline ::viam::app::datasync::v1::DataType DataCaptureMetadata::type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.type)
  return _internal_type();
}
inline void DataCaptureMetadata::_internal_set_type(::viam::app::datasync::v1::DataType value) {
  
  _impl_.type_ = value;
}
inline void DataCaptureMetadata::set_type(::viam::app::datasync::v1::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.type)
}

// map<string, .google.protobuf.Any> method_parameters = 6 [json_name = "methodParameters"];
inline int DataCaptureMetadata::_internal_method_parameters_size() const {
  return _impl_.method_parameters_.size();
}
inline int DataCaptureMetadata::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
DataCaptureMetadata::_internal_method_parameters() const {
  return _impl_.method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
DataCaptureMetadata::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.DataCaptureMetadata.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
DataCaptureMetadata::_internal_mutable_method_parameters() {
  return _impl_.method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
DataCaptureMetadata::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.DataCaptureMetadata.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_extension = 7 [json_name = "fileExtension"];
inline void DataCaptureMetadata::clear_file_extension() {
  _impl_.file_extension_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::file_extension() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
  return _internal_file_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_file_extension(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_extension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
}
inline std::string* DataCaptureMetadata::mutable_file_extension() {
  std::string* _s = _internal_mutable_file_extension();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_file_extension() const {
  return _impl_.file_extension_.Get();
}
inline void DataCaptureMetadata::_internal_set_file_extension(const std::string& value) {
  
  _impl_.file_extension_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_file_extension() {
  
  return _impl_.file_extension_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_file_extension() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
  return _impl_.file_extension_.Release();
}
inline void DataCaptureMetadata::set_allocated_file_extension(std::string* file_extension) {
  if (file_extension != nullptr) {
    
  } else {
    
  }
  _impl_.file_extension_.SetAllocated(file_extension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_extension_.IsDefault()) {
    _impl_.file_extension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
}

// repeated string tags = 8 [json_name = "tags"];
inline int DataCaptureMetadata::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int DataCaptureMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void DataCaptureMetadata::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* DataCaptureMetadata::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& DataCaptureMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return _internal_tags(index);
}
inline std::string* DataCaptureMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return _impl_.tags_.Mutable(index);
}
inline void DataCaptureMetadata::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline std::string* DataCaptureMetadata::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void DataCaptureMetadata::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataCaptureMetadata::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataCaptureMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return &_impl_.tags_;
}

// string session_id = 9 [json_name = "sessionId"];
inline void DataCaptureMetadata::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.session_id)
}
inline std::string* DataCaptureMetadata::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.session_id)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void DataCaptureMetadata::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.session_id)
  return _impl_.session_id_.Release();
}
inline void DataCaptureMetadata::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.session_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TabularCapture

// .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
inline bool TabularCapture::_internal_has_interval() const {
  return this != internal_default_instance() && _impl_.interval_ != nullptr;
}
inline bool TabularCapture::has_interval() const {
  return _internal_has_interval();
}
inline void TabularCapture::clear_interval() {
  if (GetArenaForAllocation() == nullptr && _impl_.interval_ != nullptr) {
    delete _impl_.interval_;
  }
  _impl_.interval_ = nullptr;
}
inline const ::viam::app::datasync::v1::CaptureInterval& TabularCapture::_internal_interval() const {
  const ::viam::app::datasync::v1::CaptureInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::datasync::v1::CaptureInterval&>(
      ::viam::app::datasync::v1::_CaptureInterval_default_instance_);
}
inline const ::viam::app::datasync::v1::CaptureInterval& TabularCapture::interval() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.interval)
  return _internal_interval();
}
inline void TabularCapture::unsafe_arena_set_allocated_interval(
    ::viam::app::datasync::v1::CaptureInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.TabularCapture.interval)
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::release_interval() {
  
  ::viam::app::datasync::v1::CaptureInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.interval)
  
  ::viam::app::datasync::v1::CaptureInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::_internal_mutable_interval() {
  
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::datasync::v1::CaptureInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::mutable_interval() {
  ::viam::app::datasync::v1::CaptureInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.interval)
  return _msg;
}
inline void TabularCapture::set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.interval_;
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interval);
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.interval)
}

// string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
inline void TabularCapture::clear_org_id() {
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.org_id)
}
inline std::string* TabularCapture::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.org_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_org_id() const {
  return _impl_.org_id_.Get();
}
inline void TabularCapture::_internal_set_org_id(const std::string& value) {
  
  _impl_.org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_org_id() {
  
  return _impl_.org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.org_id)
  return _impl_.org_id_.Release();
}
inline void TabularCapture::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  _impl_.org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.org_id_.IsDefault()) {
    _impl_.org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.org_id)
}

// string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
inline void TabularCapture::clear_robot_id() {
  _impl_.robot_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.robot_id)
}
inline std::string* TabularCapture::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.robot_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_robot_id() const {
  return _impl_.robot_id_.Get();
}
inline void TabularCapture::_internal_set_robot_id(const std::string& value) {
  
  _impl_.robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_robot_id() {
  
  return _impl_.robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.robot_id)
  return _impl_.robot_id_.Release();
}
inline void TabularCapture::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  _impl_.robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.robot_id_.IsDefault()) {
    _impl_.robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.robot_id)
}

// string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
inline void TabularCapture::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.part_id)
}
inline std::string* TabularCapture::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.part_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void TabularCapture::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.part_id)
  return _impl_.part_id_.Release();
}
inline void TabularCapture::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.part_id)
}

// string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
inline void TabularCapture::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.location_id)
}
inline std::string* TabularCapture::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.location_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void TabularCapture::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.location_id)
  return _impl_.location_id_.Release();
}
inline void TabularCapture::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.location_id)
}

// string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
inline void TabularCapture::clear_component_name() {
  _impl_.component_name_.ClearToEmpty();
}
inline const std::string& TabularCapture::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.component_name)
}
inline std::string* TabularCapture::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.component_name)
  return _s;
}
inline const std::string& TabularCapture::_internal_component_name() const {
  return _impl_.component_name_.Get();
}
inline void TabularCapture::_internal_set_component_name(const std::string& value) {
  
  _impl_.component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_component_name() {
  
  return _impl_.component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.component_name)
  return _impl_.component_name_.Release();
}
inline void TabularCapture::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  _impl_.component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_name_.IsDefault()) {
    _impl_.component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.component_name)
}

// string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
inline void TabularCapture::clear_component_type() {
  _impl_.component_type_.ClearToEmpty();
}
inline const std::string& TabularCapture::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.component_type)
}
inline std::string* TabularCapture::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.component_type)
  return _s;
}
inline const std::string& TabularCapture::_internal_component_type() const {
  return _impl_.component_type_.Get();
}
inline void TabularCapture::_internal_set_component_type(const std::string& value) {
  
  _impl_.component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_component_type() {
  
  return _impl_.component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.component_type)
  return _impl_.component_type_.Release();
}
inline void TabularCapture::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  _impl_.component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_type_.IsDefault()) {
    _impl_.component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.component_type)
}

// string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
inline void TabularCapture::clear_component_model() {
  _impl_.component_model_.ClearToEmpty();
}
inline const std::string& TabularCapture::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.component_model)
}
inline std::string* TabularCapture::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.component_model)
  return _s;
}
inline const std::string& TabularCapture::_internal_component_model() const {
  return _impl_.component_model_.Get();
}
inline void TabularCapture::_internal_set_component_model(const std::string& value) {
  
  _impl_.component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_component_model() {
  
  return _impl_.component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.component_model)
  return _impl_.component_model_.Release();
}
inline void TabularCapture::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  _impl_.component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_model_.IsDefault()) {
    _impl_.component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.component_model)
}

// string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
inline void TabularCapture::clear_method_name() {
  _impl_.method_name_.ClearToEmpty();
}
inline const std::string& TabularCapture::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.method_name)
}
inline std::string* TabularCapture::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.method_name)
  return _s;
}
inline const std::string& TabularCapture::_internal_method_name() const {
  return _impl_.method_name_.Get();
}
inline void TabularCapture::_internal_set_method_name(const std::string& value) {
  
  _impl_.method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_method_name() {
  
  return _impl_.method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.method_name)
  return _impl_.method_name_.Release();
}
inline void TabularCapture::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  _impl_.method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_name_.IsDefault()) {
    _impl_.method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.method_name)
}

// string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
inline void TabularCapture::clear_blob_path() {
  _impl_.blob_path_.ClearToEmpty();
}
inline const std::string& TabularCapture::blob_path() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.blob_path)
  return _internal_blob_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_blob_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blob_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.blob_path)
}
inline std::string* TabularCapture::mutable_blob_path() {
  std::string* _s = _internal_mutable_blob_path();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.blob_path)
  return _s;
}
inline const std::string& TabularCapture::_internal_blob_path() const {
  return _impl_.blob_path_.Get();
}
inline void TabularCapture::_internal_set_blob_path(const std::string& value) {
  
  _impl_.blob_path_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_blob_path() {
  
  return _impl_.blob_path_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_blob_path() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.blob_path)
  return _impl_.blob_path_.Release();
}
inline void TabularCapture::set_allocated_blob_path(std::string* blob_path) {
  if (blob_path != nullptr) {
    
  } else {
    
  }
  _impl_.blob_path_.SetAllocated(blob_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blob_path_.IsDefault()) {
    _impl_.blob_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.blob_path)
}

// repeated string column_names = 11 [json_name = "columnNames", (.tagger.v1.tags) = "bson:\"column_names\" json:\"column_names\""];
inline int TabularCapture::_internal_column_names_size() const {
  return _impl_.column_names_.size();
}
inline int TabularCapture::column_names_size() const {
  return _internal_column_names_size();
}
inline void TabularCapture::clear_column_names() {
  _impl_.column_names_.Clear();
}
inline std::string* TabularCapture::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.TabularCapture.column_names)
  return _s;
}
inline const std::string& TabularCapture::_internal_column_names(int index) const {
  return _impl_.column_names_.Get(index);
}
inline const std::string& TabularCapture::column_names(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.column_names)
  return _internal_column_names(index);
}
inline std::string* TabularCapture::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.column_names)
  return _impl_.column_names_.Mutable(index);
}
inline void TabularCapture::set_column_names(int index, const std::string& value) {
  _impl_.column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::set_column_names(int index, std::string&& value) {
  _impl_.column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::set_column_names(int index, const char* value, size_t size) {
  _impl_.column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.TabularCapture.column_names)
}
inline std::string* TabularCapture::_internal_add_column_names() {
  return _impl_.column_names_.Add();
}
inline void TabularCapture::add_column_names(const std::string& value) {
  _impl_.column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::add_column_names(std::string&& value) {
  _impl_.column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::add_column_names(const char* value, size_t size) {
  _impl_.column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.TabularCapture.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TabularCapture::column_names() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.TabularCapture.column_names)
  return _impl_.column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TabularCapture::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.TabularCapture.column_names)
  return &_impl_.column_names_;
}

// map<string, .google.protobuf.Any> method_parameters = 12 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
inline int TabularCapture::_internal_method_parameters_size() const {
  return _impl_.method_parameters_.size();
}
inline int TabularCapture::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
TabularCapture::_internal_method_parameters() const {
  return _impl_.method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
TabularCapture::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.TabularCapture.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
TabularCapture::_internal_mutable_method_parameters() {
  return _impl_.method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
TabularCapture::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.TabularCapture.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_id = 13 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
inline void TabularCapture::clear_file_id() {
  _impl_.file_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::file_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.file_id)
}
inline std::string* TabularCapture::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.file_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_file_id() const {
  return _impl_.file_id_.Get();
}
inline void TabularCapture::_internal_set_file_id(const std::string& value) {
  
  _impl_.file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_file_id() {
  
  return _impl_.file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_file_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.file_id)
  return _impl_.file_id_.Release();
}
inline void TabularCapture::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  _impl_.file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_id_.IsDefault()) {
    _impl_.file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.file_id)
}

// repeated string tags = 14 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
inline int TabularCapture::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int TabularCapture::tags_size() const {
  return _internal_tags_size();
}
inline void TabularCapture::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* TabularCapture::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.TabularCapture.tags)
  return _s;
}
inline const std::string& TabularCapture::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& TabularCapture::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.tags)
  return _internal_tags(index);
}
inline std::string* TabularCapture::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.tags)
  return _impl_.tags_.Mutable(index);
}
inline void TabularCapture::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.TabularCapture.tags)
}
inline std::string* TabularCapture::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void TabularCapture::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.TabularCapture.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TabularCapture::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.TabularCapture.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TabularCapture::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.TabularCapture.tags)
  return &_impl_.tags_;
}

// int32 message_count = 15 [json_name = "messageCount", (.tagger.v1.tags) = "bson:\"message_count\" json:\"message_count\""];
inline void TabularCapture::clear_message_count() {
  _impl_.message_count_ = 0;
}
inline int32_t TabularCapture::_internal_message_count() const {
  return _impl_.message_count_;
}
inline int32_t TabularCapture::message_count() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.message_count)
  return _internal_message_count();
}
inline void TabularCapture::_internal_set_message_count(int32_t value) {
  
  _impl_.message_count_ = value;
}
inline void TabularCapture::set_message_count(int32_t value) {
  _internal_set_message_count(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.message_count)
}

// int64 file_size_bytes = 16 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
inline void TabularCapture::clear_file_size_bytes() {
  _impl_.file_size_bytes_ = int64_t{0};
}
inline int64_t TabularCapture::_internal_file_size_bytes() const {
  return _impl_.file_size_bytes_;
}
inline int64_t TabularCapture::file_size_bytes() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.file_size_bytes)
  return _internal_file_size_bytes();
}
inline void TabularCapture::_internal_set_file_size_bytes(int64_t value) {
  
  _impl_.file_size_bytes_ = value;
}
inline void TabularCapture::set_file_size_bytes(int64_t value) {
  _internal_set_file_size_bytes(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.file_size_bytes)
}

// string session_id = 17 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
inline void TabularCapture::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.session_id)
}
inline std::string* TabularCapture::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.session_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TabularCapture::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.session_id)
  return _impl_.session_id_.Release();
}
inline void TabularCapture::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.session_id)
}

// string mime_type = 18 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
inline void TabularCapture::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& TabularCapture::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.mime_type)
}
inline std::string* TabularCapture::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.mime_type)
  return _s;
}
inline const std::string& TabularCapture::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void TabularCapture::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.mime_type)
  return _impl_.mime_type_.Release();
}
inline void TabularCapture::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.mime_type)
}

// string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void TabularCapture::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TabularCapture::id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.id)
}
inline std::string* TabularCapture::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.id)
  return _s;
}
inline const std::string& TabularCapture::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TabularCapture::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.id)
  return _impl_.id_.Release();
}
inline void TabularCapture::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BinaryCapture

// .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
inline bool BinaryCapture::_internal_has_interval() const {
  return this != internal_default_instance() && _impl_.interval_ != nullptr;
}
inline bool BinaryCapture::has_interval() const {
  return _internal_has_interval();
}
inline void BinaryCapture::clear_interval() {
  if (GetArenaForAllocation() == nullptr && _impl_.interval_ != nullptr) {
    delete _impl_.interval_;
  }
  _impl_.interval_ = nullptr;
}
inline const ::viam::app::datasync::v1::CaptureInterval& BinaryCapture::_internal_interval() const {
  const ::viam::app::datasync::v1::CaptureInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::datasync::v1::CaptureInterval&>(
      ::viam::app::datasync::v1::_CaptureInterval_default_instance_);
}
inline const ::viam::app::datasync::v1::CaptureInterval& BinaryCapture::interval() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.interval)
  return _internal_interval();
}
inline void BinaryCapture::unsafe_arena_set_allocated_interval(
    ::viam::app::datasync::v1::CaptureInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.BinaryCapture.interval)
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::release_interval() {
  
  ::viam::app::datasync::v1::CaptureInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.interval)
  
  ::viam::app::datasync::v1::CaptureInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::_internal_mutable_interval() {
  
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::datasync::v1::CaptureInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::mutable_interval() {
  ::viam::app::datasync::v1::CaptureInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.interval)
  return _msg;
}
inline void BinaryCapture::set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.interval_;
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interval);
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.interval)
}

// string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
inline void BinaryCapture::clear_org_id() {
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.org_id)
}
inline std::string* BinaryCapture::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.org_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_org_id() const {
  return _impl_.org_id_.Get();
}
inline void BinaryCapture::_internal_set_org_id(const std::string& value) {
  
  _impl_.org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_org_id() {
  
  return _impl_.org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.org_id)
  return _impl_.org_id_.Release();
}
inline void BinaryCapture::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  _impl_.org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.org_id_.IsDefault()) {
    _impl_.org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.org_id)
}

// string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
inline void BinaryCapture::clear_robot_id() {
  _impl_.robot_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.robot_id)
}
inline std::string* BinaryCapture::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.robot_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_robot_id() const {
  return _impl_.robot_id_.Get();
}
inline void BinaryCapture::_internal_set_robot_id(const std::string& value) {
  
  _impl_.robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_robot_id() {
  
  return _impl_.robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.robot_id)
  return _impl_.robot_id_.Release();
}
inline void BinaryCapture::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  _impl_.robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.robot_id_.IsDefault()) {
    _impl_.robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.robot_id)
}

// string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
inline void BinaryCapture::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.part_id)
}
inline std::string* BinaryCapture::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.part_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void BinaryCapture::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.part_id)
  return _impl_.part_id_.Release();
}
inline void BinaryCapture::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.part_id)
}

// string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
inline void BinaryCapture::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.location_id)
}
inline std::string* BinaryCapture::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.location_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void BinaryCapture::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.location_id)
  return _impl_.location_id_.Release();
}
inline void BinaryCapture::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.location_id)
}

// string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
inline void BinaryCapture::clear_component_name() {
  _impl_.component_name_.ClearToEmpty();
}
inline const std::string& BinaryCapture::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.component_name)
}
inline std::string* BinaryCapture::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.component_name)
  return _s;
}
inline const std::string& BinaryCapture::_internal_component_name() const {
  return _impl_.component_name_.Get();
}
inline void BinaryCapture::_internal_set_component_name(const std::string& value) {
  
  _impl_.component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_component_name() {
  
  return _impl_.component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.component_name)
  return _impl_.component_name_.Release();
}
inline void BinaryCapture::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  _impl_.component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_name_.IsDefault()) {
    _impl_.component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.component_name)
}

// string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
inline void BinaryCapture::clear_component_type() {
  _impl_.component_type_.ClearToEmpty();
}
inline const std::string& BinaryCapture::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.component_type)
}
inline std::string* BinaryCapture::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.component_type)
  return _s;
}
inline const std::string& BinaryCapture::_internal_component_type() const {
  return _impl_.component_type_.Get();
}
inline void BinaryCapture::_internal_set_component_type(const std::string& value) {
  
  _impl_.component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_component_type() {
  
  return _impl_.component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.component_type)
  return _impl_.component_type_.Release();
}
inline void BinaryCapture::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  _impl_.component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_type_.IsDefault()) {
    _impl_.component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.component_type)
}

// string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
inline void BinaryCapture::clear_component_model() {
  _impl_.component_model_.ClearToEmpty();
}
inline const std::string& BinaryCapture::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.component_model)
}
inline std::string* BinaryCapture::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.component_model)
  return _s;
}
inline const std::string& BinaryCapture::_internal_component_model() const {
  return _impl_.component_model_.Get();
}
inline void BinaryCapture::_internal_set_component_model(const std::string& value) {
  
  _impl_.component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_component_model() {
  
  return _impl_.component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.component_model)
  return _impl_.component_model_.Release();
}
inline void BinaryCapture::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  _impl_.component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_model_.IsDefault()) {
    _impl_.component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.component_model)
}

// string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
inline void BinaryCapture::clear_method_name() {
  _impl_.method_name_.ClearToEmpty();
}
inline const std::string& BinaryCapture::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.method_name)
}
inline std::string* BinaryCapture::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.method_name)
  return _s;
}
inline const std::string& BinaryCapture::_internal_method_name() const {
  return _impl_.method_name_.Get();
}
inline void BinaryCapture::_internal_set_method_name(const std::string& value) {
  
  _impl_.method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_method_name() {
  
  return _impl_.method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.method_name)
  return _impl_.method_name_.Release();
}
inline void BinaryCapture::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  _impl_.method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_name_.IsDefault()) {
    _impl_.method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.method_name)
}

// string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
inline void BinaryCapture::clear_blob_path() {
  _impl_.blob_path_.ClearToEmpty();
}
inline const std::string& BinaryCapture::blob_path() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.blob_path)
  return _internal_blob_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_blob_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blob_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.blob_path)
}
inline std::string* BinaryCapture::mutable_blob_path() {
  std::string* _s = _internal_mutable_blob_path();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.blob_path)
  return _s;
}
inline const std::string& BinaryCapture::_internal_blob_path() const {
  return _impl_.blob_path_.Get();
}
inline void BinaryCapture::_internal_set_blob_path(const std::string& value) {
  
  _impl_.blob_path_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_blob_path() {
  
  return _impl_.blob_path_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_blob_path() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.blob_path)
  return _impl_.blob_path_.Release();
}
inline void BinaryCapture::set_allocated_blob_path(std::string* blob_path) {
  if (blob_path != nullptr) {
    
  } else {
    
  }
  _impl_.blob_path_.SetAllocated(blob_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blob_path_.IsDefault()) {
    _impl_.blob_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.blob_path)
}

// map<string, .google.protobuf.Any> method_parameters = 11 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
inline int BinaryCapture::_internal_method_parameters_size() const {
  return _impl_.method_parameters_.size();
}
inline int BinaryCapture::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
BinaryCapture::_internal_method_parameters() const {
  return _impl_.method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
BinaryCapture::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.BinaryCapture.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
BinaryCapture::_internal_mutable_method_parameters() {
  return _impl_.method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
BinaryCapture::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.BinaryCapture.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_id = 12 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
inline void BinaryCapture::clear_file_id() {
  _impl_.file_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::file_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_id)
}
inline std::string* BinaryCapture::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.file_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_file_id() const {
  return _impl_.file_id_.Get();
}
inline void BinaryCapture::_internal_set_file_id(const std::string& value) {
  
  _impl_.file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_file_id() {
  
  return _impl_.file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_file_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.file_id)
  return _impl_.file_id_.Release();
}
inline void BinaryCapture::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  _impl_.file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_id_.IsDefault()) {
    _impl_.file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.file_id)
}

// repeated string tags = 13 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
inline int BinaryCapture::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int BinaryCapture::tags_size() const {
  return _internal_tags_size();
}
inline void BinaryCapture::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* BinaryCapture::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.BinaryCapture.tags)
  return _s;
}
inline const std::string& BinaryCapture::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& BinaryCapture::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.tags)
  return _internal_tags(index);
}
inline std::string* BinaryCapture::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.tags)
  return _impl_.tags_.Mutable(index);
}
inline void BinaryCapture::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.BinaryCapture.tags)
}
inline std::string* BinaryCapture::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void BinaryCapture::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.BinaryCapture.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BinaryCapture::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.BinaryCapture.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BinaryCapture::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.BinaryCapture.tags)
  return &_impl_.tags_;
}

// int64 file_size_bytes = 14 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
inline void BinaryCapture::clear_file_size_bytes() {
  _impl_.file_size_bytes_ = int64_t{0};
}
inline int64_t BinaryCapture::_internal_file_size_bytes() const {
  return _impl_.file_size_bytes_;
}
inline int64_t BinaryCapture::file_size_bytes() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_size_bytes)
  return _internal_file_size_bytes();
}
inline void BinaryCapture::_internal_set_file_size_bytes(int64_t value) {
  
  _impl_.file_size_bytes_ = value;
}
inline void BinaryCapture::set_file_size_bytes(int64_t value) {
  _internal_set_file_size_bytes(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_size_bytes)
}

// string session_id = 15 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
inline void BinaryCapture::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.session_id)
}
inline std::string* BinaryCapture::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.session_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void BinaryCapture::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.session_id)
  return _impl_.session_id_.Release();
}
inline void BinaryCapture::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.session_id)
}

// string mime_type = 16 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
inline void BinaryCapture::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& BinaryCapture::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.mime_type)
}
inline std::string* BinaryCapture::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.mime_type)
  return _s;
}
inline const std::string& BinaryCapture::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void BinaryCapture::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.mime_type)
  return _impl_.mime_type_.Release();
}
inline void BinaryCapture::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.mime_type)
}

// string file_name = 17 [json_name = "fileName", (.tagger.v1.tags) = "bson:\"file_name\" json:\"file_name\""];
inline void BinaryCapture::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& BinaryCapture::file_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_name)
}
inline std::string* BinaryCapture::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.file_name)
  return _s;
}
inline const std::string& BinaryCapture::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void BinaryCapture::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_file_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.file_name)
  return _impl_.file_name_.Release();
}
inline void BinaryCapture::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.file_name)
}

// string file_ext = 18 [json_name = "fileExt", (.tagger.v1.tags) = "bson:\"file_ext\" json:\"file_ext\""];
inline void BinaryCapture::clear_file_ext() {
  _impl_.file_ext_.ClearToEmpty();
}
inline const std::string& BinaryCapture::file_ext() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_ext)
  return _internal_file_ext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_file_ext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_ext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_ext)
}
inline std::string* BinaryCapture::mutable_file_ext() {
  std::string* _s = _internal_mutable_file_ext();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.file_ext)
  return _s;
}
inline const std::string& BinaryCapture::_internal_file_ext() const {
  return _impl_.file_ext_.Get();
}
inline void BinaryCapture::_internal_set_file_ext(const std::string& value) {
  
  _impl_.file_ext_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_file_ext() {
  
  return _impl_.file_ext_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_file_ext() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.file_ext)
  return _impl_.file_ext_.Release();
}
inline void BinaryCapture::set_allocated_file_ext(std::string* file_ext) {
  if (file_ext != nullptr) {
    
  } else {
    
  }
  _impl_.file_ext_.SetAllocated(file_ext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_ext_.IsDefault()) {
    _impl_.file_ext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.file_ext)
}

// string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void BinaryCapture::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.id)
}
inline std::string* BinaryCapture::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BinaryCapture::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.id)
  return _impl_.id_.Release();
}
inline void BinaryCapture::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace datasync
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::datasync::v1::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::datasync::v1::DataType>() {
  return ::viam::app::datasync::v1::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fdatasync_2fv1_2fdata_5fsync_2eproto
