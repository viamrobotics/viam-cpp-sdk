// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/datasync/v1/data_sync.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fdatasync_2fv1_2fdata_5fsync_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fdatasync_2fv1_2fdata_5fsync_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fdatasync_2fv1_2fdata_5fsync_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
namespace viam {
namespace app {
namespace datasync {
namespace v1 {
class BinaryCapture;
struct BinaryCaptureDefaultTypeInternal;
extern BinaryCaptureDefaultTypeInternal _BinaryCapture_default_instance_;
class BinaryCapture_MethodParametersEntry_DoNotUse;
struct BinaryCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern BinaryCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal _BinaryCapture_MethodParametersEntry_DoNotUse_default_instance_;
class CaptureInterval;
struct CaptureIntervalDefaultTypeInternal;
extern CaptureIntervalDefaultTypeInternal _CaptureInterval_default_instance_;
class DataCaptureMetadata;
struct DataCaptureMetadataDefaultTypeInternal;
extern DataCaptureMetadataDefaultTypeInternal _DataCaptureMetadata_default_instance_;
class DataCaptureMetadata_MethodParametersEntry_DoNotUse;
struct DataCaptureMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern DataCaptureMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal _DataCaptureMetadata_MethodParametersEntry_DoNotUse_default_instance_;
class FileData;
struct FileDataDefaultTypeInternal;
extern FileDataDefaultTypeInternal _FileData_default_instance_;
class SensorData;
struct SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorMetadata;
struct SensorMetadataDefaultTypeInternal;
extern SensorMetadataDefaultTypeInternal _SensorMetadata_default_instance_;
class TabularCapture;
struct TabularCaptureDefaultTypeInternal;
extern TabularCaptureDefaultTypeInternal _TabularCapture_default_instance_;
class TabularCapture_MethodParametersEntry_DoNotUse;
struct TabularCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern TabularCapture_MethodParametersEntry_DoNotUseDefaultTypeInternal _TabularCapture_MethodParametersEntry_DoNotUse_default_instance_;
class UploadMetadata;
struct UploadMetadataDefaultTypeInternal;
extern UploadMetadataDefaultTypeInternal _UploadMetadata_default_instance_;
class UploadMetadata_MethodParametersEntry_DoNotUse;
struct UploadMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal;
extern UploadMetadata_MethodParametersEntry_DoNotUseDefaultTypeInternal _UploadMetadata_MethodParametersEntry_DoNotUse_default_instance_;
class UploadRequest;
struct UploadRequestDefaultTypeInternal;
extern UploadRequestDefaultTypeInternal _UploadRequest_default_instance_;
class UploadResponse;
struct UploadResponseDefaultTypeInternal;
extern UploadResponseDefaultTypeInternal _UploadResponse_default_instance_;
}  // namespace v1
}  // namespace datasync
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::datasync::v1::BinaryCapture* Arena::CreateMaybeMessage<::viam::app::datasync::v1::BinaryCapture>(Arena*);
template<> ::viam::app::datasync::v1::BinaryCapture_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::BinaryCapture_MethodParametersEntry_DoNotUse>(Arena*);
template<> ::viam::app::datasync::v1::CaptureInterval* Arena::CreateMaybeMessage<::viam::app::datasync::v1::CaptureInterval>(Arena*);
template<> ::viam::app::datasync::v1::DataCaptureMetadata* Arena::CreateMaybeMessage<::viam::app::datasync::v1::DataCaptureMetadata>(Arena*);
template<> ::viam::app::datasync::v1::DataCaptureMetadata_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::DataCaptureMetadata_MethodParametersEntry_DoNotUse>(Arena*);
template<> ::viam::app::datasync::v1::FileData* Arena::CreateMaybeMessage<::viam::app::datasync::v1::FileData>(Arena*);
template<> ::viam::app::datasync::v1::SensorData* Arena::CreateMaybeMessage<::viam::app::datasync::v1::SensorData>(Arena*);
template<> ::viam::app::datasync::v1::SensorMetadata* Arena::CreateMaybeMessage<::viam::app::datasync::v1::SensorMetadata>(Arena*);
template<> ::viam::app::datasync::v1::TabularCapture* Arena::CreateMaybeMessage<::viam::app::datasync::v1::TabularCapture>(Arena*);
template<> ::viam::app::datasync::v1::TabularCapture_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::TabularCapture_MethodParametersEntry_DoNotUse>(Arena*);
template<> ::viam::app::datasync::v1::UploadMetadata* Arena::CreateMaybeMessage<::viam::app::datasync::v1::UploadMetadata>(Arena*);
template<> ::viam::app::datasync::v1::UploadMetadata_MethodParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::UploadMetadata_MethodParametersEntry_DoNotUse>(Arena*);
template<> ::viam::app::datasync::v1::UploadRequest* Arena::CreateMaybeMessage<::viam::app::datasync::v1::UploadRequest>(Arena*);
template<> ::viam::app::datasync::v1::UploadResponse* Arena::CreateMaybeMessage<::viam::app::datasync::v1::UploadResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace datasync {
namespace v1 {

enum DataType : int {
  DATA_TYPE_UNSPECIFIED = 0,
  DATA_TYPE_BINARY_SENSOR = 1,
  DATA_TYPE_TABULAR_SENSOR = 2,
  DATA_TYPE_FILE = 3,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = DATA_TYPE_UNSPECIFIED;
constexpr DataType DataType_MAX = DATA_TYPE_FILE;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class SensorMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.SensorMetadata) */ {
 public:
  inline SensorMetadata() : SensorMetadata(nullptr) {}
  ~SensorMetadata() override;
  explicit PROTOBUF_CONSTEXPR SensorMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMetadata(const SensorMetadata& from);
  SensorMetadata(SensorMetadata&& from) noexcept
    : SensorMetadata() {
    *this = ::std::move(from);
  }

  inline SensorMetadata& operator=(const SensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMetadata& operator=(SensorMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMetadata* internal_default_instance() {
    return reinterpret_cast<const SensorMetadata*>(
               &_SensorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SensorMetadata& a, SensorMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.SensorMetadata";
  }
  protected:
  explicit SensorMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeRequestedFieldNumber = 1,
    kTimeReceivedFieldNumber = 2,
  };
  // .google.protobuf.Timestamp time_requested = 1 [json_name = "timeRequested"];
  bool has_time_requested() const;
  private:
  bool _internal_has_time_requested() const;
  public:
  void clear_time_requested();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_requested() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time_requested();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time_requested();
  void set_allocated_time_requested(::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time_requested() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time_requested();
  public:
  void unsafe_arena_set_allocated_time_requested(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time_requested();

  // .google.protobuf.Timestamp time_received = 2 [json_name = "timeReceived"];
  bool has_time_received() const;
  private:
  bool _internal_has_time_received() const;
  public:
  void clear_time_received();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_received() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time_received();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time_received();
  void set_allocated_time_received(::PROTOBUF_NAMESPACE_ID::Timestamp* time_received);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time_received() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time_received();
  public:
  void unsafe_arena_set_allocated_time_received(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time_received);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time_received();

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.SensorMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* time_received_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class SensorData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.SensorData) */ {
 public:
  inline SensorData() : SensorData(nullptr) {}
  ~SensorData() override;
  explicit PROTOBUF_CONSTEXPR SensorData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorData(const SensorData& from);
  SensorData(SensorData&& from) noexcept
    : SensorData() {
    *this = ::std::move(from);
  }

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorData& operator=(SensorData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorData& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kStruct = 2,
    kBinary = 3,
    DATA_NOT_SET = 0,
  };

  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
               &_SensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SensorData& a, SensorData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.SensorData";
  }
  protected:
  explicit SensorData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kStructFieldNumber = 2,
    kBinaryFieldNumber = 3,
  };
  // .viam.app.datasync.v1.SensorMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::datasync::v1::SensorMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::SensorMetadata* release_metadata();
  ::viam::app::datasync::v1::SensorMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::datasync::v1::SensorMetadata* metadata);
  private:
  const ::viam::app::datasync::v1::SensorMetadata& _internal_metadata() const;
  ::viam::app::datasync::v1::SensorMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::datasync::v1::SensorMetadata* metadata);
  ::viam::app::datasync::v1::SensorMetadata* unsafe_arena_release_metadata();

  // .google.protobuf.Struct struct = 2 [json_name = "struct"];
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::PROTOBUF_NAMESPACE_ID::Struct& struct_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_struct_();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_struct_();
  void set_allocated_struct_(::PROTOBUF_NAMESPACE_ID::Struct* struct_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_struct_() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::PROTOBUF_NAMESPACE_ID::Struct* struct_);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_struct_();

  // bytes binary = 3 [json_name = "binary"];
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const std::string& binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary();
  PROTOBUF_NODISCARD std::string* release_binary();
  void set_allocated_binary(std::string* binary);
  private:
  const std::string& _internal_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary(const std::string& value);
  std::string* _internal_mutable_binary();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.SensorData)
 private:
  class _Internal;
  void set_has_struct_();
  void set_has_binary();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::viam::app::datasync::v1::SensorMetadata* metadata_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::Struct* struct__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class FileData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.FileData) */ {
 public:
  inline FileData() : FileData(nullptr) {}
  ~FileData() override;
  explicit PROTOBUF_CONSTEXPR FileData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileData(const FileData& from);
  FileData(FileData&& from) noexcept
    : FileData() {
    *this = ::std::move(from);
  }

  inline FileData& operator=(const FileData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileData& operator=(FileData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileData* internal_default_instance() {
    return reinterpret_cast<const FileData*>(
               &_FileData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileData& a, FileData& b) {
    a.Swap(&b);
  }
  inline void Swap(FileData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.FileData";
  }
  protected:
  explicit FileData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1 [json_name = "data"];
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.FileData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class UploadMetadata_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UploadMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UploadMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  UploadMetadata_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UploadMetadata_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UploadMetadata_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UploadMetadata_MethodParametersEntry_DoNotUse& other);
  static const UploadMetadata_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UploadMetadata_MethodParametersEntry_DoNotUse*>(&_UploadMetadata_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.UploadMetadata.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class UploadMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.UploadMetadata) */ {
 public:
  inline UploadMetadata() : UploadMetadata(nullptr) {}
  ~UploadMetadata() override;
  explicit PROTOBUF_CONSTEXPR UploadMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadMetadata(const UploadMetadata& from);
  UploadMetadata(UploadMetadata&& from) noexcept
    : UploadMetadata() {
    *this = ::std::move(from);
  }

  inline UploadMetadata& operator=(const UploadMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadMetadata& operator=(UploadMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadMetadata* internal_default_instance() {
    return reinterpret_cast<const UploadMetadata*>(
               &_UploadMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UploadMetadata& a, UploadMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.UploadMetadata";
  }
  protected:
  explicit UploadMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMethodParametersFieldNumber = 8,
    kTagsFieldNumber = 10,
    kPartIdFieldNumber = 1,
    kComponentTypeFieldNumber = 2,
    kComponentNameFieldNumber = 3,
    kComponentModelFieldNumber = 4,
    kMethodNameFieldNumber = 5,
    kFileNameFieldNumber = 7,
    kFileExtensionFieldNumber = 9,
    kSessionIdFieldNumber = 11,
    kTypeFieldNumber = 6,
  };
  // map<string, .google.protobuf.Any> method_parameters = 8 [json_name = "methodParameters"];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 10 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string component_type = 2 [json_name = "componentType"];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_name = 3 [json_name = "componentName"];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_model = 4 [json_name = "componentModel"];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 5 [json_name = "methodName"];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string file_name = 7 [json_name = "fileName"];
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string file_extension = 9 [json_name = "fileExtension"];
  void clear_file_extension();
  const std::string& file_extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_extension();
  PROTOBUF_NODISCARD std::string* release_file_extension();
  void set_allocated_file_extension(std::string* file_extension);
  private:
  const std::string& _internal_file_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_extension(const std::string& value);
  std::string* _internal_mutable_file_extension();
  public:

  // string session_id = 11 [json_name = "sessionId"];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .viam.app.datasync.v1.DataType type = 6 [json_name = "type"];
  void clear_type();
  ::viam::app::datasync::v1::DataType type() const;
  void set_type(::viam::app::datasync::v1::DataType value);
  private:
  ::viam::app::datasync::v1::DataType _internal_type() const;
  void _internal_set_type(::viam::app::datasync::v1::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.UploadMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      UploadMetadata_MethodParametersEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::Any,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_extension_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class UploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.UploadRequest) */ {
 public:
  inline UploadRequest() : UploadRequest(nullptr) {}
  ~UploadRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadRequest(const UploadRequest& from);
  UploadRequest(UploadRequest&& from) noexcept
    : UploadRequest() {
    *this = ::std::move(from);
  }

  inline UploadRequest& operator=(const UploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadRequest& operator=(UploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadRequest& default_instance() {
    return *internal_default_instance();
  }
  enum UploadPacketCase {
    kMetadata = 1,
    kSensorContents = 2,
    kFileContents = 3,
    UPLOAD_PACKET_NOT_SET = 0,
  };

  static inline const UploadRequest* internal_default_instance() {
    return reinterpret_cast<const UploadRequest*>(
               &_UploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UploadRequest& a, UploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.UploadRequest";
  }
  protected:
  explicit UploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSensorContentsFieldNumber = 2,
    kFileContentsFieldNumber = 3,
  };
  // .viam.app.datasync.v1.UploadMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::datasync::v1::UploadMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::UploadMetadata* release_metadata();
  ::viam::app::datasync::v1::UploadMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::datasync::v1::UploadMetadata* metadata);
  private:
  const ::viam::app::datasync::v1::UploadMetadata& _internal_metadata() const;
  ::viam::app::datasync::v1::UploadMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::datasync::v1::UploadMetadata* metadata);
  ::viam::app::datasync::v1::UploadMetadata* unsafe_arena_release_metadata();

  // .viam.app.datasync.v1.SensorData sensor_contents = 2 [json_name = "sensorContents"];
  bool has_sensor_contents() const;
  private:
  bool _internal_has_sensor_contents() const;
  public:
  void clear_sensor_contents();
  const ::viam::app::datasync::v1::SensorData& sensor_contents() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::SensorData* release_sensor_contents();
  ::viam::app::datasync::v1::SensorData* mutable_sensor_contents();
  void set_allocated_sensor_contents(::viam::app::datasync::v1::SensorData* sensor_contents);
  private:
  const ::viam::app::datasync::v1::SensorData& _internal_sensor_contents() const;
  ::viam::app::datasync::v1::SensorData* _internal_mutable_sensor_contents();
  public:
  void unsafe_arena_set_allocated_sensor_contents(
      ::viam::app::datasync::v1::SensorData* sensor_contents);
  ::viam::app::datasync::v1::SensorData* unsafe_arena_release_sensor_contents();

  // .viam.app.datasync.v1.FileData file_contents = 3 [json_name = "fileContents"];
  bool has_file_contents() const;
  private:
  bool _internal_has_file_contents() const;
  public:
  void clear_file_contents();
  const ::viam::app::datasync::v1::FileData& file_contents() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::FileData* release_file_contents();
  ::viam::app::datasync::v1::FileData* mutable_file_contents();
  void set_allocated_file_contents(::viam::app::datasync::v1::FileData* file_contents);
  private:
  const ::viam::app::datasync::v1::FileData& _internal_file_contents() const;
  ::viam::app::datasync::v1::FileData* _internal_mutable_file_contents();
  public:
  void unsafe_arena_set_allocated_file_contents(
      ::viam::app::datasync::v1::FileData* file_contents);
  ::viam::app::datasync::v1::FileData* unsafe_arena_release_file_contents();

  void clear_upload_packet();
  UploadPacketCase upload_packet_case() const;
  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.UploadRequest)
 private:
  class _Internal;
  void set_has_metadata();
  void set_has_sensor_contents();
  void set_has_file_contents();

  inline bool has_upload_packet() const;
  inline void clear_has_upload_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union UploadPacketUnion {
    constexpr UploadPacketUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::viam::app::datasync::v1::UploadMetadata* metadata_;
    ::viam::app::datasync::v1::SensorData* sensor_contents_;
    ::viam::app::datasync::v1::FileData* file_contents_;
  } upload_packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class UploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.UploadResponse) */ {
 public:
  inline UploadResponse() : UploadResponse(nullptr) {}
  ~UploadResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadResponse(const UploadResponse& from);
  UploadResponse(UploadResponse&& from) noexcept
    : UploadResponse() {
    *this = ::std::move(from);
  }

  inline UploadResponse& operator=(const UploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadResponse& operator=(UploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadResponse* internal_default_instance() {
    return reinterpret_cast<const UploadResponse*>(
               &_UploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UploadResponse& a, UploadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.UploadResponse";
  }
  protected:
  explicit UploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsWrittenFieldNumber = 1,
  };
  // int32 requests_written = 1 [json_name = "requestsWritten"];
  void clear_requests_written();
  int32_t requests_written() const;
  void set_requests_written(int32_t value);
  private:
  int32_t _internal_requests_written() const;
  void _internal_set_requests_written(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.UploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t requests_written_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class CaptureInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.CaptureInterval) */ {
 public:
  inline CaptureInterval() : CaptureInterval(nullptr) {}
  ~CaptureInterval() override;
  explicit PROTOBUF_CONSTEXPR CaptureInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureInterval(const CaptureInterval& from);
  CaptureInterval(CaptureInterval&& from) noexcept
    : CaptureInterval() {
    *this = ::std::move(from);
  }

  inline CaptureInterval& operator=(const CaptureInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureInterval& operator=(CaptureInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureInterval* internal_default_instance() {
    return reinterpret_cast<const CaptureInterval*>(
               &_CaptureInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CaptureInterval& a, CaptureInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureInterval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CaptureInterval& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.CaptureInterval";
  }
  protected:
  explicit CaptureInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .google.protobuf.Timestamp start = 1 [json_name = "start"];
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start();
  void set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start();

  // .google.protobuf.Timestamp end = 2 [json_name = "end"];
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end();
  void set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.CaptureInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* start_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class DataCaptureMetadata_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataCaptureMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataCaptureMetadata_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  DataCaptureMetadata_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DataCaptureMetadata_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DataCaptureMetadata_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DataCaptureMetadata_MethodParametersEntry_DoNotUse& other);
  static const DataCaptureMetadata_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataCaptureMetadata_MethodParametersEntry_DoNotUse*>(&_DataCaptureMetadata_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.DataCaptureMetadata.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class DataCaptureMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.DataCaptureMetadata) */ {
 public:
  inline DataCaptureMetadata() : DataCaptureMetadata(nullptr) {}
  ~DataCaptureMetadata() override;
  explicit PROTOBUF_CONSTEXPR DataCaptureMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataCaptureMetadata(const DataCaptureMetadata& from);
  DataCaptureMetadata(DataCaptureMetadata&& from) noexcept
    : DataCaptureMetadata() {
    *this = ::std::move(from);
  }

  inline DataCaptureMetadata& operator=(const DataCaptureMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCaptureMetadata& operator=(DataCaptureMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataCaptureMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataCaptureMetadata* internal_default_instance() {
    return reinterpret_cast<const DataCaptureMetadata*>(
               &_DataCaptureMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DataCaptureMetadata& a, DataCaptureMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCaptureMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCaptureMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataCaptureMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataCaptureMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataCaptureMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataCaptureMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataCaptureMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.DataCaptureMetadata";
  }
  protected:
  explicit DataCaptureMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMethodParametersFieldNumber = 6,
    kTagsFieldNumber = 8,
    kComponentTypeFieldNumber = 1,
    kComponentNameFieldNumber = 2,
    kComponentModelFieldNumber = 3,
    kMethodNameFieldNumber = 4,
    kFileExtensionFieldNumber = 7,
    kSessionIdFieldNumber = 9,
    kTypeFieldNumber = 5,
  };
  // map<string, .google.protobuf.Any> method_parameters = 6 [json_name = "methodParameters"];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 8 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string component_type = 1 [json_name = "componentType"];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_name = 2 [json_name = "componentName"];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_model = 3 [json_name = "componentModel"];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 4 [json_name = "methodName"];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string file_extension = 7 [json_name = "fileExtension"];
  void clear_file_extension();
  const std::string& file_extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_extension();
  PROTOBUF_NODISCARD std::string* release_file_extension();
  void set_allocated_file_extension(std::string* file_extension);
  private:
  const std::string& _internal_file_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_extension(const std::string& value);
  std::string* _internal_mutable_file_extension();
  public:

  // string session_id = 9 [json_name = "sessionId"];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .viam.app.datasync.v1.DataType type = 5 [json_name = "type"];
  void clear_type();
  ::viam::app::datasync::v1::DataType type() const;
  void set_type(::viam::app::datasync::v1::DataType value);
  private:
  ::viam::app::datasync::v1::DataType _internal_type() const;
  void _internal_set_type(::viam::app::datasync::v1::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.DataCaptureMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DataCaptureMetadata_MethodParametersEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::Any,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_extension_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class TabularCapture_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TabularCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TabularCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TabularCapture_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TabularCapture_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TabularCapture_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TabularCapture_MethodParametersEntry_DoNotUse& other);
  static const TabularCapture_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TabularCapture_MethodParametersEntry_DoNotUse*>(&_TabularCapture_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.TabularCapture.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class TabularCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.TabularCapture) */ {
 public:
  inline TabularCapture() : TabularCapture(nullptr) {}
  ~TabularCapture() override;
  explicit PROTOBUF_CONSTEXPR TabularCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabularCapture(const TabularCapture& from);
  TabularCapture(TabularCapture&& from) noexcept
    : TabularCapture() {
    *this = ::std::move(from);
  }

  inline TabularCapture& operator=(const TabularCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabularCapture& operator=(TabularCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TabularCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabularCapture* internal_default_instance() {
    return reinterpret_cast<const TabularCapture*>(
               &_TabularCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TabularCapture& a, TabularCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(TabularCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabularCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabularCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabularCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TabularCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TabularCapture& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TabularCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.TabularCapture";
  }
  protected:
  explicit TabularCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 11,
    kMethodParametersFieldNumber = 12,
    kTagsFieldNumber = 14,
    kOrgIdFieldNumber = 2,
    kRobotIdFieldNumber = 3,
    kPartIdFieldNumber = 4,
    kLocationIdFieldNumber = 5,
    kComponentNameFieldNumber = 6,
    kComponentTypeFieldNumber = 7,
    kComponentModelFieldNumber = 8,
    kMethodNameFieldNumber = 9,
    kBlobPathFieldNumber = 10,
    kFileIdFieldNumber = 13,
    kSessionIdFieldNumber = 17,
    kMimeTypeFieldNumber = 18,
    kIdFieldNumber = 19,
    kIntervalFieldNumber = 1,
    kFileSizeBytesFieldNumber = 16,
    kMessageCountFieldNumber = 15,
  };
  // repeated string column_names = 11 [json_name = "columnNames", (.tagger.v1.tags) = "bson:\"column_names\" json:\"column_names\""];
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // map<string, .google.protobuf.Any> method_parameters = 12 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 14 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
  void clear_blob_path();
  const std::string& blob_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob_path();
  PROTOBUF_NODISCARD std::string* release_blob_path();
  void set_allocated_blob_path(std::string* blob_path);
  private:
  const std::string& _internal_blob_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob_path(const std::string& value);
  std::string* _internal_mutable_blob_path();
  public:

  // string file_id = 13 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string session_id = 17 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string mime_type = 18 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::viam::app::datasync::v1::CaptureInterval& interval() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::CaptureInterval* release_interval();
  ::viam::app::datasync::v1::CaptureInterval* mutable_interval();
  void set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval);
  private:
  const ::viam::app::datasync::v1::CaptureInterval& _internal_interval() const;
  ::viam::app::datasync::v1::CaptureInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::viam::app::datasync::v1::CaptureInterval* interval);
  ::viam::app::datasync::v1::CaptureInterval* unsafe_arena_release_interval();

  // int64 file_size_bytes = 16 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
  void clear_file_size_bytes();
  int64_t file_size_bytes() const;
  void set_file_size_bytes(int64_t value);
  private:
  int64_t _internal_file_size_bytes() const;
  void _internal_set_file_size_bytes(int64_t value);
  public:

  // int32 message_count = 15 [json_name = "messageCount", (.tagger.v1.tags) = "bson:\"message_count\" json:\"message_count\""];
  void clear_message_count();
  int32_t message_count() const;
  void set_message_count(int32_t value);
  private:
  int32_t _internal_message_count() const;
  void _internal_set_message_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.TabularCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TabularCapture_MethodParametersEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::Any,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::viam::app::datasync::v1::CaptureInterval* interval_;
  int64_t file_size_bytes_;
  int32_t message_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// -------------------------------------------------------------------

class BinaryCapture_MethodParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BinaryCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BinaryCapture_MethodParametersEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BinaryCapture_MethodParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BinaryCapture_MethodParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BinaryCapture_MethodParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BinaryCapture_MethodParametersEntry_DoNotUse& other);
  static const BinaryCapture_MethodParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BinaryCapture_MethodParametersEntry_DoNotUse*>(&_BinaryCapture_MethodParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "viam.app.datasync.v1.BinaryCapture.MethodParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};

// -------------------------------------------------------------------

class BinaryCapture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.datasync.v1.BinaryCapture) */ {
 public:
  inline BinaryCapture() : BinaryCapture(nullptr) {}
  ~BinaryCapture() override;
  explicit PROTOBUF_CONSTEXPR BinaryCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryCapture(const BinaryCapture& from);
  BinaryCapture(BinaryCapture&& from) noexcept
    : BinaryCapture() {
    *this = ::std::move(from);
  }

  inline BinaryCapture& operator=(const BinaryCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryCapture& operator=(BinaryCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryCapture* internal_default_instance() {
    return reinterpret_cast<const BinaryCapture*>(
               &_BinaryCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BinaryCapture& a, BinaryCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryCapture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryCapture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BinaryCapture& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.datasync.v1.BinaryCapture";
  }
  protected:
  explicit BinaryCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMethodParametersFieldNumber = 11,
    kTagsFieldNumber = 13,
    kOrgIdFieldNumber = 2,
    kRobotIdFieldNumber = 3,
    kPartIdFieldNumber = 4,
    kLocationIdFieldNumber = 5,
    kComponentNameFieldNumber = 6,
    kComponentTypeFieldNumber = 7,
    kComponentModelFieldNumber = 8,
    kMethodNameFieldNumber = 9,
    kBlobPathFieldNumber = 10,
    kFileIdFieldNumber = 12,
    kSessionIdFieldNumber = 15,
    kMimeTypeFieldNumber = 16,
    kFileNameFieldNumber = 17,
    kFileExtFieldNumber = 18,
    kIdFieldNumber = 19,
    kIntervalFieldNumber = 1,
    kFileSizeBytesFieldNumber = 14,
  };
  // map<string, .google.protobuf.Any> method_parameters = 11 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
  int method_parameters_size() const;
  private:
  int _internal_method_parameters_size() const;
  public:
  void clear_method_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_method_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      method_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_method_parameters();

  // repeated string tags = 13 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
  void clear_component_name();
  const std::string& component_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_name();
  PROTOBUF_NODISCARD std::string* release_component_name();
  void set_allocated_component_name(std::string* component_name);
  private:
  const std::string& _internal_component_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_name(const std::string& value);
  std::string* _internal_mutable_component_name();
  public:

  // string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_NODISCARD std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
  void clear_component_model();
  const std::string& component_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_model();
  PROTOBUF_NODISCARD std::string* release_component_model();
  void set_allocated_component_model(std::string* component_model);
  private:
  const std::string& _internal_component_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_model(const std::string& value);
  std::string* _internal_mutable_component_model();
  public:

  // string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
  void clear_method_name();
  const std::string& method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
  void clear_blob_path();
  const std::string& blob_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob_path();
  PROTOBUF_NODISCARD std::string* release_blob_path();
  void set_allocated_blob_path(std::string* blob_path);
  private:
  const std::string& _internal_blob_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob_path(const std::string& value);
  std::string* _internal_mutable_blob_path();
  public:

  // string file_id = 12 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string session_id = 15 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string mime_type = 16 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string file_name = 17 [json_name = "fileName", (.tagger.v1.tags) = "bson:\"file_name\" json:\"file_name\""];
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string file_ext = 18 [json_name = "fileExt", (.tagger.v1.tags) = "bson:\"file_ext\" json:\"file_ext\""];
  void clear_file_ext();
  const std::string& file_ext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_ext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_ext();
  PROTOBUF_NODISCARD std::string* release_file_ext();
  void set_allocated_file_ext(std::string* file_ext);
  private:
  const std::string& _internal_file_ext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_ext(const std::string& value);
  std::string* _internal_mutable_file_ext();
  public:

  // string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::viam::app::datasync::v1::CaptureInterval& interval() const;
  PROTOBUF_NODISCARD ::viam::app::datasync::v1::CaptureInterval* release_interval();
  ::viam::app::datasync::v1::CaptureInterval* mutable_interval();
  void set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval);
  private:
  const ::viam::app::datasync::v1::CaptureInterval& _internal_interval() const;
  ::viam::app::datasync::v1::CaptureInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::viam::app::datasync::v1::CaptureInterval* interval);
  ::viam::app::datasync::v1::CaptureInterval* unsafe_arena_release_interval();

  // int64 file_size_bytes = 14 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
  void clear_file_size_bytes();
  int64_t file_size_bytes() const;
  void set_file_size_bytes(int64_t value);
  private:
  int64_t _internal_file_size_bytes() const;
  void _internal_set_file_size_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.datasync.v1.BinaryCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      BinaryCapture_MethodParametersEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::Any,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> method_parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_ext_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::viam::app::datasync::v1::CaptureInterval* interval_;
  int64_t file_size_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_app_2fdatasync_2fv1_2fdata_5fsync_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SensorMetadata

// .google.protobuf.Timestamp time_requested = 1 [json_name = "timeRequested"];
inline bool SensorMetadata::_internal_has_time_requested() const {
  return this != internal_default_instance() && time_requested_ != nullptr;
}
inline bool SensorMetadata::has_time_requested() const {
  return _internal_has_time_requested();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::_internal_time_requested() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = time_requested_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::time_requested() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorMetadata.time_requested)
  return _internal_time_requested();
}
inline void SensorMetadata::unsafe_arena_set_allocated_time_requested(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_requested_);
  }
  time_requested_ = time_requested;
  if (time_requested) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorMetadata.time_requested)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::release_time_requested() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_requested_;
  time_requested_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::unsafe_arena_release_time_requested() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorMetadata.time_requested)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_requested_;
  time_requested_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::_internal_mutable_time_requested() {
  
  if (time_requested_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    time_requested_ = p;
  }
  return time_requested_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::mutable_time_requested() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time_requested();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorMetadata.time_requested)
  return _msg;
}
inline void SensorMetadata::set_allocated_time_requested(::PROTOBUF_NAMESPACE_ID::Timestamp* time_requested) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_requested_);
  }
  if (time_requested) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_requested));
    if (message_arena != submessage_arena) {
      time_requested = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_requested, submessage_arena);
    }
    
  } else {
    
  }
  time_requested_ = time_requested;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorMetadata.time_requested)
}

// .google.protobuf.Timestamp time_received = 2 [json_name = "timeReceived"];
inline bool SensorMetadata::_internal_has_time_received() const {
  return this != internal_default_instance() && time_received_ != nullptr;
}
inline bool SensorMetadata::has_time_received() const {
  return _internal_has_time_received();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::_internal_time_received() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = time_received_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorMetadata::time_received() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorMetadata.time_received)
  return _internal_time_received();
}
inline void SensorMetadata::unsafe_arena_set_allocated_time_received(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_received) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_received_);
  }
  time_received_ = time_received;
  if (time_received) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorMetadata.time_received)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::release_time_received() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_received_;
  time_received_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::unsafe_arena_release_time_received() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorMetadata.time_received)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_received_;
  time_received_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::_internal_mutable_time_received() {
  
  if (time_received_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    time_received_ = p;
  }
  return time_received_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorMetadata::mutable_time_received() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time_received();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorMetadata.time_received)
  return _msg;
}
inline void SensorMetadata::set_allocated_time_received(::PROTOBUF_NAMESPACE_ID::Timestamp* time_received) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_received_);
  }
  if (time_received) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_received));
    if (message_arena != submessage_arena) {
      time_received = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_received, submessage_arena);
    }
    
  } else {
    
  }
  time_received_ = time_received;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorMetadata.time_received)
}

// -------------------------------------------------------------------

// SensorData

// .viam.app.datasync.v1.SensorMetadata metadata = 1 [json_name = "metadata"];
inline bool SensorData::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool SensorData::has_metadata() const {
  return _internal_has_metadata();
}
inline void SensorData::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::viam::app::datasync::v1::SensorMetadata& SensorData::_internal_metadata() const {
  const ::viam::app::datasync::v1::SensorMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::datasync::v1::SensorMetadata&>(
      ::viam::app::datasync::v1::_SensorMetadata_default_instance_);
}
inline const ::viam::app::datasync::v1::SensorMetadata& SensorData::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorData.metadata)
  return _internal_metadata();
}
inline void SensorData::unsafe_arena_set_allocated_metadata(
    ::viam::app::datasync::v1::SensorMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorData.metadata)
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::release_metadata() {
  
  ::viam::app::datasync::v1::SensorMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorData.metadata)
  
  ::viam::app::datasync::v1::SensorMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::datasync::v1::SensorMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::viam::app::datasync::v1::SensorMetadata* SensorData::mutable_metadata() {
  ::viam::app::datasync::v1::SensorMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorData.metadata)
  return _msg;
}
inline void SensorData::set_allocated_metadata(::viam::app::datasync::v1::SensorMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorData.metadata)
}

// .google.protobuf.Struct struct = 2 [json_name = "struct"];
inline bool SensorData::_internal_has_struct_() const {
  return data_case() == kStruct;
}
inline bool SensorData::has_struct_() const {
  return _internal_has_struct_();
}
inline void SensorData::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::release_struct_() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorData.struct)
  if (_internal_has_struct_()) {
    clear_has_data();
    ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_.struct__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& SensorData::_internal_struct_() const {
  return _internal_has_struct_()
      ? *data_.struct__
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Struct&>(::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& SensorData::struct_() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorData.struct)
  return _internal_struct_();
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.datasync.v1.SensorData.struct)
  if (_internal_has_struct_()) {
    clear_has_data();
    ::PROTOBUF_NAMESPACE_ID::Struct* temp = data_.struct__;
    data_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorData::unsafe_arena_set_allocated_struct_(::PROTOBUF_NAMESPACE_ID::Struct* struct_) {
  clear_data();
  if (struct_) {
    set_has_struct_();
    data_.struct__ = struct_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.SensorData.struct)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::_internal_mutable_struct_() {
  if (!_internal_has_struct_()) {
    clear_data();
    set_has_struct_();
    data_.struct__ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Struct >(GetArenaForAllocation());
  }
  return data_.struct__;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SensorData::mutable_struct_() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorData.struct)
  return _msg;
}

// bytes binary = 3 [json_name = "binary"];
inline bool SensorData::_internal_has_binary() const {
  return data_case() == kBinary;
}
inline bool SensorData::has_binary() const {
  return _internal_has_binary();
}
inline void SensorData::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void SensorData::clear_binary() {
  if (_internal_has_binary()) {
    data_.binary_.Destroy();
    clear_has_data();
  }
}
inline const std::string& SensorData::binary() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.SensorData.binary)
  return _internal_binary();
}
template <typename ArgT0, typename... ArgT>
inline void SensorData::set_binary(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    data_.binary_.InitDefault();
  }
  data_.binary_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.SensorData.binary)
}
inline std::string* SensorData::mutable_binary() {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.SensorData.binary)
  return _s;
}
inline const std::string& SensorData::_internal_binary() const {
  if (_internal_has_binary()) {
    return data_.binary_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SensorData::_internal_set_binary(const std::string& value) {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    data_.binary_.InitDefault();
  }
  data_.binary_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorData::_internal_mutable_binary() {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    data_.binary_.InitDefault();
  }
  return data_.binary_.Mutable(      GetArenaForAllocation());
}
inline std::string* SensorData::release_binary() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.SensorData.binary)
  if (_internal_has_binary()) {
    clear_has_data();
    return data_.binary_.Release();
  } else {
    return nullptr;
  }
}
inline void SensorData::set_allocated_binary(std::string* binary) {
  if (has_data()) {
    clear_data();
  }
  if (binary != nullptr) {
    set_has_binary();
    data_.binary_.InitAllocated(binary, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.SensorData.binary)
}

inline bool SensorData::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SensorData::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline SensorData::DataCase SensorData::data_case() const {
  return SensorData::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileData

// bytes data = 1 [json_name = "data"];
inline void FileData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& FileData::data() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.FileData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileData::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.FileData.data)
}
inline std::string* FileData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.FileData.data)
  return _s;
}
inline const std::string& FileData::_internal_data() const {
  return data_.Get();
}
inline void FileData::_internal_set_data(const std::string& value) {
  
  data_.Set(value, GetArenaForAllocation());
}
inline std::string* FileData::_internal_mutable_data() {
  
  return data_.Mutable(GetArenaForAllocation());
}
inline std::string* FileData::release_data() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.FileData.data)
  return data_.Release();
}
inline void FileData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault()) {
    data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.FileData.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UploadMetadata

// string part_id = 1 [json_name = "partId"];
inline void UploadMetadata::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& UploadMetadata::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.part_id)
}
inline std::string* UploadMetadata::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.part_id)
  return _s;
}
inline const std::string& UploadMetadata::_internal_part_id() const {
  return part_id_.Get();
}
inline void UploadMetadata::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.part_id)
  return part_id_.Release();
}
inline void UploadMetadata::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.part_id)
}

// string component_type = 2 [json_name = "componentType"];
inline void UploadMetadata::clear_component_type() {
  component_type_.ClearToEmpty();
}
inline const std::string& UploadMetadata::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.component_type)
}
inline std::string* UploadMetadata::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.component_type)
  return _s;
}
inline const std::string& UploadMetadata::_internal_component_type() const {
  return component_type_.Get();
}
inline void UploadMetadata::_internal_set_component_type(const std::string& value) {
  
  component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_component_type() {
  
  return component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.component_type)
  return component_type_.Release();
}
inline void UploadMetadata::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_type_.IsDefault()) {
    component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.component_type)
}

// string component_name = 3 [json_name = "componentName"];
inline void UploadMetadata::clear_component_name() {
  component_name_.ClearToEmpty();
}
inline const std::string& UploadMetadata::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.component_name)
}
inline std::string* UploadMetadata::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.component_name)
  return _s;
}
inline const std::string& UploadMetadata::_internal_component_name() const {
  return component_name_.Get();
}
inline void UploadMetadata::_internal_set_component_name(const std::string& value) {
  
  component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_component_name() {
  
  return component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.component_name)
  return component_name_.Release();
}
inline void UploadMetadata::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_name_.IsDefault()) {
    component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.component_name)
}

// string component_model = 4 [json_name = "componentModel"];
inline void UploadMetadata::clear_component_model() {
  component_model_.ClearToEmpty();
}
inline const std::string& UploadMetadata::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.component_model)
}
inline std::string* UploadMetadata::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.component_model)
  return _s;
}
inline const std::string& UploadMetadata::_internal_component_model() const {
  return component_model_.Get();
}
inline void UploadMetadata::_internal_set_component_model(const std::string& value) {
  
  component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_component_model() {
  
  return component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.component_model)
  return component_model_.Release();
}
inline void UploadMetadata::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_model_.IsDefault()) {
    component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.component_model)
}

// string method_name = 5 [json_name = "methodName"];
inline void UploadMetadata::clear_method_name() {
  method_name_.ClearToEmpty();
}
inline const std::string& UploadMetadata::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.method_name)
}
inline std::string* UploadMetadata::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.method_name)
  return _s;
}
inline const std::string& UploadMetadata::_internal_method_name() const {
  return method_name_.Get();
}
inline void UploadMetadata::_internal_set_method_name(const std::string& value) {
  
  method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_method_name() {
  
  return method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.method_name)
  return method_name_.Release();
}
inline void UploadMetadata::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_name_.IsDefault()) {
    method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.method_name)
}

// .viam.app.datasync.v1.DataType type = 6 [json_name = "type"];
inline void UploadMetadata::clear_type() {
  type_ = 0;
}
inline ::viam::app::datasync::v1::DataType UploadMetadata::_internal_type() const {
  return static_cast< ::viam::app::datasync::v1::DataType >(type_);
}
inline ::viam::app::datasync::v1::DataType UploadMetadata::type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.type)
  return _internal_type();
}
inline void UploadMetadata::_internal_set_type(::viam::app::datasync::v1::DataType value) {
  
  type_ = value;
}
inline void UploadMetadata::set_type(::viam::app::datasync::v1::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.type)
}

// string file_name = 7 [json_name = "fileName"];
inline void UploadMetadata::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& UploadMetadata::file_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.file_name)
}
inline std::string* UploadMetadata::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.file_name)
  return _s;
}
inline const std::string& UploadMetadata::_internal_file_name() const {
  return file_name_.Get();
}
inline void UploadMetadata::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_file_name() {
  
  return file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_file_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.file_name)
  return file_name_.Release();
}
inline void UploadMetadata::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault()) {
    file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.file_name)
}

// map<string, .google.protobuf.Any> method_parameters = 8 [json_name = "methodParameters"];
inline int UploadMetadata::_internal_method_parameters_size() const {
  return method_parameters_.size();
}
inline int UploadMetadata::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
UploadMetadata::_internal_method_parameters() const {
  return method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
UploadMetadata::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.UploadMetadata.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
UploadMetadata::_internal_mutable_method_parameters() {
  return method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
UploadMetadata::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.UploadMetadata.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_extension = 9 [json_name = "fileExtension"];
inline void UploadMetadata::clear_file_extension() {
  file_extension_.ClearToEmpty();
}
inline const std::string& UploadMetadata::file_extension() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.file_extension)
  return _internal_file_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_file_extension(ArgT0&& arg0, ArgT... args) {
 
 file_extension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.file_extension)
}
inline std::string* UploadMetadata::mutable_file_extension() {
  std::string* _s = _internal_mutable_file_extension();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.file_extension)
  return _s;
}
inline const std::string& UploadMetadata::_internal_file_extension() const {
  return file_extension_.Get();
}
inline void UploadMetadata::_internal_set_file_extension(const std::string& value) {
  
  file_extension_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_file_extension() {
  
  return file_extension_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_file_extension() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.file_extension)
  return file_extension_.Release();
}
inline void UploadMetadata::set_allocated_file_extension(std::string* file_extension) {
  if (file_extension != nullptr) {
    
  } else {
    
  }
  file_extension_.SetAllocated(file_extension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_extension_.IsDefault()) {
    file_extension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.file_extension)
}

// repeated string tags = 10 [json_name = "tags"];
inline int UploadMetadata::_internal_tags_size() const {
  return tags_.size();
}
inline int UploadMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void UploadMetadata::clear_tags() {
  tags_.Clear();
}
inline std::string* UploadMetadata::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.UploadMetadata.tags)
  return _s;
}
inline const std::string& UploadMetadata::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& UploadMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.tags)
  return _internal_tags(index);
}
inline std::string* UploadMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.tags)
  return tags_.Mutable(index);
}
inline void UploadMetadata::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.UploadMetadata.tags)
}
inline std::string* UploadMetadata::_internal_add_tags() {
  return tags_.Add();
}
inline void UploadMetadata::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.UploadMetadata.tags)
}
inline void UploadMetadata::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.UploadMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadMetadata::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.UploadMetadata.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.UploadMetadata.tags)
  return &tags_;
}

// string session_id = 11 [json_name = "sessionId"];
inline void UploadMetadata::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& UploadMetadata::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadMetadata.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadMetadata.session_id)
}
inline std::string* UploadMetadata::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadMetadata.session_id)
  return _s;
}
inline const std::string& UploadMetadata::_internal_session_id() const {
  return session_id_.Get();
}
inline void UploadMetadata::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_session_id() {
  
  return session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadMetadata.session_id)
  return session_id_.Release();
}
inline void UploadMetadata::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_id_.IsDefault()) {
    session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.UploadMetadata.session_id)
}

// -------------------------------------------------------------------

// UploadRequest

// .viam.app.datasync.v1.UploadMetadata metadata = 1 [json_name = "metadata"];
inline bool UploadRequest::_internal_has_metadata() const {
  return upload_packet_case() == kMetadata;
}
inline bool UploadRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void UploadRequest::set_has_metadata() {
  _oneof_case_[0] = kMetadata;
}
inline void UploadRequest::clear_metadata() {
  if (_internal_has_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete upload_packet_.metadata_;
    }
    clear_has_upload_packet();
  }
}
inline ::viam::app::datasync::v1::UploadMetadata* UploadRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadRequest.metadata)
  if (_internal_has_metadata()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::UploadMetadata* temp = upload_packet_.metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    upload_packet_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::datasync::v1::UploadMetadata& UploadRequest::_internal_metadata() const {
  return _internal_has_metadata()
      ? *upload_packet_.metadata_
      : reinterpret_cast< ::viam::app::datasync::v1::UploadMetadata&>(::viam::app::datasync::v1::_UploadMetadata_default_instance_);
}
inline const ::viam::app::datasync::v1::UploadMetadata& UploadRequest::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadRequest.metadata)
  return _internal_metadata();
}
inline ::viam::app::datasync::v1::UploadMetadata* UploadRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.datasync.v1.UploadRequest.metadata)
  if (_internal_has_metadata()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::UploadMetadata* temp = upload_packet_.metadata_;
    upload_packet_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UploadRequest::unsafe_arena_set_allocated_metadata(::viam::app::datasync::v1::UploadMetadata* metadata) {
  clear_upload_packet();
  if (metadata) {
    set_has_metadata();
    upload_packet_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.UploadRequest.metadata)
}
inline ::viam::app::datasync::v1::UploadMetadata* UploadRequest::_internal_mutable_metadata() {
  if (!_internal_has_metadata()) {
    clear_upload_packet();
    set_has_metadata();
    upload_packet_.metadata_ = CreateMaybeMessage< ::viam::app::datasync::v1::UploadMetadata >(GetArenaForAllocation());
  }
  return upload_packet_.metadata_;
}
inline ::viam::app::datasync::v1::UploadMetadata* UploadRequest::mutable_metadata() {
  ::viam::app::datasync::v1::UploadMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadRequest.metadata)
  return _msg;
}

// .viam.app.datasync.v1.SensorData sensor_contents = 2 [json_name = "sensorContents"];
inline bool UploadRequest::_internal_has_sensor_contents() const {
  return upload_packet_case() == kSensorContents;
}
inline bool UploadRequest::has_sensor_contents() const {
  return _internal_has_sensor_contents();
}
inline void UploadRequest::set_has_sensor_contents() {
  _oneof_case_[0] = kSensorContents;
}
inline void UploadRequest::clear_sensor_contents() {
  if (_internal_has_sensor_contents()) {
    if (GetArenaForAllocation() == nullptr) {
      delete upload_packet_.sensor_contents_;
    }
    clear_has_upload_packet();
  }
}
inline ::viam::app::datasync::v1::SensorData* UploadRequest::release_sensor_contents() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadRequest.sensor_contents)
  if (_internal_has_sensor_contents()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::SensorData* temp = upload_packet_.sensor_contents_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    upload_packet_.sensor_contents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::datasync::v1::SensorData& UploadRequest::_internal_sensor_contents() const {
  return _internal_has_sensor_contents()
      ? *upload_packet_.sensor_contents_
      : reinterpret_cast< ::viam::app::datasync::v1::SensorData&>(::viam::app::datasync::v1::_SensorData_default_instance_);
}
inline const ::viam::app::datasync::v1::SensorData& UploadRequest::sensor_contents() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadRequest.sensor_contents)
  return _internal_sensor_contents();
}
inline ::viam::app::datasync::v1::SensorData* UploadRequest::unsafe_arena_release_sensor_contents() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.datasync.v1.UploadRequest.sensor_contents)
  if (_internal_has_sensor_contents()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::SensorData* temp = upload_packet_.sensor_contents_;
    upload_packet_.sensor_contents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UploadRequest::unsafe_arena_set_allocated_sensor_contents(::viam::app::datasync::v1::SensorData* sensor_contents) {
  clear_upload_packet();
  if (sensor_contents) {
    set_has_sensor_contents();
    upload_packet_.sensor_contents_ = sensor_contents;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.UploadRequest.sensor_contents)
}
inline ::viam::app::datasync::v1::SensorData* UploadRequest::_internal_mutable_sensor_contents() {
  if (!_internal_has_sensor_contents()) {
    clear_upload_packet();
    set_has_sensor_contents();
    upload_packet_.sensor_contents_ = CreateMaybeMessage< ::viam::app::datasync::v1::SensorData >(GetArenaForAllocation());
  }
  return upload_packet_.sensor_contents_;
}
inline ::viam::app::datasync::v1::SensorData* UploadRequest::mutable_sensor_contents() {
  ::viam::app::datasync::v1::SensorData* _msg = _internal_mutable_sensor_contents();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadRequest.sensor_contents)
  return _msg;
}

// .viam.app.datasync.v1.FileData file_contents = 3 [json_name = "fileContents"];
inline bool UploadRequest::_internal_has_file_contents() const {
  return upload_packet_case() == kFileContents;
}
inline bool UploadRequest::has_file_contents() const {
  return _internal_has_file_contents();
}
inline void UploadRequest::set_has_file_contents() {
  _oneof_case_[0] = kFileContents;
}
inline void UploadRequest::clear_file_contents() {
  if (_internal_has_file_contents()) {
    if (GetArenaForAllocation() == nullptr) {
      delete upload_packet_.file_contents_;
    }
    clear_has_upload_packet();
  }
}
inline ::viam::app::datasync::v1::FileData* UploadRequest::release_file_contents() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.UploadRequest.file_contents)
  if (_internal_has_file_contents()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::FileData* temp = upload_packet_.file_contents_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    upload_packet_.file_contents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::viam::app::datasync::v1::FileData& UploadRequest::_internal_file_contents() const {
  return _internal_has_file_contents()
      ? *upload_packet_.file_contents_
      : reinterpret_cast< ::viam::app::datasync::v1::FileData&>(::viam::app::datasync::v1::_FileData_default_instance_);
}
inline const ::viam::app::datasync::v1::FileData& UploadRequest::file_contents() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadRequest.file_contents)
  return _internal_file_contents();
}
inline ::viam::app::datasync::v1::FileData* UploadRequest::unsafe_arena_release_file_contents() {
  // @@protoc_insertion_point(field_unsafe_arena_release:viam.app.datasync.v1.UploadRequest.file_contents)
  if (_internal_has_file_contents()) {
    clear_has_upload_packet();
    ::viam::app::datasync::v1::FileData* temp = upload_packet_.file_contents_;
    upload_packet_.file_contents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UploadRequest::unsafe_arena_set_allocated_file_contents(::viam::app::datasync::v1::FileData* file_contents) {
  clear_upload_packet();
  if (file_contents) {
    set_has_file_contents();
    upload_packet_.file_contents_ = file_contents;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.UploadRequest.file_contents)
}
inline ::viam::app::datasync::v1::FileData* UploadRequest::_internal_mutable_file_contents() {
  if (!_internal_has_file_contents()) {
    clear_upload_packet();
    set_has_file_contents();
    upload_packet_.file_contents_ = CreateMaybeMessage< ::viam::app::datasync::v1::FileData >(GetArenaForAllocation());
  }
  return upload_packet_.file_contents_;
}
inline ::viam::app::datasync::v1::FileData* UploadRequest::mutable_file_contents() {
  ::viam::app::datasync::v1::FileData* _msg = _internal_mutable_file_contents();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.UploadRequest.file_contents)
  return _msg;
}

inline bool UploadRequest::has_upload_packet() const {
  return upload_packet_case() != UPLOAD_PACKET_NOT_SET;
}
inline void UploadRequest::clear_has_upload_packet() {
  _oneof_case_[0] = UPLOAD_PACKET_NOT_SET;
}
inline UploadRequest::UploadPacketCase UploadRequest::upload_packet_case() const {
  return UploadRequest::UploadPacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UploadResponse

// int32 requests_written = 1 [json_name = "requestsWritten"];
inline void UploadResponse::clear_requests_written() {
  requests_written_ = 0;
}
inline int32_t UploadResponse::_internal_requests_written() const {
  return requests_written_;
}
inline int32_t UploadResponse::requests_written() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.UploadResponse.requests_written)
  return _internal_requests_written();
}
inline void UploadResponse::_internal_set_requests_written(int32_t value) {
  
  requests_written_ = value;
}
inline void UploadResponse::set_requests_written(int32_t value) {
  _internal_set_requests_written(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.UploadResponse.requests_written)
}

// -------------------------------------------------------------------

// CaptureInterval

// .google.protobuf.Timestamp start = 1 [json_name = "start"];
inline bool CaptureInterval::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool CaptureInterval::has_start() const {
  return _internal_has_start();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::_internal_start() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::start() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.CaptureInterval.start)
  return _internal_start();
}
inline void CaptureInterval::unsafe_arena_set_allocated_start(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.CaptureInterval.start)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::release_start() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.CaptureInterval.start)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::mutable_start() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.CaptureInterval.start)
  return _msg;
}
inline void CaptureInterval::set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.CaptureInterval.start)
}

// .google.protobuf.Timestamp end = 2 [json_name = "end"];
inline bool CaptureInterval::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool CaptureInterval::has_end() const {
  return _internal_has_end();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::_internal_end() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CaptureInterval::end() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.CaptureInterval.end)
  return _internal_end();
}
inline void CaptureInterval::unsafe_arena_set_allocated_end(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.CaptureInterval.end)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::release_end() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.CaptureInterval.end)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CaptureInterval::mutable_end() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.CaptureInterval.end)
  return _msg;
}
inline void CaptureInterval::set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.CaptureInterval.end)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataCaptureMetadata

// string component_type = 1 [json_name = "componentType"];
inline void DataCaptureMetadata::clear_component_type() {
  component_type_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.component_type)
}
inline std::string* DataCaptureMetadata::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.component_type)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_component_type() const {
  return component_type_.Get();
}
inline void DataCaptureMetadata::_internal_set_component_type(const std::string& value) {
  
  component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_component_type() {
  
  return component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.component_type)
  return component_type_.Release();
}
inline void DataCaptureMetadata::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_type_.IsDefault()) {
    component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.component_type)
}

// string component_name = 2 [json_name = "componentName"];
inline void DataCaptureMetadata::clear_component_name() {
  component_name_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.component_name)
}
inline std::string* DataCaptureMetadata::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.component_name)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_component_name() const {
  return component_name_.Get();
}
inline void DataCaptureMetadata::_internal_set_component_name(const std::string& value) {
  
  component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_component_name() {
  
  return component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.component_name)
  return component_name_.Release();
}
inline void DataCaptureMetadata::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_name_.IsDefault()) {
    component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.component_name)
}

// string component_model = 3 [json_name = "componentModel"];
inline void DataCaptureMetadata::clear_component_model() {
  component_model_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.component_model)
}
inline std::string* DataCaptureMetadata::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.component_model)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_component_model() const {
  return component_model_.Get();
}
inline void DataCaptureMetadata::_internal_set_component_model(const std::string& value) {
  
  component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_component_model() {
  
  return component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.component_model)
  return component_model_.Release();
}
inline void DataCaptureMetadata::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_model_.IsDefault()) {
    component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.component_model)
}

// string method_name = 4 [json_name = "methodName"];
inline void DataCaptureMetadata::clear_method_name() {
  method_name_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.method_name)
}
inline std::string* DataCaptureMetadata::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.method_name)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_method_name() const {
  return method_name_.Get();
}
inline void DataCaptureMetadata::_internal_set_method_name(const std::string& value) {
  
  method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_method_name() {
  
  return method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.method_name)
  return method_name_.Release();
}
inline void DataCaptureMetadata::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_name_.IsDefault()) {
    method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.method_name)
}

// .viam.app.datasync.v1.DataType type = 5 [json_name = "type"];
inline void DataCaptureMetadata::clear_type() {
  type_ = 0;
}
inline ::viam::app::datasync::v1::DataType DataCaptureMetadata::_internal_type() const {
  return static_cast< ::viam::app::datasync::v1::DataType >(type_);
}
inline ::viam::app::datasync::v1::DataType DataCaptureMetadata::type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.type)
  return _internal_type();
}
inline void DataCaptureMetadata::_internal_set_type(::viam::app::datasync::v1::DataType value) {
  
  type_ = value;
}
inline void DataCaptureMetadata::set_type(::viam::app::datasync::v1::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.type)
}

// map<string, .google.protobuf.Any> method_parameters = 6 [json_name = "methodParameters"];
inline int DataCaptureMetadata::_internal_method_parameters_size() const {
  return method_parameters_.size();
}
inline int DataCaptureMetadata::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
DataCaptureMetadata::_internal_method_parameters() const {
  return method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
DataCaptureMetadata::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.DataCaptureMetadata.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
DataCaptureMetadata::_internal_mutable_method_parameters() {
  return method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
DataCaptureMetadata::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.DataCaptureMetadata.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_extension = 7 [json_name = "fileExtension"];
inline void DataCaptureMetadata::clear_file_extension() {
  file_extension_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::file_extension() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
  return _internal_file_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_file_extension(ArgT0&& arg0, ArgT... args) {
 
 file_extension_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
}
inline std::string* DataCaptureMetadata::mutable_file_extension() {
  std::string* _s = _internal_mutable_file_extension();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_file_extension() const {
  return file_extension_.Get();
}
inline void DataCaptureMetadata::_internal_set_file_extension(const std::string& value) {
  
  file_extension_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_file_extension() {
  
  return file_extension_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_file_extension() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
  return file_extension_.Release();
}
inline void DataCaptureMetadata::set_allocated_file_extension(std::string* file_extension) {
  if (file_extension != nullptr) {
    
  } else {
    
  }
  file_extension_.SetAllocated(file_extension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_extension_.IsDefault()) {
    file_extension_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.file_extension)
}

// repeated string tags = 8 [json_name = "tags"];
inline int DataCaptureMetadata::_internal_tags_size() const {
  return tags_.size();
}
inline int DataCaptureMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void DataCaptureMetadata::clear_tags() {
  tags_.Clear();
}
inline std::string* DataCaptureMetadata::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& DataCaptureMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return _internal_tags(index);
}
inline std::string* DataCaptureMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return tags_.Mutable(index);
}
inline void DataCaptureMetadata::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline std::string* DataCaptureMetadata::_internal_add_tags() {
  return tags_.Add();
}
inline void DataCaptureMetadata::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline void DataCaptureMetadata::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.DataCaptureMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataCaptureMetadata::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataCaptureMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.DataCaptureMetadata.tags)
  return &tags_;
}

// string session_id = 9 [json_name = "sessionId"];
inline void DataCaptureMetadata::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& DataCaptureMetadata::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.DataCaptureMetadata.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataCaptureMetadata::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.DataCaptureMetadata.session_id)
}
inline std::string* DataCaptureMetadata::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.DataCaptureMetadata.session_id)
  return _s;
}
inline const std::string& DataCaptureMetadata::_internal_session_id() const {
  return session_id_.Get();
}
inline void DataCaptureMetadata::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::_internal_mutable_session_id() {
  
  return session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataCaptureMetadata::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.DataCaptureMetadata.session_id)
  return session_id_.Release();
}
inline void DataCaptureMetadata::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_id_.IsDefault()) {
    session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.DataCaptureMetadata.session_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TabularCapture

// .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
inline bool TabularCapture::_internal_has_interval() const {
  return this != internal_default_instance() && interval_ != nullptr;
}
inline bool TabularCapture::has_interval() const {
  return _internal_has_interval();
}
inline void TabularCapture::clear_interval() {
  if (GetArenaForAllocation() == nullptr && interval_ != nullptr) {
    delete interval_;
  }
  interval_ = nullptr;
}
inline const ::viam::app::datasync::v1::CaptureInterval& TabularCapture::_internal_interval() const {
  const ::viam::app::datasync::v1::CaptureInterval* p = interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::datasync::v1::CaptureInterval&>(
      ::viam::app::datasync::v1::_CaptureInterval_default_instance_);
}
inline const ::viam::app::datasync::v1::CaptureInterval& TabularCapture::interval() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.interval)
  return _internal_interval();
}
inline void TabularCapture::unsafe_arena_set_allocated_interval(
    ::viam::app::datasync::v1::CaptureInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval_);
  }
  interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.TabularCapture.interval)
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::release_interval() {
  
  ::viam::app::datasync::v1::CaptureInterval* temp = interval_;
  interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.interval)
  
  ::viam::app::datasync::v1::CaptureInterval* temp = interval_;
  interval_ = nullptr;
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::_internal_mutable_interval() {
  
  if (interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::datasync::v1::CaptureInterval>(GetArenaForAllocation());
    interval_ = p;
  }
  return interval_;
}
inline ::viam::app::datasync::v1::CaptureInterval* TabularCapture::mutable_interval() {
  ::viam::app::datasync::v1::CaptureInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.interval)
  return _msg;
}
inline void TabularCapture::set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete interval_;
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interval);
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.interval)
}

// string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
inline void TabularCapture::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.org_id)
}
inline std::string* TabularCapture::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.org_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_org_id() const {
  return org_id_.Get();
}
inline void TabularCapture::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.org_id)
  return org_id_.Release();
}
inline void TabularCapture::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.org_id)
}

// string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
inline void TabularCapture::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.robot_id)
}
inline std::string* TabularCapture::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.robot_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void TabularCapture::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.robot_id)
  return robot_id_.Release();
}
inline void TabularCapture::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.robot_id)
}

// string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
inline void TabularCapture::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.part_id)
}
inline std::string* TabularCapture::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.part_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_part_id() const {
  return part_id_.Get();
}
inline void TabularCapture::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.part_id)
  return part_id_.Release();
}
inline void TabularCapture::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.part_id)
}

// string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
inline void TabularCapture::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.location_id)
}
inline std::string* TabularCapture::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.location_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_location_id() const {
  return location_id_.Get();
}
inline void TabularCapture::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.location_id)
  return location_id_.Release();
}
inline void TabularCapture::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.location_id)
}

// string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
inline void TabularCapture::clear_component_name() {
  component_name_.ClearToEmpty();
}
inline const std::string& TabularCapture::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.component_name)
}
inline std::string* TabularCapture::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.component_name)
  return _s;
}
inline const std::string& TabularCapture::_internal_component_name() const {
  return component_name_.Get();
}
inline void TabularCapture::_internal_set_component_name(const std::string& value) {
  
  component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_component_name() {
  
  return component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.component_name)
  return component_name_.Release();
}
inline void TabularCapture::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_name_.IsDefault()) {
    component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.component_name)
}

// string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
inline void TabularCapture::clear_component_type() {
  component_type_.ClearToEmpty();
}
inline const std::string& TabularCapture::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.component_type)
}
inline std::string* TabularCapture::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.component_type)
  return _s;
}
inline const std::string& TabularCapture::_internal_component_type() const {
  return component_type_.Get();
}
inline void TabularCapture::_internal_set_component_type(const std::string& value) {
  
  component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_component_type() {
  
  return component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.component_type)
  return component_type_.Release();
}
inline void TabularCapture::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_type_.IsDefault()) {
    component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.component_type)
}

// string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
inline void TabularCapture::clear_component_model() {
  component_model_.ClearToEmpty();
}
inline const std::string& TabularCapture::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.component_model)
}
inline std::string* TabularCapture::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.component_model)
  return _s;
}
inline const std::string& TabularCapture::_internal_component_model() const {
  return component_model_.Get();
}
inline void TabularCapture::_internal_set_component_model(const std::string& value) {
  
  component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_component_model() {
  
  return component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.component_model)
  return component_model_.Release();
}
inline void TabularCapture::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_model_.IsDefault()) {
    component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.component_model)
}

// string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
inline void TabularCapture::clear_method_name() {
  method_name_.ClearToEmpty();
}
inline const std::string& TabularCapture::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.method_name)
}
inline std::string* TabularCapture::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.method_name)
  return _s;
}
inline const std::string& TabularCapture::_internal_method_name() const {
  return method_name_.Get();
}
inline void TabularCapture::_internal_set_method_name(const std::string& value) {
  
  method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_method_name() {
  
  return method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.method_name)
  return method_name_.Release();
}
inline void TabularCapture::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_name_.IsDefault()) {
    method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.method_name)
}

// string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
inline void TabularCapture::clear_blob_path() {
  blob_path_.ClearToEmpty();
}
inline const std::string& TabularCapture::blob_path() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.blob_path)
  return _internal_blob_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_blob_path(ArgT0&& arg0, ArgT... args) {
 
 blob_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.blob_path)
}
inline std::string* TabularCapture::mutable_blob_path() {
  std::string* _s = _internal_mutable_blob_path();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.blob_path)
  return _s;
}
inline const std::string& TabularCapture::_internal_blob_path() const {
  return blob_path_.Get();
}
inline void TabularCapture::_internal_set_blob_path(const std::string& value) {
  
  blob_path_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_blob_path() {
  
  return blob_path_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_blob_path() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.blob_path)
  return blob_path_.Release();
}
inline void TabularCapture::set_allocated_blob_path(std::string* blob_path) {
  if (blob_path != nullptr) {
    
  } else {
    
  }
  blob_path_.SetAllocated(blob_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blob_path_.IsDefault()) {
    blob_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.blob_path)
}

// repeated string column_names = 11 [json_name = "columnNames", (.tagger.v1.tags) = "bson:\"column_names\" json:\"column_names\""];
inline int TabularCapture::_internal_column_names_size() const {
  return column_names_.size();
}
inline int TabularCapture::column_names_size() const {
  return _internal_column_names_size();
}
inline void TabularCapture::clear_column_names() {
  column_names_.Clear();
}
inline std::string* TabularCapture::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.TabularCapture.column_names)
  return _s;
}
inline const std::string& TabularCapture::_internal_column_names(int index) const {
  return column_names_.Get(index);
}
inline const std::string& TabularCapture::column_names(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.column_names)
  return _internal_column_names(index);
}
inline std::string* TabularCapture::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.column_names)
  return column_names_.Mutable(index);
}
inline void TabularCapture::set_column_names(int index, const std::string& value) {
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::set_column_names(int index, std::string&& value) {
  column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::set_column_names(int index, const char* value, size_t size) {
  column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.TabularCapture.column_names)
}
inline std::string* TabularCapture::_internal_add_column_names() {
  return column_names_.Add();
}
inline void TabularCapture::add_column_names(const std::string& value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::add_column_names(std::string&& value) {
  column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.TabularCapture.column_names)
}
inline void TabularCapture::add_column_names(const char* value, size_t size) {
  column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.TabularCapture.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TabularCapture::column_names() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.TabularCapture.column_names)
  return column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TabularCapture::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.TabularCapture.column_names)
  return &column_names_;
}

// map<string, .google.protobuf.Any> method_parameters = 12 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
inline int TabularCapture::_internal_method_parameters_size() const {
  return method_parameters_.size();
}
inline int TabularCapture::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
TabularCapture::_internal_method_parameters() const {
  return method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
TabularCapture::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.TabularCapture.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
TabularCapture::_internal_mutable_method_parameters() {
  return method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
TabularCapture::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.TabularCapture.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_id = 13 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
inline void TabularCapture::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::file_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.file_id)
}
inline std::string* TabularCapture::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.file_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_file_id() const {
  return file_id_.Get();
}
inline void TabularCapture::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_file_id() {
  
  return file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_file_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.file_id)
  return file_id_.Release();
}
inline void TabularCapture::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.file_id)
}

// repeated string tags = 14 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
inline int TabularCapture::_internal_tags_size() const {
  return tags_.size();
}
inline int TabularCapture::tags_size() const {
  return _internal_tags_size();
}
inline void TabularCapture::clear_tags() {
  tags_.Clear();
}
inline std::string* TabularCapture::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.TabularCapture.tags)
  return _s;
}
inline const std::string& TabularCapture::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& TabularCapture::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.tags)
  return _internal_tags(index);
}
inline std::string* TabularCapture::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.tags)
  return tags_.Mutable(index);
}
inline void TabularCapture::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.TabularCapture.tags)
}
inline std::string* TabularCapture::_internal_add_tags() {
  return tags_.Add();
}
inline void TabularCapture::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.TabularCapture.tags)
}
inline void TabularCapture::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.TabularCapture.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TabularCapture::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.TabularCapture.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TabularCapture::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.TabularCapture.tags)
  return &tags_;
}

// int32 message_count = 15 [json_name = "messageCount", (.tagger.v1.tags) = "bson:\"message_count\" json:\"message_count\""];
inline void TabularCapture::clear_message_count() {
  message_count_ = 0;
}
inline int32_t TabularCapture::_internal_message_count() const {
  return message_count_;
}
inline int32_t TabularCapture::message_count() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.message_count)
  return _internal_message_count();
}
inline void TabularCapture::_internal_set_message_count(int32_t value) {
  
  message_count_ = value;
}
inline void TabularCapture::set_message_count(int32_t value) {
  _internal_set_message_count(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.message_count)
}

// int64 file_size_bytes = 16 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
inline void TabularCapture::clear_file_size_bytes() {
  file_size_bytes_ = int64_t{0};
}
inline int64_t TabularCapture::_internal_file_size_bytes() const {
  return file_size_bytes_;
}
inline int64_t TabularCapture::file_size_bytes() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.file_size_bytes)
  return _internal_file_size_bytes();
}
inline void TabularCapture::_internal_set_file_size_bytes(int64_t value) {
  
  file_size_bytes_ = value;
}
inline void TabularCapture::set_file_size_bytes(int64_t value) {
  _internal_set_file_size_bytes(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.file_size_bytes)
}

// string session_id = 17 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
inline void TabularCapture::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& TabularCapture::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.session_id)
}
inline std::string* TabularCapture::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.session_id)
  return _s;
}
inline const std::string& TabularCapture::_internal_session_id() const {
  return session_id_.Get();
}
inline void TabularCapture::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_session_id() {
  
  return session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.session_id)
  return session_id_.Release();
}
inline void TabularCapture::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_id_.IsDefault()) {
    session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.session_id)
}

// string mime_type = 18 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
inline void TabularCapture::clear_mime_type() {
  mime_type_.ClearToEmpty();
}
inline const std::string& TabularCapture::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.mime_type)
}
inline std::string* TabularCapture::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.mime_type)
  return _s;
}
inline const std::string& TabularCapture::_internal_mime_type() const {
  return mime_type_.Get();
}
inline void TabularCapture::_internal_set_mime_type(const std::string& value) {
  
  mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_mime_type() {
  
  return mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.mime_type)
  return mime_type_.Release();
}
inline void TabularCapture::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault()) {
    mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.mime_type)
}

// string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void TabularCapture::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TabularCapture::id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.TabularCapture.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabularCapture::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.TabularCapture.id)
}
inline std::string* TabularCapture::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.TabularCapture.id)
  return _s;
}
inline const std::string& TabularCapture::_internal_id() const {
  return id_.Get();
}
inline void TabularCapture::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabularCapture::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabularCapture::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.TabularCapture.id)
  return id_.Release();
}
inline void TabularCapture::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.TabularCapture.id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BinaryCapture

// .viam.app.datasync.v1.CaptureInterval interval = 1 [json_name = "interval", (.tagger.v1.tags) = "bson:\"interval\" json:\"interval\""];
inline bool BinaryCapture::_internal_has_interval() const {
  return this != internal_default_instance() && interval_ != nullptr;
}
inline bool BinaryCapture::has_interval() const {
  return _internal_has_interval();
}
inline void BinaryCapture::clear_interval() {
  if (GetArenaForAllocation() == nullptr && interval_ != nullptr) {
    delete interval_;
  }
  interval_ = nullptr;
}
inline const ::viam::app::datasync::v1::CaptureInterval& BinaryCapture::_internal_interval() const {
  const ::viam::app::datasync::v1::CaptureInterval* p = interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::datasync::v1::CaptureInterval&>(
      ::viam::app::datasync::v1::_CaptureInterval_default_instance_);
}
inline const ::viam::app::datasync::v1::CaptureInterval& BinaryCapture::interval() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.interval)
  return _internal_interval();
}
inline void BinaryCapture::unsafe_arena_set_allocated_interval(
    ::viam::app::datasync::v1::CaptureInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval_);
  }
  interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.datasync.v1.BinaryCapture.interval)
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::release_interval() {
  
  ::viam::app::datasync::v1::CaptureInterval* temp = interval_;
  interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.interval)
  
  ::viam::app::datasync::v1::CaptureInterval* temp = interval_;
  interval_ = nullptr;
  return temp;
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::_internal_mutable_interval() {
  
  if (interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::datasync::v1::CaptureInterval>(GetArenaForAllocation());
    interval_ = p;
  }
  return interval_;
}
inline ::viam::app::datasync::v1::CaptureInterval* BinaryCapture::mutable_interval() {
  ::viam::app::datasync::v1::CaptureInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.interval)
  return _msg;
}
inline void BinaryCapture::set_allocated_interval(::viam::app::datasync::v1::CaptureInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete interval_;
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interval);
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.interval)
}

// string org_id = 2 [json_name = "orgId", (.tagger.v1.tags) = "bson:\"org_id\" json:\"org_id\""];
inline void BinaryCapture::clear_org_id() {
  org_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::org_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_org_id(ArgT0&& arg0, ArgT... args) {
 
 org_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.org_id)
}
inline std::string* BinaryCapture::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.org_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_org_id() const {
  return org_id_.Get();
}
inline void BinaryCapture::_internal_set_org_id(const std::string& value) {
  
  org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_org_id() {
  
  return org_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_org_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.org_id)
  return org_id_.Release();
}
inline void BinaryCapture::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    
  } else {
    
  }
  org_id_.SetAllocated(org_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault()) {
    org_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.org_id)
}

// string robot_id = 3 [json_name = "robotId", (.tagger.v1.tags) = "bson:\"robot_id\" json:\"robot_id\""];
inline void BinaryCapture::clear_robot_id() {
  robot_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.robot_id)
}
inline std::string* BinaryCapture::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.robot_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_robot_id() const {
  return robot_id_.Get();
}
inline void BinaryCapture::_internal_set_robot_id(const std::string& value) {
  
  robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_robot_id() {
  
  return robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.robot_id)
  return robot_id_.Release();
}
inline void BinaryCapture::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robot_id_.IsDefault()) {
    robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.robot_id)
}

// string part_id = 4 [json_name = "partId", (.tagger.v1.tags) = "bson:\"part_id\" json:\"part_id\""];
inline void BinaryCapture::clear_part_id() {
  part_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.part_id)
}
inline std::string* BinaryCapture::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.part_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_part_id() const {
  return part_id_.Get();
}
inline void BinaryCapture::_internal_set_part_id(const std::string& value) {
  
  part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_part_id() {
  
  return part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.part_id)
  return part_id_.Release();
}
inline void BinaryCapture::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_id_.IsDefault()) {
    part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.part_id)
}

// string location_id = 5 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"location_id\""];
inline void BinaryCapture::clear_location_id() {
  location_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.location_id)
}
inline std::string* BinaryCapture::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.location_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_location_id() const {
  return location_id_.Get();
}
inline void BinaryCapture::_internal_set_location_id(const std::string& value) {
  
  location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_location_id() {
  
  return location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.location_id)
  return location_id_.Release();
}
inline void BinaryCapture::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_id_.IsDefault()) {
    location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.location_id)
}

// string component_name = 6 [json_name = "componentName", (.tagger.v1.tags) = "bson:\"component_name\" json:\"component_name\""];
inline void BinaryCapture::clear_component_name() {
  component_name_.ClearToEmpty();
}
inline const std::string& BinaryCapture::component_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.component_name)
  return _internal_component_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_component_name(ArgT0&& arg0, ArgT... args) {
 
 component_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.component_name)
}
inline std::string* BinaryCapture::mutable_component_name() {
  std::string* _s = _internal_mutable_component_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.component_name)
  return _s;
}
inline const std::string& BinaryCapture::_internal_component_name() const {
  return component_name_.Get();
}
inline void BinaryCapture::_internal_set_component_name(const std::string& value) {
  
  component_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_component_name() {
  
  return component_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_component_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.component_name)
  return component_name_.Release();
}
inline void BinaryCapture::set_allocated_component_name(std::string* component_name) {
  if (component_name != nullptr) {
    
  } else {
    
  }
  component_name_.SetAllocated(component_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_name_.IsDefault()) {
    component_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.component_name)
}

// string component_type = 7 [json_name = "componentType", (.tagger.v1.tags) = "bson:\"component_type\" json:\"component_type\""];
inline void BinaryCapture::clear_component_type() {
  component_type_.ClearToEmpty();
}
inline const std::string& BinaryCapture::component_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 component_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.component_type)
}
inline std::string* BinaryCapture::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.component_type)
  return _s;
}
inline const std::string& BinaryCapture::_internal_component_type() const {
  return component_type_.Get();
}
inline void BinaryCapture::_internal_set_component_type(const std::string& value) {
  
  component_type_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_component_type() {
  
  return component_type_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_component_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.component_type)
  return component_type_.Release();
}
inline void BinaryCapture::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  component_type_.SetAllocated(component_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_type_.IsDefault()) {
    component_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.component_type)
}

// string component_model = 8 [json_name = "componentModel", (.tagger.v1.tags) = "bson:\"component_model\" json:\"component_model\""];
inline void BinaryCapture::clear_component_model() {
  component_model_.ClearToEmpty();
}
inline const std::string& BinaryCapture::component_model() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.component_model)
  return _internal_component_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_component_model(ArgT0&& arg0, ArgT... args) {
 
 component_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.component_model)
}
inline std::string* BinaryCapture::mutable_component_model() {
  std::string* _s = _internal_mutable_component_model();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.component_model)
  return _s;
}
inline const std::string& BinaryCapture::_internal_component_model() const {
  return component_model_.Get();
}
inline void BinaryCapture::_internal_set_component_model(const std::string& value) {
  
  component_model_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_component_model() {
  
  return component_model_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_component_model() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.component_model)
  return component_model_.Release();
}
inline void BinaryCapture::set_allocated_component_model(std::string* component_model) {
  if (component_model != nullptr) {
    
  } else {
    
  }
  component_model_.SetAllocated(component_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (component_model_.IsDefault()) {
    component_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.component_model)
}

// string method_name = 9 [json_name = "methodName", (.tagger.v1.tags) = "bson:\"method_name\" json:\"method_name\""];
inline void BinaryCapture::clear_method_name() {
  method_name_.ClearToEmpty();
}
inline const std::string& BinaryCapture::method_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.method_name)
  return _internal_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_method_name(ArgT0&& arg0, ArgT... args) {
 
 method_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.method_name)
}
inline std::string* BinaryCapture::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.method_name)
  return _s;
}
inline const std::string& BinaryCapture::_internal_method_name() const {
  return method_name_.Get();
}
inline void BinaryCapture::_internal_set_method_name(const std::string& value) {
  
  method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_method_name() {
  
  return method_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_method_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.method_name)
  return method_name_.Release();
}
inline void BinaryCapture::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  method_name_.SetAllocated(method_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_name_.IsDefault()) {
    method_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.method_name)
}

// string blob_path = 10 [json_name = "blobPath", (.tagger.v1.tags) = "bson:\"blob_path\" json:\"blob_path\""];
inline void BinaryCapture::clear_blob_path() {
  blob_path_.ClearToEmpty();
}
inline const std::string& BinaryCapture::blob_path() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.blob_path)
  return _internal_blob_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_blob_path(ArgT0&& arg0, ArgT... args) {
 
 blob_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.blob_path)
}
inline std::string* BinaryCapture::mutable_blob_path() {
  std::string* _s = _internal_mutable_blob_path();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.blob_path)
  return _s;
}
inline const std::string& BinaryCapture::_internal_blob_path() const {
  return blob_path_.Get();
}
inline void BinaryCapture::_internal_set_blob_path(const std::string& value) {
  
  blob_path_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_blob_path() {
  
  return blob_path_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_blob_path() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.blob_path)
  return blob_path_.Release();
}
inline void BinaryCapture::set_allocated_blob_path(std::string* blob_path) {
  if (blob_path != nullptr) {
    
  } else {
    
  }
  blob_path_.SetAllocated(blob_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blob_path_.IsDefault()) {
    blob_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.blob_path)
}

// map<string, .google.protobuf.Any> method_parameters = 11 [json_name = "methodParameters", (.tagger.v1.tags) = "bson:\"method_parameters\" json:\"method_parameters\""];
inline int BinaryCapture::_internal_method_parameters_size() const {
  return method_parameters_.size();
}
inline int BinaryCapture::method_parameters_size() const {
  return _internal_method_parameters_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
BinaryCapture::_internal_method_parameters() const {
  return method_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
BinaryCapture::method_parameters() const {
  // @@protoc_insertion_point(field_map:viam.app.datasync.v1.BinaryCapture.method_parameters)
  return _internal_method_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
BinaryCapture::_internal_mutable_method_parameters() {
  return method_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
BinaryCapture::mutable_method_parameters() {
  // @@protoc_insertion_point(field_mutable_map:viam.app.datasync.v1.BinaryCapture.method_parameters)
  return _internal_mutable_method_parameters();
}

// string file_id = 12 [json_name = "fileId", (.tagger.v1.tags) = "bson:\"file_id\" json:\"file_id\""];
inline void BinaryCapture::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::file_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_id)
}
inline std::string* BinaryCapture::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.file_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_file_id() const {
  return file_id_.Get();
}
inline void BinaryCapture::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_file_id() {
  
  return file_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_file_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.file_id)
  return file_id_.Release();
}
inline void BinaryCapture::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(file_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault()) {
    file_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.file_id)
}

// repeated string tags = 13 [json_name = "tags", (.tagger.v1.tags) = "bson:\"tags\" json:\"tags\""];
inline int BinaryCapture::_internal_tags_size() const {
  return tags_.size();
}
inline int BinaryCapture::tags_size() const {
  return _internal_tags_size();
}
inline void BinaryCapture::clear_tags() {
  tags_.Clear();
}
inline std::string* BinaryCapture::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.datasync.v1.BinaryCapture.tags)
  return _s;
}
inline const std::string& BinaryCapture::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& BinaryCapture::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.tags)
  return _internal_tags(index);
}
inline std::string* BinaryCapture::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.tags)
  return tags_.Mutable(index);
}
inline void BinaryCapture::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.datasync.v1.BinaryCapture.tags)
}
inline std::string* BinaryCapture::_internal_add_tags() {
  return tags_.Add();
}
inline void BinaryCapture::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.datasync.v1.BinaryCapture.tags)
}
inline void BinaryCapture::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.datasync.v1.BinaryCapture.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BinaryCapture::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.datasync.v1.BinaryCapture.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BinaryCapture::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.datasync.v1.BinaryCapture.tags)
  return &tags_;
}

// int64 file_size_bytes = 14 [json_name = "fileSizeBytes", (.tagger.v1.tags) = "bson:\"file_size_bytes\" json:\"file_size_bytes\""];
inline void BinaryCapture::clear_file_size_bytes() {
  file_size_bytes_ = int64_t{0};
}
inline int64_t BinaryCapture::_internal_file_size_bytes() const {
  return file_size_bytes_;
}
inline int64_t BinaryCapture::file_size_bytes() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_size_bytes)
  return _internal_file_size_bytes();
}
inline void BinaryCapture::_internal_set_file_size_bytes(int64_t value) {
  
  file_size_bytes_ = value;
}
inline void BinaryCapture::set_file_size_bytes(int64_t value) {
  _internal_set_file_size_bytes(value);
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_size_bytes)
}

// string session_id = 15 [json_name = "sessionId", (.tagger.v1.tags) = "bson:\"session_id\" json:\"session_id\""];
inline void BinaryCapture::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::session_id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.session_id)
}
inline std::string* BinaryCapture::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.session_id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_session_id() const {
  return session_id_.Get();
}
inline void BinaryCapture::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_session_id() {
  
  return session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.session_id)
  return session_id_.Release();
}
inline void BinaryCapture::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_id_.IsDefault()) {
    session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.session_id)
}

// string mime_type = 16 [json_name = "mimeType", (.tagger.v1.tags) = "bson:\"mime_type\" json:\"mime_type\""];
inline void BinaryCapture::clear_mime_type() {
  mime_type_.ClearToEmpty();
}
inline const std::string& BinaryCapture::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.mime_type)
}
inline std::string* BinaryCapture::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.mime_type)
  return _s;
}
inline const std::string& BinaryCapture::_internal_mime_type() const {
  return mime_type_.Get();
}
inline void BinaryCapture::_internal_set_mime_type(const std::string& value) {
  
  mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_mime_type() {
  
  return mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.mime_type)
  return mime_type_.Release();
}
inline void BinaryCapture::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault()) {
    mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.mime_type)
}

// string file_name = 17 [json_name = "fileName", (.tagger.v1.tags) = "bson:\"file_name\" json:\"file_name\""];
inline void BinaryCapture::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& BinaryCapture::file_name() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_name)
}
inline std::string* BinaryCapture::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.file_name)
  return _s;
}
inline const std::string& BinaryCapture::_internal_file_name() const {
  return file_name_.Get();
}
inline void BinaryCapture::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_file_name() {
  
  return file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_file_name() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.file_name)
  return file_name_.Release();
}
inline void BinaryCapture::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault()) {
    file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.file_name)
}

// string file_ext = 18 [json_name = "fileExt", (.tagger.v1.tags) = "bson:\"file_ext\" json:\"file_ext\""];
inline void BinaryCapture::clear_file_ext() {
  file_ext_.ClearToEmpty();
}
inline const std::string& BinaryCapture::file_ext() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.file_ext)
  return _internal_file_ext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_file_ext(ArgT0&& arg0, ArgT... args) {
 
 file_ext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.file_ext)
}
inline std::string* BinaryCapture::mutable_file_ext() {
  std::string* _s = _internal_mutable_file_ext();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.file_ext)
  return _s;
}
inline const std::string& BinaryCapture::_internal_file_ext() const {
  return file_ext_.Get();
}
inline void BinaryCapture::_internal_set_file_ext(const std::string& value) {
  
  file_ext_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_file_ext() {
  
  return file_ext_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_file_ext() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.file_ext)
  return file_ext_.Release();
}
inline void BinaryCapture::set_allocated_file_ext(std::string* file_ext) {
  if (file_ext != nullptr) {
    
  } else {
    
  }
  file_ext_.SetAllocated(file_ext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_ext_.IsDefault()) {
    file_ext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.file_ext)
}

// string id = 19 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void BinaryCapture::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& BinaryCapture::id() const {
  // @@protoc_insertion_point(field_get:viam.app.datasync.v1.BinaryCapture.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinaryCapture::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.datasync.v1.BinaryCapture.id)
}
inline std::string* BinaryCapture::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.datasync.v1.BinaryCapture.id)
  return _s;
}
inline const std::string& BinaryCapture::_internal_id() const {
  return id_.Get();
}
inline void BinaryCapture::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryCapture::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* BinaryCapture::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.datasync.v1.BinaryCapture.id)
  return id_.Release();
}
inline void BinaryCapture::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.datasync.v1.BinaryCapture.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace datasync
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::datasync::v1::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::datasync::v1::DataType>() {
  return ::viam::app::datasync::v1::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fdatasync_2fv1_2fdata_5fsync_2eproto
