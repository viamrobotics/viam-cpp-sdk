// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/mltraining/v1/ml_training.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fmltraining_2fv1_2fml_5ftraining_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fmltraining_2fv1_2fml_5ftraining_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "app/data/v1/data.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fmltraining_2fv1_2fml_5ftraining_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
namespace viam {
namespace app {
namespace mltraining {
namespace v1 {
class GetTrainingJobRequest;
struct GetTrainingJobRequestDefaultTypeInternal;
extern GetTrainingJobRequestDefaultTypeInternal _GetTrainingJobRequest_default_instance_;
class GetTrainingJobResponse;
struct GetTrainingJobResponseDefaultTypeInternal;
extern GetTrainingJobResponseDefaultTypeInternal _GetTrainingJobResponse_default_instance_;
class SubmitTrainingJobRequest;
struct SubmitTrainingJobRequestDefaultTypeInternal;
extern SubmitTrainingJobRequestDefaultTypeInternal _SubmitTrainingJobRequest_default_instance_;
class SubmitTrainingJobResponse;
struct SubmitTrainingJobResponseDefaultTypeInternal;
extern SubmitTrainingJobResponseDefaultTypeInternal _SubmitTrainingJobResponse_default_instance_;
class TrainingJob;
struct TrainingJobDefaultTypeInternal;
extern TrainingJobDefaultTypeInternal _TrainingJob_default_instance_;
class TrainingJobMetadata;
struct TrainingJobMetadataDefaultTypeInternal;
extern TrainingJobMetadataDefaultTypeInternal _TrainingJobMetadata_default_instance_;
}  // namespace v1
}  // namespace mltraining
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::mltraining::v1::GetTrainingJobRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::GetTrainingJobRequest>(Arena*);
template<> ::viam::app::mltraining::v1::GetTrainingJobResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::GetTrainingJobResponse>(Arena*);
template<> ::viam::app::mltraining::v1::SubmitTrainingJobRequest* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::SubmitTrainingJobRequest>(Arena*);
template<> ::viam::app::mltraining::v1::SubmitTrainingJobResponse* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::SubmitTrainingJobResponse>(Arena*);
template<> ::viam::app::mltraining::v1::TrainingJob* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJob>(Arena*);
template<> ::viam::app::mltraining::v1::TrainingJobMetadata* Arena::CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJobMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace mltraining {
namespace v1 {

enum ModelType : int {
  MODEL_TYPE_UNSPECIFIED = 0,
  MODEL_TYPE_SINGLE_LABEL_CLASSIFICATION = 1,
  MODEL_TYPE_MULTI_LABEL_CLASSIFICATION = 2,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = MODEL_TYPE_UNSPECIFIED;
constexpr ModelType ModelType_MAX = MODEL_TYPE_MULTI_LABEL_CLASSIFICATION;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelType_descriptor();
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelType_descriptor(), enum_t_value);
}
inline bool ModelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelType>(
    ModelType_descriptor(), name, value);
}
enum TrainingStatus : int {
  TRAINING_STATUS_UNSPECIFIED = 0,
  TRAINING_STATUS_PENDING = 1,
  TRAINING_STATUS_IN_PROGRESS = 2,
  TRAINING_STATUS_COMPLETED = 3,
  TRAINING_STATUS_FAILED = 4,
  TRAINING_STATUS_SUBMITTING = 5,
  TrainingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrainingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrainingStatus_IsValid(int value);
constexpr TrainingStatus TrainingStatus_MIN = TRAINING_STATUS_UNSPECIFIED;
constexpr TrainingStatus TrainingStatus_MAX = TRAINING_STATUS_SUBMITTING;
constexpr int TrainingStatus_ARRAYSIZE = TrainingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrainingStatus_descriptor();
template<typename T>
inline const std::string& TrainingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrainingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrainingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrainingStatus_descriptor(), enum_t_value);
}
inline bool TrainingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrainingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrainingStatus>(
    TrainingStatus_descriptor(), name, value);
}
// ===================================================================

class SubmitTrainingJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.SubmitTrainingJobRequest) */ {
 public:
  inline SubmitTrainingJobRequest() : SubmitTrainingJobRequest(nullptr) {}
  ~SubmitTrainingJobRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitTrainingJobRequest(const SubmitTrainingJobRequest& from);
  SubmitTrainingJobRequest(SubmitTrainingJobRequest&& from) noexcept
    : SubmitTrainingJobRequest() {
    *this = ::std::move(from);
  }

  inline SubmitTrainingJobRequest& operator=(const SubmitTrainingJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitTrainingJobRequest& operator=(SubmitTrainingJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitTrainingJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitTrainingJobRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitTrainingJobRequest*>(
               &_SubmitTrainingJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SubmitTrainingJobRequest& a, SubmitTrainingJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitTrainingJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitTrainingJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitTrainingJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitTrainingJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitTrainingJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitTrainingJobRequest& from) {
    SubmitTrainingJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitTrainingJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.SubmitTrainingJobRequest";
  }
  protected:
  explicit SubmitTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 6,
    kOrganizationIdFieldNumber = 2,
    kModelNameFieldNumber = 3,
    kModelVersionFieldNumber = 4,
    kFilterFieldNumber = 1,
    kModelTypeFieldNumber = 5,
  };
  // repeated string tags = 6 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string model_name = 3 [json_name = "modelName"];
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_version = 4 [json_name = "modelVersion"];
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // .viam.app.data.v1.Filter filter = 1 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::viam::app::data::v1::Filter& filter() const;
  PROTOBUF_NODISCARD ::viam::app::data::v1::Filter* release_filter();
  ::viam::app::data::v1::Filter* mutable_filter();
  void set_allocated_filter(::viam::app::data::v1::Filter* filter);
  private:
  const ::viam::app::data::v1::Filter& _internal_filter() const;
  ::viam::app::data::v1::Filter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::viam::app::data::v1::Filter* filter);
  ::viam::app::data::v1::Filter* unsafe_arena_release_filter();

  // .viam.app.mltraining.v1.ModelType model_type = 5 [json_name = "modelType"];
  void clear_model_type();
  ::viam::app::mltraining::v1::ModelType model_type() const;
  void set_model_type(::viam::app::mltraining::v1::ModelType value);
  private:
  ::viam::app::mltraining::v1::ModelType _internal_model_type() const;
  void _internal_set_model_type(::viam::app::mltraining::v1::ModelType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.SubmitTrainingJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    ::viam::app::data::v1::Filter* filter_;
    int model_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class SubmitTrainingJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.SubmitTrainingJobResponse) */ {
 public:
  inline SubmitTrainingJobResponse() : SubmitTrainingJobResponse(nullptr) {}
  ~SubmitTrainingJobResponse() override;
  explicit PROTOBUF_CONSTEXPR SubmitTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitTrainingJobResponse(const SubmitTrainingJobResponse& from);
  SubmitTrainingJobResponse(SubmitTrainingJobResponse&& from) noexcept
    : SubmitTrainingJobResponse() {
    *this = ::std::move(from);
  }

  inline SubmitTrainingJobResponse& operator=(const SubmitTrainingJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitTrainingJobResponse& operator=(SubmitTrainingJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitTrainingJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitTrainingJobResponse* internal_default_instance() {
    return reinterpret_cast<const SubmitTrainingJobResponse*>(
               &_SubmitTrainingJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubmitTrainingJobResponse& a, SubmitTrainingJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitTrainingJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitTrainingJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitTrainingJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitTrainingJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitTrainingJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitTrainingJobResponse& from) {
    SubmitTrainingJobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitTrainingJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.SubmitTrainingJobResponse";
  }
  protected:
  explicit SubmitTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.SubmitTrainingJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class GetTrainingJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.GetTrainingJobRequest) */ {
 public:
  inline GetTrainingJobRequest() : GetTrainingJobRequest(nullptr) {}
  ~GetTrainingJobRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTrainingJobRequest(const GetTrainingJobRequest& from);
  GetTrainingJobRequest(GetTrainingJobRequest&& from) noexcept
    : GetTrainingJobRequest() {
    *this = ::std::move(from);
  }

  inline GetTrainingJobRequest& operator=(const GetTrainingJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrainingJobRequest& operator=(GetTrainingJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTrainingJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTrainingJobRequest* internal_default_instance() {
    return reinterpret_cast<const GetTrainingJobRequest*>(
               &_GetTrainingJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetTrainingJobRequest& a, GetTrainingJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrainingJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrainingJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTrainingJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTrainingJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTrainingJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTrainingJobRequest& from) {
    GetTrainingJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrainingJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.GetTrainingJobRequest";
  }
  protected:
  explicit GetTrainingJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.GetTrainingJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class GetTrainingJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.GetTrainingJobResponse) */ {
 public:
  inline GetTrainingJobResponse() : GetTrainingJobResponse(nullptr) {}
  ~GetTrainingJobResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTrainingJobResponse(const GetTrainingJobResponse& from);
  GetTrainingJobResponse(GetTrainingJobResponse&& from) noexcept
    : GetTrainingJobResponse() {
    *this = ::std::move(from);
  }

  inline GetTrainingJobResponse& operator=(const GetTrainingJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrainingJobResponse& operator=(GetTrainingJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTrainingJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTrainingJobResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrainingJobResponse*>(
               &_GetTrainingJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetTrainingJobResponse& a, GetTrainingJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrainingJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrainingJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTrainingJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTrainingJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTrainingJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTrainingJobResponse& from) {
    GetTrainingJobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrainingJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.GetTrainingJobResponse";
  }
  protected:
  explicit GetTrainingJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .viam.app.mltraining.v1.TrainingJobMetadata metadata = 2 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::mltraining::v1::TrainingJobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::mltraining::v1::TrainingJobMetadata* release_metadata();
  ::viam::app::mltraining::v1::TrainingJobMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::mltraining::v1::TrainingJobMetadata* metadata);
  private:
  const ::viam::app::mltraining::v1::TrainingJobMetadata& _internal_metadata() const;
  ::viam::app::mltraining::v1::TrainingJobMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::mltraining::v1::TrainingJobMetadata* metadata);
  ::viam::app::mltraining::v1::TrainingJobMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.GetTrainingJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::viam::app::mltraining::v1::TrainingJobMetadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class TrainingJobMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.TrainingJobMetadata) */ {
 public:
  inline TrainingJobMetadata() : TrainingJobMetadata(nullptr) {}
  ~TrainingJobMetadata() override;
  explicit PROTOBUF_CONSTEXPR TrainingJobMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainingJobMetadata(const TrainingJobMetadata& from);
  TrainingJobMetadata(TrainingJobMetadata&& from) noexcept
    : TrainingJobMetadata() {
    *this = ::std::move(from);
  }

  inline TrainingJobMetadata& operator=(const TrainingJobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingJobMetadata& operator=(TrainingJobMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingJobMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingJobMetadata* internal_default_instance() {
    return reinterpret_cast<const TrainingJobMetadata*>(
               &_TrainingJobMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrainingJobMetadata& a, TrainingJobMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainingJobMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingJobMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingJobMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingJobMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrainingJobMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrainingJobMetadata& from) {
    TrainingJobMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainingJobMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.TrainingJobMetadata";
  }
  protected:
  explicit TrainingJobMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSyncedModelIdFieldNumber = 5,
    kRequestFieldNumber = 1,
    kCreatedOnFieldNumber = 3,
    kLastModifiedFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // string synced_model_id = 5 [json_name = "syncedModelId"];
  void clear_synced_model_id();
  const std::string& synced_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_synced_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_synced_model_id();
  PROTOBUF_NODISCARD std::string* release_synced_model_id();
  void set_allocated_synced_model_id(std::string* synced_model_id);
  private:
  const std::string& _internal_synced_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_synced_model_id(const std::string& value);
  std::string* _internal_mutable_synced_model_id();
  public:

  // .viam.app.mltraining.v1.SubmitTrainingJobRequest request = 1 [json_name = "request"];
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::viam::app::mltraining::v1::SubmitTrainingJobRequest& request() const;
  PROTOBUF_NODISCARD ::viam::app::mltraining::v1::SubmitTrainingJobRequest* release_request();
  ::viam::app::mltraining::v1::SubmitTrainingJobRequest* mutable_request();
  void set_allocated_request(::viam::app::mltraining::v1::SubmitTrainingJobRequest* request);
  private:
  const ::viam::app::mltraining::v1::SubmitTrainingJobRequest& _internal_request() const;
  ::viam::app::mltraining::v1::SubmitTrainingJobRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::viam::app::mltraining::v1::SubmitTrainingJobRequest* request);
  ::viam::app::mltraining::v1::SubmitTrainingJobRequest* unsafe_arena_release_request();

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .google.protobuf.Timestamp last_modified = 4 [json_name = "lastModified"];
  bool has_last_modified() const;
  private:
  bool _internal_has_last_modified() const;
  public:
  void clear_last_modified();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_modified() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_modified();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_modified();
  void set_allocated_last_modified(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_modified() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_modified();
  public:
  void unsafe_arena_set_allocated_last_modified(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_modified();

  // .viam.app.mltraining.v1.TrainingStatus status = 2 [json_name = "status"];
  void clear_status();
  ::viam::app::mltraining::v1::TrainingStatus status() const;
  void set_status(::viam::app::mltraining::v1::TrainingStatus value);
  private:
  ::viam::app::mltraining::v1::TrainingStatus _internal_status() const;
  void _internal_set_status(::viam::app::mltraining::v1::TrainingStatus value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.TrainingJobMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr synced_model_id_;
    ::viam::app::mltraining::v1::SubmitTrainingJobRequest* request_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// -------------------------------------------------------------------

class TrainingJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.mltraining.v1.TrainingJob) */ {
 public:
  inline TrainingJob() : TrainingJob(nullptr) {}
  ~TrainingJob() override;
  explicit PROTOBUF_CONSTEXPR TrainingJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainingJob(const TrainingJob& from);
  TrainingJob(TrainingJob&& from) noexcept
    : TrainingJob() {
    *this = ::std::move(from);
  }

  inline TrainingJob& operator=(const TrainingJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingJob& operator=(TrainingJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingJob* internal_default_instance() {
    return reinterpret_cast<const TrainingJob*>(
               &_TrainingJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TrainingJob& a, TrainingJob& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainingJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrainingJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrainingJob& from) {
    TrainingJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrainingJob* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.mltraining.v1.TrainingJob";
  }
  protected:
  explicit TrainingJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kOutputPathFieldNumber = 3,
    kVertexJobIdFieldNumber = 4,
    kMetadataFieldNumber = 2,
    kModelMetadataFieldNumber = 5,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string output_path = 3 [json_name = "outputPath", (.tagger.v1.tags) = "bson:\"output_path\" json:\"output_path\""];
  void clear_output_path();
  const std::string& output_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_path();
  PROTOBUF_NODISCARD std::string* release_output_path();
  void set_allocated_output_path(std::string* output_path);
  private:
  const std::string& _internal_output_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_path(const std::string& value);
  std::string* _internal_mutable_output_path();
  public:

  // string vertex_job_id = 4 [json_name = "vertexJobId", (.tagger.v1.tags) = "bson:\"vertex_job_id\" json:\"vertex_job_id\""];
  void clear_vertex_job_id();
  const std::string& vertex_job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vertex_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vertex_job_id();
  PROTOBUF_NODISCARD std::string* release_vertex_job_id();
  void set_allocated_vertex_job_id(std::string* vertex_job_id);
  private:
  const std::string& _internal_vertex_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vertex_job_id(const std::string& value);
  std::string* _internal_mutable_vertex_job_id();
  public:

  // .viam.app.mltraining.v1.TrainingJobMetadata metadata = 2 [json_name = "metadata", (.tagger.v1.tags) = "bson:\"metadata\" json:\"metadata\""];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::viam::app::mltraining::v1::TrainingJobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::viam::app::mltraining::v1::TrainingJobMetadata* release_metadata();
  ::viam::app::mltraining::v1::TrainingJobMetadata* mutable_metadata();
  void set_allocated_metadata(::viam::app::mltraining::v1::TrainingJobMetadata* metadata);
  private:
  const ::viam::app::mltraining::v1::TrainingJobMetadata& _internal_metadata() const;
  ::viam::app::mltraining::v1::TrainingJobMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::viam::app::mltraining::v1::TrainingJobMetadata* metadata);
  ::viam::app::mltraining::v1::TrainingJobMetadata* unsafe_arena_release_metadata();

  // .google.protobuf.Struct model_metadata = 5 [json_name = "modelMetadata", (.tagger.v1.tags) = "bson:\"model_metadata\" json:\"model_metadata\""];
  bool has_model_metadata() const;
  private:
  bool _internal_has_model_metadata() const;
  public:
  void clear_model_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& model_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_model_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_model_metadata();
  void set_allocated_model_metadata(::PROTOBUF_NAMESPACE_ID::Struct* model_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_model_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_model_metadata();
  public:
  void unsafe_arena_set_allocated_model_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* model_metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_model_metadata();

  // @@protoc_insertion_point(class_scope:viam.app.mltraining.v1.TrainingJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vertex_job_id_;
    ::viam::app::mltraining::v1::TrainingJobMetadata* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Struct* model_metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fmltraining_2fv1_2fml_5ftraining_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubmitTrainingJobRequest

// .viam.app.data.v1.Filter filter = 1 [json_name = "filter"];
inline bool SubmitTrainingJobRequest::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool SubmitTrainingJobRequest::has_filter() const {
  return _internal_has_filter();
}
inline const ::viam::app::data::v1::Filter& SubmitTrainingJobRequest::_internal_filter() const {
  const ::viam::app::data::v1::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::data::v1::Filter&>(
      ::viam::app::data::v1::_Filter_default_instance_);
}
inline const ::viam::app::data::v1::Filter& SubmitTrainingJobRequest::filter() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.filter)
  return _internal_filter();
}
inline void SubmitTrainingJobRequest::unsafe_arena_set_allocated_filter(
    ::viam::app::data::v1::Filter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.filter)
}
inline ::viam::app::data::v1::Filter* SubmitTrainingJobRequest::release_filter() {
  
  ::viam::app::data::v1::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::data::v1::Filter* SubmitTrainingJobRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.filter)
  
  ::viam::app::data::v1::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::viam::app::data::v1::Filter* SubmitTrainingJobRequest::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::data::v1::Filter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::viam::app::data::v1::Filter* SubmitTrainingJobRequest::mutable_filter() {
  ::viam::app::data::v1::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.filter)
  return _msg;
}
inline void SubmitTrainingJobRequest::set_allocated_filter(::viam::app::data::v1::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter));
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.filter)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void SubmitTrainingJobRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
}
inline std::string* SubmitTrainingJobRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void SubmitTrainingJobRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void SubmitTrainingJobRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.organization_id)
}

// string model_name = 3 [json_name = "modelName"];
inline void SubmitTrainingJobRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobRequest::model_name() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
}
inline std::string* SubmitTrainingJobRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void SubmitTrainingJobRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void SubmitTrainingJobRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_name)
}

// string model_version = 4 [json_name = "modelVersion"];
inline void SubmitTrainingJobRequest::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobRequest::model_version() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobRequest::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
}
inline std::string* SubmitTrainingJobRequest::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void SubmitTrainingJobRequest::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobRequest::release_model_version() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
  return _impl_.model_version_.Release();
}
inline void SubmitTrainingJobRequest::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_version)
}

// .viam.app.mltraining.v1.ModelType model_type = 5 [json_name = "modelType"];
inline void SubmitTrainingJobRequest::clear_model_type() {
  _impl_.model_type_ = 0;
}
inline ::viam::app::mltraining::v1::ModelType SubmitTrainingJobRequest::_internal_model_type() const {
  return static_cast< ::viam::app::mltraining::v1::ModelType >(_impl_.model_type_);
}
inline ::viam::app::mltraining::v1::ModelType SubmitTrainingJobRequest::model_type() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_type)
  return _internal_model_type();
}
inline void SubmitTrainingJobRequest::_internal_set_model_type(::viam::app::mltraining::v1::ModelType value) {
  
  _impl_.model_type_ = value;
}
inline void SubmitTrainingJobRequest::set_model_type(::viam::app::mltraining::v1::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.model_type)
}

// repeated string tags = 6 [json_name = "tags"];
inline int SubmitTrainingJobRequest::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int SubmitTrainingJobRequest::tags_size() const {
  return _internal_tags_size();
}
inline void SubmitTrainingJobRequest::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* SubmitTrainingJobRequest::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return _s;
}
inline const std::string& SubmitTrainingJobRequest::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& SubmitTrainingJobRequest::tags(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return _internal_tags(index);
}
inline std::string* SubmitTrainingJobRequest::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return _impl_.tags_.Mutable(index);
}
inline void SubmitTrainingJobRequest::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline std::string* SubmitTrainingJobRequest::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void SubmitTrainingJobRequest::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline void SubmitTrainingJobRequest::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubmitTrainingJobRequest::tags() const {
  // @@protoc_insertion_point(field_list:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubmitTrainingJobRequest::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.mltraining.v1.SubmitTrainingJobRequest.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// SubmitTrainingJobResponse

// string id = 1 [json_name = "id"];
inline void SubmitTrainingJobResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SubmitTrainingJobResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitTrainingJobResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
}
inline std::string* SubmitTrainingJobResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
  return _s;
}
inline const std::string& SubmitTrainingJobResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SubmitTrainingJobResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitTrainingJobResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
  return _impl_.id_.Release();
}
inline void SubmitTrainingJobResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.SubmitTrainingJobResponse.id)
}

// -------------------------------------------------------------------

// GetTrainingJobRequest

// string id = 1 [json_name = "id"];
inline void GetTrainingJobRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetTrainingJobRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTrainingJobRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.GetTrainingJobRequest.id)
}
inline std::string* GetTrainingJobRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobRequest.id)
  return _s;
}
inline const std::string& GetTrainingJobRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetTrainingJobRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTrainingJobRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTrainingJobRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobRequest.id)
  return _impl_.id_.Release();
}
inline void GetTrainingJobRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobRequest.id)
}

// -------------------------------------------------------------------

// GetTrainingJobResponse

// string id = 1 [json_name = "id"];
inline void GetTrainingJobResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetTrainingJobResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTrainingJobResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.GetTrainingJobResponse.id)
}
inline std::string* GetTrainingJobResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobResponse.id)
  return _s;
}
inline const std::string& GetTrainingJobResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetTrainingJobResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTrainingJobResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTrainingJobResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobResponse.id)
  return _impl_.id_.Release();
}
inline void GetTrainingJobResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobResponse.id)
}

// .viam.app.mltraining.v1.TrainingJobMetadata metadata = 2 [json_name = "metadata"];
inline bool GetTrainingJobResponse::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool GetTrainingJobResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline void GetTrainingJobResponse::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& GetTrainingJobResponse::_internal_metadata() const {
  const ::viam::app::mltraining::v1::TrainingJobMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::mltraining::v1::TrainingJobMetadata&>(
      ::viam::app::mltraining::v1::_TrainingJobMetadata_default_instance_);
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& GetTrainingJobResponse::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
  return _internal_metadata();
}
inline void GetTrainingJobResponse::unsafe_arena_set_allocated_metadata(
    ::viam::app::mltraining::v1::TrainingJobMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::release_metadata() {
  
  ::viam::app::mltraining::v1::TrainingJobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
  
  ::viam::app::mltraining::v1::TrainingJobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJobMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* GetTrainingJobResponse::mutable_metadata() {
  ::viam::app::mltraining::v1::TrainingJobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
  return _msg;
}
inline void GetTrainingJobResponse::set_allocated_metadata(::viam::app::mltraining::v1::TrainingJobMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.GetTrainingJobResponse.metadata)
}

// -------------------------------------------------------------------

// TrainingJobMetadata

// .viam.app.mltraining.v1.SubmitTrainingJobRequest request = 1 [json_name = "request"];
inline bool TrainingJobMetadata::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool TrainingJobMetadata::has_request() const {
  return _internal_has_request();
}
inline void TrainingJobMetadata::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::viam::app::mltraining::v1::SubmitTrainingJobRequest& TrainingJobMetadata::_internal_request() const {
  const ::viam::app::mltraining::v1::SubmitTrainingJobRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::mltraining::v1::SubmitTrainingJobRequest&>(
      ::viam::app::mltraining::v1::_SubmitTrainingJobRequest_default_instance_);
}
inline const ::viam::app::mltraining::v1::SubmitTrainingJobRequest& TrainingJobMetadata::request() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.request)
  return _internal_request();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_request(
    ::viam::app::mltraining::v1::SubmitTrainingJobRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.request)
}
inline ::viam::app::mltraining::v1::SubmitTrainingJobRequest* TrainingJobMetadata::release_request() {
  
  ::viam::app::mltraining::v1::SubmitTrainingJobRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::mltraining::v1::SubmitTrainingJobRequest* TrainingJobMetadata::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.request)
  
  ::viam::app::mltraining::v1::SubmitTrainingJobRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::viam::app::mltraining::v1::SubmitTrainingJobRequest* TrainingJobMetadata::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::mltraining::v1::SubmitTrainingJobRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::viam::app::mltraining::v1::SubmitTrainingJobRequest* TrainingJobMetadata::mutable_request() {
  ::viam::app::mltraining::v1::SubmitTrainingJobRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.request)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_request(::viam::app::mltraining::v1::SubmitTrainingJobRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.request)
}

// .viam.app.mltraining.v1.TrainingStatus status = 2 [json_name = "status"];
inline void TrainingJobMetadata::clear_status() {
  _impl_.status_ = 0;
}
inline ::viam::app::mltraining::v1::TrainingStatus TrainingJobMetadata::_internal_status() const {
  return static_cast< ::viam::app::mltraining::v1::TrainingStatus >(_impl_.status_);
}
inline ::viam::app::mltraining::v1::TrainingStatus TrainingJobMetadata::status() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.status)
  return _internal_status();
}
inline void TrainingJobMetadata::_internal_set_status(::viam::app::mltraining::v1::TrainingStatus value) {
  
  _impl_.status_ = value;
}
inline void TrainingJobMetadata::set_status(::viam::app::mltraining::v1::TrainingStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.status)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool TrainingJobMetadata::_internal_has_created_on() const {
  return this != internal_default_instance() && _impl_.created_on_ != nullptr;
}
inline bool TrainingJobMetadata::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
  return _internal_created_on();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  _impl_.created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::_internal_mutable_created_on() {
  
  if (_impl_.created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_on_ = p;
  }
  return _impl_.created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.created_on)
}

// .google.protobuf.Timestamp last_modified = 4 [json_name = "lastModified"];
inline bool TrainingJobMetadata::_internal_has_last_modified() const {
  return this != internal_default_instance() && _impl_.last_modified_ != nullptr;
}
inline bool TrainingJobMetadata::has_last_modified() const {
  return _internal_has_last_modified();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::_internal_last_modified() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_modified_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrainingJobMetadata::last_modified() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
  return _internal_last_modified();
}
inline void TrainingJobMetadata::unsafe_arena_set_allocated_last_modified(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_modified_);
  }
  _impl_.last_modified_ = last_modified;
  if (last_modified) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::release_last_modified() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_modified_;
  _impl_.last_modified_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::unsafe_arena_release_last_modified() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_modified_;
  _impl_.last_modified_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::_internal_mutable_last_modified() {
  
  if (_impl_.last_modified_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_modified_ = p;
  }
  return _impl_.last_modified_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrainingJobMetadata::mutable_last_modified() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
  return _msg;
}
inline void TrainingJobMetadata::set_allocated_last_modified(::PROTOBUF_NAMESPACE_ID::Timestamp* last_modified) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_modified_);
  }
  if (last_modified) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_modified));
    if (message_arena != submessage_arena) {
      last_modified = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_modified, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_modified_ = last_modified;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.last_modified)
}

// string synced_model_id = 5 [json_name = "syncedModelId"];
inline void TrainingJobMetadata::clear_synced_model_id() {
  _impl_.synced_model_id_.ClearToEmpty();
}
inline const std::string& TrainingJobMetadata::synced_model_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
  return _internal_synced_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJobMetadata::set_synced_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.synced_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
}
inline std::string* TrainingJobMetadata::mutable_synced_model_id() {
  std::string* _s = _internal_mutable_synced_model_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
  return _s;
}
inline const std::string& TrainingJobMetadata::_internal_synced_model_id() const {
  return _impl_.synced_model_id_.Get();
}
inline void TrainingJobMetadata::_internal_set_synced_model_id(const std::string& value) {
  
  _impl_.synced_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::_internal_mutable_synced_model_id() {
  
  return _impl_.synced_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJobMetadata::release_synced_model_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
  return _impl_.synced_model_id_.Release();
}
inline void TrainingJobMetadata::set_allocated_synced_model_id(std::string* synced_model_id) {
  if (synced_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.synced_model_id_.SetAllocated(synced_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.synced_model_id_.IsDefault()) {
    _impl_.synced_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJobMetadata.synced_model_id)
}

// -------------------------------------------------------------------

// TrainingJob

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void TrainingJob::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TrainingJob::id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJob.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJob::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJob.id)
}
inline std::string* TrainingJob::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJob.id)
  return _s;
}
inline const std::string& TrainingJob::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TrainingJob::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJob::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJob::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJob.id)
  return _impl_.id_.Release();
}
inline void TrainingJob::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJob.id)
}

// .viam.app.mltraining.v1.TrainingJobMetadata metadata = 2 [json_name = "metadata", (.tagger.v1.tags) = "bson:\"metadata\" json:\"metadata\""];
inline bool TrainingJob::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool TrainingJob::has_metadata() const {
  return _internal_has_metadata();
}
inline void TrainingJob::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& TrainingJob::_internal_metadata() const {
  const ::viam::app::mltraining::v1::TrainingJobMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::mltraining::v1::TrainingJobMetadata&>(
      ::viam::app::mltraining::v1::_TrainingJobMetadata_default_instance_);
}
inline const ::viam::app::mltraining::v1::TrainingJobMetadata& TrainingJob::metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJob.metadata)
  return _internal_metadata();
}
inline void TrainingJob::unsafe_arena_set_allocated_metadata(
    ::viam::app::mltraining::v1::TrainingJobMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJob.metadata)
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* TrainingJob::release_metadata() {
  
  ::viam::app::mltraining::v1::TrainingJobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* TrainingJob::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJob.metadata)
  
  ::viam::app::mltraining::v1::TrainingJobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* TrainingJob::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::mltraining::v1::TrainingJobMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::viam::app::mltraining::v1::TrainingJobMetadata* TrainingJob::mutable_metadata() {
  ::viam::app::mltraining::v1::TrainingJobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJob.metadata)
  return _msg;
}
inline void TrainingJob::set_allocated_metadata(::viam::app::mltraining::v1::TrainingJobMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJob.metadata)
}

// string output_path = 3 [json_name = "outputPath", (.tagger.v1.tags) = "bson:\"output_path\" json:\"output_path\""];
inline void TrainingJob::clear_output_path() {
  _impl_.output_path_.ClearToEmpty();
}
inline const std::string& TrainingJob::output_path() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJob.output_path)
  return _internal_output_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJob::set_output_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJob.output_path)
}
inline std::string* TrainingJob::mutable_output_path() {
  std::string* _s = _internal_mutable_output_path();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJob.output_path)
  return _s;
}
inline const std::string& TrainingJob::_internal_output_path() const {
  return _impl_.output_path_.Get();
}
inline void TrainingJob::_internal_set_output_path(const std::string& value) {
  
  _impl_.output_path_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJob::_internal_mutable_output_path() {
  
  return _impl_.output_path_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJob::release_output_path() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJob.output_path)
  return _impl_.output_path_.Release();
}
inline void TrainingJob::set_allocated_output_path(std::string* output_path) {
  if (output_path != nullptr) {
    
  } else {
    
  }
  _impl_.output_path_.SetAllocated(output_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_path_.IsDefault()) {
    _impl_.output_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJob.output_path)
}

// string vertex_job_id = 4 [json_name = "vertexJobId", (.tagger.v1.tags) = "bson:\"vertex_job_id\" json:\"vertex_job_id\""];
inline void TrainingJob::clear_vertex_job_id() {
  _impl_.vertex_job_id_.ClearToEmpty();
}
inline const std::string& TrainingJob::vertex_job_id() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJob.vertex_job_id)
  return _internal_vertex_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrainingJob::set_vertex_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vertex_job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.mltraining.v1.TrainingJob.vertex_job_id)
}
inline std::string* TrainingJob::mutable_vertex_job_id() {
  std::string* _s = _internal_mutable_vertex_job_id();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJob.vertex_job_id)
  return _s;
}
inline const std::string& TrainingJob::_internal_vertex_job_id() const {
  return _impl_.vertex_job_id_.Get();
}
inline void TrainingJob::_internal_set_vertex_job_id(const std::string& value) {
  
  _impl_.vertex_job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrainingJob::_internal_mutable_vertex_job_id() {
  
  return _impl_.vertex_job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrainingJob::release_vertex_job_id() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJob.vertex_job_id)
  return _impl_.vertex_job_id_.Release();
}
inline void TrainingJob::set_allocated_vertex_job_id(std::string* vertex_job_id) {
  if (vertex_job_id != nullptr) {
    
  } else {
    
  }
  _impl_.vertex_job_id_.SetAllocated(vertex_job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vertex_job_id_.IsDefault()) {
    _impl_.vertex_job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJob.vertex_job_id)
}

// .google.protobuf.Struct model_metadata = 5 [json_name = "modelMetadata", (.tagger.v1.tags) = "bson:\"model_metadata\" json:\"model_metadata\""];
inline bool TrainingJob::_internal_has_model_metadata() const {
  return this != internal_default_instance() && _impl_.model_metadata_ != nullptr;
}
inline bool TrainingJob::has_model_metadata() const {
  return _internal_has_model_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TrainingJob::_internal_model_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.model_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& TrainingJob::model_metadata() const {
  // @@protoc_insertion_point(field_get:viam.app.mltraining.v1.TrainingJob.model_metadata)
  return _internal_model_metadata();
}
inline void TrainingJob::unsafe_arena_set_allocated_model_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* model_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_metadata_);
  }
  _impl_.model_metadata_ = model_metadata;
  if (model_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.mltraining.v1.TrainingJob.model_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainingJob::release_model_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.model_metadata_;
  _impl_.model_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainingJob::unsafe_arena_release_model_metadata() {
  // @@protoc_insertion_point(field_release:viam.app.mltraining.v1.TrainingJob.model_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.model_metadata_;
  _impl_.model_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainingJob::_internal_mutable_model_metadata() {
  
  if (_impl_.model_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.model_metadata_ = p;
  }
  return _impl_.model_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* TrainingJob::mutable_model_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_model_metadata();
  // @@protoc_insertion_point(field_mutable:viam.app.mltraining.v1.TrainingJob.model_metadata)
  return _msg;
}
inline void TrainingJob::set_allocated_model_metadata(::PROTOBUF_NAMESPACE_ID::Struct* model_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_metadata_);
  }
  if (model_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_metadata));
    if (message_arena != submessage_arena) {
      model_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_metadata_ = model_metadata;
  // @@protoc_insertion_point(field_set_allocated:viam.app.mltraining.v1.TrainingJob.model_metadata)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace mltraining
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::mltraining::v1::ModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::mltraining::v1::ModelType>() {
  return ::viam::app::mltraining::v1::ModelType_descriptor();
}
template <> struct is_proto_enum< ::viam::app::mltraining::v1::TrainingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::mltraining::v1::TrainingStatus>() {
  return ::viam::app::mltraining::v1::TrainingStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fmltraining_2fv1_2fml_5ftraining_2eproto
