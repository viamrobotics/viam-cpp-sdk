// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/v1/app.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "tagger/v1/tagger.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_app_2fv1_2fapp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fv1_2fapp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_app_2fv1_2fapp_2eproto;
namespace viam {
namespace app {
namespace v1 {
class CreateLocationRequest;
struct CreateLocationRequestDefaultTypeInternal;
extern CreateLocationRequestDefaultTypeInternal _CreateLocationRequest_default_instance_;
class CreateLocationResponse;
struct CreateLocationResponseDefaultTypeInternal;
extern CreateLocationResponseDefaultTypeInternal _CreateLocationResponse_default_instance_;
class CreateLocationSecretRequest;
struct CreateLocationSecretRequestDefaultTypeInternal;
extern CreateLocationSecretRequestDefaultTypeInternal _CreateLocationSecretRequest_default_instance_;
class CreateLocationSecretResponse;
struct CreateLocationSecretResponseDefaultTypeInternal;
extern CreateLocationSecretResponseDefaultTypeInternal _CreateLocationSecretResponse_default_instance_;
class CreateRobotPartSecretRequest;
struct CreateRobotPartSecretRequestDefaultTypeInternal;
extern CreateRobotPartSecretRequestDefaultTypeInternal _CreateRobotPartSecretRequest_default_instance_;
class CreateRobotPartSecretResponse;
struct CreateRobotPartSecretResponseDefaultTypeInternal;
extern CreateRobotPartSecretResponseDefaultTypeInternal _CreateRobotPartSecretResponse_default_instance_;
class DeleteLocationSecretRequest;
struct DeleteLocationSecretRequestDefaultTypeInternal;
extern DeleteLocationSecretRequestDefaultTypeInternal _DeleteLocationSecretRequest_default_instance_;
class DeleteLocationSecretResponse;
struct DeleteLocationSecretResponseDefaultTypeInternal;
extern DeleteLocationSecretResponseDefaultTypeInternal _DeleteLocationSecretResponse_default_instance_;
class DeleteRobotPartRequest;
struct DeleteRobotPartRequestDefaultTypeInternal;
extern DeleteRobotPartRequestDefaultTypeInternal _DeleteRobotPartRequest_default_instance_;
class DeleteRobotPartResponse;
struct DeleteRobotPartResponseDefaultTypeInternal;
extern DeleteRobotPartResponseDefaultTypeInternal _DeleteRobotPartResponse_default_instance_;
class DeleteRobotPartSecretRequest;
struct DeleteRobotPartSecretRequestDefaultTypeInternal;
extern DeleteRobotPartSecretRequestDefaultTypeInternal _DeleteRobotPartSecretRequest_default_instance_;
class DeleteRobotPartSecretResponse;
struct DeleteRobotPartSecretResponseDefaultTypeInternal;
extern DeleteRobotPartSecretResponseDefaultTypeInternal _DeleteRobotPartSecretResponse_default_instance_;
class DeleteRobotRequest;
struct DeleteRobotRequestDefaultTypeInternal;
extern DeleteRobotRequestDefaultTypeInternal _DeleteRobotRequest_default_instance_;
class DeleteRobotResponse;
struct DeleteRobotResponseDefaultTypeInternal;
extern DeleteRobotResponseDefaultTypeInternal _DeleteRobotResponse_default_instance_;
class FindRobotsRequest;
struct FindRobotsRequestDefaultTypeInternal;
extern FindRobotsRequestDefaultTypeInternal _FindRobotsRequest_default_instance_;
class FindRobotsResponse;
struct FindRobotsResponseDefaultTypeInternal;
extern FindRobotsResponseDefaultTypeInternal _FindRobotsResponse_default_instance_;
class Fragment;
struct FragmentDefaultTypeInternal;
extern FragmentDefaultTypeInternal _Fragment_default_instance_;
class GetRobotPartHistoryRequest;
struct GetRobotPartHistoryRequestDefaultTypeInternal;
extern GetRobotPartHistoryRequestDefaultTypeInternal _GetRobotPartHistoryRequest_default_instance_;
class GetRobotPartHistoryResponse;
struct GetRobotPartHistoryResponseDefaultTypeInternal;
extern GetRobotPartHistoryResponseDefaultTypeInternal _GetRobotPartHistoryResponse_default_instance_;
class GetRobotPartLogsRequest;
struct GetRobotPartLogsRequestDefaultTypeInternal;
extern GetRobotPartLogsRequestDefaultTypeInternal _GetRobotPartLogsRequest_default_instance_;
class GetRobotPartLogsResponse;
struct GetRobotPartLogsResponseDefaultTypeInternal;
extern GetRobotPartLogsResponseDefaultTypeInternal _GetRobotPartLogsResponse_default_instance_;
class GetRobotPartRequest;
struct GetRobotPartRequestDefaultTypeInternal;
extern GetRobotPartRequestDefaultTypeInternal _GetRobotPartRequest_default_instance_;
class GetRobotPartResponse;
struct GetRobotPartResponseDefaultTypeInternal;
extern GetRobotPartResponseDefaultTypeInternal _GetRobotPartResponse_default_instance_;
class GetRobotPartsRequest;
struct GetRobotPartsRequestDefaultTypeInternal;
extern GetRobotPartsRequestDefaultTypeInternal _GetRobotPartsRequest_default_instance_;
class GetRobotPartsResponse;
struct GetRobotPartsResponseDefaultTypeInternal;
extern GetRobotPartsResponseDefaultTypeInternal _GetRobotPartsResponse_default_instance_;
class GetRobotRequest;
struct GetRobotRequestDefaultTypeInternal;
extern GetRobotRequestDefaultTypeInternal _GetRobotRequest_default_instance_;
class GetRobotResponse;
struct GetRobotResponseDefaultTypeInternal;
extern GetRobotResponseDefaultTypeInternal _GetRobotResponse_default_instance_;
class ListLocationsRequest;
struct ListLocationsRequestDefaultTypeInternal;
extern ListLocationsRequestDefaultTypeInternal _ListLocationsRequest_default_instance_;
class ListLocationsResponse;
struct ListLocationsResponseDefaultTypeInternal;
extern ListLocationsResponseDefaultTypeInternal _ListLocationsResponse_default_instance_;
class ListOrganizationsRequest;
struct ListOrganizationsRequestDefaultTypeInternal;
extern ListOrganizationsRequestDefaultTypeInternal _ListOrganizationsRequest_default_instance_;
class ListOrganizationsResponse;
struct ListOrganizationsResponseDefaultTypeInternal;
extern ListOrganizationsResponseDefaultTypeInternal _ListOrganizationsResponse_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class LocationAuth;
struct LocationAuthDefaultTypeInternal;
extern LocationAuthDefaultTypeInternal _LocationAuth_default_instance_;
class LocationAuthRequest;
struct LocationAuthRequestDefaultTypeInternal;
extern LocationAuthRequestDefaultTypeInternal _LocationAuthRequest_default_instance_;
class LocationAuthResponse;
struct LocationAuthResponseDefaultTypeInternal;
extern LocationAuthResponseDefaultTypeInternal _LocationAuthResponse_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class MarkPartAsMainRequest;
struct MarkPartAsMainRequestDefaultTypeInternal;
extern MarkPartAsMainRequestDefaultTypeInternal _MarkPartAsMainRequest_default_instance_;
class MarkPartAsMainResponse;
struct MarkPartAsMainResponseDefaultTypeInternal;
extern MarkPartAsMainResponseDefaultTypeInternal _MarkPartAsMainResponse_default_instance_;
class NewRobotPartRequest;
struct NewRobotPartRequestDefaultTypeInternal;
extern NewRobotPartRequestDefaultTypeInternal _NewRobotPartRequest_default_instance_;
class NewRobotPartResponse;
struct NewRobotPartResponseDefaultTypeInternal;
extern NewRobotPartResponseDefaultTypeInternal _NewRobotPartResponse_default_instance_;
class NewRobotRequest;
struct NewRobotRequestDefaultTypeInternal;
extern NewRobotRequestDefaultTypeInternal _NewRobotRequest_default_instance_;
class NewRobotResponse;
struct NewRobotResponseDefaultTypeInternal;
extern NewRobotResponseDefaultTypeInternal _NewRobotResponse_default_instance_;
class Organization;
struct OrganizationDefaultTypeInternal;
extern OrganizationDefaultTypeInternal _Organization_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class RobotPart;
struct RobotPartDefaultTypeInternal;
extern RobotPartDefaultTypeInternal _RobotPart_default_instance_;
class RobotPartHistoryEntry;
struct RobotPartHistoryEntryDefaultTypeInternal;
extern RobotPartHistoryEntryDefaultTypeInternal _RobotPartHistoryEntry_default_instance_;
class SharedSecret;
struct SharedSecretDefaultTypeInternal;
extern SharedSecretDefaultTypeInternal _SharedSecret_default_instance_;
class TailRobotPartLogsRequest;
struct TailRobotPartLogsRequestDefaultTypeInternal;
extern TailRobotPartLogsRequestDefaultTypeInternal _TailRobotPartLogsRequest_default_instance_;
class TailRobotPartLogsResponse;
struct TailRobotPartLogsResponseDefaultTypeInternal;
extern TailRobotPartLogsResponseDefaultTypeInternal _TailRobotPartLogsResponse_default_instance_;
class UpdateRobotPartRequest;
struct UpdateRobotPartRequestDefaultTypeInternal;
extern UpdateRobotPartRequestDefaultTypeInternal _UpdateRobotPartRequest_default_instance_;
class UpdateRobotPartResponse;
struct UpdateRobotPartResponseDefaultTypeInternal;
extern UpdateRobotPartResponseDefaultTypeInternal _UpdateRobotPartResponse_default_instance_;
class UpdateRobotRequest;
struct UpdateRobotRequestDefaultTypeInternal;
extern UpdateRobotRequestDefaultTypeInternal _UpdateRobotRequest_default_instance_;
class UpdateRobotResponse;
struct UpdateRobotResponseDefaultTypeInternal;
extern UpdateRobotResponseDefaultTypeInternal _UpdateRobotResponse_default_instance_;
}  // namespace v1
}  // namespace app
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::app::v1::CreateLocationRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationRequest>(Arena*);
template<> ::viam::app::v1::CreateLocationResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationResponse>(Arena*);
template<> ::viam::app::v1::CreateLocationSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationSecretRequest>(Arena*);
template<> ::viam::app::v1::CreateLocationSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateLocationSecretResponse>(Arena*);
template<> ::viam::app::v1::CreateRobotPartSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::CreateRobotPartSecretRequest>(Arena*);
template<> ::viam::app::v1::CreateRobotPartSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::CreateRobotPartSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteLocationSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationSecretRequest>(Arena*);
template<> ::viam::app::v1::DeleteLocationSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteLocationSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartSecretRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartSecretRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotPartSecretResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotPartSecretResponse>(Arena*);
template<> ::viam::app::v1::DeleteRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotRequest>(Arena*);
template<> ::viam::app::v1::DeleteRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::DeleteRobotResponse>(Arena*);
template<> ::viam::app::v1::FindRobotsRequest* Arena::CreateMaybeMessage<::viam::app::v1::FindRobotsRequest>(Arena*);
template<> ::viam::app::v1::FindRobotsResponse* Arena::CreateMaybeMessage<::viam::app::v1::FindRobotsResponse>(Arena*);
template<> ::viam::app::v1::Fragment* Arena::CreateMaybeMessage<::viam::app::v1::Fragment>(Arena*);
template<> ::viam::app::v1::GetRobotPartHistoryRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartHistoryRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartHistoryResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartHistoryResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartLogsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartLogsRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartLogsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartLogsResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartResponse>(Arena*);
template<> ::viam::app::v1::GetRobotPartsRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartsRequest>(Arena*);
template<> ::viam::app::v1::GetRobotPartsResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotPartsResponse>(Arena*);
template<> ::viam::app::v1::GetRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotRequest>(Arena*);
template<> ::viam::app::v1::GetRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::GetRobotResponse>(Arena*);
template<> ::viam::app::v1::ListLocationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListLocationsRequest>(Arena*);
template<> ::viam::app::v1::ListLocationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListLocationsResponse>(Arena*);
template<> ::viam::app::v1::ListOrganizationsRequest* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsRequest>(Arena*);
template<> ::viam::app::v1::ListOrganizationsResponse* Arena::CreateMaybeMessage<::viam::app::v1::ListOrganizationsResponse>(Arena*);
template<> ::viam::app::v1::Location* Arena::CreateMaybeMessage<::viam::app::v1::Location>(Arena*);
template<> ::viam::app::v1::LocationAuth* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuth>(Arena*);
template<> ::viam::app::v1::LocationAuthRequest* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuthRequest>(Arena*);
template<> ::viam::app::v1::LocationAuthResponse* Arena::CreateMaybeMessage<::viam::app::v1::LocationAuthResponse>(Arena*);
template<> ::viam::app::v1::LogEntry* Arena::CreateMaybeMessage<::viam::app::v1::LogEntry>(Arena*);
template<> ::viam::app::v1::MarkPartAsMainRequest* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartAsMainRequest>(Arena*);
template<> ::viam::app::v1::MarkPartAsMainResponse* Arena::CreateMaybeMessage<::viam::app::v1::MarkPartAsMainResponse>(Arena*);
template<> ::viam::app::v1::NewRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotPartRequest>(Arena*);
template<> ::viam::app::v1::NewRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotPartResponse>(Arena*);
template<> ::viam::app::v1::NewRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotRequest>(Arena*);
template<> ::viam::app::v1::NewRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::NewRobotResponse>(Arena*);
template<> ::viam::app::v1::Organization* Arena::CreateMaybeMessage<::viam::app::v1::Organization>(Arena*);
template<> ::viam::app::v1::Robot* Arena::CreateMaybeMessage<::viam::app::v1::Robot>(Arena*);
template<> ::viam::app::v1::RobotPart* Arena::CreateMaybeMessage<::viam::app::v1::RobotPart>(Arena*);
template<> ::viam::app::v1::RobotPartHistoryEntry* Arena::CreateMaybeMessage<::viam::app::v1::RobotPartHistoryEntry>(Arena*);
template<> ::viam::app::v1::SharedSecret* Arena::CreateMaybeMessage<::viam::app::v1::SharedSecret>(Arena*);
template<> ::viam::app::v1::TailRobotPartLogsRequest* Arena::CreateMaybeMessage<::viam::app::v1::TailRobotPartLogsRequest>(Arena*);
template<> ::viam::app::v1::TailRobotPartLogsResponse* Arena::CreateMaybeMessage<::viam::app::v1::TailRobotPartLogsResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotPartResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotPartResponse>(Arena*);
template<> ::viam::app::v1::UpdateRobotRequest* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotRequest>(Arena*);
template<> ::viam::app::v1::UpdateRobotResponse* Arena::CreateMaybeMessage<::viam::app::v1::UpdateRobotResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace app {
namespace v1 {

enum SharedSecret_State : int {
  SharedSecret_State_STATE_UNSPECIFIED = 0,
  SharedSecret_State_STATE_ENABLED = 1,
  SharedSecret_State_STATE_DISABLED = 2,
  SharedSecret_State_SharedSecret_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SharedSecret_State_SharedSecret_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SharedSecret_State_IsValid(int value);
constexpr SharedSecret_State SharedSecret_State_State_MIN = SharedSecret_State_STATE_UNSPECIFIED;
constexpr SharedSecret_State SharedSecret_State_State_MAX = SharedSecret_State_STATE_DISABLED;
constexpr int SharedSecret_State_State_ARRAYSIZE = SharedSecret_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SharedSecret_State_descriptor();
template<typename T>
inline const std::string& SharedSecret_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SharedSecret_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SharedSecret_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SharedSecret_State_descriptor(), enum_t_value);
}
inline bool SharedSecret_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharedSecret_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SharedSecret_State>(
    SharedSecret_State_descriptor(), name, value);
}
// ===================================================================

class Robot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  explicit PROTOBUF_CONSTEXPR Robot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Robot& from) {
    Robot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLocationFieldNumber = 3,
    kLastAccessFieldNumber = 4,
    kCreatedOnFieldNumber = 5,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 3 [json_name = "location", (.tagger.v1.tags) = "bson:\"location\" json:\"location\""];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // .google.protobuf.Timestamp last_access = 4 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // .google.protobuf.Timestamp created_on = 5 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RobotPart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotPart) */ {
 public:
  inline RobotPart() : RobotPart(nullptr) {}
  ~RobotPart() override;
  explicit PROTOBUF_CONSTEXPR RobotPart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotPart(const RobotPart& from);
  RobotPart(RobotPart&& from) noexcept
    : RobotPart() {
    *this = ::std::move(from);
  }

  inline RobotPart& operator=(const RobotPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPart& operator=(RobotPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotPart* internal_default_instance() {
    return reinterpret_cast<const RobotPart*>(
               &_RobotPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RobotPart& a, RobotPart& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotPart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotPart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotPart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotPart& from) {
    RobotPart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RobotPart";
  }
  protected:
  explicit RobotPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 14,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSecretFieldNumber = 3,
    kRobotFieldNumber = 4,
    kFqdnFieldNumber = 9,
    kDnsNameFieldNumber = 10,
    kLocalFqdnFieldNumber = 11,
    kLocationIdFieldNumber = 12,
    kRobotConfigFieldNumber = 5,
    kLastAccessFieldNumber = 6,
    kUserSuppliedInfoFieldNumber = 7,
    kCreatedOnFieldNumber = 13,
    kMainPartFieldNumber = 8,
  };
  // repeated .viam.app.v1.SharedSecret secrets = 14 [json_name = "secrets", (.tagger.v1.tags) = "bson:\"secrets\""];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  ::viam::app::v1::SharedSecret* mutable_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
      mutable_secrets();
  private:
  const ::viam::app::v1::SharedSecret& _internal_secrets(int index) const;
  ::viam::app::v1::SharedSecret* _internal_add_secrets();
  public:
  const ::viam::app::v1::SharedSecret& secrets(int index) const;
  ::viam::app::v1::SharedSecret* add_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
      secrets() const;

  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string secret = 3 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\" json:\"secret,omitempty\""];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string robot = 4 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
  void clear_robot();
  const std::string& robot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot();
  PROTOBUF_NODISCARD std::string* release_robot();
  void set_allocated_robot(std::string* robot);
  private:
  const std::string& _internal_robot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot(const std::string& value);
  std::string* _internal_mutable_robot();
  public:

  // string fqdn = 9 [json_name = "fqdn"];
  void clear_fqdn();
  const std::string& fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fqdn();
  PROTOBUF_NODISCARD std::string* release_fqdn();
  void set_allocated_fqdn(std::string* fqdn);
  private:
  const std::string& _internal_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fqdn(const std::string& value);
  std::string* _internal_mutable_fqdn();
  public:

  // string dns_name = 10 [json_name = "dnsName", (.tagger.v1.tags) = "bson:\"dns_name\" json:\"dns_name\""];
  void clear_dns_name();
  const std::string& dns_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dns_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dns_name();
  PROTOBUF_NODISCARD std::string* release_dns_name();
  void set_allocated_dns_name(std::string* dns_name);
  private:
  const std::string& _internal_dns_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns_name(const std::string& value);
  std::string* _internal_mutable_dns_name();
  public:

  // string local_fqdn = 11 [json_name = "localFqdn"];
  void clear_local_fqdn();
  const std::string& local_fqdn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_fqdn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_fqdn();
  PROTOBUF_NODISCARD std::string* release_local_fqdn();
  void set_allocated_local_fqdn(std::string* local_fqdn);
  private:
  const std::string& _internal_local_fqdn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_fqdn(const std::string& value);
  std::string* _internal_mutable_local_fqdn();
  public:

  // string location_id = 12 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"-\""];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // .google.protobuf.Struct robot_config = 5 [json_name = "robotConfig", (.tagger.v1.tags) = "bson:\"config\" json:\"robot_config\""];
  bool has_robot_config() const;
  private:
  bool _internal_has_robot_config() const;
  public:
  void clear_robot_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& robot_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_robot_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_robot_config();
  void set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_robot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_robot_config();
  public:
  void unsafe_arena_set_allocated_robot_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_robot_config();

  // .google.protobuf.Timestamp last_access = 6 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
  bool has_last_access() const;
  private:
  bool _internal_has_last_access() const;
  public:
  void clear_last_access();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_access() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_access();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_access();
  void set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_access() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_access();
  public:
  void unsafe_arena_set_allocated_last_access(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_access();

  // .google.protobuf.Struct user_supplied_info = 7 [json_name = "userSuppliedInfo", (.tagger.v1.tags) = "bson:\"user_supplied_info\" json:\"user_supplied_info\""];
  bool has_user_supplied_info() const;
  private:
  bool _internal_has_user_supplied_info() const;
  public:
  void clear_user_supplied_info();
  const ::PROTOBUF_NAMESPACE_ID::Struct& user_supplied_info() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_user_supplied_info();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_user_supplied_info();
  void set_allocated_user_supplied_info(::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_user_supplied_info() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_user_supplied_info();
  public:
  void unsafe_arena_set_allocated_user_supplied_info(
      ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_user_supplied_info();

  // .google.protobuf.Timestamp created_on = 13 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // bool main_part = 8 [json_name = "mainPart", (.tagger.v1.tags) = "bson:\"main_part\" json:\"main_part\""];
  void clear_main_part();
  bool main_part() const;
  void set_main_part(bool value);
  private:
  bool _internal_main_part() const;
  void _internal_set_main_part(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotPart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret > secrets_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fqdn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dns_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_fqdn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access_;
    ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
    bool main_part_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class RobotPartHistoryEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.RobotPartHistoryEntry) */ {
 public:
  inline RobotPartHistoryEntry() : RobotPartHistoryEntry(nullptr) {}
  ~RobotPartHistoryEntry() override;
  explicit PROTOBUF_CONSTEXPR RobotPartHistoryEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotPartHistoryEntry(const RobotPartHistoryEntry& from);
  RobotPartHistoryEntry(RobotPartHistoryEntry&& from) noexcept
    : RobotPartHistoryEntry() {
    *this = ::std::move(from);
  }

  inline RobotPartHistoryEntry& operator=(const RobotPartHistoryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPartHistoryEntry& operator=(RobotPartHistoryEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotPartHistoryEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotPartHistoryEntry* internal_default_instance() {
    return reinterpret_cast<const RobotPartHistoryEntry*>(
               &_RobotPartHistoryEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotPartHistoryEntry& a, RobotPartHistoryEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPartHistoryEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPartHistoryEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotPartHistoryEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotPartHistoryEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotPartHistoryEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotPartHistoryEntry& from) {
    RobotPartHistoryEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPartHistoryEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.RobotPartHistoryEntry";
  }
  protected:
  explicit RobotPartHistoryEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
    kRobotFieldNumber = 2,
    kWhenFieldNumber = 3,
    kOldFieldNumber = 4,
  };
  // string part = 1 [json_name = "part", (.tagger.v1.tags) = "bson:\"part\" json:\"part\""];
  void clear_part();
  const std::string& part() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part();
  PROTOBUF_NODISCARD std::string* release_part();
  void set_allocated_part(std::string* part);
  private:
  const std::string& _internal_part() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part(const std::string& value);
  std::string* _internal_mutable_part();
  public:

  // string robot = 2 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
  void clear_robot();
  const std::string& robot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot();
  PROTOBUF_NODISCARD std::string* release_robot();
  void set_allocated_robot(std::string* robot);
  private:
  const std::string& _internal_robot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot(const std::string& value);
  std::string* _internal_mutable_robot();
  public:

  // .google.protobuf.Timestamp when = 3 [json_name = "when", (.tagger.v1.tags) = "bson:\"when\" json:\"when\""];
  bool has_when() const;
  private:
  bool _internal_has_when() const;
  public:
  void clear_when();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& when() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_when();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_when();
  void set_allocated_when(::PROTOBUF_NAMESPACE_ID::Timestamp* when);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_when() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_when();
  public:
  void unsafe_arena_set_allocated_when(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* when);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_when();

  // .viam.app.v1.RobotPart old = 4 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
  bool has_old() const;
  private:
  bool _internal_has_old() const;
  public:
  void clear_old();
  const ::viam::app::v1::RobotPart& old() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_old();
  ::viam::app::v1::RobotPart* mutable_old();
  void set_allocated_old(::viam::app::v1::RobotPart* old);
  private:
  const ::viam::app::v1::RobotPart& _internal_old() const;
  ::viam::app::v1::RobotPart* _internal_mutable_old();
  public:
  void unsafe_arena_set_allocated_old(
      ::viam::app::v1::RobotPart* old);
  ::viam::app::v1::RobotPart* unsafe_arena_release_old();

  // @@protoc_insertion_point(class_scope:viam.app.v1.RobotPartHistoryEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* when_;
    ::viam::app::v1::RobotPart* old_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsRequest) */ {
 public:
  inline ListOrganizationsRequest() : ListOrganizationsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsRequest(const ListOrganizationsRequest& from);
  ListOrganizationsRequest(ListOrganizationsRequest&& from) noexcept
    : ListOrganizationsRequest() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsRequest& operator=(const ListOrganizationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsRequest& operator=(ListOrganizationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsRequest*>(
               &_ListOrganizationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListOrganizationsRequest& a, ListOrganizationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListOrganizationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListOrganizationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsRequest";
  }
  protected:
  explicit ListOrganizationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Organization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Organization) */ {
 public:
  inline Organization() : Organization(nullptr) {}
  ~Organization() override;
  explicit PROTOBUF_CONSTEXPR Organization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Organization(const Organization& from);
  Organization(Organization&& from) noexcept
    : Organization() {
    *this = ::std::move(from);
  }

  inline Organization& operator=(const Organization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Organization& operator=(Organization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Organization& default_instance() {
    return *internal_default_instance();
  }
  static inline const Organization* internal_default_instance() {
    return reinterpret_cast<const Organization*>(
               &_Organization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Organization& a, Organization& b) {
    a.Swap(&b);
  }
  inline void Swap(Organization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Organization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Organization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Organization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Organization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Organization& from) {
    Organization::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Organization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Organization";
  }
  protected:
  explicit Organization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedOnFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Organization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListOrganizationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListOrganizationsResponse) */ {
 public:
  inline ListOrganizationsResponse() : ListOrganizationsResponse(nullptr) {}
  ~ListOrganizationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOrganizationsResponse(const ListOrganizationsResponse& from);
  ListOrganizationsResponse(ListOrganizationsResponse&& from) noexcept
    : ListOrganizationsResponse() {
    *this = ::std::move(from);
  }

  inline ListOrganizationsResponse& operator=(const ListOrganizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOrganizationsResponse& operator=(ListOrganizationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOrganizationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOrganizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListOrganizationsResponse*>(
               &_ListOrganizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListOrganizationsResponse& a, ListOrganizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOrganizationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOrganizationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOrganizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOrganizationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOrganizationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListOrganizationsResponse& from) {
    ListOrganizationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOrganizationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListOrganizationsResponse";
  }
  protected:
  explicit ListOrganizationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Organization organizations = 1 [json_name = "organizations"];
  int organizations_size() const;
  private:
  int _internal_organizations_size() const;
  public:
  void clear_organizations();
  ::viam::app::v1::Organization* mutable_organizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >*
      mutable_organizations();
  private:
  const ::viam::app::v1::Organization& _internal_organizations(int index) const;
  ::viam::app::v1::Organization* _internal_add_organizations();
  public:
  const ::viam::app::v1::Organization& organizations(int index) const;
  ::viam::app::v1::Organization* add_organizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >&
      organizations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListOrganizationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization > organizations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedOnFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // @@protoc_insertion_point(class_scope:viam.app.v1.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationRequest) */ {
 public:
  inline CreateLocationRequest() : CreateLocationRequest(nullptr) {}
  ~CreateLocationRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationRequest(const CreateLocationRequest& from);
  CreateLocationRequest(CreateLocationRequest&& from) noexcept
    : CreateLocationRequest() {
    *this = ::std::move(from);
  }

  inline CreateLocationRequest& operator=(const CreateLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationRequest& operator=(CreateLocationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateLocationRequest*>(
               &_CreateLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateLocationRequest& a, CreateLocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateLocationRequest& from) {
    CreateLocationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationRequest";
  }
  protected:
  explicit CreateLocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationResponse) */ {
 public:
  inline CreateLocationResponse() : CreateLocationResponse(nullptr) {}
  ~CreateLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationResponse(const CreateLocationResponse& from);
  CreateLocationResponse(CreateLocationResponse&& from) noexcept
    : CreateLocationResponse() {
    *this = ::std::move(from);
  }

  inline CreateLocationResponse& operator=(const CreateLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationResponse& operator=(CreateLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateLocationResponse*>(
               &_CreateLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateLocationResponse& a, CreateLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateLocationResponse& from) {
    CreateLocationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationResponse";
  }
  protected:
  explicit CreateLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // .viam.app.v1.Location location = 1 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::viam::app::v1::Location& location() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Location* release_location();
  ::viam::app::v1::Location* mutable_location();
  void set_allocated_location(::viam::app::v1::Location* location);
  private:
  const ::viam::app::v1::Location& _internal_location() const;
  ::viam::app::v1::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::viam::app::v1::Location* location);
  ::viam::app::v1::Location* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::v1::Location* location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListLocationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListLocationsRequest) */ {
 public:
  inline ListLocationsRequest() : ListLocationsRequest(nullptr) {}
  ~ListLocationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListLocationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocationsRequest(const ListLocationsRequest& from);
  ListLocationsRequest(ListLocationsRequest&& from) noexcept
    : ListLocationsRequest() {
    *this = ::std::move(from);
  }

  inline ListLocationsRequest& operator=(const ListLocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocationsRequest& operator=(ListLocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListLocationsRequest*>(
               &_ListLocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListLocationsRequest& a, ListLocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListLocationsRequest& from) {
    ListLocationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListLocationsRequest";
  }
  protected:
  explicit ListLocationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListLocationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class ListLocationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.ListLocationsResponse) */ {
 public:
  inline ListLocationsResponse() : ListLocationsResponse(nullptr) {}
  ~ListLocationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListLocationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListLocationsResponse(const ListLocationsResponse& from);
  ListLocationsResponse(ListLocationsResponse&& from) noexcept
    : ListLocationsResponse() {
    *this = ::std::move(from);
  }

  inline ListLocationsResponse& operator=(const ListLocationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLocationsResponse& operator=(ListLocationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListLocationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListLocationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListLocationsResponse*>(
               &_ListLocationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListLocationsResponse& a, ListLocationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLocationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLocationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListLocationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListLocationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListLocationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListLocationsResponse& from) {
    ListLocationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLocationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.ListLocationsResponse";
  }
  protected:
  explicit ListLocationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Location locations = 1 [json_name = "locations"];
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  ::viam::app::v1::Location* mutable_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >*
      mutable_locations();
  private:
  const ::viam::app::v1::Location& _internal_locations(int index) const;
  ::viam::app::v1::Location* _internal_add_locations();
  public:
  const ::viam::app::v1::Location& locations(int index) const;
  ::viam::app::v1::Location* add_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >&
      locations() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.ListLocationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location > locations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationSecretRequest) */ {
 public:
  inline CreateLocationSecretRequest() : CreateLocationSecretRequest(nullptr) {}
  ~CreateLocationSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationSecretRequest(const CreateLocationSecretRequest& from);
  CreateLocationSecretRequest(CreateLocationSecretRequest&& from) noexcept
    : CreateLocationSecretRequest() {
    *this = ::std::move(from);
  }

  inline CreateLocationSecretRequest& operator=(const CreateLocationSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationSecretRequest& operator=(CreateLocationSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationSecretRequest* internal_default_instance() {
    return reinterpret_cast<const CreateLocationSecretRequest*>(
               &_CreateLocationSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateLocationSecretRequest& a, CreateLocationSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateLocationSecretRequest& from) {
    CreateLocationSecretRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationSecretRequest";
  }
  protected:
  explicit CreateLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateLocationSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateLocationSecretResponse) */ {
 public:
  inline CreateLocationSecretResponse() : CreateLocationSecretResponse(nullptr) {}
  ~CreateLocationSecretResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLocationSecretResponse(const CreateLocationSecretResponse& from);
  CreateLocationSecretResponse(CreateLocationSecretResponse&& from) noexcept
    : CreateLocationSecretResponse() {
    *this = ::std::move(from);
  }

  inline CreateLocationSecretResponse& operator=(const CreateLocationSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLocationSecretResponse& operator=(CreateLocationSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateLocationSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLocationSecretResponse* internal_default_instance() {
    return reinterpret_cast<const CreateLocationSecretResponse*>(
               &_CreateLocationSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateLocationSecretResponse& a, CreateLocationSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateLocationSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLocationSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLocationSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLocationSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateLocationSecretResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateLocationSecretResponse& from) {
    CreateLocationSecretResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateLocationSecretResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateLocationSecretResponse";
  }
  protected:
  explicit CreateLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
  };
  // .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateLocationSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::v1::LocationAuth* auth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationSecretRequest) */ {
 public:
  inline DeleteLocationSecretRequest() : DeleteLocationSecretRequest(nullptr) {}
  ~DeleteLocationSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationSecretRequest(const DeleteLocationSecretRequest& from);
  DeleteLocationSecretRequest(DeleteLocationSecretRequest&& from) noexcept
    : DeleteLocationSecretRequest() {
    *this = ::std::move(from);
  }

  inline DeleteLocationSecretRequest& operator=(const DeleteLocationSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationSecretRequest& operator=(DeleteLocationSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationSecretRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationSecretRequest*>(
               &_DeleteLocationSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteLocationSecretRequest& a, DeleteLocationSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteLocationSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteLocationSecretRequest& from) {
    DeleteLocationSecretRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteLocationSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationSecretRequest";
  }
  protected:
  explicit DeleteLocationSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
    kSecretIdFieldNumber = 2,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // string secret_id = 2 [json_name = "secretId"];
  void clear_secret_id();
  const std::string& secret_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* secret_id);
  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(const std::string& value);
  std::string* _internal_mutable_secret_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteLocationSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteLocationSecretResponse) */ {
 public:
  inline DeleteLocationSecretResponse() : DeleteLocationSecretResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteLocationSecretResponse(const DeleteLocationSecretResponse& from);
  DeleteLocationSecretResponse(DeleteLocationSecretResponse&& from) noexcept
    : DeleteLocationSecretResponse() {
    *this = ::std::move(from);
  }

  inline DeleteLocationSecretResponse& operator=(const DeleteLocationSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLocationSecretResponse& operator=(DeleteLocationSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLocationSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLocationSecretResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteLocationSecretResponse*>(
               &_DeleteLocationSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteLocationSecretResponse& a, DeleteLocationSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteLocationSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLocationSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLocationSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteLocationSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteLocationSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteLocationSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteLocationSecretResponse";
  }
  protected:
  explicit DeleteLocationSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteLocationSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuth) */ {
 public:
  inline LocationAuth() : LocationAuth(nullptr) {}
  ~LocationAuth() override;
  explicit PROTOBUF_CONSTEXPR LocationAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuth(const LocationAuth& from);
  LocationAuth(LocationAuth&& from) noexcept
    : LocationAuth() {
    *this = ::std::move(from);
  }

  inline LocationAuth& operator=(const LocationAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuth& operator=(LocationAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuth* internal_default_instance() {
    return reinterpret_cast<const LocationAuth*>(
               &_LocationAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LocationAuth& a, LocationAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationAuth& from) {
    LocationAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuth";
  }
  protected:
  explicit LocationAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kSecretFieldNumber = 1,
    kLocationIdFieldNumber = 2,
  };
  // repeated .viam.app.v1.SharedSecret secrets = 3 [json_name = "secrets"];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  ::viam::app::v1::SharedSecret* mutable_secrets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
      mutable_secrets();
  private:
  const ::viam::app::v1::SharedSecret& _internal_secrets(int index) const;
  ::viam::app::v1::SharedSecret* _internal_add_secrets();
  public:
  const ::viam::app::v1::SharedSecret& secrets(int index) const;
  ::viam::app::v1::SharedSecret* add_secrets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
      secrets() const;

  // string secret = 1 [json_name = "secret", deprecated = true];
  PROTOBUF_DEPRECATED void clear_secret();
  PROTOBUF_DEPRECATED const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_secret(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_secret();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_secret();
  PROTOBUF_DEPRECATED void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string location_id = 2 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret > secrets_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class SharedSecret final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.SharedSecret) */ {
 public:
  inline SharedSecret() : SharedSecret(nullptr) {}
  ~SharedSecret() override;
  explicit PROTOBUF_CONSTEXPR SharedSecret(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharedSecret(const SharedSecret& from);
  SharedSecret(SharedSecret&& from) noexcept
    : SharedSecret() {
    *this = ::std::move(from);
  }

  inline SharedSecret& operator=(const SharedSecret& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedSecret& operator=(SharedSecret&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SharedSecret& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedSecret* internal_default_instance() {
    return reinterpret_cast<const SharedSecret*>(
               &_SharedSecret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SharedSecret& a, SharedSecret& b) {
    a.Swap(&b);
  }
  inline void Swap(SharedSecret* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedSecret* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedSecret* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharedSecret>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SharedSecret& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SharedSecret& from) {
    SharedSecret::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SharedSecret* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.SharedSecret";
  }
  protected:
  explicit SharedSecret(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SharedSecret_State State;
  static constexpr State STATE_UNSPECIFIED =
    SharedSecret_State_STATE_UNSPECIFIED;
  static constexpr State STATE_ENABLED =
    SharedSecret_State_STATE_ENABLED;
  static constexpr State STATE_DISABLED =
    SharedSecret_State_STATE_DISABLED;
  static inline bool State_IsValid(int value) {
    return SharedSecret_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SharedSecret_State_State_MIN;
  static constexpr State State_MAX =
    SharedSecret_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SharedSecret_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SharedSecret_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SharedSecret_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SharedSecret_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSecretFieldNumber = 2,
    kCreatedOnFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"id\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string secret = 2 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\""];
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // .viam.app.v1.SharedSecret.State state = 4 [json_name = "state", (.tagger.v1.tags) = "bson:\"state\""];
  void clear_state();
  ::viam::app::v1::SharedSecret_State state() const;
  void set_state(::viam::app::v1::SharedSecret_State value);
  private:
  ::viam::app::v1::SharedSecret_State _internal_state() const;
  void _internal_set_state(::viam::app::v1::SharedSecret_State value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.SharedSecret)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuthRequest) */ {
 public:
  inline LocationAuthRequest() : LocationAuthRequest(nullptr) {}
  ~LocationAuthRequest() override;
  explicit PROTOBUF_CONSTEXPR LocationAuthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuthRequest(const LocationAuthRequest& from);
  LocationAuthRequest(LocationAuthRequest&& from) noexcept
    : LocationAuthRequest() {
    *this = ::std::move(from);
  }

  inline LocationAuthRequest& operator=(const LocationAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuthRequest& operator=(LocationAuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuthRequest* internal_default_instance() {
    return reinterpret_cast<const LocationAuthRequest*>(
               &_LocationAuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LocationAuthRequest& a, LocationAuthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuthRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationAuthRequest& from) {
    LocationAuthRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuthRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuthRequest";
  }
  protected:
  explicit LocationAuthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LocationAuthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LocationAuthResponse) */ {
 public:
  inline LocationAuthResponse() : LocationAuthResponse(nullptr) {}
  ~LocationAuthResponse() override;
  explicit PROTOBUF_CONSTEXPR LocationAuthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationAuthResponse(const LocationAuthResponse& from);
  LocationAuthResponse(LocationAuthResponse&& from) noexcept
    : LocationAuthResponse() {
    *this = ::std::move(from);
  }

  inline LocationAuthResponse& operator=(const LocationAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationAuthResponse& operator=(LocationAuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationAuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationAuthResponse* internal_default_instance() {
    return reinterpret_cast<const LocationAuthResponse*>(
               &_LocationAuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LocationAuthResponse& a, LocationAuthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationAuthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationAuthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationAuthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationAuthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationAuthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationAuthResponse& from) {
    LocationAuthResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationAuthResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LocationAuthResponse";
  }
  protected:
  explicit LocationAuthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 1,
  };
  // .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const ::viam::app::v1::LocationAuth& auth() const;
  PROTOBUF_NODISCARD ::viam::app::v1::LocationAuth* release_auth();
  ::viam::app::v1::LocationAuth* mutable_auth();
  void set_allocated_auth(::viam::app::v1::LocationAuth* auth);
  private:
  const ::viam::app::v1::LocationAuth& _internal_auth() const;
  ::viam::app::v1::LocationAuth* _internal_mutable_auth();
  public:
  void unsafe_arena_set_allocated_auth(
      ::viam::app::v1::LocationAuth* auth);
  ::viam::app::v1::LocationAuth* unsafe_arena_release_auth();

  // @@protoc_insertion_point(class_scope:viam.app.v1.LocationAuthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::v1::LocationAuth* auth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotRequest) */ {
 public:
  inline GetRobotRequest() : GetRobotRequest(nullptr) {}
  ~GetRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotRequest(const GetRobotRequest& from);
  GetRobotRequest(GetRobotRequest&& from) noexcept
    : GetRobotRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotRequest& operator=(const GetRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotRequest& operator=(GetRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotRequest*>(
               &_GetRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetRobotRequest& a, GetRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotRequest& from) {
    GetRobotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotRequest";
  }
  protected:
  explicit GetRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotResponse) */ {
 public:
  inline GetRobotResponse() : GetRobotResponse(nullptr) {}
  ~GetRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotResponse(const GetRobotResponse& from);
  GetRobotResponse(GetRobotResponse&& from) noexcept
    : GetRobotResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotResponse& operator=(const GetRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotResponse& operator=(GetRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotResponse*>(
               &_GetRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetRobotResponse& a, GetRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotResponse& from) {
    GetRobotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotResponse";
  }
  protected:
  explicit GetRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // .viam.app.v1.Robot robot = 1 [json_name = "robot"];
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::viam::app::v1::Robot& robot() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Robot* release_robot();
  ::viam::app::v1::Robot* mutable_robot();
  void set_allocated_robot(::viam::app::v1::Robot* robot);
  private:
  const ::viam::app::v1::Robot& _internal_robot() const;
  ::viam::app::v1::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::viam::app::v1::Robot* robot);
  ::viam::app::v1::Robot* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::v1::Robot* robot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartsRequest) */ {
 public:
  inline GetRobotPartsRequest() : GetRobotPartsRequest(nullptr) {}
  ~GetRobotPartsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartsRequest(const GetRobotPartsRequest& from);
  GetRobotPartsRequest(GetRobotPartsRequest&& from) noexcept
    : GetRobotPartsRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartsRequest& operator=(const GetRobotPartsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartsRequest& operator=(GetRobotPartsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartsRequest*>(
               &_GetRobotPartsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetRobotPartsRequest& a, GetRobotPartsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartsRequest& from) {
    GetRobotPartsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartsRequest";
  }
  protected:
  explicit GetRobotPartsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartsResponse) */ {
 public:
  inline GetRobotPartsResponse() : GetRobotPartsResponse(nullptr) {}
  ~GetRobotPartsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartsResponse(const GetRobotPartsResponse& from);
  GetRobotPartsResponse(GetRobotPartsResponse&& from) noexcept
    : GetRobotPartsResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartsResponse& operator=(const GetRobotPartsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartsResponse& operator=(GetRobotPartsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartsResponse*>(
               &_GetRobotPartsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetRobotPartsResponse& a, GetRobotPartsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartsResponse& from) {
    GetRobotPartsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartsResponse";
  }
  protected:
  explicit GetRobotPartsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 1,
  };
  // repeated .viam.app.v1.RobotPart parts = 1 [json_name = "parts"];
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::viam::app::v1::RobotPart* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >*
      mutable_parts();
  private:
  const ::viam::app::v1::RobotPart& _internal_parts(int index) const;
  ::viam::app::v1::RobotPart* _internal_add_parts();
  public:
  const ::viam::app::v1::RobotPart& parts(int index) const;
  ::viam::app::v1::RobotPart* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >&
      parts() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart > parts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartRequest) */ {
 public:
  inline GetRobotPartRequest() : GetRobotPartRequest(nullptr) {}
  ~GetRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartRequest(const GetRobotPartRequest& from);
  GetRobotPartRequest(GetRobotPartRequest&& from) noexcept
    : GetRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartRequest& operator=(const GetRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartRequest& operator=(GetRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartRequest*>(
               &_GetRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetRobotPartRequest& a, GetRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartRequest& from) {
    GetRobotPartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartRequest";
  }
  protected:
  explicit GetRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartResponse) */ {
 public:
  inline GetRobotPartResponse() : GetRobotPartResponse(nullptr) {}
  ~GetRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartResponse(const GetRobotPartResponse& from);
  GetRobotPartResponse(GetRobotPartResponse&& from) noexcept
    : GetRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartResponse& operator=(const GetRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartResponse& operator=(GetRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartResponse*>(
               &_GetRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetRobotPartResponse& a, GetRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartResponse& from) {
    GetRobotPartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartResponse";
  }
  protected:
  explicit GetRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigJsonFieldNumber = 2,
    kPartFieldNumber = 1,
  };
  // string config_json = 2 [json_name = "configJson"];
  void clear_config_json();
  const std::string& config_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_json();
  PROTOBUF_NODISCARD std::string* release_config_json();
  void set_allocated_config_json(std::string* config_json);
  private:
  const std::string& _internal_config_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_json(const std::string& value);
  std::string* _internal_mutable_config_json();
  public:

  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_json_;
    ::viam::app::v1::RobotPart* part_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartLogsRequest) */ {
 public:
  inline GetRobotPartLogsRequest() : GetRobotPartLogsRequest(nullptr) {}
  ~GetRobotPartLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartLogsRequest(const GetRobotPartLogsRequest& from);
  GetRobotPartLogsRequest(GetRobotPartLogsRequest&& from) noexcept
    : GetRobotPartLogsRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartLogsRequest& operator=(const GetRobotPartLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartLogsRequest& operator=(GetRobotPartLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartLogsRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartLogsRequest*>(
               &_GetRobotPartLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetRobotPartLogsRequest& a, GetRobotPartLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartLogsRequest& from) {
    GetRobotPartLogsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartLogsRequest";
  }
  protected:
  explicit GetRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kErrorsOnlyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool errors_only = 2 [json_name = "errorsOnly"];
  void clear_errors_only();
  bool errors_only() const;
  void set_errors_only(bool value);
  private:
  bool _internal_errors_only() const;
  void _internal_set_errors_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    bool errors_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class LogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  explicit PROTOBUF_CONSTEXPR LogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEntry(const LogEntry& from);
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogEntry& from) {
    LogEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.LogEntry";
  }
  protected:
  explicit LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 8,
    kHostFieldNumber = 1,
    kLevelFieldNumber = 2,
    kLoggerNameFieldNumber = 4,
    kMessageFieldNumber = 5,
    kStackFieldNumber = 7,
    kTimeFieldNumber = 3,
    kCallerFieldNumber = 6,
  };
  // repeated .google.protobuf.Struct fields = 8 [json_name = "fields"];
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Struct >*
      mutable_fields();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_fields(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_add_fields();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Struct& fields(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Struct* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Struct >&
      fields() const;

  // string host = 1 [json_name = "host"];
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string level = 2 [json_name = "level"];
  void clear_level();
  const std::string& level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* level);
  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(const std::string& value);
  std::string* _internal_mutable_level();
  public:

  // string logger_name = 4 [json_name = "loggerName"];
  void clear_logger_name();
  const std::string& logger_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logger_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logger_name();
  PROTOBUF_NODISCARD std::string* release_logger_name();
  void set_allocated_logger_name(std::string* logger_name);
  private:
  const std::string& _internal_logger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logger_name(const std::string& value);
  std::string* _internal_mutable_logger_name();
  public:

  // string message = 5 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string stack = 7 [json_name = "stack"];
  void clear_stack();
  const std::string& stack() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stack(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stack();
  PROTOBUF_NODISCARD std::string* release_stack();
  void set_allocated_stack(std::string* stack);
  private:
  const std::string& _internal_stack() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stack(const std::string& value);
  std::string* _internal_mutable_stack();
  public:

  // .google.protobuf.Timestamp time = 3 [json_name = "time"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // .google.protobuf.Struct caller = 6 [json_name = "caller"];
  bool has_caller() const;
  private:
  bool _internal_has_caller() const;
  public:
  void clear_caller();
  const ::PROTOBUF_NAMESPACE_ID::Struct& caller() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_caller();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_caller();
  void set_allocated_caller(::PROTOBUF_NAMESPACE_ID::Struct* caller);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_caller() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_caller();
  public:
  void unsafe_arena_set_allocated_caller(
      ::PROTOBUF_NAMESPACE_ID::Struct* caller);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_caller();

  // @@protoc_insertion_point(class_scope:viam.app.v1.LogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Struct > fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logger_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stack_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    ::PROTOBUF_NAMESPACE_ID::Struct* caller_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartLogsResponse) */ {
 public:
  inline GetRobotPartLogsResponse() : GetRobotPartLogsResponse(nullptr) {}
  ~GetRobotPartLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartLogsResponse(const GetRobotPartLogsResponse& from);
  GetRobotPartLogsResponse(GetRobotPartLogsResponse&& from) noexcept
    : GetRobotPartLogsResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartLogsResponse& operator=(const GetRobotPartLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartLogsResponse& operator=(GetRobotPartLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartLogsResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartLogsResponse*>(
               &_GetRobotPartLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetRobotPartLogsResponse& a, GetRobotPartLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartLogsResponse& from) {
    GetRobotPartLogsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartLogsResponse";
  }
  protected:
  explicit GetRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
  };
  // repeated .viam.app.v1.LogEntry logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::app::v1::LogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >*
      mutable_logs();
  private:
  const ::viam::app::v1::LogEntry& _internal_logs(int index) const;
  ::viam::app::v1::LogEntry* _internal_add_logs();
  public:
  const ::viam::app::v1::LogEntry& logs(int index) const;
  ::viam::app::v1::LogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >&
      logs() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry > logs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TailRobotPartLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TailRobotPartLogsRequest) */ {
 public:
  inline TailRobotPartLogsRequest() : TailRobotPartLogsRequest(nullptr) {}
  ~TailRobotPartLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR TailRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailRobotPartLogsRequest(const TailRobotPartLogsRequest& from);
  TailRobotPartLogsRequest(TailRobotPartLogsRequest&& from) noexcept
    : TailRobotPartLogsRequest() {
    *this = ::std::move(from);
  }

  inline TailRobotPartLogsRequest& operator=(const TailRobotPartLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailRobotPartLogsRequest& operator=(TailRobotPartLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailRobotPartLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailRobotPartLogsRequest* internal_default_instance() {
    return reinterpret_cast<const TailRobotPartLogsRequest*>(
               &_TailRobotPartLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TailRobotPartLogsRequest& a, TailRobotPartLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TailRobotPartLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailRobotPartLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailRobotPartLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailRobotPartLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailRobotPartLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TailRobotPartLogsRequest& from) {
    TailRobotPartLogsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailRobotPartLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TailRobotPartLogsRequest";
  }
  protected:
  explicit TailRobotPartLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kErrorsOnlyFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool errors_only = 2 [json_name = "errorsOnly"];
  void clear_errors_only();
  bool errors_only() const;
  void set_errors_only(bool value);
  private:
  bool _internal_errors_only() const;
  void _internal_set_errors_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.TailRobotPartLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    bool errors_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class TailRobotPartLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.TailRobotPartLogsResponse) */ {
 public:
  inline TailRobotPartLogsResponse() : TailRobotPartLogsResponse(nullptr) {}
  ~TailRobotPartLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR TailRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailRobotPartLogsResponse(const TailRobotPartLogsResponse& from);
  TailRobotPartLogsResponse(TailRobotPartLogsResponse&& from) noexcept
    : TailRobotPartLogsResponse() {
    *this = ::std::move(from);
  }

  inline TailRobotPartLogsResponse& operator=(const TailRobotPartLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailRobotPartLogsResponse& operator=(TailRobotPartLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailRobotPartLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailRobotPartLogsResponse* internal_default_instance() {
    return reinterpret_cast<const TailRobotPartLogsResponse*>(
               &_TailRobotPartLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TailRobotPartLogsResponse& a, TailRobotPartLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TailRobotPartLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailRobotPartLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailRobotPartLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailRobotPartLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailRobotPartLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TailRobotPartLogsResponse& from) {
    TailRobotPartLogsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailRobotPartLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.TailRobotPartLogsResponse";
  }
  protected:
  explicit TailRobotPartLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
  };
  // repeated .viam.app.v1.LogEntry logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::viam::app::v1::LogEntry* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >*
      mutable_logs();
  private:
  const ::viam::app::v1::LogEntry& _internal_logs(int index) const;
  ::viam::app::v1::LogEntry* _internal_add_logs();
  public:
  const ::viam::app::v1::LogEntry& logs(int index) const;
  ::viam::app::v1::LogEntry* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >&
      logs() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.TailRobotPartLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry > logs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartHistoryRequest) */ {
 public:
  inline GetRobotPartHistoryRequest() : GetRobotPartHistoryRequest(nullptr) {}
  ~GetRobotPartHistoryRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartHistoryRequest(const GetRobotPartHistoryRequest& from);
  GetRobotPartHistoryRequest(GetRobotPartHistoryRequest&& from) noexcept
    : GetRobotPartHistoryRequest() {
    *this = ::std::move(from);
  }

  inline GetRobotPartHistoryRequest& operator=(const GetRobotPartHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartHistoryRequest& operator=(GetRobotPartHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartHistoryRequest*>(
               &_GetRobotPartHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetRobotPartHistoryRequest& a, GetRobotPartHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartHistoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartHistoryRequest& from) {
    GetRobotPartHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartHistoryRequest";
  }
  protected:
  explicit GetRobotPartHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class GetRobotPartHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.GetRobotPartHistoryResponse) */ {
 public:
  inline GetRobotPartHistoryResponse() : GetRobotPartHistoryResponse(nullptr) {}
  ~GetRobotPartHistoryResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRobotPartHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRobotPartHistoryResponse(const GetRobotPartHistoryResponse& from);
  GetRobotPartHistoryResponse(GetRobotPartHistoryResponse&& from) noexcept
    : GetRobotPartHistoryResponse() {
    *this = ::std::move(from);
  }

  inline GetRobotPartHistoryResponse& operator=(const GetRobotPartHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRobotPartHistoryResponse& operator=(GetRobotPartHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRobotPartHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRobotPartHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const GetRobotPartHistoryResponse*>(
               &_GetRobotPartHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetRobotPartHistoryResponse& a, GetRobotPartHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRobotPartHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRobotPartHistoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRobotPartHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRobotPartHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRobotPartHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRobotPartHistoryResponse& from) {
    GetRobotPartHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRobotPartHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.GetRobotPartHistoryResponse";
  }
  protected:
  explicit GetRobotPartHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
  };
  // repeated .viam.app.v1.RobotPartHistoryEntry history = 1 [json_name = "history"];
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::viam::app::v1::RobotPartHistoryEntry* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >*
      mutable_history();
  private:
  const ::viam::app::v1::RobotPartHistoryEntry& _internal_history(int index) const;
  ::viam::app::v1::RobotPartHistoryEntry* _internal_add_history();
  public:
  const ::viam::app::v1::RobotPartHistoryEntry& history(int index) const;
  ::viam::app::v1::RobotPartHistoryEntry* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >&
      history() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.GetRobotPartHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry > history_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartRequest) */ {
 public:
  inline UpdateRobotPartRequest() : UpdateRobotPartRequest(nullptr) {}
  ~UpdateRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartRequest(const UpdateRobotPartRequest& from);
  UpdateRobotPartRequest(UpdateRobotPartRequest&& from) noexcept
    : UpdateRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartRequest& operator=(const UpdateRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartRequest& operator=(UpdateRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartRequest*>(
               &_UpdateRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UpdateRobotPartRequest& a, UpdateRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRobotPartRequest& from) {
    UpdateRobotPartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartRequest";
  }
  protected:
  explicit UpdateRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kRobotConfigFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct robot_config = 3 [json_name = "robotConfig"];
  bool has_robot_config() const;
  private:
  bool _internal_has_robot_config() const;
  public:
  void clear_robot_config();
  const ::PROTOBUF_NAMESPACE_ID::Struct& robot_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_robot_config();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_robot_config();
  void set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_robot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_robot_config();
  public:
  void unsafe_arena_set_allocated_robot_config(
      ::PROTOBUF_NAMESPACE_ID::Struct* robot_config);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_robot_config();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotPartResponse) */ {
 public:
  inline UpdateRobotPartResponse() : UpdateRobotPartResponse(nullptr) {}
  ~UpdateRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotPartResponse(const UpdateRobotPartResponse& from);
  UpdateRobotPartResponse(UpdateRobotPartResponse&& from) noexcept
    : UpdateRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotPartResponse& operator=(const UpdateRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotPartResponse& operator=(UpdateRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotPartResponse*>(
               &_UpdateRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(UpdateRobotPartResponse& a, UpdateRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRobotPartResponse& from) {
    UpdateRobotPartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotPartResponse";
  }
  protected:
  explicit UpdateRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::v1::RobotPart* part_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotPartRequest) */ {
 public:
  inline NewRobotPartRequest() : NewRobotPartRequest(nullptr) {}
  ~NewRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR NewRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotPartRequest(const NewRobotPartRequest& from);
  NewRobotPartRequest(NewRobotPartRequest&& from) noexcept
    : NewRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline NewRobotPartRequest& operator=(const NewRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotPartRequest& operator=(NewRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const NewRobotPartRequest*>(
               &_NewRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(NewRobotPartRequest& a, NewRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewRobotPartRequest& from) {
    NewRobotPartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotPartRequest";
  }
  protected:
  explicit NewRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
    kPartNameFieldNumber = 2,
  };
  // string robot_id = 1 [json_name = "robotId"];
  void clear_robot_id();
  const std::string& robot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robot_id();
  PROTOBUF_NODISCARD std::string* release_robot_id();
  void set_allocated_robot_id(std::string* robot_id);
  private:
  const std::string& _internal_robot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_id(const std::string& value);
  std::string* _internal_mutable_robot_id();
  public:

  // string part_name = 2 [json_name = "partName"];
  void clear_part_name();
  const std::string& part_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_name();
  PROTOBUF_NODISCARD std::string* release_part_name();
  void set_allocated_part_name(std::string* part_name);
  private:
  const std::string& _internal_part_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_name(const std::string& value);
  std::string* _internal_mutable_part_name();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotPartResponse) */ {
 public:
  inline NewRobotPartResponse() : NewRobotPartResponse(nullptr) {}
  ~NewRobotPartResponse() override;
  explicit PROTOBUF_CONSTEXPR NewRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotPartResponse(const NewRobotPartResponse& from);
  NewRobotPartResponse(NewRobotPartResponse&& from) noexcept
    : NewRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline NewRobotPartResponse& operator=(const NewRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotPartResponse& operator=(NewRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const NewRobotPartResponse*>(
               &_NewRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(NewRobotPartResponse& a, NewRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotPartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewRobotPartResponse& from) {
    NewRobotPartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotPartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotPartResponse";
  }
  protected:
  explicit NewRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartRequest) */ {
 public:
  inline DeleteRobotPartRequest() : DeleteRobotPartRequest(nullptr) {}
  ~DeleteRobotPartRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartRequest(const DeleteRobotPartRequest& from);
  DeleteRobotPartRequest(DeleteRobotPartRequest&& from) noexcept
    : DeleteRobotPartRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartRequest& operator=(const DeleteRobotPartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartRequest& operator=(DeleteRobotPartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartRequest*>(
               &_DeleteRobotPartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DeleteRobotPartRequest& a, DeleteRobotPartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotPartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRobotPartRequest& from) {
    DeleteRobotPartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotPartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartRequest";
  }
  protected:
  explicit DeleteRobotPartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartResponse) */ {
 public:
  inline DeleteRobotPartResponse() : DeleteRobotPartResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartResponse(const DeleteRobotPartResponse& from);
  DeleteRobotPartResponse(DeleteRobotPartResponse&& from) noexcept
    : DeleteRobotPartResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartResponse& operator=(const DeleteRobotPartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartResponse& operator=(DeleteRobotPartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartResponse*>(
               &_DeleteRobotPartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DeleteRobotPartResponse& a, DeleteRobotPartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotPartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotPartResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartResponse";
  }
  protected:
  explicit DeleteRobotPartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class Fragment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.Fragment) */ {
 public:
  inline Fragment() : Fragment(nullptr) {}
  ~Fragment() override;
  explicit PROTOBUF_CONSTEXPR Fragment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fragment(const Fragment& from);
  Fragment(Fragment&& from) noexcept
    : Fragment() {
    *this = ::std::move(from);
  }

  inline Fragment& operator=(const Fragment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fragment& operator=(Fragment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fragment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fragment* internal_default_instance() {
    return reinterpret_cast<const Fragment*>(
               &_Fragment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Fragment& a, Fragment& b) {
    a.Swap(&b);
  }
  inline void Swap(Fragment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fragment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fragment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fragment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fragment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fragment& from) {
    Fragment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fragment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.Fragment";
  }
  protected:
  explicit Fragment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kOrganizationOwnerFieldNumber = 4,
    kFragmentFieldNumber = 3,
    kCreatedOnFieldNumber = 6,
    kPublicFieldNumber = 5,
  };
  // string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string organization_owner = 4 [json_name = "organizationOwner", (.tagger.v1.tags) = "bson:\"organization_owner\" json:\"owner\""];
  void clear_organization_owner();
  const std::string& organization_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_owner();
  PROTOBUF_NODISCARD std::string* release_organization_owner();
  void set_allocated_organization_owner(std::string* organization_owner);
  private:
  const std::string& _internal_organization_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_owner(const std::string& value);
  std::string* _internal_mutable_organization_owner();
  public:

  // .google.protobuf.Struct fragment = 3 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
  bool has_fragment() const;
  private:
  bool _internal_has_fragment() const;
  public:
  void clear_fragment();
  const ::PROTOBUF_NAMESPACE_ID::Struct& fragment() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_fragment();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_fragment();
  void set_allocated_fragment(::PROTOBUF_NAMESPACE_ID::Struct* fragment);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_fragment() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_fragment();
  public:
  void unsafe_arena_set_allocated_fragment(
      ::PROTOBUF_NAMESPACE_ID::Struct* fragment);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_fragment();

  // .google.protobuf.Timestamp created_on = 6 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
  bool has_created_on() const;
  private:
  bool _internal_has_created_on() const;
  public:
  void clear_created_on();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_on() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_on();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_on();
  void set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_on() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_on();
  public:
  void unsafe_arena_set_allocated_created_on(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_on();

  // bool public = 5 [json_name = "public", (.tagger.v1.tags) = "bson:\"public\" json:\"public\""];
  void clear_public_();
  bool public_() const;
  void set_public_(bool value);
  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.Fragment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_owner_;
    ::PROTOBUF_NAMESPACE_ID::Struct* fragment_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on_;
    bool public__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FindRobotsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FindRobotsRequest) */ {
 public:
  inline FindRobotsRequest() : FindRobotsRequest(nullptr) {}
  ~FindRobotsRequest() override;
  explicit PROTOBUF_CONSTEXPR FindRobotsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindRobotsRequest(const FindRobotsRequest& from);
  FindRobotsRequest(FindRobotsRequest&& from) noexcept
    : FindRobotsRequest() {
    *this = ::std::move(from);
  }

  inline FindRobotsRequest& operator=(const FindRobotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindRobotsRequest& operator=(FindRobotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindRobotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindRobotsRequest* internal_default_instance() {
    return reinterpret_cast<const FindRobotsRequest*>(
               &_FindRobotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FindRobotsRequest& a, FindRobotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindRobotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindRobotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindRobotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindRobotsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindRobotsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindRobotsRequest& from) {
    FindRobotsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindRobotsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FindRobotsRequest";
  }
  protected:
  explicit FindRobotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationIdFieldNumber = 1,
  };
  // string location_id = 1 [json_name = "locationId"];
  void clear_location_id();
  const std::string& location_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location_id();
  PROTOBUF_NODISCARD std::string* release_location_id();
  void set_allocated_location_id(std::string* location_id);
  private:
  const std::string& _internal_location_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location_id(const std::string& value);
  std::string* _internal_mutable_location_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.FindRobotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class FindRobotsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.FindRobotsResponse) */ {
 public:
  inline FindRobotsResponse() : FindRobotsResponse(nullptr) {}
  ~FindRobotsResponse() override;
  explicit PROTOBUF_CONSTEXPR FindRobotsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindRobotsResponse(const FindRobotsResponse& from);
  FindRobotsResponse(FindRobotsResponse&& from) noexcept
    : FindRobotsResponse() {
    *this = ::std::move(from);
  }

  inline FindRobotsResponse& operator=(const FindRobotsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindRobotsResponse& operator=(FindRobotsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindRobotsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindRobotsResponse* internal_default_instance() {
    return reinterpret_cast<const FindRobotsResponse*>(
               &_FindRobotsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(FindRobotsResponse& a, FindRobotsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FindRobotsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindRobotsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindRobotsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindRobotsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindRobotsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindRobotsResponse& from) {
    FindRobotsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindRobotsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.FindRobotsResponse";
  }
  protected:
  explicit FindRobotsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsFieldNumber = 1,
  };
  // repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
  int robots_size() const;
  private:
  int _internal_robots_size() const;
  public:
  void clear_robots();
  ::viam::app::v1::Robot* mutable_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
      mutable_robots();
  private:
  const ::viam::app::v1::Robot& _internal_robots(int index) const;
  ::viam::app::v1::Robot* _internal_add_robots();
  public:
  const ::viam::app::v1::Robot& robots(int index) const;
  ::viam::app::v1::Robot* add_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
      robots() const;

  // @@protoc_insertion_point(class_scope:viam.app.v1.FindRobotsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot > robots_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotRequest) */ {
 public:
  inline NewRobotRequest() : NewRobotRequest(nullptr) {}
  ~NewRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR NewRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotRequest(const NewRobotRequest& from);
  NewRobotRequest(NewRobotRequest&& from) noexcept
    : NewRobotRequest() {
    *this = ::std::move(from);
  }

  inline NewRobotRequest& operator=(const NewRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotRequest& operator=(NewRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotRequest* internal_default_instance() {
    return reinterpret_cast<const NewRobotRequest*>(
               &_NewRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(NewRobotRequest& a, NewRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewRobotRequest& from) {
    NewRobotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotRequest";
  }
  protected:
  explicit NewRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 2 [json_name = "location"];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class NewRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.NewRobotResponse) */ {
 public:
  inline NewRobotResponse() : NewRobotResponse(nullptr) {}
  ~NewRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR NewRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewRobotResponse(const NewRobotResponse& from);
  NewRobotResponse(NewRobotResponse&& from) noexcept
    : NewRobotResponse() {
    *this = ::std::move(from);
  }

  inline NewRobotResponse& operator=(const NewRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRobotResponse& operator=(NewRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewRobotResponse* internal_default_instance() {
    return reinterpret_cast<const NewRobotResponse*>(
               &_NewRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(NewRobotResponse& a, NewRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewRobotResponse& from) {
    NewRobotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.NewRobotResponse";
  }
  protected:
  explicit NewRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.NewRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotRequest) */ {
 public:
  inline UpdateRobotRequest() : UpdateRobotRequest(nullptr) {}
  ~UpdateRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotRequest(const UpdateRobotRequest& from);
  UpdateRobotRequest(UpdateRobotRequest&& from) noexcept
    : UpdateRobotRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRobotRequest& operator=(const UpdateRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotRequest& operator=(UpdateRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotRequest*>(
               &_UpdateRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(UpdateRobotRequest& a, UpdateRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRobotRequest& from) {
    UpdateRobotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotRequest";
  }
  protected:
  explicit UpdateRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLocationFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 3 [json_name = "location"];
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class UpdateRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.UpdateRobotResponse) */ {
 public:
  inline UpdateRobotResponse() : UpdateRobotResponse(nullptr) {}
  ~UpdateRobotResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRobotResponse(const UpdateRobotResponse& from);
  UpdateRobotResponse(UpdateRobotResponse&& from) noexcept
    : UpdateRobotResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRobotResponse& operator=(const UpdateRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRobotResponse& operator=(UpdateRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRobotResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRobotResponse*>(
               &_UpdateRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(UpdateRobotResponse& a, UpdateRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRobotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRobotResponse& from) {
    UpdateRobotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRobotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.UpdateRobotResponse";
  }
  protected:
  explicit UpdateRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // .viam.app.v1.Robot robot = 1 [json_name = "robot"];
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::viam::app::v1::Robot& robot() const;
  PROTOBUF_NODISCARD ::viam::app::v1::Robot* release_robot();
  ::viam::app::v1::Robot* mutable_robot();
  void set_allocated_robot(::viam::app::v1::Robot* robot);
  private:
  const ::viam::app::v1::Robot& _internal_robot() const;
  ::viam::app::v1::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::viam::app::v1::Robot* robot);
  ::viam::app::v1::Robot* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:viam.app.v1.UpdateRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::v1::Robot* robot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotRequest) */ {
 public:
  inline DeleteRobotRequest() : DeleteRobotRequest(nullptr) {}
  ~DeleteRobotRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotRequest(const DeleteRobotRequest& from);
  DeleteRobotRequest(DeleteRobotRequest&& from) noexcept
    : DeleteRobotRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotRequest& operator=(const DeleteRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotRequest& operator=(DeleteRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotRequest*>(
               &_DeleteRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(DeleteRobotRequest& a, DeleteRobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRobotRequest& from) {
    DeleteRobotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotRequest";
  }
  protected:
  explicit DeleteRobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotResponse) */ {
 public:
  inline DeleteRobotResponse() : DeleteRobotResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotResponse(const DeleteRobotResponse& from);
  DeleteRobotResponse(DeleteRobotResponse&& from) noexcept
    : DeleteRobotResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotResponse& operator=(const DeleteRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotResponse& operator=(DeleteRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotResponse*>(
               &_DeleteRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DeleteRobotResponse& a, DeleteRobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotResponse";
  }
  protected:
  explicit DeleteRobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartAsMainRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartAsMainRequest) */ {
 public:
  inline MarkPartAsMainRequest() : MarkPartAsMainRequest(nullptr) {}
  ~MarkPartAsMainRequest() override;
  explicit PROTOBUF_CONSTEXPR MarkPartAsMainRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartAsMainRequest(const MarkPartAsMainRequest& from);
  MarkPartAsMainRequest(MarkPartAsMainRequest&& from) noexcept
    : MarkPartAsMainRequest() {
    *this = ::std::move(from);
  }

  inline MarkPartAsMainRequest& operator=(const MarkPartAsMainRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartAsMainRequest& operator=(MarkPartAsMainRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartAsMainRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartAsMainRequest* internal_default_instance() {
    return reinterpret_cast<const MarkPartAsMainRequest*>(
               &_MarkPartAsMainRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(MarkPartAsMainRequest& a, MarkPartAsMainRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartAsMainRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartAsMainRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartAsMainRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartAsMainRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkPartAsMainRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarkPartAsMainRequest& from) {
    MarkPartAsMainRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkPartAsMainRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartAsMainRequest";
  }
  protected:
  explicit MarkPartAsMainRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartAsMainRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class MarkPartAsMainResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.MarkPartAsMainResponse) */ {
 public:
  inline MarkPartAsMainResponse() : MarkPartAsMainResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MarkPartAsMainResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkPartAsMainResponse(const MarkPartAsMainResponse& from);
  MarkPartAsMainResponse(MarkPartAsMainResponse&& from) noexcept
    : MarkPartAsMainResponse() {
    *this = ::std::move(from);
  }

  inline MarkPartAsMainResponse& operator=(const MarkPartAsMainResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkPartAsMainResponse& operator=(MarkPartAsMainResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkPartAsMainResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkPartAsMainResponse* internal_default_instance() {
    return reinterpret_cast<const MarkPartAsMainResponse*>(
               &_MarkPartAsMainResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(MarkPartAsMainResponse& a, MarkPartAsMainResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkPartAsMainResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkPartAsMainResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkPartAsMainResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkPartAsMainResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MarkPartAsMainResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MarkPartAsMainResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.MarkPartAsMainResponse";
  }
  protected:
  explicit MarkPartAsMainResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.MarkPartAsMainResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRobotPartSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRobotPartSecretRequest) */ {
 public:
  inline CreateRobotPartSecretRequest() : CreateRobotPartSecretRequest(nullptr) {}
  ~CreateRobotPartSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRobotPartSecretRequest(const CreateRobotPartSecretRequest& from);
  CreateRobotPartSecretRequest(CreateRobotPartSecretRequest&& from) noexcept
    : CreateRobotPartSecretRequest() {
    *this = ::std::move(from);
  }

  inline CreateRobotPartSecretRequest& operator=(const CreateRobotPartSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRobotPartSecretRequest& operator=(CreateRobotPartSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRobotPartSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRobotPartSecretRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRobotPartSecretRequest*>(
               &_CreateRobotPartSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CreateRobotPartSecretRequest& a, CreateRobotPartSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRobotPartSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRobotPartSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRobotPartSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRobotPartSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRobotPartSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRobotPartSecretRequest& from) {
    CreateRobotPartSecretRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRobotPartSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRobotPartSecretRequest";
  }
  protected:
  explicit CreateRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRobotPartSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class CreateRobotPartSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.CreateRobotPartSecretResponse) */ {
 public:
  inline CreateRobotPartSecretResponse() : CreateRobotPartSecretResponse(nullptr) {}
  ~CreateRobotPartSecretResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRobotPartSecretResponse(const CreateRobotPartSecretResponse& from);
  CreateRobotPartSecretResponse(CreateRobotPartSecretResponse&& from) noexcept
    : CreateRobotPartSecretResponse() {
    *this = ::std::move(from);
  }

  inline CreateRobotPartSecretResponse& operator=(const CreateRobotPartSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRobotPartSecretResponse& operator=(CreateRobotPartSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRobotPartSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRobotPartSecretResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRobotPartSecretResponse*>(
               &_CreateRobotPartSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CreateRobotPartSecretResponse& a, CreateRobotPartSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRobotPartSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRobotPartSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRobotPartSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRobotPartSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRobotPartSecretResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRobotPartSecretResponse& from) {
    CreateRobotPartSecretResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRobotPartSecretResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.CreateRobotPartSecretResponse";
  }
  protected:
  explicit CreateRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartFieldNumber = 1,
  };
  // .viam.app.v1.RobotPart part = 1 [json_name = "part"];
  bool has_part() const;
  private:
  bool _internal_has_part() const;
  public:
  void clear_part();
  const ::viam::app::v1::RobotPart& part() const;
  PROTOBUF_NODISCARD ::viam::app::v1::RobotPart* release_part();
  ::viam::app::v1::RobotPart* mutable_part();
  void set_allocated_part(::viam::app::v1::RobotPart* part);
  private:
  const ::viam::app::v1::RobotPart& _internal_part() const;
  ::viam::app::v1::RobotPart* _internal_mutable_part();
  public:
  void unsafe_arena_set_allocated_part(
      ::viam::app::v1::RobotPart* part);
  ::viam::app::v1::RobotPart* unsafe_arena_release_part();

  // @@protoc_insertion_point(class_scope:viam.app.v1.CreateRobotPartSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::app::v1::RobotPart* part_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartSecretRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartSecretRequest) */ {
 public:
  inline DeleteRobotPartSecretRequest() : DeleteRobotPartSecretRequest(nullptr) {}
  ~DeleteRobotPartSecretRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartSecretRequest(const DeleteRobotPartSecretRequest& from);
  DeleteRobotPartSecretRequest(DeleteRobotPartSecretRequest&& from) noexcept
    : DeleteRobotPartSecretRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartSecretRequest& operator=(const DeleteRobotPartSecretRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartSecretRequest& operator=(DeleteRobotPartSecretRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartSecretRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartSecretRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartSecretRequest*>(
               &_DeleteRobotPartSecretRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(DeleteRobotPartSecretRequest& a, DeleteRobotPartSecretRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartSecretRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartSecretRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartSecretRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartSecretRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRobotPartSecretRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRobotPartSecretRequest& from) {
    DeleteRobotPartSecretRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRobotPartSecretRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartSecretRequest";
  }
  protected:
  explicit DeleteRobotPartSecretRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIdFieldNumber = 1,
    kSecretIdFieldNumber = 2,
  };
  // string part_id = 1 [json_name = "partId"];
  void clear_part_id();
  const std::string& part_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_id();
  PROTOBUF_NODISCARD std::string* release_part_id();
  void set_allocated_part_id(std::string* part_id);
  private:
  const std::string& _internal_part_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_id(const std::string& value);
  std::string* _internal_mutable_part_id();
  public:

  // string secret_id = 2 [json_name = "secretId"];
  void clear_secret_id();
  const std::string& secret_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* secret_id);
  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(const std::string& value);
  std::string* _internal_mutable_secret_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartSecretRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// -------------------------------------------------------------------

class DeleteRobotPartSecretResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.app.v1.DeleteRobotPartSecretResponse) */ {
 public:
  inline DeleteRobotPartSecretResponse() : DeleteRobotPartSecretResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRobotPartSecretResponse(const DeleteRobotPartSecretResponse& from);
  DeleteRobotPartSecretResponse(DeleteRobotPartSecretResponse&& from) noexcept
    : DeleteRobotPartSecretResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRobotPartSecretResponse& operator=(const DeleteRobotPartSecretResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRobotPartSecretResponse& operator=(DeleteRobotPartSecretResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRobotPartSecretResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRobotPartSecretResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRobotPartSecretResponse*>(
               &_DeleteRobotPartSecretResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(DeleteRobotPartSecretResponse& a, DeleteRobotPartSecretResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRobotPartSecretResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRobotPartSecretResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRobotPartSecretResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRobotPartSecretResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRobotPartSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRobotPartSecretResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.app.v1.DeleteRobotPartSecretResponse";
  }
  protected:
  explicit DeleteRobotPartSecretResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.app.v1.DeleteRobotPartSecretResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_app_2fv1_2fapp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Robot

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void Robot::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Robot::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.id)
}
inline std::string* Robot::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.id)
  return _s;
}
inline const std::string& Robot::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Robot::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.id)
  return _impl_.id_.Release();
}
inline void Robot::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void Robot::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Robot::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.name)
}
inline std::string* Robot::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.name)
  return _s;
}
inline const std::string& Robot::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Robot::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.name)
  return _impl_.name_.Release();
}
inline void Robot::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.name)
}

// string location = 3 [json_name = "location", (.tagger.v1.tags) = "bson:\"location\" json:\"location\""];
inline void Robot::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& Robot::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Robot.location)
}
inline std::string* Robot::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.location)
  return _s;
}
inline const std::string& Robot::_internal_location() const {
  return _impl_.location_.Get();
}
inline void Robot::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* Robot::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.location)
  return _impl_.location_.Release();
}
inline void Robot::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.location)
}

// .google.protobuf.Timestamp last_access = 4 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
inline bool Robot::_internal_has_last_access() const {
  return this != internal_default_instance() && _impl_.last_access_ != nullptr;
}
inline bool Robot::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.last_access)
  return _internal_last_access();
}
inline void Robot::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_access_);
  }
  _impl_.last_access_ = last_access;
  if (last_access) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Robot.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::release_last_access() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_access_;
  _impl_.last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.last_access)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_access_;
  _impl_.last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::_internal_mutable_last_access() {
  
  if (_impl_.last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_access_ = p;
  }
  return _impl_.last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.last_access)
  return _msg;
}
inline void Robot::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.last_access)
}

// .google.protobuf.Timestamp created_on = 5 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool Robot::_internal_has_created_on() const {
  return this != internal_default_instance() && _impl_.created_on_ != nullptr;
}
inline bool Robot::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Robot::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Robot.created_on)
  return _internal_created_on();
}
inline void Robot::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  _impl_.created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Robot.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Robot.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::_internal_mutable_created_on() {
  
  if (_impl_.created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_on_ = p;
  }
  return _impl_.created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Robot::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Robot.created_on)
  return _msg;
}
inline void Robot::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Robot.created_on)
}

// -------------------------------------------------------------------

// RobotPart

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void RobotPart::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RobotPart::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.id)
}
inline std::string* RobotPart::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.id)
  return _s;
}
inline const std::string& RobotPart::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RobotPart::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.id)
  return _impl_.id_.Release();
}
inline void RobotPart::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void RobotPart::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RobotPart::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.name)
}
inline std::string* RobotPart::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.name)
  return _s;
}
inline const std::string& RobotPart::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RobotPart::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.name)
  return _impl_.name_.Release();
}
inline void RobotPart::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.name)
}

// string dns_name = 10 [json_name = "dnsName", (.tagger.v1.tags) = "bson:\"dns_name\" json:\"dns_name\""];
inline void RobotPart::clear_dns_name() {
  _impl_.dns_name_.ClearToEmpty();
}
inline const std::string& RobotPart::dns_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.dns_name)
  return _internal_dns_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_dns_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dns_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.dns_name)
}
inline std::string* RobotPart::mutable_dns_name() {
  std::string* _s = _internal_mutable_dns_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.dns_name)
  return _s;
}
inline const std::string& RobotPart::_internal_dns_name() const {
  return _impl_.dns_name_.Get();
}
inline void RobotPart::_internal_set_dns_name(const std::string& value) {
  
  _impl_.dns_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_dns_name() {
  
  return _impl_.dns_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_dns_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.dns_name)
  return _impl_.dns_name_.Release();
}
inline void RobotPart::set_allocated_dns_name(std::string* dns_name) {
  if (dns_name != nullptr) {
    
  } else {
    
  }
  _impl_.dns_name_.SetAllocated(dns_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dns_name_.IsDefault()) {
    _impl_.dns_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.dns_name)
}

// string secret = 3 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\" json:\"secret,omitempty\""];
inline void RobotPart::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& RobotPart::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.secret)
}
inline std::string* RobotPart::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.secret)
  return _s;
}
inline const std::string& RobotPart::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void RobotPart::_internal_set_secret(const std::string& value) {
  
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_secret() {
  
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.secret)
  return _impl_.secret_.Release();
}
inline void RobotPart::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.secret)
}

// string robot = 4 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
inline void RobotPart::clear_robot() {
  _impl_.robot_.ClearToEmpty();
}
inline const std::string& RobotPart::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.robot)
  return _internal_robot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_robot(ArgT0&& arg0, ArgT... args) {
 
 _impl_.robot_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.robot)
}
inline std::string* RobotPart::mutable_robot() {
  std::string* _s = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.robot)
  return _s;
}
inline const std::string& RobotPart::_internal_robot() const {
  return _impl_.robot_.Get();
}
inline void RobotPart::_internal_set_robot(const std::string& value) {
  
  _impl_.robot_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_robot() {
  
  return _impl_.robot_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.robot)
  return _impl_.robot_.Release();
}
inline void RobotPart::set_allocated_robot(std::string* robot) {
  if (robot != nullptr) {
    
  } else {
    
  }
  _impl_.robot_.SetAllocated(robot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.robot_.IsDefault()) {
    _impl_.robot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.robot)
}

// string location_id = 12 [json_name = "locationId", (.tagger.v1.tags) = "bson:\"location_id\" json:\"-\""];
inline void RobotPart::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& RobotPart::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.location_id)
}
inline std::string* RobotPart::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.location_id)
  return _s;
}
inline const std::string& RobotPart::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void RobotPart::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.location_id)
  return _impl_.location_id_.Release();
}
inline void RobotPart::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.location_id)
}

// .google.protobuf.Struct robot_config = 5 [json_name = "robotConfig", (.tagger.v1.tags) = "bson:\"config\" json:\"robot_config\""];
inline bool RobotPart::_internal_has_robot_config() const {
  return this != internal_default_instance() && _impl_.robot_config_ != nullptr;
}
inline bool RobotPart::has_robot_config() const {
  return _internal_has_robot_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::_internal_robot_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.robot_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::robot_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.robot_config)
  return _internal_robot_config();
}
inline void RobotPart::unsafe_arena_set_allocated_robot_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_config_);
  }
  _impl_.robot_config_ = robot_config;
  if (robot_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.robot_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::release_robot_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.robot_config_;
  _impl_.robot_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::unsafe_arena_release_robot_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.robot_config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.robot_config_;
  _impl_.robot_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::_internal_mutable_robot_config() {
  
  if (_impl_.robot_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.robot_config_ = p;
  }
  return _impl_.robot_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::mutable_robot_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_robot_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.robot_config)
  return _msg;
}
inline void RobotPart::set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_config_);
  }
  if (robot_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config));
    if (message_arena != submessage_arena) {
      robot_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_config_ = robot_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.robot_config)
}

// .google.protobuf.Timestamp last_access = 6 [json_name = "lastAccess", (.tagger.v1.tags) = "bson:\"last_access\" json:\"last_access\""];
inline bool RobotPart::_internal_has_last_access() const {
  return this != internal_default_instance() && _impl_.last_access_ != nullptr;
}
inline bool RobotPart::has_last_access() const {
  return _internal_has_last_access();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::_internal_last_access() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::last_access() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.last_access)
  return _internal_last_access();
}
inline void RobotPart::unsafe_arena_set_allocated_last_access(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_access_);
  }
  _impl_.last_access_ = last_access;
  if (last_access) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.last_access)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::release_last_access() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_access_;
  _impl_.last_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::unsafe_arena_release_last_access() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.last_access)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_access_;
  _impl_.last_access_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::_internal_mutable_last_access() {
  
  if (_impl_.last_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_access_ = p;
  }
  return _impl_.last_access_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::mutable_last_access() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_access();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.last_access)
  return _msg;
}
inline void RobotPart::set_allocated_last_access(::PROTOBUF_NAMESPACE_ID::Timestamp* last_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_access_);
  }
  if (last_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_access));
    if (message_arena != submessage_arena) {
      last_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_access, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_access_ = last_access;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.last_access)
}

// .google.protobuf.Struct user_supplied_info = 7 [json_name = "userSuppliedInfo", (.tagger.v1.tags) = "bson:\"user_supplied_info\" json:\"user_supplied_info\""];
inline bool RobotPart::_internal_has_user_supplied_info() const {
  return this != internal_default_instance() && _impl_.user_supplied_info_ != nullptr;
}
inline bool RobotPart::has_user_supplied_info() const {
  return _internal_has_user_supplied_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::_internal_user_supplied_info() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.user_supplied_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RobotPart::user_supplied_info() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.user_supplied_info)
  return _internal_user_supplied_info();
}
inline void RobotPart::unsafe_arena_set_allocated_user_supplied_info(
    ::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_supplied_info_);
  }
  _impl_.user_supplied_info_ = user_supplied_info;
  if (user_supplied_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.user_supplied_info)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::release_user_supplied_info() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.user_supplied_info_;
  _impl_.user_supplied_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::unsafe_arena_release_user_supplied_info() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.user_supplied_info)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.user_supplied_info_;
  _impl_.user_supplied_info_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::_internal_mutable_user_supplied_info() {
  
  if (_impl_.user_supplied_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.user_supplied_info_ = p;
  }
  return _impl_.user_supplied_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RobotPart::mutable_user_supplied_info() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_user_supplied_info();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.user_supplied_info)
  return _msg;
}
inline void RobotPart::set_allocated_user_supplied_info(::PROTOBUF_NAMESPACE_ID::Struct* user_supplied_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_supplied_info_);
  }
  if (user_supplied_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_supplied_info));
    if (message_arena != submessage_arena) {
      user_supplied_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_supplied_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_supplied_info_ = user_supplied_info;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.user_supplied_info)
}

// bool main_part = 8 [json_name = "mainPart", (.tagger.v1.tags) = "bson:\"main_part\" json:\"main_part\""];
inline void RobotPart::clear_main_part() {
  _impl_.main_part_ = false;
}
inline bool RobotPart::_internal_main_part() const {
  return _impl_.main_part_;
}
inline bool RobotPart::main_part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.main_part)
  return _internal_main_part();
}
inline void RobotPart::_internal_set_main_part(bool value) {
  
  _impl_.main_part_ = value;
}
inline void RobotPart::set_main_part(bool value) {
  _internal_set_main_part(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.main_part)
}

// string fqdn = 9 [json_name = "fqdn"];
inline void RobotPart::clear_fqdn() {
  _impl_.fqdn_.ClearToEmpty();
}
inline const std::string& RobotPart::fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.fqdn)
  return _internal_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_fqdn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.fqdn)
}
inline std::string* RobotPart::mutable_fqdn() {
  std::string* _s = _internal_mutable_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.fqdn)
  return _s;
}
inline const std::string& RobotPart::_internal_fqdn() const {
  return _impl_.fqdn_.Get();
}
inline void RobotPart::_internal_set_fqdn(const std::string& value) {
  
  _impl_.fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_fqdn() {
  
  return _impl_.fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.fqdn)
  return _impl_.fqdn_.Release();
}
inline void RobotPart::set_allocated_fqdn(std::string* fqdn) {
  if (fqdn != nullptr) {
    
  } else {
    
  }
  _impl_.fqdn_.SetAllocated(fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fqdn_.IsDefault()) {
    _impl_.fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.fqdn)
}

// string local_fqdn = 11 [json_name = "localFqdn"];
inline void RobotPart::clear_local_fqdn() {
  _impl_.local_fqdn_.ClearToEmpty();
}
inline const std::string& RobotPart::local_fqdn() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.local_fqdn)
  return _internal_local_fqdn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPart::set_local_fqdn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_fqdn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPart.local_fqdn)
}
inline std::string* RobotPart::mutable_local_fqdn() {
  std::string* _s = _internal_mutable_local_fqdn();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.local_fqdn)
  return _s;
}
inline const std::string& RobotPart::_internal_local_fqdn() const {
  return _impl_.local_fqdn_.Get();
}
inline void RobotPart::_internal_set_local_fqdn(const std::string& value) {
  
  _impl_.local_fqdn_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPart::_internal_mutable_local_fqdn() {
  
  return _impl_.local_fqdn_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPart::release_local_fqdn() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.local_fqdn)
  return _impl_.local_fqdn_.Release();
}
inline void RobotPart::set_allocated_local_fqdn(std::string* local_fqdn) {
  if (local_fqdn != nullptr) {
    
  } else {
    
  }
  _impl_.local_fqdn_.SetAllocated(local_fqdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_fqdn_.IsDefault()) {
    _impl_.local_fqdn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.local_fqdn)
}

// .google.protobuf.Timestamp created_on = 13 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool RobotPart::_internal_has_created_on() const {
  return this != internal_default_instance() && _impl_.created_on_ != nullptr;
}
inline bool RobotPart::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPart::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.created_on)
  return _internal_created_on();
}
inline void RobotPart::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  _impl_.created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPart.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPart.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::_internal_mutable_created_on() {
  
  if (_impl_.created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_on_ = p;
  }
  return _impl_.created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPart::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.created_on)
  return _msg;
}
inline void RobotPart::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPart.created_on)
}

// repeated .viam.app.v1.SharedSecret secrets = 14 [json_name = "secrets", (.tagger.v1.tags) = "bson:\"secrets\""];
inline int RobotPart::_internal_secrets_size() const {
  return _impl_.secrets_.size();
}
inline int RobotPart::secrets_size() const {
  return _internal_secrets_size();
}
inline void RobotPart::clear_secrets() {
  _impl_.secrets_.Clear();
}
inline ::viam::app::v1::SharedSecret* RobotPart::mutable_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPart.secrets)
  return _impl_.secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
RobotPart::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.RobotPart.secrets)
  return &_impl_.secrets_;
}
inline const ::viam::app::v1::SharedSecret& RobotPart::_internal_secrets(int index) const {
  return _impl_.secrets_.Get(index);
}
inline const ::viam::app::v1::SharedSecret& RobotPart::secrets(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPart.secrets)
  return _internal_secrets(index);
}
inline ::viam::app::v1::SharedSecret* RobotPart::_internal_add_secrets() {
  return _impl_.secrets_.Add();
}
inline ::viam::app::v1::SharedSecret* RobotPart::add_secrets() {
  ::viam::app::v1::SharedSecret* _add = _internal_add_secrets();
  // @@protoc_insertion_point(field_add:viam.app.v1.RobotPart.secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
RobotPart::secrets() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.RobotPart.secrets)
  return _impl_.secrets_;
}

// -------------------------------------------------------------------

// RobotPartHistoryEntry

// string part = 1 [json_name = "part", (.tagger.v1.tags) = "bson:\"part\" json:\"part\""];
inline void RobotPartHistoryEntry::clear_part() {
  _impl_.part_.ClearToEmpty();
}
inline const std::string& RobotPartHistoryEntry::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.part)
  return _internal_part();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPartHistoryEntry::set_part(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPartHistoryEntry.part)
}
inline std::string* RobotPartHistoryEntry::mutable_part() {
  std::string* _s = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.part)
  return _s;
}
inline const std::string& RobotPartHistoryEntry::_internal_part() const {
  return _impl_.part_.Get();
}
inline void RobotPartHistoryEntry::_internal_set_part(const std::string& value) {
  
  _impl_.part_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::_internal_mutable_part() {
  
  return _impl_.part_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.part)
  return _impl_.part_.Release();
}
inline void RobotPartHistoryEntry::set_allocated_part(std::string* part) {
  if (part != nullptr) {
    
  } else {
    
  }
  _impl_.part_.SetAllocated(part, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_.IsDefault()) {
    _impl_.part_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.part)
}

// string robot = 2 [json_name = "robot", (.tagger.v1.tags) = "bson:\"robot\" json:\"robot\""];
inline void RobotPartHistoryEntry::clear_robot() {
  _impl_.robot_.ClearToEmpty();
}
inline const std::string& RobotPartHistoryEntry::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.robot)
  return _internal_robot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotPartHistoryEntry::set_robot(ArgT0&& arg0, ArgT... args) {
 
 _impl_.robot_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.RobotPartHistoryEntry.robot)
}
inline std::string* RobotPartHistoryEntry::mutable_robot() {
  std::string* _s = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.robot)
  return _s;
}
inline const std::string& RobotPartHistoryEntry::_internal_robot() const {
  return _impl_.robot_.Get();
}
inline void RobotPartHistoryEntry::_internal_set_robot(const std::string& value) {
  
  _impl_.robot_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::_internal_mutable_robot() {
  
  return _impl_.robot_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotPartHistoryEntry::release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.robot)
  return _impl_.robot_.Release();
}
inline void RobotPartHistoryEntry::set_allocated_robot(std::string* robot) {
  if (robot != nullptr) {
    
  } else {
    
  }
  _impl_.robot_.SetAllocated(robot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.robot_.IsDefault()) {
    _impl_.robot_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.robot)
}

// .google.protobuf.Timestamp when = 3 [json_name = "when", (.tagger.v1.tags) = "bson:\"when\" json:\"when\""];
inline bool RobotPartHistoryEntry::_internal_has_when() const {
  return this != internal_default_instance() && _impl_.when_ != nullptr;
}
inline bool RobotPartHistoryEntry::has_when() const {
  return _internal_has_when();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPartHistoryEntry::_internal_when() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.when_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RobotPartHistoryEntry::when() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.when)
  return _internal_when();
}
inline void RobotPartHistoryEntry::unsafe_arena_set_allocated_when(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* when) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.when_);
  }
  _impl_.when_ = when;
  if (when) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPartHistoryEntry.when)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::release_when() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.when_;
  _impl_.when_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::unsafe_arena_release_when() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.when)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.when_;
  _impl_.when_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::_internal_mutable_when() {
  
  if (_impl_.when_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.when_ = p;
  }
  return _impl_.when_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RobotPartHistoryEntry::mutable_when() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_when();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.when)
  return _msg;
}
inline void RobotPartHistoryEntry::set_allocated_when(::PROTOBUF_NAMESPACE_ID::Timestamp* when) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.when_);
  }
  if (when) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(when));
    if (message_arena != submessage_arena) {
      when = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, when, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.when_ = when;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.when)
}

// .viam.app.v1.RobotPart old = 4 [json_name = "old", (.tagger.v1.tags) = "bson:\"old\" json:\"old\""];
inline bool RobotPartHistoryEntry::_internal_has_old() const {
  return this != internal_default_instance() && _impl_.old_ != nullptr;
}
inline bool RobotPartHistoryEntry::has_old() const {
  return _internal_has_old();
}
inline void RobotPartHistoryEntry::clear_old() {
  if (GetArenaForAllocation() == nullptr && _impl_.old_ != nullptr) {
    delete _impl_.old_;
  }
  _impl_.old_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& RobotPartHistoryEntry::_internal_old() const {
  const ::viam::app::v1::RobotPart* p = _impl_.old_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& RobotPartHistoryEntry::old() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.RobotPartHistoryEntry.old)
  return _internal_old();
}
inline void RobotPartHistoryEntry::unsafe_arena_set_allocated_old(
    ::viam::app::v1::RobotPart* old) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_);
  }
  _impl_.old_ = old;
  if (old) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.RobotPartHistoryEntry.old)
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::release_old() {
  
  ::viam::app::v1::RobotPart* temp = _impl_.old_;
  _impl_.old_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::unsafe_arena_release_old() {
  // @@protoc_insertion_point(field_release:viam.app.v1.RobotPartHistoryEntry.old)
  
  ::viam::app::v1::RobotPart* temp = _impl_.old_;
  _impl_.old_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::_internal_mutable_old() {
  
  if (_impl_.old_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    _impl_.old_ = p;
  }
  return _impl_.old_;
}
inline ::viam::app::v1::RobotPart* RobotPartHistoryEntry::mutable_old() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_old();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.RobotPartHistoryEntry.old)
  return _msg;
}
inline void RobotPartHistoryEntry::set_allocated_old(::viam::app::v1::RobotPart* old) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.old_;
  }
  if (old) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old);
    if (message_arena != submessage_arena) {
      old = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.old_ = old;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.RobotPartHistoryEntry.old)
}

// -------------------------------------------------------------------

// ListOrganizationsRequest

// -------------------------------------------------------------------

// Organization

// string id = 1 [json_name = "id"];
inline void Organization::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Organization::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.id)
}
inline std::string* Organization::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.id)
  return _s;
}
inline const std::string& Organization::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Organization::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.id)
  return _impl_.id_.Release();
}
inline void Organization::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.id)
}

// string name = 2 [json_name = "name"];
inline void Organization::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Organization::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Organization.name)
}
inline std::string* Organization::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.name)
  return _s;
}
inline const std::string& Organization::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Organization::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.name)
  return _impl_.name_.Release();
}
inline void Organization::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.name)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool Organization::_internal_has_created_on() const {
  return this != internal_default_instance() && _impl_.created_on_ != nullptr;
}
inline bool Organization::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Organization::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Organization::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Organization.created_on)
  return _internal_created_on();
}
inline void Organization::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  _impl_.created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Organization.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Organization.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::_internal_mutable_created_on() {
  
  if (_impl_.created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_on_ = p;
  }
  return _impl_.created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Organization::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Organization.created_on)
  return _msg;
}
inline void Organization::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Organization.created_on)
}

// -------------------------------------------------------------------

// ListOrganizationsResponse

// repeated .viam.app.v1.Organization organizations = 1 [json_name = "organizations"];
inline int ListOrganizationsResponse::_internal_organizations_size() const {
  return _impl_.organizations_.size();
}
inline int ListOrganizationsResponse::organizations_size() const {
  return _internal_organizations_size();
}
inline void ListOrganizationsResponse::clear_organizations() {
  _impl_.organizations_.Clear();
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::mutable_organizations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListOrganizationsResponse.organizations)
  return _impl_.organizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >*
ListOrganizationsResponse::mutable_organizations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListOrganizationsResponse.organizations)
  return &_impl_.organizations_;
}
inline const ::viam::app::v1::Organization& ListOrganizationsResponse::_internal_organizations(int index) const {
  return _impl_.organizations_.Get(index);
}
inline const ::viam::app::v1::Organization& ListOrganizationsResponse::organizations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListOrganizationsResponse.organizations)
  return _internal_organizations(index);
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::_internal_add_organizations() {
  return _impl_.organizations_.Add();
}
inline ::viam::app::v1::Organization* ListOrganizationsResponse::add_organizations() {
  ::viam::app::v1::Organization* _add = _internal_add_organizations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListOrganizationsResponse.organizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Organization >&
ListOrganizationsResponse::organizations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListOrganizationsResponse.organizations)
  return _impl_.organizations_;
}

// -------------------------------------------------------------------

// Location

// string id = 1 [json_name = "id"];
inline void Location::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Location::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.id)
}
inline std::string* Location::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.id)
  return _s;
}
inline const std::string& Location::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Location::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.id)
  return _impl_.id_.Release();
}
inline void Location::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.id)
}

// string name = 2 [json_name = "name"];
inline void Location::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Location::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Location.name)
}
inline std::string* Location::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.name)
  return _s;
}
inline const std::string& Location::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Location::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.name)
  return _impl_.name_.Release();
}
inline void Location::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.name)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn"];
inline bool Location::_internal_has_created_on() const {
  return this != internal_default_instance() && _impl_.created_on_ != nullptr;
}
inline bool Location::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Location::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Location::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Location.created_on)
  return _internal_created_on();
}
inline void Location::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  _impl_.created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Location.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Location.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::_internal_mutable_created_on() {
  
  if (_impl_.created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_on_ = p;
  }
  return _impl_.created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Location::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Location.created_on)
  return _msg;
}
inline void Location::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Location.created_on)
}

// -------------------------------------------------------------------

// CreateLocationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateLocationRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& CreateLocationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.organization_id)
}
inline std::string* CreateLocationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.organization_id)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void CreateLocationRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void CreateLocationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.organization_id)
}

// string name = 2 [json_name = "name"];
inline void CreateLocationRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateLocationRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationRequest.name)
}
inline std::string* CreateLocationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationRequest.name)
  return _s;
}
inline const std::string& CreateLocationRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateLocationRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationRequest.name)
  return _impl_.name_.Release();
}
inline void CreateLocationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationRequest.name)
}

// -------------------------------------------------------------------

// CreateLocationResponse

// .viam.app.v1.Location location = 1 [json_name = "location"];
inline bool CreateLocationResponse::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool CreateLocationResponse::has_location() const {
  return _internal_has_location();
}
inline void CreateLocationResponse::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::viam::app::v1::Location& CreateLocationResponse::_internal_location() const {
  const ::viam::app::v1::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Location&>(
      ::viam::app::v1::_Location_default_instance_);
}
inline const ::viam::app::v1::Location& CreateLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationResponse.location)
  return _internal_location();
}
inline void CreateLocationResponse::unsafe_arena_set_allocated_location(
    ::viam::app::v1::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateLocationResponse.location)
}
inline ::viam::app::v1::Location* CreateLocationResponse::release_location() {
  
  ::viam::app::v1::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Location* CreateLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationResponse.location)
  
  ::viam::app::v1::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Location* CreateLocationResponse::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Location>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::viam::app::v1::Location* CreateLocationResponse::mutable_location() {
  ::viam::app::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationResponse.location)
  return _msg;
}
inline void CreateLocationResponse::set_allocated_location(::viam::app::v1::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationResponse.location)
}

// -------------------------------------------------------------------

// ListLocationsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void ListLocationsRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& ListLocationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListLocationsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListLocationsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.ListLocationsRequest.organization_id)
}
inline std::string* ListLocationsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListLocationsRequest.organization_id)
  return _s;
}
inline const std::string& ListLocationsRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void ListLocationsRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListLocationsRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListLocationsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.ListLocationsRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void ListLocationsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.ListLocationsRequest.organization_id)
}

// -------------------------------------------------------------------

// ListLocationsResponse

// repeated .viam.app.v1.Location locations = 1 [json_name = "locations"];
inline int ListLocationsResponse::_internal_locations_size() const {
  return _impl_.locations_.size();
}
inline int ListLocationsResponse::locations_size() const {
  return _internal_locations_size();
}
inline void ListLocationsResponse::clear_locations() {
  _impl_.locations_.Clear();
}
inline ::viam::app::v1::Location* ListLocationsResponse::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.ListLocationsResponse.locations)
  return _impl_.locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >*
ListLocationsResponse::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.ListLocationsResponse.locations)
  return &_impl_.locations_;
}
inline const ::viam::app::v1::Location& ListLocationsResponse::_internal_locations(int index) const {
  return _impl_.locations_.Get(index);
}
inline const ::viam::app::v1::Location& ListLocationsResponse::locations(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.ListLocationsResponse.locations)
  return _internal_locations(index);
}
inline ::viam::app::v1::Location* ListLocationsResponse::_internal_add_locations() {
  return _impl_.locations_.Add();
}
inline ::viam::app::v1::Location* ListLocationsResponse::add_locations() {
  ::viam::app::v1::Location* _add = _internal_add_locations();
  // @@protoc_insertion_point(field_add:viam.app.v1.ListLocationsResponse.locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Location >&
ListLocationsResponse::locations() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.ListLocationsResponse.locations)
  return _impl_.locations_;
}

// -------------------------------------------------------------------

// CreateLocationSecretRequest

// string location_id = 1 [json_name = "locationId"];
inline void CreateLocationSecretRequest::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& CreateLocationSecretRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationSecretRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateLocationSecretRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateLocationSecretRequest.location_id)
}
inline std::string* CreateLocationSecretRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationSecretRequest.location_id)
  return _s;
}
inline const std::string& CreateLocationSecretRequest::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void CreateLocationSecretRequest::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateLocationSecretRequest::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateLocationSecretRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationSecretRequest.location_id)
  return _impl_.location_id_.Release();
}
inline void CreateLocationSecretRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationSecretRequest.location_id)
}

// -------------------------------------------------------------------

// CreateLocationSecretResponse

// .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
inline bool CreateLocationSecretResponse::_internal_has_auth() const {
  return this != internal_default_instance() && _impl_.auth_ != nullptr;
}
inline bool CreateLocationSecretResponse::has_auth() const {
  return _internal_has_auth();
}
inline void CreateLocationSecretResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && _impl_.auth_ != nullptr) {
    delete _impl_.auth_;
  }
  _impl_.auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& CreateLocationSecretResponse::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& CreateLocationSecretResponse::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateLocationSecretResponse.auth)
  return _internal_auth();
}
inline void CreateLocationSecretResponse::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateLocationSecretResponse.auth)
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateLocationSecretResponse.auth)
  
  ::viam::app::v1::LocationAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::_internal_mutable_auth() {
  
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    _impl_.auth_ = p;
  }
  return _impl_.auth_;
}
inline ::viam::app::v1::LocationAuth* CreateLocationSecretResponse::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateLocationSecretResponse.auth)
  return _msg;
}
inline void CreateLocationSecretResponse::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateLocationSecretResponse.auth)
}

// -------------------------------------------------------------------

// DeleteLocationSecretRequest

// string location_id = 1 [json_name = "locationId"];
inline void DeleteLocationSecretRequest::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationSecretRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationSecretRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationSecretRequest.location_id)
}
inline std::string* DeleteLocationSecretRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return _s;
}
inline const std::string& DeleteLocationSecretRequest::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void DeleteLocationSecretRequest::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationSecretRequest.location_id)
  return _impl_.location_id_.Release();
}
inline void DeleteLocationSecretRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationSecretRequest.location_id)
}

// string secret_id = 2 [json_name = "secretId"];
inline void DeleteLocationSecretRequest::clear_secret_id() {
  _impl_.secret_id_.ClearToEmpty();
}
inline const std::string& DeleteLocationSecretRequest::secret_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return _internal_secret_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteLocationSecretRequest::set_secret_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteLocationSecretRequest.secret_id)
}
inline std::string* DeleteLocationSecretRequest::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return _s;
}
inline const std::string& DeleteLocationSecretRequest::_internal_secret_id() const {
  return _impl_.secret_id_.Get();
}
inline void DeleteLocationSecretRequest::_internal_set_secret_id(const std::string& value) {
  
  _impl_.secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::_internal_mutable_secret_id() {
  
  return _impl_.secret_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteLocationSecretRequest::release_secret_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteLocationSecretRequest.secret_id)
  return _impl_.secret_id_.Release();
}
inline void DeleteLocationSecretRequest::set_allocated_secret_id(std::string* secret_id) {
  if (secret_id != nullptr) {
    
  } else {
    
  }
  _impl_.secret_id_.SetAllocated(secret_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_id_.IsDefault()) {
    _impl_.secret_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteLocationSecretRequest.secret_id)
}

// -------------------------------------------------------------------

// DeleteLocationSecretResponse

// -------------------------------------------------------------------

// LocationAuth

// string secret = 1 [json_name = "secret", deprecated = true];
inline void LocationAuth::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& LocationAuth::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuth::set_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuth.secret)
}
inline std::string* LocationAuth::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.secret)
  return _s;
}
inline const std::string& LocationAuth::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void LocationAuth::_internal_set_secret(const std::string& value) {
  
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuth::_internal_mutable_secret() {
  
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuth::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuth.secret)
  return _impl_.secret_.Release();
}
inline void LocationAuth::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuth.secret)
}

// string location_id = 2 [json_name = "locationId"];
inline void LocationAuth::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& LocationAuth::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuth::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuth.location_id)
}
inline std::string* LocationAuth::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.location_id)
  return _s;
}
inline const std::string& LocationAuth::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void LocationAuth::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuth::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuth::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuth.location_id)
  return _impl_.location_id_.Release();
}
inline void LocationAuth::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuth.location_id)
}

// repeated .viam.app.v1.SharedSecret secrets = 3 [json_name = "secrets"];
inline int LocationAuth::_internal_secrets_size() const {
  return _impl_.secrets_.size();
}
inline int LocationAuth::secrets_size() const {
  return _internal_secrets_size();
}
inline void LocationAuth::clear_secrets() {
  _impl_.secrets_.Clear();
}
inline ::viam::app::v1::SharedSecret* LocationAuth::mutable_secrets(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuth.secrets)
  return _impl_.secrets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >*
LocationAuth::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.LocationAuth.secrets)
  return &_impl_.secrets_;
}
inline const ::viam::app::v1::SharedSecret& LocationAuth::_internal_secrets(int index) const {
  return _impl_.secrets_.Get(index);
}
inline const ::viam::app::v1::SharedSecret& LocationAuth::secrets(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuth.secrets)
  return _internal_secrets(index);
}
inline ::viam::app::v1::SharedSecret* LocationAuth::_internal_add_secrets() {
  return _impl_.secrets_.Add();
}
inline ::viam::app::v1::SharedSecret* LocationAuth::add_secrets() {
  ::viam::app::v1::SharedSecret* _add = _internal_add_secrets();
  // @@protoc_insertion_point(field_add:viam.app.v1.LocationAuth.secrets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::SharedSecret >&
LocationAuth::secrets() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.LocationAuth.secrets)
  return _impl_.secrets_;
}

// -------------------------------------------------------------------

// SharedSecret

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"id\""];
inline void SharedSecret::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SharedSecret::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharedSecret::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.id)
}
inline std::string* SharedSecret::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.id)
  return _s;
}
inline const std::string& SharedSecret::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SharedSecret::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedSecret::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedSecret::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.id)
  return _impl_.id_.Release();
}
inline void SharedSecret::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.id)
}

// string secret = 2 [json_name = "secret", (.tagger.v1.tags) = "bson:\"secret\""];
inline void SharedSecret::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& SharedSecret::secret() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharedSecret::set_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.secret)
}
inline std::string* SharedSecret::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.secret)
  return _s;
}
inline const std::string& SharedSecret::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void SharedSecret::_internal_set_secret(const std::string& value) {
  
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedSecret::_internal_mutable_secret() {
  
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedSecret::release_secret() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.secret)
  return _impl_.secret_.Release();
}
inline void SharedSecret::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.secret)
}

// .google.protobuf.Timestamp created_on = 3 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\" json:\"created_on\""];
inline bool SharedSecret::_internal_has_created_on() const {
  return this != internal_default_instance() && _impl_.created_on_ != nullptr;
}
inline bool SharedSecret::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SharedSecret::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SharedSecret::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.created_on)
  return _internal_created_on();
}
inline void SharedSecret::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  _impl_.created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.SharedSecret.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.SharedSecret.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::_internal_mutable_created_on() {
  
  if (_impl_.created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_on_ = p;
  }
  return _impl_.created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SharedSecret::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.SharedSecret.created_on)
  return _msg;
}
inline void SharedSecret::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.SharedSecret.created_on)
}

// .viam.app.v1.SharedSecret.State state = 4 [json_name = "state", (.tagger.v1.tags) = "bson:\"state\""];
inline void SharedSecret::clear_state() {
  _impl_.state_ = 0;
}
inline ::viam::app::v1::SharedSecret_State SharedSecret::_internal_state() const {
  return static_cast< ::viam::app::v1::SharedSecret_State >(_impl_.state_);
}
inline ::viam::app::v1::SharedSecret_State SharedSecret::state() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.SharedSecret.state)
  return _internal_state();
}
inline void SharedSecret::_internal_set_state(::viam::app::v1::SharedSecret_State value) {
  
  _impl_.state_ = value;
}
inline void SharedSecret::set_state(::viam::app::v1::SharedSecret_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.SharedSecret.state)
}

// -------------------------------------------------------------------

// LocationAuthRequest

// string location_id = 1 [json_name = "locationId"];
inline void LocationAuthRequest::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& LocationAuthRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuthRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationAuthRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LocationAuthRequest.location_id)
}
inline std::string* LocationAuthRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuthRequest.location_id)
  return _s;
}
inline const std::string& LocationAuthRequest::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void LocationAuthRequest::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationAuthRequest::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationAuthRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuthRequest.location_id)
  return _impl_.location_id_.Release();
}
inline void LocationAuthRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuthRequest.location_id)
}

// -------------------------------------------------------------------

// LocationAuthResponse

// .viam.app.v1.LocationAuth auth = 1 [json_name = "auth"];
inline bool LocationAuthResponse::_internal_has_auth() const {
  return this != internal_default_instance() && _impl_.auth_ != nullptr;
}
inline bool LocationAuthResponse::has_auth() const {
  return _internal_has_auth();
}
inline void LocationAuthResponse::clear_auth() {
  if (GetArenaForAllocation() == nullptr && _impl_.auth_ != nullptr) {
    delete _impl_.auth_;
  }
  _impl_.auth_ = nullptr;
}
inline const ::viam::app::v1::LocationAuth& LocationAuthResponse::_internal_auth() const {
  const ::viam::app::v1::LocationAuth* p = _impl_.auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::LocationAuth&>(
      ::viam::app::v1::_LocationAuth_default_instance_);
}
inline const ::viam::app::v1::LocationAuth& LocationAuthResponse::auth() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LocationAuthResponse.auth)
  return _internal_auth();
}
inline void LocationAuthResponse::unsafe_arena_set_allocated_auth(
    ::viam::app::v1::LocationAuth* auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auth_);
  }
  _impl_.auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.LocationAuthResponse.auth)
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::release_auth() {
  
  ::viam::app::v1::LocationAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::unsafe_arena_release_auth() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LocationAuthResponse.auth)
  
  ::viam::app::v1::LocationAuth* temp = _impl_.auth_;
  _impl_.auth_ = nullptr;
  return temp;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::_internal_mutable_auth() {
  
  if (_impl_.auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::LocationAuth>(GetArenaForAllocation());
    _impl_.auth_ = p;
  }
  return _impl_.auth_;
}
inline ::viam::app::v1::LocationAuth* LocationAuthResponse::mutable_auth() {
  ::viam::app::v1::LocationAuth* _msg = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LocationAuthResponse.auth)
  return _msg;
}
inline void LocationAuthResponse::set_allocated_auth(::viam::app::v1::LocationAuth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auth);
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LocationAuthResponse.auth)
}

// -------------------------------------------------------------------

// GetRobotRequest

// string id = 1 [json_name = "id"];
inline void GetRobotRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotRequest.id)
}
inline std::string* GetRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotRequest.id)
  return _s;
}
inline const std::string& GetRobotRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetRobotRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotRequest.id)
  return _impl_.id_.Release();
}
inline void GetRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotRequest.id)
}

// -------------------------------------------------------------------

// GetRobotResponse

// .viam.app.v1.Robot robot = 1 [json_name = "robot"];
inline bool GetRobotResponse::_internal_has_robot() const {
  return this != internal_default_instance() && _impl_.robot_ != nullptr;
}
inline bool GetRobotResponse::has_robot() const {
  return _internal_has_robot();
}
inline void GetRobotResponse::clear_robot() {
  if (GetArenaForAllocation() == nullptr && _impl_.robot_ != nullptr) {
    delete _impl_.robot_;
  }
  _impl_.robot_ = nullptr;
}
inline const ::viam::app::v1::Robot& GetRobotResponse::_internal_robot() const {
  const ::viam::app::v1::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Robot&>(
      ::viam::app::v1::_Robot_default_instance_);
}
inline const ::viam::app::v1::Robot& GetRobotResponse::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotResponse.robot)
  return _internal_robot();
}
inline void GetRobotResponse::unsafe_arena_set_allocated_robot(
    ::viam::app::v1::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = robot;
  if (robot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotResponse.robot)
}
inline ::viam::app::v1::Robot* GetRobotResponse::release_robot() {
  
  ::viam::app::v1::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Robot* GetRobotResponse::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotResponse.robot)
  
  ::viam::app::v1::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Robot* GetRobotResponse::_internal_mutable_robot() {
  
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Robot>(GetArenaForAllocation());
    _impl_.robot_ = p;
  }
  return _impl_.robot_;
}
inline ::viam::app::v1::Robot* GetRobotResponse::mutable_robot() {
  ::viam::app::v1::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotResponse.robot)
  return _msg;
}
inline void GetRobotResponse::set_allocated_robot(::viam::app::v1::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotResponse.robot)
}

// -------------------------------------------------------------------

// GetRobotPartsRequest

// string robot_id = 1 [json_name = "robotId"];
inline void GetRobotPartsRequest::clear_robot_id() {
  _impl_.robot_id_.ClearToEmpty();
}
inline const std::string& GetRobotPartsRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartsRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartsRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartsRequest.robot_id)
}
inline std::string* GetRobotPartsRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartsRequest.robot_id)
  return _s;
}
inline const std::string& GetRobotPartsRequest::_internal_robot_id() const {
  return _impl_.robot_id_.Get();
}
inline void GetRobotPartsRequest::_internal_set_robot_id(const std::string& value) {
  
  _impl_.robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartsRequest::_internal_mutable_robot_id() {
  
  return _impl_.robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartsRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartsRequest.robot_id)
  return _impl_.robot_id_.Release();
}
inline void GetRobotPartsRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  _impl_.robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.robot_id_.IsDefault()) {
    _impl_.robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartsRequest.robot_id)
}

// -------------------------------------------------------------------

// GetRobotPartsResponse

// repeated .viam.app.v1.RobotPart parts = 1 [json_name = "parts"];
inline int GetRobotPartsResponse::_internal_parts_size() const {
  return _impl_.parts_.size();
}
inline int GetRobotPartsResponse::parts_size() const {
  return _internal_parts_size();
}
inline void GetRobotPartsResponse::clear_parts() {
  _impl_.parts_.Clear();
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartsResponse.parts)
  return _impl_.parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >*
GetRobotPartsResponse::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartsResponse.parts)
  return &_impl_.parts_;
}
inline const ::viam::app::v1::RobotPart& GetRobotPartsResponse::_internal_parts(int index) const {
  return _impl_.parts_.Get(index);
}
inline const ::viam::app::v1::RobotPart& GetRobotPartsResponse::parts(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartsResponse.parts)
  return _internal_parts(index);
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::_internal_add_parts() {
  return _impl_.parts_.Add();
}
inline ::viam::app::v1::RobotPart* GetRobotPartsResponse::add_parts() {
  ::viam::app::v1::RobotPart* _add = _internal_add_parts();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartsResponse.parts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPart >&
GetRobotPartsResponse::parts() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartsResponse.parts)
  return _impl_.parts_;
}

// -------------------------------------------------------------------

// GetRobotPartRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetRobotPartRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartRequest.id)
}
inline std::string* GetRobotPartRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartRequest.id)
  return _s;
}
inline const std::string& GetRobotPartRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetRobotPartRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartRequest.id)
  return _impl_.id_.Release();
}
inline void GetRobotPartRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartRequest.id)
}

// -------------------------------------------------------------------

// GetRobotPartResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool GetRobotPartResponse::_internal_has_part() const {
  return this != internal_default_instance() && _impl_.part_ != nullptr;
}
inline bool GetRobotPartResponse::has_part() const {
  return _internal_has_part();
}
inline void GetRobotPartResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && _impl_.part_ != nullptr) {
    delete _impl_.part_;
  }
  _impl_.part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& GetRobotPartResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = _impl_.part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& GetRobotPartResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartResponse.part)
  return _internal_part();
}
inline void GetRobotPartResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.part_);
  }
  _impl_.part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.GetRobotPartResponse.part)
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = _impl_.part_;
  _impl_.part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartResponse.part)
  
  ::viam::app::v1::RobotPart* temp = _impl_.part_;
  _impl_.part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::_internal_mutable_part() {
  
  if (_impl_.part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    _impl_.part_ = p;
  }
  return _impl_.part_;
}
inline ::viam::app::v1::RobotPart* GetRobotPartResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartResponse.part)
  return _msg;
}
inline void GetRobotPartResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartResponse.part)
}

// string config_json = 2 [json_name = "configJson"];
inline void GetRobotPartResponse::clear_config_json() {
  _impl_.config_json_.ClearToEmpty();
}
inline const std::string& GetRobotPartResponse::config_json() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartResponse.config_json)
  return _internal_config_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartResponse::set_config_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartResponse.config_json)
}
inline std::string* GetRobotPartResponse::mutable_config_json() {
  std::string* _s = _internal_mutable_config_json();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartResponse.config_json)
  return _s;
}
inline const std::string& GetRobotPartResponse::_internal_config_json() const {
  return _impl_.config_json_.Get();
}
inline void GetRobotPartResponse::_internal_set_config_json(const std::string& value) {
  
  _impl_.config_json_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartResponse::_internal_mutable_config_json() {
  
  return _impl_.config_json_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartResponse::release_config_json() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartResponse.config_json)
  return _impl_.config_json_.Release();
}
inline void GetRobotPartResponse::set_allocated_config_json(std::string* config_json) {
  if (config_json != nullptr) {
    
  } else {
    
  }
  _impl_.config_json_.SetAllocated(config_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_json_.IsDefault()) {
    _impl_.config_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartResponse.config_json)
}

// -------------------------------------------------------------------

// GetRobotPartLogsRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartLogsRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetRobotPartLogsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartLogsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.id)
}
inline std::string* GetRobotPartLogsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsRequest.id)
  return _s;
}
inline const std::string& GetRobotPartLogsRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetRobotPartLogsRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartLogsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartLogsRequest.id)
  return _impl_.id_.Release();
}
inline void GetRobotPartLogsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartLogsRequest.id)
}

// bool errors_only = 2 [json_name = "errorsOnly"];
inline void GetRobotPartLogsRequest::clear_errors_only() {
  _impl_.errors_only_ = false;
}
inline bool GetRobotPartLogsRequest::_internal_errors_only() const {
  return _impl_.errors_only_;
}
inline bool GetRobotPartLogsRequest::errors_only() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsRequest.errors_only)
  return _internal_errors_only();
}
inline void GetRobotPartLogsRequest::_internal_set_errors_only(bool value) {
  
  _impl_.errors_only_ = value;
}
inline void GetRobotPartLogsRequest::set_errors_only(bool value) {
  _internal_set_errors_only(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartLogsRequest.errors_only)
}

// -------------------------------------------------------------------

// LogEntry

// string host = 1 [json_name = "host"];
inline void LogEntry::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& LogEntry::host() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogEntry.host)
}
inline std::string* LogEntry::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.host)
  return _s;
}
inline const std::string& LogEntry::_internal_host() const {
  return _impl_.host_.Get();
}
inline void LogEntry::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_host() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogEntry.host)
  return _impl_.host_.Release();
}
inline void LogEntry::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogEntry.host)
}

// string level = 2 [json_name = "level"];
inline void LogEntry::clear_level() {
  _impl_.level_.ClearToEmpty();
}
inline const std::string& LogEntry::level() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.level)
  return _internal_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_level(ArgT0&& arg0, ArgT... args) {
 
 _impl_.level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogEntry.level)
}
inline std::string* LogEntry::mutable_level() {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.level)
  return _s;
}
inline const std::string& LogEntry::_internal_level() const {
  return _impl_.level_.Get();
}
inline void LogEntry::_internal_set_level(const std::string& value) {
  
  _impl_.level_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_level() {
  
  return _impl_.level_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_level() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogEntry.level)
  return _impl_.level_.Release();
}
inline void LogEntry::set_allocated_level(std::string* level) {
  if (level != nullptr) {
    
  } else {
    
  }
  _impl_.level_.SetAllocated(level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_.IsDefault()) {
    _impl_.level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogEntry.level)
}

// .google.protobuf.Timestamp time = 3 [json_name = "time"];
inline bool LogEntry::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool LogEntry::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogEntry::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogEntry::time() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.time)
  return _internal_time();
}
inline void LogEntry::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.LogEntry.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEntry::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEntry::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogEntry.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEntry::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEntry::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.time)
  return _msg;
}
inline void LogEntry::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogEntry.time)
}

// string logger_name = 4 [json_name = "loggerName"];
inline void LogEntry::clear_logger_name() {
  _impl_.logger_name_.ClearToEmpty();
}
inline const std::string& LogEntry::logger_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.logger_name)
  return _internal_logger_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_logger_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logger_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogEntry.logger_name)
}
inline std::string* LogEntry::mutable_logger_name() {
  std::string* _s = _internal_mutable_logger_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.logger_name)
  return _s;
}
inline const std::string& LogEntry::_internal_logger_name() const {
  return _impl_.logger_name_.Get();
}
inline void LogEntry::_internal_set_logger_name(const std::string& value) {
  
  _impl_.logger_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_logger_name() {
  
  return _impl_.logger_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_logger_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogEntry.logger_name)
  return _impl_.logger_name_.Release();
}
inline void LogEntry::set_allocated_logger_name(std::string* logger_name) {
  if (logger_name != nullptr) {
    
  } else {
    
  }
  _impl_.logger_name_.SetAllocated(logger_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logger_name_.IsDefault()) {
    _impl_.logger_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogEntry.logger_name)
}

// string message = 5 [json_name = "message"];
inline void LogEntry::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogEntry::message() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogEntry.message)
}
inline std::string* LogEntry::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.message)
  return _s;
}
inline const std::string& LogEntry::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LogEntry::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_message() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogEntry.message)
  return _impl_.message_.Release();
}
inline void LogEntry::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogEntry.message)
}

// .google.protobuf.Struct caller = 6 [json_name = "caller"];
inline bool LogEntry::_internal_has_caller() const {
  return this != internal_default_instance() && _impl_.caller_ != nullptr;
}
inline bool LogEntry::has_caller() const {
  return _internal_has_caller();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEntry::_internal_caller() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.caller_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEntry::caller() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.caller)
  return _internal_caller();
}
inline void LogEntry::unsafe_arena_set_allocated_caller(
    ::PROTOBUF_NAMESPACE_ID::Struct* caller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caller_);
  }
  _impl_.caller_ = caller;
  if (caller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.LogEntry.caller)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEntry::release_caller() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.caller_;
  _impl_.caller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEntry::unsafe_arena_release_caller() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogEntry.caller)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.caller_;
  _impl_.caller_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEntry::_internal_mutable_caller() {
  
  if (_impl_.caller_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.caller_ = p;
  }
  return _impl_.caller_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEntry::mutable_caller() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.caller)
  return _msg;
}
inline void LogEntry::set_allocated_caller(::PROTOBUF_NAMESPACE_ID::Struct* caller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caller_);
  }
  if (caller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caller));
    if (message_arena != submessage_arena) {
      caller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.caller_ = caller;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogEntry.caller)
}

// string stack = 7 [json_name = "stack"];
inline void LogEntry::clear_stack() {
  _impl_.stack_.ClearToEmpty();
}
inline const std::string& LogEntry::stack() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.stack)
  return _internal_stack();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_stack(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stack_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.LogEntry.stack)
}
inline std::string* LogEntry::mutable_stack() {
  std::string* _s = _internal_mutable_stack();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.stack)
  return _s;
}
inline const std::string& LogEntry::_internal_stack() const {
  return _impl_.stack_.Get();
}
inline void LogEntry::_internal_set_stack(const std::string& value) {
  
  _impl_.stack_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_stack() {
  
  return _impl_.stack_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_stack() {
  // @@protoc_insertion_point(field_release:viam.app.v1.LogEntry.stack)
  return _impl_.stack_.Release();
}
inline void LogEntry::set_allocated_stack(std::string* stack) {
  if (stack != nullptr) {
    
  } else {
    
  }
  _impl_.stack_.SetAllocated(stack, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stack_.IsDefault()) {
    _impl_.stack_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.LogEntry.stack)
}

// repeated .google.protobuf.Struct fields = 8 [json_name = "fields"];
inline int LogEntry::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int LogEntry::fields_size() const {
  return _internal_fields_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEntry::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.LogEntry.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Struct >*
LogEntry::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.LogEntry.fields)
  return &_impl_.fields_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEntry::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEntry::fields(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.LogEntry.fields)
  return _internal_fields(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEntry::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEntry::add_fields() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:viam.app.v1.LogEntry.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Struct >&
LogEntry::fields() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.LogEntry.fields)
  return _impl_.fields_;
}

// -------------------------------------------------------------------

// GetRobotPartLogsResponse

// repeated .viam.app.v1.LogEntry logs = 1 [json_name = "logs"];
inline int GetRobotPartLogsResponse::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int GetRobotPartLogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline void GetRobotPartLogsResponse::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::viam::app::v1::LogEntry* GetRobotPartLogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >*
GetRobotPartLogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartLogsResponse.logs)
  return &_impl_.logs_;
}
inline const ::viam::app::v1::LogEntry& GetRobotPartLogsResponse::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::viam::app::v1::LogEntry& GetRobotPartLogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _internal_logs(index);
}
inline ::viam::app::v1::LogEntry* GetRobotPartLogsResponse::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::viam::app::v1::LogEntry* GetRobotPartLogsResponse::add_logs() {
  ::viam::app::v1::LogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >&
GetRobotPartLogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartLogsResponse.logs)
  return _impl_.logs_;
}

// -------------------------------------------------------------------

// TailRobotPartLogsRequest

// string id = 1 [json_name = "id"];
inline void TailRobotPartLogsRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TailRobotPartLogsRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TailRobotPartLogsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.id)
}
inline std::string* TailRobotPartLogsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsRequest.id)
  return _s;
}
inline const std::string& TailRobotPartLogsRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TailRobotPartLogsRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TailRobotPartLogsRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.TailRobotPartLogsRequest.id)
  return _impl_.id_.Release();
}
inline void TailRobotPartLogsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.TailRobotPartLogsRequest.id)
}

// bool errors_only = 2 [json_name = "errorsOnly"];
inline void TailRobotPartLogsRequest::clear_errors_only() {
  _impl_.errors_only_ = false;
}
inline bool TailRobotPartLogsRequest::_internal_errors_only() const {
  return _impl_.errors_only_;
}
inline bool TailRobotPartLogsRequest::errors_only() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsRequest.errors_only)
  return _internal_errors_only();
}
inline void TailRobotPartLogsRequest::_internal_set_errors_only(bool value) {
  
  _impl_.errors_only_ = value;
}
inline void TailRobotPartLogsRequest::set_errors_only(bool value) {
  _internal_set_errors_only(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.TailRobotPartLogsRequest.errors_only)
}

// -------------------------------------------------------------------

// TailRobotPartLogsResponse

// repeated .viam.app.v1.LogEntry logs = 1 [json_name = "logs"];
inline int TailRobotPartLogsResponse::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int TailRobotPartLogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline void TailRobotPartLogsResponse::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::viam::app::v1::LogEntry* TailRobotPartLogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >*
TailRobotPartLogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.TailRobotPartLogsResponse.logs)
  return &_impl_.logs_;
}
inline const ::viam::app::v1::LogEntry& TailRobotPartLogsResponse::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::viam::app::v1::LogEntry& TailRobotPartLogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _internal_logs(index);
}
inline ::viam::app::v1::LogEntry* TailRobotPartLogsResponse::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::viam::app::v1::LogEntry* TailRobotPartLogsResponse::add_logs() {
  ::viam::app::v1::LogEntry* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::LogEntry >&
TailRobotPartLogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.TailRobotPartLogsResponse.logs)
  return _impl_.logs_;
}

// -------------------------------------------------------------------

// GetRobotPartHistoryRequest

// string id = 1 [json_name = "id"];
inline void GetRobotPartHistoryRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetRobotPartHistoryRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartHistoryRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRobotPartHistoryRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.GetRobotPartHistoryRequest.id)
}
inline std::string* GetRobotPartHistoryRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartHistoryRequest.id)
  return _s;
}
inline const std::string& GetRobotPartHistoryRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetRobotPartHistoryRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRobotPartHistoryRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRobotPartHistoryRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.GetRobotPartHistoryRequest.id)
  return _impl_.id_.Release();
}
inline void GetRobotPartHistoryRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.GetRobotPartHistoryRequest.id)
}

// -------------------------------------------------------------------

// GetRobotPartHistoryResponse

// repeated .viam.app.v1.RobotPartHistoryEntry history = 1 [json_name = "history"];
inline int GetRobotPartHistoryResponse::_internal_history_size() const {
  return _impl_.history_.size();
}
inline int GetRobotPartHistoryResponse::history_size() const {
  return _internal_history_size();
}
inline void GetRobotPartHistoryResponse::clear_history() {
  _impl_.history_.Clear();
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _impl_.history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >*
GetRobotPartHistoryResponse::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.GetRobotPartHistoryResponse.history)
  return &_impl_.history_;
}
inline const ::viam::app::v1::RobotPartHistoryEntry& GetRobotPartHistoryResponse::_internal_history(int index) const {
  return _impl_.history_.Get(index);
}
inline const ::viam::app::v1::RobotPartHistoryEntry& GetRobotPartHistoryResponse::history(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _internal_history(index);
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::_internal_add_history() {
  return _impl_.history_.Add();
}
inline ::viam::app::v1::RobotPartHistoryEntry* GetRobotPartHistoryResponse::add_history() {
  ::viam::app::v1::RobotPartHistoryEntry* _add = _internal_add_history();
  // @@protoc_insertion_point(field_add:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::RobotPartHistoryEntry >&
GetRobotPartHistoryResponse::history() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.GetRobotPartHistoryResponse.history)
  return _impl_.history_;
}

// -------------------------------------------------------------------

// UpdateRobotPartRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotPartRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateRobotPartRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotPartRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotPartRequest.id)
}
inline std::string* UpdateRobotPartRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.id)
  return _s;
}
inline const std::string& UpdateRobotPartRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateRobotPartRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateRobotPartRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateRobotPartRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateRobotPartRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotPartRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotPartRequest.name)
}
inline std::string* UpdateRobotPartRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.name)
  return _s;
}
inline const std::string& UpdateRobotPartRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateRobotPartRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotPartRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateRobotPartRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.name)
}

// .google.protobuf.Struct robot_config = 3 [json_name = "robotConfig"];
inline bool UpdateRobotPartRequest::_internal_has_robot_config() const {
  return this != internal_default_instance() && _impl_.robot_config_ != nullptr;
}
inline bool UpdateRobotPartRequest::has_robot_config() const {
  return _internal_has_robot_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartRequest::_internal_robot_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.robot_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRobotPartRequest::robot_config() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartRequest.robot_config)
  return _internal_robot_config();
}
inline void UpdateRobotPartRequest::unsafe_arena_set_allocated_robot_config(
    ::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_config_);
  }
  _impl_.robot_config_ = robot_config;
  if (robot_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartRequest.robot_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::release_robot_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.robot_config_;
  _impl_.robot_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::unsafe_arena_release_robot_config() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartRequest.robot_config)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.robot_config_;
  _impl_.robot_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::_internal_mutable_robot_config() {
  
  if (_impl_.robot_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.robot_config_ = p;
  }
  return _impl_.robot_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRobotPartRequest::mutable_robot_config() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_robot_config();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartRequest.robot_config)
  return _msg;
}
inline void UpdateRobotPartRequest::set_allocated_robot_config(::PROTOBUF_NAMESPACE_ID::Struct* robot_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_config_);
  }
  if (robot_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_config));
    if (message_arena != submessage_arena) {
      robot_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_config_ = robot_config;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartRequest.robot_config)
}

// -------------------------------------------------------------------

// UpdateRobotPartResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool UpdateRobotPartResponse::_internal_has_part() const {
  return this != internal_default_instance() && _impl_.part_ != nullptr;
}
inline bool UpdateRobotPartResponse::has_part() const {
  return _internal_has_part();
}
inline void UpdateRobotPartResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && _impl_.part_ != nullptr) {
    delete _impl_.part_;
  }
  _impl_.part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& UpdateRobotPartResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = _impl_.part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& UpdateRobotPartResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotPartResponse.part)
  return _internal_part();
}
inline void UpdateRobotPartResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.part_);
  }
  _impl_.part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotPartResponse.part)
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = _impl_.part_;
  _impl_.part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotPartResponse.part)
  
  ::viam::app::v1::RobotPart* temp = _impl_.part_;
  _impl_.part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::_internal_mutable_part() {
  
  if (_impl_.part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    _impl_.part_ = p;
  }
  return _impl_.part_;
}
inline ::viam::app::v1::RobotPart* UpdateRobotPartResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotPartResponse.part)
  return _msg;
}
inline void UpdateRobotPartResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotPartResponse.part)
}

// -------------------------------------------------------------------

// NewRobotPartRequest

// string robot_id = 1 [json_name = "robotId"];
inline void NewRobotPartRequest::clear_robot_id() {
  _impl_.robot_id_.ClearToEmpty();
}
inline const std::string& NewRobotPartRequest::robot_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartRequest.robot_id)
  return _internal_robot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartRequest::set_robot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.robot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartRequest.robot_id)
}
inline std::string* NewRobotPartRequest::mutable_robot_id() {
  std::string* _s = _internal_mutable_robot_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartRequest.robot_id)
  return _s;
}
inline const std::string& NewRobotPartRequest::_internal_robot_id() const {
  return _impl_.robot_id_.Get();
}
inline void NewRobotPartRequest::_internal_set_robot_id(const std::string& value) {
  
  _impl_.robot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::_internal_mutable_robot_id() {
  
  return _impl_.robot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::release_robot_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartRequest.robot_id)
  return _impl_.robot_id_.Release();
}
inline void NewRobotPartRequest::set_allocated_robot_id(std::string* robot_id) {
  if (robot_id != nullptr) {
    
  } else {
    
  }
  _impl_.robot_id_.SetAllocated(robot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.robot_id_.IsDefault()) {
    _impl_.robot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartRequest.robot_id)
}

// string part_name = 2 [json_name = "partName"];
inline void NewRobotPartRequest::clear_part_name() {
  _impl_.part_name_.ClearToEmpty();
}
inline const std::string& NewRobotPartRequest::part_name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartRequest.part_name)
  return _internal_part_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartRequest::set_part_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartRequest.part_name)
}
inline std::string* NewRobotPartRequest::mutable_part_name() {
  std::string* _s = _internal_mutable_part_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartRequest.part_name)
  return _s;
}
inline const std::string& NewRobotPartRequest::_internal_part_name() const {
  return _impl_.part_name_.Get();
}
inline void NewRobotPartRequest::_internal_set_part_name(const std::string& value) {
  
  _impl_.part_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::_internal_mutable_part_name() {
  
  return _impl_.part_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartRequest::release_part_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartRequest.part_name)
  return _impl_.part_name_.Release();
}
inline void NewRobotPartRequest::set_allocated_part_name(std::string* part_name) {
  if (part_name != nullptr) {
    
  } else {
    
  }
  _impl_.part_name_.SetAllocated(part_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_name_.IsDefault()) {
    _impl_.part_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartRequest.part_name)
}

// -------------------------------------------------------------------

// NewRobotPartResponse

// string part_id = 1 [json_name = "partId"];
inline void NewRobotPartResponse::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& NewRobotPartResponse::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotPartResponse.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotPartResponse::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotPartResponse.part_id)
}
inline std::string* NewRobotPartResponse::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotPartResponse.part_id)
  return _s;
}
inline const std::string& NewRobotPartResponse::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void NewRobotPartResponse::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotPartResponse::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotPartResponse::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotPartResponse.part_id)
  return _impl_.part_id_.Release();
}
inline void NewRobotPartResponse::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotPartResponse.part_id)
}

// -------------------------------------------------------------------

// DeleteRobotPartRequest

// string part_id = 1 [json_name = "partId"];
inline void DeleteRobotPartRequest::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartRequest.part_id)
}
inline std::string* DeleteRobotPartRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartRequest.part_id)
  return _s;
}
inline const std::string& DeleteRobotPartRequest::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void DeleteRobotPartRequest::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartRequest::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartRequest.part_id)
  return _impl_.part_id_.Release();
}
inline void DeleteRobotPartRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartRequest.part_id)
}

// -------------------------------------------------------------------

// DeleteRobotPartResponse

// -------------------------------------------------------------------

// Fragment

// string id = 1 [json_name = "id", (.tagger.v1.tags) = "bson:\"_id\" json:\"id,omitempty\""];
inline void Fragment::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Fragment::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.id)
}
inline std::string* Fragment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.id)
  return _s;
}
inline const std::string& Fragment::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Fragment::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.id)
  return _impl_.id_.Release();
}
inline void Fragment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.id)
}

// string name = 2 [json_name = "name", (.tagger.v1.tags) = "bson:\"name\" json:\"name\""];
inline void Fragment::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Fragment::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.name)
}
inline std::string* Fragment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.name)
  return _s;
}
inline const std::string& Fragment::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Fragment::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.name)
  return _impl_.name_.Release();
}
inline void Fragment::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.name)
}

// .google.protobuf.Struct fragment = 3 [json_name = "fragment", (.tagger.v1.tags) = "bson:\"fragment\" json:\"fragment\""];
inline bool Fragment::_internal_has_fragment() const {
  return this != internal_default_instance() && _impl_.fragment_ != nullptr;
}
inline bool Fragment::has_fragment() const {
  return _internal_has_fragment();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Fragment::_internal_fragment() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.fragment_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Fragment::fragment() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.fragment)
  return _internal_fragment();
}
inline void Fragment::unsafe_arena_set_allocated_fragment(
    ::PROTOBUF_NAMESPACE_ID::Struct* fragment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fragment_);
  }
  _impl_.fragment_ = fragment;
  if (fragment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Fragment.fragment)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::release_fragment() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.fragment_;
  _impl_.fragment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.fragment)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.fragment_;
  _impl_.fragment_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::_internal_mutable_fragment() {
  
  if (_impl_.fragment_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.fragment_ = p;
  }
  return _impl_.fragment_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Fragment::mutable_fragment() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_fragment();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.fragment)
  return _msg;
}
inline void Fragment::set_allocated_fragment(::PROTOBUF_NAMESPACE_ID::Struct* fragment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fragment_);
  }
  if (fragment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment));
    if (message_arena != submessage_arena) {
      fragment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fragment_ = fragment;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.fragment)
}

// string organization_owner = 4 [json_name = "organizationOwner", (.tagger.v1.tags) = "bson:\"organization_owner\" json:\"owner\""];
inline void Fragment::clear_organization_owner() {
  _impl_.organization_owner_.ClearToEmpty();
}
inline const std::string& Fragment::organization_owner() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.organization_owner)
  return _internal_organization_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fragment::set_organization_owner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.organization_owner)
}
inline std::string* Fragment::mutable_organization_owner() {
  std::string* _s = _internal_mutable_organization_owner();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.organization_owner)
  return _s;
}
inline const std::string& Fragment::_internal_organization_owner() const {
  return _impl_.organization_owner_.Get();
}
inline void Fragment::_internal_set_organization_owner(const std::string& value) {
  
  _impl_.organization_owner_.Set(value, GetArenaForAllocation());
}
inline std::string* Fragment::_internal_mutable_organization_owner() {
  
  return _impl_.organization_owner_.Mutable(GetArenaForAllocation());
}
inline std::string* Fragment::release_organization_owner() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.organization_owner)
  return _impl_.organization_owner_.Release();
}
inline void Fragment::set_allocated_organization_owner(std::string* organization_owner) {
  if (organization_owner != nullptr) {
    
  } else {
    
  }
  _impl_.organization_owner_.SetAllocated(organization_owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_owner_.IsDefault()) {
    _impl_.organization_owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.organization_owner)
}

// bool public = 5 [json_name = "public", (.tagger.v1.tags) = "bson:\"public\" json:\"public\""];
inline void Fragment::clear_public_() {
  _impl_.public__ = false;
}
inline bool Fragment::_internal_public_() const {
  return _impl_.public__;
}
inline bool Fragment::public_() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.public)
  return _internal_public_();
}
inline void Fragment::_internal_set_public_(bool value) {
  
  _impl_.public__ = value;
}
inline void Fragment::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:viam.app.v1.Fragment.public)
}

// .google.protobuf.Timestamp created_on = 6 [json_name = "createdOn", (.tagger.v1.tags) = "bson:\"created_on\""];
inline bool Fragment::_internal_has_created_on() const {
  return this != internal_default_instance() && _impl_.created_on_ != nullptr;
}
inline bool Fragment::has_created_on() const {
  return _internal_has_created_on();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::_internal_created_on() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Fragment::created_on() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.Fragment.created_on)
  return _internal_created_on();
}
inline void Fragment::unsafe_arena_set_allocated_created_on(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  _impl_.created_on_ = created_on;
  if (created_on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.Fragment.created_on)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::release_created_on() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::unsafe_arena_release_created_on() {
  // @@protoc_insertion_point(field_release:viam.app.v1.Fragment.created_on)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_on_;
  _impl_.created_on_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::_internal_mutable_created_on() {
  
  if (_impl_.created_on_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_on_ = p;
  }
  return _impl_.created_on_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Fragment::mutable_created_on() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_on();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.Fragment.created_on)
  return _msg;
}
inline void Fragment::set_allocated_created_on(::PROTOBUF_NAMESPACE_ID::Timestamp* created_on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_on_);
  }
  if (created_on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_on));
    if (message_arena != submessage_arena) {
      created_on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_on, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_on_ = created_on;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.Fragment.created_on)
}

// -------------------------------------------------------------------

// FindRobotsRequest

// string location_id = 1 [json_name = "locationId"];
inline void FindRobotsRequest::clear_location_id() {
  _impl_.location_id_.ClearToEmpty();
}
inline const std::string& FindRobotsRequest::location_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FindRobotsRequest.location_id)
  return _internal_location_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindRobotsRequest::set_location_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.FindRobotsRequest.location_id)
}
inline std::string* FindRobotsRequest::mutable_location_id() {
  std::string* _s = _internal_mutable_location_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FindRobotsRequest.location_id)
  return _s;
}
inline const std::string& FindRobotsRequest::_internal_location_id() const {
  return _impl_.location_id_.Get();
}
inline void FindRobotsRequest::_internal_set_location_id(const std::string& value) {
  
  _impl_.location_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FindRobotsRequest::_internal_mutable_location_id() {
  
  return _impl_.location_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FindRobotsRequest::release_location_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.FindRobotsRequest.location_id)
  return _impl_.location_id_.Release();
}
inline void FindRobotsRequest::set_allocated_location_id(std::string* location_id) {
  if (location_id != nullptr) {
    
  } else {
    
  }
  _impl_.location_id_.SetAllocated(location_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_id_.IsDefault()) {
    _impl_.location_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.FindRobotsRequest.location_id)
}

// -------------------------------------------------------------------

// FindRobotsResponse

// repeated .viam.app.v1.Robot robots = 1 [json_name = "robots"];
inline int FindRobotsResponse::_internal_robots_size() const {
  return _impl_.robots_.size();
}
inline int FindRobotsResponse::robots_size() const {
  return _internal_robots_size();
}
inline void FindRobotsResponse::clear_robots() {
  _impl_.robots_.Clear();
}
inline ::viam::app::v1::Robot* FindRobotsResponse::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:viam.app.v1.FindRobotsResponse.robots)
  return _impl_.robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >*
FindRobotsResponse::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:viam.app.v1.FindRobotsResponse.robots)
  return &_impl_.robots_;
}
inline const ::viam::app::v1::Robot& FindRobotsResponse::_internal_robots(int index) const {
  return _impl_.robots_.Get(index);
}
inline const ::viam::app::v1::Robot& FindRobotsResponse::robots(int index) const {
  // @@protoc_insertion_point(field_get:viam.app.v1.FindRobotsResponse.robots)
  return _internal_robots(index);
}
inline ::viam::app::v1::Robot* FindRobotsResponse::_internal_add_robots() {
  return _impl_.robots_.Add();
}
inline ::viam::app::v1::Robot* FindRobotsResponse::add_robots() {
  ::viam::app::v1::Robot* _add = _internal_add_robots();
  // @@protoc_insertion_point(field_add:viam.app.v1.FindRobotsResponse.robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::app::v1::Robot >&
FindRobotsResponse::robots() const {
  // @@protoc_insertion_point(field_list:viam.app.v1.FindRobotsResponse.robots)
  return _impl_.robots_;
}

// -------------------------------------------------------------------

// NewRobotRequest

// string name = 1 [json_name = "name"];
inline void NewRobotRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NewRobotRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotRequest.name)
}
inline std::string* NewRobotRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotRequest.name)
  return _s;
}
inline const std::string& NewRobotRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NewRobotRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotRequest.name)
  return _impl_.name_.Release();
}
inline void NewRobotRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotRequest.name)
}

// string location = 2 [json_name = "location"];
inline void NewRobotRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& NewRobotRequest::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotRequest.location)
}
inline std::string* NewRobotRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotRequest.location)
  return _s;
}
inline const std::string& NewRobotRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void NewRobotRequest::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotRequest::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotRequest::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotRequest.location)
  return _impl_.location_.Release();
}
inline void NewRobotRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotRequest.location)
}

// -------------------------------------------------------------------

// NewRobotResponse

// string id = 1 [json_name = "id"];
inline void NewRobotResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NewRobotResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.NewRobotResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewRobotResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.NewRobotResponse.id)
}
inline std::string* NewRobotResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.NewRobotResponse.id)
  return _s;
}
inline const std::string& NewRobotResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void NewRobotResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewRobotResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewRobotResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.NewRobotResponse.id)
  return _impl_.id_.Release();
}
inline void NewRobotResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.NewRobotResponse.id)
}

// -------------------------------------------------------------------

// UpdateRobotRequest

// string id = 1 [json_name = "id"];
inline void UpdateRobotRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.id)
}
inline std::string* UpdateRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.id)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateRobotRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.id)
}

// string name = 2 [json_name = "name"];
inline void UpdateRobotRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.name)
}
inline std::string* UpdateRobotRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.name)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateRobotRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateRobotRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.name)
}

// string location = 3 [json_name = "location"];
inline void UpdateRobotRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& UpdateRobotRequest::location() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRobotRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.UpdateRobotRequest.location)
}
inline std::string* UpdateRobotRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotRequest.location)
  return _s;
}
inline const std::string& UpdateRobotRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void UpdateRobotRequest::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRobotRequest::release_location() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotRequest.location)
  return _impl_.location_.Release();
}
inline void UpdateRobotRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotRequest.location)
}

// -------------------------------------------------------------------

// UpdateRobotResponse

// .viam.app.v1.Robot robot = 1 [json_name = "robot"];
inline bool UpdateRobotResponse::_internal_has_robot() const {
  return this != internal_default_instance() && _impl_.robot_ != nullptr;
}
inline bool UpdateRobotResponse::has_robot() const {
  return _internal_has_robot();
}
inline void UpdateRobotResponse::clear_robot() {
  if (GetArenaForAllocation() == nullptr && _impl_.robot_ != nullptr) {
    delete _impl_.robot_;
  }
  _impl_.robot_ = nullptr;
}
inline const ::viam::app::v1::Robot& UpdateRobotResponse::_internal_robot() const {
  const ::viam::app::v1::Robot* p = _impl_.robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::Robot&>(
      ::viam::app::v1::_Robot_default_instance_);
}
inline const ::viam::app::v1::Robot& UpdateRobotResponse::robot() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.UpdateRobotResponse.robot)
  return _internal_robot();
}
inline void UpdateRobotResponse::unsafe_arena_set_allocated_robot(
    ::viam::app::v1::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_);
  }
  _impl_.robot_ = robot;
  if (robot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.UpdateRobotResponse.robot)
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::release_robot() {
  
  ::viam::app::v1::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:viam.app.v1.UpdateRobotResponse.robot)
  
  ::viam::app::v1::Robot* temp = _impl_.robot_;
  _impl_.robot_ = nullptr;
  return temp;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::_internal_mutable_robot() {
  
  if (_impl_.robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::Robot>(GetArenaForAllocation());
    _impl_.robot_ = p;
  }
  return _impl_.robot_;
}
inline ::viam::app::v1::Robot* UpdateRobotResponse::mutable_robot() {
  ::viam::app::v1::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.UpdateRobotResponse.robot)
  return _msg;
}
inline void UpdateRobotResponse::set_allocated_robot(::viam::app::v1::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.UpdateRobotResponse.robot)
}

// -------------------------------------------------------------------

// DeleteRobotRequest

// string id = 1 [json_name = "id"];
inline void DeleteRobotRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteRobotRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotRequest.id)
}
inline std::string* DeleteRobotRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotRequest.id)
  return _s;
}
inline const std::string& DeleteRobotRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DeleteRobotRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteRobotRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotRequest.id)
}

// -------------------------------------------------------------------

// DeleteRobotResponse

// -------------------------------------------------------------------

// MarkPartAsMainRequest

// string part_id = 1 [json_name = "partId"];
inline void MarkPartAsMainRequest::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& MarkPartAsMainRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.MarkPartAsMainRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkPartAsMainRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.MarkPartAsMainRequest.part_id)
}
inline std::string* MarkPartAsMainRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.MarkPartAsMainRequest.part_id)
  return _s;
}
inline const std::string& MarkPartAsMainRequest::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void MarkPartAsMainRequest::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkPartAsMainRequest::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkPartAsMainRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.MarkPartAsMainRequest.part_id)
  return _impl_.part_id_.Release();
}
inline void MarkPartAsMainRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.MarkPartAsMainRequest.part_id)
}

// -------------------------------------------------------------------

// MarkPartAsMainResponse

// -------------------------------------------------------------------

// CreateRobotPartSecretRequest

// string part_id = 1 [json_name = "partId"];
inline void CreateRobotPartSecretRequest::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& CreateRobotPartSecretRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRobotPartSecretRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.CreateRobotPartSecretRequest.part_id)
}
inline std::string* CreateRobotPartSecretRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return _s;
}
inline const std::string& CreateRobotPartSecretRequest::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void CreateRobotPartSecretRequest::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRobotPartSecretRequest::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRobotPartSecretRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRobotPartSecretRequest.part_id)
  return _impl_.part_id_.Release();
}
inline void CreateRobotPartSecretRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRobotPartSecretRequest.part_id)
}

// -------------------------------------------------------------------

// CreateRobotPartSecretResponse

// .viam.app.v1.RobotPart part = 1 [json_name = "part"];
inline bool CreateRobotPartSecretResponse::_internal_has_part() const {
  return this != internal_default_instance() && _impl_.part_ != nullptr;
}
inline bool CreateRobotPartSecretResponse::has_part() const {
  return _internal_has_part();
}
inline void CreateRobotPartSecretResponse::clear_part() {
  if (GetArenaForAllocation() == nullptr && _impl_.part_ != nullptr) {
    delete _impl_.part_;
  }
  _impl_.part_ = nullptr;
}
inline const ::viam::app::v1::RobotPart& CreateRobotPartSecretResponse::_internal_part() const {
  const ::viam::app::v1::RobotPart* p = _impl_.part_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::app::v1::RobotPart&>(
      ::viam::app::v1::_RobotPart_default_instance_);
}
inline const ::viam::app::v1::RobotPart& CreateRobotPartSecretResponse::part() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.CreateRobotPartSecretResponse.part)
  return _internal_part();
}
inline void CreateRobotPartSecretResponse::unsafe_arena_set_allocated_part(
    ::viam::app::v1::RobotPart* part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.part_);
  }
  _impl_.part_ = part;
  if (part) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.app.v1.CreateRobotPartSecretResponse.part)
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::release_part() {
  
  ::viam::app::v1::RobotPart* temp = _impl_.part_;
  _impl_.part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::unsafe_arena_release_part() {
  // @@protoc_insertion_point(field_release:viam.app.v1.CreateRobotPartSecretResponse.part)
  
  ::viam::app::v1::RobotPart* temp = _impl_.part_;
  _impl_.part_ = nullptr;
  return temp;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::_internal_mutable_part() {
  
  if (_impl_.part_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::app::v1::RobotPart>(GetArenaForAllocation());
    _impl_.part_ = p;
  }
  return _impl_.part_;
}
inline ::viam::app::v1::RobotPart* CreateRobotPartSecretResponse::mutable_part() {
  ::viam::app::v1::RobotPart* _msg = _internal_mutable_part();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.CreateRobotPartSecretResponse.part)
  return _msg;
}
inline void CreateRobotPartSecretResponse::set_allocated_part(::viam::app::v1::RobotPart* part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.part_;
  }
  if (part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(part);
    if (message_arena != submessage_arena) {
      part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, part, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.part_ = part;
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.CreateRobotPartSecretResponse.part)
}

// -------------------------------------------------------------------

// DeleteRobotPartSecretRequest

// string part_id = 1 [json_name = "partId"];
inline void DeleteRobotPartSecretRequest::clear_part_id() {
  _impl_.part_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartSecretRequest::part_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return _internal_part_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartSecretRequest::set_part_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.part_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
}
inline std::string* DeleteRobotPartSecretRequest::mutable_part_id() {
  std::string* _s = _internal_mutable_part_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return _s;
}
inline const std::string& DeleteRobotPartSecretRequest::_internal_part_id() const {
  return _impl_.part_id_.Get();
}
inline void DeleteRobotPartSecretRequest::_internal_set_part_id(const std::string& value) {
  
  _impl_.part_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::_internal_mutable_part_id() {
  
  return _impl_.part_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::release_part_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
  return _impl_.part_id_.Release();
}
inline void DeleteRobotPartSecretRequest::set_allocated_part_id(std::string* part_id) {
  if (part_id != nullptr) {
    
  } else {
    
  }
  _impl_.part_id_.SetAllocated(part_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.part_id_.IsDefault()) {
    _impl_.part_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartSecretRequest.part_id)
}

// string secret_id = 2 [json_name = "secretId"];
inline void DeleteRobotPartSecretRequest::clear_secret_id() {
  _impl_.secret_id_.ClearToEmpty();
}
inline const std::string& DeleteRobotPartSecretRequest::secret_id() const {
  // @@protoc_insertion_point(field_get:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return _internal_secret_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRobotPartSecretRequest::set_secret_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
}
inline std::string* DeleteRobotPartSecretRequest::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return _s;
}
inline const std::string& DeleteRobotPartSecretRequest::_internal_secret_id() const {
  return _impl_.secret_id_.Get();
}
inline void DeleteRobotPartSecretRequest::_internal_set_secret_id(const std::string& value) {
  
  _impl_.secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::_internal_mutable_secret_id() {
  
  return _impl_.secret_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRobotPartSecretRequest::release_secret_id() {
  // @@protoc_insertion_point(field_release:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
  return _impl_.secret_id_.Release();
}
inline void DeleteRobotPartSecretRequest::set_allocated_secret_id(std::string* secret_id) {
  if (secret_id != nullptr) {
    
  } else {
    
  }
  _impl_.secret_id_.SetAllocated(secret_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_id_.IsDefault()) {
    _impl_.secret_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.app.v1.DeleteRobotPartSecretRequest.secret_id)
}

// -------------------------------------------------------------------

// DeleteRobotPartSecretResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace app
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::app::v1::SharedSecret_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::app::v1::SharedSecret_State>() {
  return ::viam::app::v1::SharedSecret_State_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_app_2fv1_2fapp_2eproto
