// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/rpc/webrtc/v1/signaling.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
namespace proto {
namespace rpc {
namespace webrtc {
namespace v1 {
class AnswerRequest;
struct AnswerRequestDefaultTypeInternal;
extern AnswerRequestDefaultTypeInternal _AnswerRequest_default_instance_;
class AnswerRequestDoneStage;
struct AnswerRequestDoneStageDefaultTypeInternal;
extern AnswerRequestDoneStageDefaultTypeInternal _AnswerRequestDoneStage_default_instance_;
class AnswerRequestErrorStage;
struct AnswerRequestErrorStageDefaultTypeInternal;
extern AnswerRequestErrorStageDefaultTypeInternal _AnswerRequestErrorStage_default_instance_;
class AnswerRequestInitStage;
struct AnswerRequestInitStageDefaultTypeInternal;
extern AnswerRequestInitStageDefaultTypeInternal _AnswerRequestInitStage_default_instance_;
class AnswerRequestUpdateStage;
struct AnswerRequestUpdateStageDefaultTypeInternal;
extern AnswerRequestUpdateStageDefaultTypeInternal _AnswerRequestUpdateStage_default_instance_;
class AnswerResponse;
struct AnswerResponseDefaultTypeInternal;
extern AnswerResponseDefaultTypeInternal _AnswerResponse_default_instance_;
class AnswerResponseDoneStage;
struct AnswerResponseDoneStageDefaultTypeInternal;
extern AnswerResponseDoneStageDefaultTypeInternal _AnswerResponseDoneStage_default_instance_;
class AnswerResponseErrorStage;
struct AnswerResponseErrorStageDefaultTypeInternal;
extern AnswerResponseErrorStageDefaultTypeInternal _AnswerResponseErrorStage_default_instance_;
class AnswerResponseInitStage;
struct AnswerResponseInitStageDefaultTypeInternal;
extern AnswerResponseInitStageDefaultTypeInternal _AnswerResponseInitStage_default_instance_;
class AnswerResponseUpdateStage;
struct AnswerResponseUpdateStageDefaultTypeInternal;
extern AnswerResponseUpdateStageDefaultTypeInternal _AnswerResponseUpdateStage_default_instance_;
class CallRequest;
struct CallRequestDefaultTypeInternal;
extern CallRequestDefaultTypeInternal _CallRequest_default_instance_;
class CallResponse;
struct CallResponseDefaultTypeInternal;
extern CallResponseDefaultTypeInternal _CallResponse_default_instance_;
class CallResponseInitStage;
struct CallResponseInitStageDefaultTypeInternal;
extern CallResponseInitStageDefaultTypeInternal _CallResponseInitStage_default_instance_;
class CallResponseUpdateStage;
struct CallResponseUpdateStageDefaultTypeInternal;
extern CallResponseUpdateStageDefaultTypeInternal _CallResponseUpdateStage_default_instance_;
class CallUpdateRequest;
struct CallUpdateRequestDefaultTypeInternal;
extern CallUpdateRequestDefaultTypeInternal _CallUpdateRequest_default_instance_;
class CallUpdateResponse;
struct CallUpdateResponseDefaultTypeInternal;
extern CallUpdateResponseDefaultTypeInternal _CallUpdateResponse_default_instance_;
class ICECandidate;
struct ICECandidateDefaultTypeInternal;
extern ICECandidateDefaultTypeInternal _ICECandidate_default_instance_;
class ICEServer;
struct ICEServerDefaultTypeInternal;
extern ICEServerDefaultTypeInternal _ICEServer_default_instance_;
class OptionalWebRTCConfigRequest;
struct OptionalWebRTCConfigRequestDefaultTypeInternal;
extern OptionalWebRTCConfigRequestDefaultTypeInternal _OptionalWebRTCConfigRequest_default_instance_;
class OptionalWebRTCConfigResponse;
struct OptionalWebRTCConfigResponseDefaultTypeInternal;
extern OptionalWebRTCConfigResponseDefaultTypeInternal _OptionalWebRTCConfigResponse_default_instance_;
class WebRTCConfig;
struct WebRTCConfigDefaultTypeInternal;
extern WebRTCConfigDefaultTypeInternal _WebRTCConfig_default_instance_;
}  // namespace v1
}  // namespace webrtc
}  // namespace rpc
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::rpc::webrtc::v1::AnswerRequest* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequest>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestDoneStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestErrorStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerRequestInitStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestInitStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerRequestUpdateStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerResponse* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponse>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseDoneStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseErrorStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerResponseInitStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseInitStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::AnswerResponseUpdateStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::CallRequest* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::CallRequest>(Arena*);
template<> ::proto::rpc::webrtc::v1::CallResponse* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::CallResponse>(Arena*);
template<> ::proto::rpc::webrtc::v1::CallResponseInitStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::CallResponseInitStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::CallResponseUpdateStage* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::CallResponseUpdateStage>(Arena*);
template<> ::proto::rpc::webrtc::v1::CallUpdateRequest* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::CallUpdateRequest>(Arena*);
template<> ::proto::rpc::webrtc::v1::CallUpdateResponse* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::CallUpdateResponse>(Arena*);
template<> ::proto::rpc::webrtc::v1::ICECandidate* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(Arena*);
template<> ::proto::rpc::webrtc::v1::ICEServer* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::ICEServer>(Arena*);
template<> ::proto::rpc::webrtc::v1::OptionalWebRTCConfigRequest* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::OptionalWebRTCConfigRequest>(Arena*);
template<> ::proto::rpc::webrtc::v1::OptionalWebRTCConfigResponse* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::OptionalWebRTCConfigResponse>(Arena*);
template<> ::proto::rpc::webrtc::v1::WebRTCConfig* Arena::CreateMaybeMessage<::proto::rpc::webrtc::v1::WebRTCConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {
namespace rpc {
namespace webrtc {
namespace v1 {

// ===================================================================

class ICECandidate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.ICECandidate) */ {
 public:
  inline ICECandidate() : ICECandidate(nullptr) {}
  ~ICECandidate() override;
  explicit PROTOBUF_CONSTEXPR ICECandidate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ICECandidate(const ICECandidate& from);
  ICECandidate(ICECandidate&& from) noexcept
    : ICECandidate() {
    *this = ::std::move(from);
  }

  inline ICECandidate& operator=(const ICECandidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICECandidate& operator=(ICECandidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICECandidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ICECandidate* internal_default_instance() {
    return reinterpret_cast<const ICECandidate*>(
               &_ICECandidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ICECandidate& a, ICECandidate& b) {
    a.Swap(&b);
  }
  inline void Swap(ICECandidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICECandidate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICECandidate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICECandidate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ICECandidate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ICECandidate& from) {
    ICECandidate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ICECandidate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.ICECandidate";
  }
  protected:
  explicit ICECandidate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
    kSdpMidFieldNumber = 2,
    kUsernameFragmentFieldNumber = 4,
    kSdpmLineIndexFieldNumber = 3,
  };
  // string candidate = 1 [json_name = "candidate"];
  void clear_candidate();
  const std::string& candidate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* candidate);
  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(const std::string& value);
  std::string* _internal_mutable_candidate();
  public:

  // optional string sdp_mid = 2 [json_name = "sdpMid"];
  bool has_sdp_mid() const;
  private:
  bool _internal_has_sdp_mid() const;
  public:
  void clear_sdp_mid();
  const std::string& sdp_mid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp_mid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp_mid();
  PROTOBUF_NODISCARD std::string* release_sdp_mid();
  void set_allocated_sdp_mid(std::string* sdp_mid);
  private:
  const std::string& _internal_sdp_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp_mid(const std::string& value);
  std::string* _internal_mutable_sdp_mid();
  public:

  // optional string username_fragment = 4 [json_name = "usernameFragment"];
  bool has_username_fragment() const;
  private:
  bool _internal_has_username_fragment() const;
  public:
  void clear_username_fragment();
  const std::string& username_fragment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username_fragment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username_fragment();
  PROTOBUF_NODISCARD std::string* release_username_fragment();
  void set_allocated_username_fragment(std::string* username_fragment);
  private:
  const std::string& _internal_username_fragment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username_fragment(const std::string& value);
  std::string* _internal_mutable_username_fragment();
  public:

  // optional uint32 sdpm_line_index = 3 [json_name = "sdpmLineIndex"];
  bool has_sdpm_line_index() const;
  private:
  bool _internal_has_sdpm_line_index() const;
  public:
  void clear_sdpm_line_index();
  uint32_t sdpm_line_index() const;
  void set_sdpm_line_index(uint32_t value);
  private:
  uint32_t _internal_sdpm_line_index() const;
  void _internal_set_sdpm_line_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.ICECandidate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_mid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_fragment_;
    uint32_t sdpm_line_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class CallRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallRequest) */ {
 public:
  inline CallRequest() : CallRequest(nullptr) {}
  ~CallRequest() override;
  explicit PROTOBUF_CONSTEXPR CallRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallRequest(const CallRequest& from);
  CallRequest(CallRequest&& from) noexcept
    : CallRequest() {
    *this = ::std::move(from);
  }

  inline CallRequest& operator=(const CallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallRequest& operator=(CallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallRequest* internal_default_instance() {
    return reinterpret_cast<const CallRequest*>(
               &_CallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CallRequest& a, CallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallRequest& from) {
    CallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.CallRequest";
  }
  protected:
  explicit CallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
    kDisableTrickleFieldNumber = 2,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // bool disable_trickle = 2 [json_name = "disableTrickle"];
  void clear_disable_trickle();
  bool disable_trickle() const;
  void set_disable_trickle(bool value);
  private:
  bool _internal_disable_trickle() const;
  void _internal_set_disable_trickle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    bool disable_trickle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class CallResponseInitStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallResponseInitStage) */ {
 public:
  inline CallResponseInitStage() : CallResponseInitStage(nullptr) {}
  ~CallResponseInitStage() override;
  explicit PROTOBUF_CONSTEXPR CallResponseInitStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallResponseInitStage(const CallResponseInitStage& from);
  CallResponseInitStage(CallResponseInitStage&& from) noexcept
    : CallResponseInitStage() {
    *this = ::std::move(from);
  }

  inline CallResponseInitStage& operator=(const CallResponseInitStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponseInitStage& operator=(CallResponseInitStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponseInitStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallResponseInitStage* internal_default_instance() {
    return reinterpret_cast<const CallResponseInitStage*>(
               &_CallResponseInitStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CallResponseInitStage& a, CallResponseInitStage& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponseInitStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponseInitStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponseInitStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponseInitStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallResponseInitStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallResponseInitStage& from) {
    CallResponseInitStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallResponseInitStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.CallResponseInitStage";
  }
  protected:
  explicit CallResponseInitStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallResponseInitStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class CallResponseUpdateStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallResponseUpdateStage) */ {
 public:
  inline CallResponseUpdateStage() : CallResponseUpdateStage(nullptr) {}
  ~CallResponseUpdateStage() override;
  explicit PROTOBUF_CONSTEXPR CallResponseUpdateStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallResponseUpdateStage(const CallResponseUpdateStage& from);
  CallResponseUpdateStage(CallResponseUpdateStage&& from) noexcept
    : CallResponseUpdateStage() {
    *this = ::std::move(from);
  }

  inline CallResponseUpdateStage& operator=(const CallResponseUpdateStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponseUpdateStage& operator=(CallResponseUpdateStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponseUpdateStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallResponseUpdateStage* internal_default_instance() {
    return reinterpret_cast<const CallResponseUpdateStage*>(
               &_CallResponseUpdateStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CallResponseUpdateStage& a, CallResponseUpdateStage& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponseUpdateStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponseUpdateStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponseUpdateStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponseUpdateStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallResponseUpdateStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallResponseUpdateStage& from) {
    CallResponseUpdateStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallResponseUpdateStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.CallResponseUpdateStage";
  }
  protected:
  explicit CallResponseUpdateStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;
  public:
  void clear_candidate();
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate);
  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();
  public:
  void unsafe_arena_set_allocated_candidate(
      ::proto::rpc::webrtc::v1::ICECandidate* candidate);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallResponseUpdateStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class CallResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallResponse) */ {
 public:
  inline CallResponse() : CallResponse(nullptr) {}
  ~CallResponse() override;
  explicit PROTOBUF_CONSTEXPR CallResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallResponse(const CallResponse& from);
  CallResponse(CallResponse&& from) noexcept
    : CallResponse() {
    *this = ::std::move(from);
  }

  inline CallResponse& operator=(const CallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponse& operator=(CallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StageCase {
    kInit = 2,
    kUpdate = 3,
    STAGE_NOT_SET = 0,
  };

  static inline const CallResponse* internal_default_instance() {
    return reinterpret_cast<const CallResponse*>(
               &_CallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CallResponse& a, CallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallResponse& from) {
    CallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.CallResponse";
  }
  protected:
  explicit CallResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kInitFieldNumber = 2,
    kUpdateFieldNumber = 3,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .proto.rpc.webrtc.v1.CallResponseInitStage init = 2 [json_name = "init"];
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::proto::rpc::webrtc::v1::CallResponseInitStage& init() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::CallResponseInitStage* release_init();
  ::proto::rpc::webrtc::v1::CallResponseInitStage* mutable_init();
  void set_allocated_init(::proto::rpc::webrtc::v1::CallResponseInitStage* init);
  private:
  const ::proto::rpc::webrtc::v1::CallResponseInitStage& _internal_init() const;
  ::proto::rpc::webrtc::v1::CallResponseInitStage* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::proto::rpc::webrtc::v1::CallResponseInitStage* init);
  ::proto::rpc::webrtc::v1::CallResponseInitStage* unsafe_arena_release_init();

  // .proto.rpc.webrtc.v1.CallResponseUpdateStage update = 3 [json_name = "update"];
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& update() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::CallResponseUpdateStage* release_update();
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* mutable_update();
  void set_allocated_update(::proto::rpc::webrtc::v1::CallResponseUpdateStage* update);
  private:
  const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& _internal_update() const;
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::proto::rpc::webrtc::v1::CallResponseUpdateStage* update);
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* unsafe_arena_release_update();

  void clear_stage();
  StageCase stage_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallResponse)
 private:
  class _Internal;
  void set_has_init();
  void set_has_update();

  inline bool has_stage() const;
  inline void clear_has_stage();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    union StageUnion {
      constexpr StageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::CallResponseInitStage* init_;
      ::proto::rpc::webrtc::v1::CallResponseUpdateStage* update_;
    } stage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class CallUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallUpdateRequest) */ {
 public:
  inline CallUpdateRequest() : CallUpdateRequest(nullptr) {}
  ~CallUpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR CallUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallUpdateRequest(const CallUpdateRequest& from);
  CallUpdateRequest(CallUpdateRequest&& from) noexcept
    : CallUpdateRequest() {
    *this = ::std::move(from);
  }

  inline CallUpdateRequest& operator=(const CallUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallUpdateRequest& operator=(CallUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  enum UpdateCase {
    kCandidate = 2,
    kDone = 3,
    kError = 4,
    UPDATE_NOT_SET = 0,
  };

  static inline const CallUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const CallUpdateRequest*>(
               &_CallUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CallUpdateRequest& a, CallUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CallUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallUpdateRequest& from) {
    CallUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.CallUpdateRequest";
  }
  protected:
  explicit CallUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kCandidateFieldNumber = 2,
    kDoneFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .proto.rpc.webrtc.v1.ICECandidate candidate = 2 [json_name = "candidate"];
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;
  public:
  void clear_candidate();
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate);
  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();
  public:
  void unsafe_arena_set_allocated_candidate(
      ::proto::rpc::webrtc::v1::ICECandidate* candidate);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  // bool done = 3 [json_name = "done"];
  bool has_done() const;
  private:
  bool _internal_has_done() const;
  public:
  void clear_done();
  bool done() const;
  void set_done(bool value);
  private:
  bool _internal_done() const;
  void _internal_set_done(bool value);
  public:

  // .google.rpc.Status error = 4 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::google::rpc::Status& error() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_error();
  ::google::rpc::Status* mutable_error();
  void set_allocated_error(::google::rpc::Status* error);
  private:
  const ::google::rpc::Status& _internal_error() const;
  ::google::rpc::Status* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::google::rpc::Status* error);
  ::google::rpc::Status* unsafe_arena_release_error();

  void clear_update();
  UpdateCase update_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallUpdateRequest)
 private:
  class _Internal;
  void set_has_candidate();
  void set_has_done();
  void set_has_error();

  inline bool has_update() const;
  inline void clear_has_update();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    union UpdateUnion {
      constexpr UpdateUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
      bool done_;
      ::google::rpc::Status* error_;
    } update_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class CallUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.CallUpdateResponse) */ {
 public:
  inline CallUpdateResponse() : CallUpdateResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CallUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallUpdateResponse(const CallUpdateResponse& from);
  CallUpdateResponse(CallUpdateResponse&& from) noexcept
    : CallUpdateResponse() {
    *this = ::std::move(from);
  }

  inline CallUpdateResponse& operator=(const CallUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallUpdateResponse& operator=(CallUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const CallUpdateResponse*>(
               &_CallUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CallUpdateResponse& a, CallUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CallUpdateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CallUpdateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.CallUpdateResponse";
  }
  protected:
  explicit CallUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.CallUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class ICEServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.ICEServer) */ {
 public:
  inline ICEServer() : ICEServer(nullptr) {}
  ~ICEServer() override;
  explicit PROTOBUF_CONSTEXPR ICEServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ICEServer(const ICEServer& from);
  ICEServer(ICEServer&& from) noexcept
    : ICEServer() {
    *this = ::std::move(from);
  }

  inline ICEServer& operator=(const ICEServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICEServer& operator=(ICEServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICEServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ICEServer* internal_default_instance() {
    return reinterpret_cast<const ICEServer*>(
               &_ICEServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ICEServer& a, ICEServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ICEServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICEServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICEServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICEServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ICEServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ICEServer& from) {
    ICEServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ICEServer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.ICEServer";
  }
  protected:
  explicit ICEServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kCredentialFieldNumber = 3,
  };
  // repeated string urls = 1 [json_name = "urls"];
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // string username = 2 [json_name = "username"];
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string credential = 3 [json_name = "credential"];
  void clear_credential();
  const std::string& credential() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credential(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credential();
  PROTOBUF_NODISCARD std::string* release_credential();
  void set_allocated_credential(std::string* credential);
  private:
  const std::string& _internal_credential() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credential(const std::string& value);
  std::string* _internal_mutable_credential();
  public:

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.ICEServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credential_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class WebRTCConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.WebRTCConfig) */ {
 public:
  inline WebRTCConfig() : WebRTCConfig(nullptr) {}
  ~WebRTCConfig() override;
  explicit PROTOBUF_CONSTEXPR WebRTCConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebRTCConfig(const WebRTCConfig& from);
  WebRTCConfig(WebRTCConfig&& from) noexcept
    : WebRTCConfig() {
    *this = ::std::move(from);
  }

  inline WebRTCConfig& operator=(const WebRTCConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebRTCConfig& operator=(WebRTCConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebRTCConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebRTCConfig* internal_default_instance() {
    return reinterpret_cast<const WebRTCConfig*>(
               &_WebRTCConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WebRTCConfig& a, WebRTCConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(WebRTCConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebRTCConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebRTCConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebRTCConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebRTCConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebRTCConfig& from) {
    WebRTCConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebRTCConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.WebRTCConfig";
  }
  protected:
  explicit WebRTCConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalIceServersFieldNumber = 1,
    kDisableTrickleFieldNumber = 2,
  };
  // repeated .proto.rpc.webrtc.v1.ICEServer additional_ice_servers = 1 [json_name = "additionalIceServers"];
  int additional_ice_servers_size() const;
  private:
  int _internal_additional_ice_servers_size() const;
  public:
  void clear_additional_ice_servers();
  ::proto::rpc::webrtc::v1::ICEServer* mutable_additional_ice_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer >*
      mutable_additional_ice_servers();
  private:
  const ::proto::rpc::webrtc::v1::ICEServer& _internal_additional_ice_servers(int index) const;
  ::proto::rpc::webrtc::v1::ICEServer* _internal_add_additional_ice_servers();
  public:
  const ::proto::rpc::webrtc::v1::ICEServer& additional_ice_servers(int index) const;
  ::proto::rpc::webrtc::v1::ICEServer* add_additional_ice_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer >&
      additional_ice_servers() const;

  // bool disable_trickle = 2 [json_name = "disableTrickle"];
  void clear_disable_trickle();
  bool disable_trickle() const;
  void set_disable_trickle(bool value);
  private:
  bool _internal_disable_trickle() const;
  void _internal_set_disable_trickle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.WebRTCConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer > additional_ice_servers_;
    bool disable_trickle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerRequestInitStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestInitStage) */ {
 public:
  inline AnswerRequestInitStage() : AnswerRequestInitStage(nullptr) {}
  ~AnswerRequestInitStage() override;
  explicit PROTOBUF_CONSTEXPR AnswerRequestInitStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerRequestInitStage(const AnswerRequestInitStage& from);
  AnswerRequestInitStage(AnswerRequestInitStage&& from) noexcept
    : AnswerRequestInitStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestInitStage& operator=(const AnswerRequestInitStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestInitStage& operator=(AnswerRequestInitStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestInitStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestInitStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestInitStage*>(
               &_AnswerRequestInitStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AnswerRequestInitStage& a, AnswerRequestInitStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestInitStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestInitStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestInitStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestInitStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerRequestInitStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerRequestInitStage& from) {
    AnswerRequestInitStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerRequestInitStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestInitStage";
  }
  protected:
  explicit AnswerRequestInitStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
    kOptionalConfigFieldNumber = 2,
    kDeadlineFieldNumber = 3,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // .proto.rpc.webrtc.v1.WebRTCConfig optional_config = 2 [json_name = "optionalConfig"];
  bool has_optional_config() const;
  private:
  bool _internal_has_optional_config() const;
  public:
  void clear_optional_config();
  const ::proto::rpc::webrtc::v1::WebRTCConfig& optional_config() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::WebRTCConfig* release_optional_config();
  ::proto::rpc::webrtc::v1::WebRTCConfig* mutable_optional_config();
  void set_allocated_optional_config(::proto::rpc::webrtc::v1::WebRTCConfig* optional_config);
  private:
  const ::proto::rpc::webrtc::v1::WebRTCConfig& _internal_optional_config() const;
  ::proto::rpc::webrtc::v1::WebRTCConfig* _internal_mutable_optional_config();
  public:
  void unsafe_arena_set_allocated_optional_config(
      ::proto::rpc::webrtc::v1::WebRTCConfig* optional_config);
  ::proto::rpc::webrtc::v1::WebRTCConfig* unsafe_arena_release_optional_config();

  // optional .google.protobuf.Timestamp deadline = 3 [json_name = "deadline"];
  bool has_deadline() const;
  private:
  bool _internal_has_deadline() const;
  public:
  void clear_deadline();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deadline() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deadline();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deadline();
  void set_allocated_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* deadline);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deadline() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deadline();
  public:
  void unsafe_arena_set_allocated_deadline(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deadline);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deadline();

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestInitStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    ::proto::rpc::webrtc::v1::WebRTCConfig* optional_config_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deadline_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerRequestUpdateStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestUpdateStage) */ {
 public:
  inline AnswerRequestUpdateStage() : AnswerRequestUpdateStage(nullptr) {}
  ~AnswerRequestUpdateStage() override;
  explicit PROTOBUF_CONSTEXPR AnswerRequestUpdateStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerRequestUpdateStage(const AnswerRequestUpdateStage& from);
  AnswerRequestUpdateStage(AnswerRequestUpdateStage&& from) noexcept
    : AnswerRequestUpdateStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestUpdateStage& operator=(const AnswerRequestUpdateStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestUpdateStage& operator=(AnswerRequestUpdateStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestUpdateStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestUpdateStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestUpdateStage*>(
               &_AnswerRequestUpdateStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AnswerRequestUpdateStage& a, AnswerRequestUpdateStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestUpdateStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestUpdateStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestUpdateStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestUpdateStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerRequestUpdateStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerRequestUpdateStage& from) {
    AnswerRequestUpdateStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerRequestUpdateStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestUpdateStage";
  }
  protected:
  explicit AnswerRequestUpdateStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;
  public:
  void clear_candidate();
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate);
  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();
  public:
  void unsafe_arena_set_allocated_candidate(
      ::proto::rpc::webrtc::v1::ICECandidate* candidate);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestUpdateStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerRequestDoneStage final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestDoneStage) */ {
 public:
  inline AnswerRequestDoneStage() : AnswerRequestDoneStage(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AnswerRequestDoneStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerRequestDoneStage(const AnswerRequestDoneStage& from);
  AnswerRequestDoneStage(AnswerRequestDoneStage&& from) noexcept
    : AnswerRequestDoneStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestDoneStage& operator=(const AnswerRequestDoneStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestDoneStage& operator=(AnswerRequestDoneStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestDoneStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestDoneStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestDoneStage*>(
               &_AnswerRequestDoneStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AnswerRequestDoneStage& a, AnswerRequestDoneStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestDoneStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestDoneStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestDoneStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestDoneStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnswerRequestDoneStage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnswerRequestDoneStage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestDoneStage";
  }
  protected:
  explicit AnswerRequestDoneStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestDoneStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerRequestErrorStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequestErrorStage) */ {
 public:
  inline AnswerRequestErrorStage() : AnswerRequestErrorStage(nullptr) {}
  ~AnswerRequestErrorStage() override;
  explicit PROTOBUF_CONSTEXPR AnswerRequestErrorStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerRequestErrorStage(const AnswerRequestErrorStage& from);
  AnswerRequestErrorStage(AnswerRequestErrorStage&& from) noexcept
    : AnswerRequestErrorStage() {
    *this = ::std::move(from);
  }

  inline AnswerRequestErrorStage& operator=(const AnswerRequestErrorStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequestErrorStage& operator=(AnswerRequestErrorStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequestErrorStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerRequestErrorStage* internal_default_instance() {
    return reinterpret_cast<const AnswerRequestErrorStage*>(
               &_AnswerRequestErrorStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AnswerRequestErrorStage& a, AnswerRequestErrorStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequestErrorStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequestErrorStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequestErrorStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequestErrorStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerRequestErrorStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerRequestErrorStage& from) {
    AnswerRequestErrorStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerRequestErrorStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequestErrorStage";
  }
  protected:
  explicit AnswerRequestErrorStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .google.rpc.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::google::rpc::Status& status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);
  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::google::rpc::Status* status);
  ::google::rpc::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequestErrorStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::rpc::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerRequest) */ {
 public:
  inline AnswerRequest() : AnswerRequest(nullptr) {}
  ~AnswerRequest() override;
  explicit PROTOBUF_CONSTEXPR AnswerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerRequest(const AnswerRequest& from);
  AnswerRequest(AnswerRequest&& from) noexcept
    : AnswerRequest() {
    *this = ::std::move(from);
  }

  inline AnswerRequest& operator=(const AnswerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerRequest& operator=(AnswerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StageCase {
    kInit = 2,
    kUpdate = 3,
    kDone = 4,
    kError = 5,
    STAGE_NOT_SET = 0,
  };

  static inline const AnswerRequest* internal_default_instance() {
    return reinterpret_cast<const AnswerRequest*>(
               &_AnswerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AnswerRequest& a, AnswerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerRequest& from) {
    AnswerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerRequest";
  }
  protected:
  explicit AnswerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kInitFieldNumber = 2,
    kUpdateFieldNumber = 3,
    kDoneFieldNumber = 4,
    kErrorFieldNumber = 5,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .proto.rpc.webrtc.v1.AnswerRequestInitStage init = 2 [json_name = "init"];
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& init() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestInitStage* release_init();
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* mutable_init();
  void set_allocated_init(::proto::rpc::webrtc::v1::AnswerRequestInitStage* init);
  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& _internal_init() const;
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::proto::rpc::webrtc::v1::AnswerRequestInitStage* init);
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* unsafe_arena_release_init();

  // .proto.rpc.webrtc.v1.AnswerRequestUpdateStage update = 3 [json_name = "update"];
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& update() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* release_update();
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* mutable_update();
  void set_allocated_update(::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* update);
  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& _internal_update() const;
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* update);
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* unsafe_arena_release_update();

  // .proto.rpc.webrtc.v1.AnswerRequestDoneStage done = 4 [json_name = "done"];
  bool has_done() const;
  private:
  bool _internal_has_done() const;
  public:
  void clear_done();
  const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& done() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* release_done();
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* mutable_done();
  void set_allocated_done(::proto::rpc::webrtc::v1::AnswerRequestDoneStage* done);
  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& _internal_done() const;
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* _internal_mutable_done();
  public:
  void unsafe_arena_set_allocated_done(
      ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* done);
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* unsafe_arena_release_done();

  // .proto.rpc.webrtc.v1.AnswerRequestErrorStage error = 5 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& error() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* release_error();
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* mutable_error();
  void set_allocated_error(::proto::rpc::webrtc::v1::AnswerRequestErrorStage* error);
  private:
  const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& _internal_error() const;
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* error);
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* unsafe_arena_release_error();

  void clear_stage();
  StageCase stage_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerRequest)
 private:
  class _Internal;
  void set_has_init();
  void set_has_update();
  void set_has_done();
  void set_has_error();

  inline bool has_stage() const;
  inline void clear_has_stage();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    union StageUnion {
      constexpr StageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::AnswerRequestInitStage* init_;
      ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* update_;
      ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* done_;
      ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* error_;
    } stage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerResponseInitStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseInitStage) */ {
 public:
  inline AnswerResponseInitStage() : AnswerResponseInitStage(nullptr) {}
  ~AnswerResponseInitStage() override;
  explicit PROTOBUF_CONSTEXPR AnswerResponseInitStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerResponseInitStage(const AnswerResponseInitStage& from);
  AnswerResponseInitStage(AnswerResponseInitStage&& from) noexcept
    : AnswerResponseInitStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseInitStage& operator=(const AnswerResponseInitStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseInitStage& operator=(AnswerResponseInitStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseInitStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseInitStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseInitStage*>(
               &_AnswerResponseInitStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AnswerResponseInitStage& a, AnswerResponseInitStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseInitStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseInitStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseInitStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseInitStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerResponseInitStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerResponseInitStage& from) {
    AnswerResponseInitStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerResponseInitStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseInitStage";
  }
  protected:
  explicit AnswerResponseInitStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
  };
  // string sdp = 1 [json_name = "sdp"];
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseInitStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerResponseUpdateStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseUpdateStage) */ {
 public:
  inline AnswerResponseUpdateStage() : AnswerResponseUpdateStage(nullptr) {}
  ~AnswerResponseUpdateStage() override;
  explicit PROTOBUF_CONSTEXPR AnswerResponseUpdateStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerResponseUpdateStage(const AnswerResponseUpdateStage& from);
  AnswerResponseUpdateStage(AnswerResponseUpdateStage&& from) noexcept
    : AnswerResponseUpdateStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseUpdateStage& operator=(const AnswerResponseUpdateStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseUpdateStage& operator=(AnswerResponseUpdateStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseUpdateStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseUpdateStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseUpdateStage*>(
               &_AnswerResponseUpdateStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AnswerResponseUpdateStage& a, AnswerResponseUpdateStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseUpdateStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseUpdateStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseUpdateStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseUpdateStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerResponseUpdateStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerResponseUpdateStage& from) {
    AnswerResponseUpdateStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerResponseUpdateStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseUpdateStage";
  }
  protected:
  explicit AnswerResponseUpdateStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;
  public:
  void clear_candidate();
  const ::proto::rpc::webrtc::v1::ICECandidate& candidate() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::ICECandidate* release_candidate();
  ::proto::rpc::webrtc::v1::ICECandidate* mutable_candidate();
  void set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate);
  private:
  const ::proto::rpc::webrtc::v1::ICECandidate& _internal_candidate() const;
  ::proto::rpc::webrtc::v1::ICECandidate* _internal_mutable_candidate();
  public:
  void unsafe_arena_set_allocated_candidate(
      ::proto::rpc::webrtc::v1::ICECandidate* candidate);
  ::proto::rpc::webrtc::v1::ICECandidate* unsafe_arena_release_candidate();

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseUpdateStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::rpc::webrtc::v1::ICECandidate* candidate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerResponseDoneStage final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseDoneStage) */ {
 public:
  inline AnswerResponseDoneStage() : AnswerResponseDoneStage(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AnswerResponseDoneStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerResponseDoneStage(const AnswerResponseDoneStage& from);
  AnswerResponseDoneStage(AnswerResponseDoneStage&& from) noexcept
    : AnswerResponseDoneStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseDoneStage& operator=(const AnswerResponseDoneStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseDoneStage& operator=(AnswerResponseDoneStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseDoneStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseDoneStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseDoneStage*>(
               &_AnswerResponseDoneStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AnswerResponseDoneStage& a, AnswerResponseDoneStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseDoneStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseDoneStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseDoneStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseDoneStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnswerResponseDoneStage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnswerResponseDoneStage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseDoneStage";
  }
  protected:
  explicit AnswerResponseDoneStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseDoneStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerResponseErrorStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponseErrorStage) */ {
 public:
  inline AnswerResponseErrorStage() : AnswerResponseErrorStage(nullptr) {}
  ~AnswerResponseErrorStage() override;
  explicit PROTOBUF_CONSTEXPR AnswerResponseErrorStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerResponseErrorStage(const AnswerResponseErrorStage& from);
  AnswerResponseErrorStage(AnswerResponseErrorStage&& from) noexcept
    : AnswerResponseErrorStage() {
    *this = ::std::move(from);
  }

  inline AnswerResponseErrorStage& operator=(const AnswerResponseErrorStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponseErrorStage& operator=(AnswerResponseErrorStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponseErrorStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerResponseErrorStage* internal_default_instance() {
    return reinterpret_cast<const AnswerResponseErrorStage*>(
               &_AnswerResponseErrorStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AnswerResponseErrorStage& a, AnswerResponseErrorStage& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponseErrorStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponseErrorStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponseErrorStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponseErrorStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerResponseErrorStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerResponseErrorStage& from) {
    AnswerResponseErrorStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerResponseErrorStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponseErrorStage";
  }
  protected:
  explicit AnswerResponseErrorStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .google.rpc.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::google::rpc::Status& status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);
  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::google::rpc::Status* status);
  ::google::rpc::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponseErrorStage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::rpc::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class AnswerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.AnswerResponse) */ {
 public:
  inline AnswerResponse() : AnswerResponse(nullptr) {}
  ~AnswerResponse() override;
  explicit PROTOBUF_CONSTEXPR AnswerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerResponse(const AnswerResponse& from);
  AnswerResponse(AnswerResponse&& from) noexcept
    : AnswerResponse() {
    *this = ::std::move(from);
  }

  inline AnswerResponse& operator=(const AnswerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerResponse& operator=(AnswerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StageCase {
    kInit = 2,
    kUpdate = 3,
    kDone = 4,
    kError = 5,
    STAGE_NOT_SET = 0,
  };

  static inline const AnswerResponse* internal_default_instance() {
    return reinterpret_cast<const AnswerResponse*>(
               &_AnswerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AnswerResponse& a, AnswerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerResponse& from) {
    AnswerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.AnswerResponse";
  }
  protected:
  explicit AnswerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kInitFieldNumber = 2,
    kUpdateFieldNumber = 3,
    kDoneFieldNumber = 4,
    kErrorFieldNumber = 5,
  };
  // string uuid = 1 [json_name = "uuid"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .proto.rpc.webrtc.v1.AnswerResponseInitStage init = 2 [json_name = "init"];
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& init() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseInitStage* release_init();
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* mutable_init();
  void set_allocated_init(::proto::rpc::webrtc::v1::AnswerResponseInitStage* init);
  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& _internal_init() const;
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::proto::rpc::webrtc::v1::AnswerResponseInitStage* init);
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* unsafe_arena_release_init();

  // .proto.rpc.webrtc.v1.AnswerResponseUpdateStage update = 3 [json_name = "update"];
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& update() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* release_update();
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* mutable_update();
  void set_allocated_update(::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* update);
  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& _internal_update() const;
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* update);
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* unsafe_arena_release_update();

  // .proto.rpc.webrtc.v1.AnswerResponseDoneStage done = 4 [json_name = "done"];
  bool has_done() const;
  private:
  bool _internal_has_done() const;
  public:
  void clear_done();
  const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& done() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* release_done();
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* mutable_done();
  void set_allocated_done(::proto::rpc::webrtc::v1::AnswerResponseDoneStage* done);
  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& _internal_done() const;
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* _internal_mutable_done();
  public:
  void unsafe_arena_set_allocated_done(
      ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* done);
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* unsafe_arena_release_done();

  // .proto.rpc.webrtc.v1.AnswerResponseErrorStage error = 5 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& error() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* release_error();
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* mutable_error();
  void set_allocated_error(::proto::rpc::webrtc::v1::AnswerResponseErrorStage* error);
  private:
  const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& _internal_error() const;
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* error);
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* unsafe_arena_release_error();

  void clear_stage();
  StageCase stage_case() const;
  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.AnswerResponse)
 private:
  class _Internal;
  void set_has_init();
  void set_has_update();
  void set_has_done();
  void set_has_error();

  inline bool has_stage() const;
  inline void clear_has_stage();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    union StageUnion {
      constexpr StageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::rpc::webrtc::v1::AnswerResponseInitStage* init_;
      ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* update_;
      ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* done_;
      ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* error_;
    } stage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class OptionalWebRTCConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.OptionalWebRTCConfigRequest) */ {
 public:
  inline OptionalWebRTCConfigRequest() : OptionalWebRTCConfigRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OptionalWebRTCConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptionalWebRTCConfigRequest(const OptionalWebRTCConfigRequest& from);
  OptionalWebRTCConfigRequest(OptionalWebRTCConfigRequest&& from) noexcept
    : OptionalWebRTCConfigRequest() {
    *this = ::std::move(from);
  }

  inline OptionalWebRTCConfigRequest& operator=(const OptionalWebRTCConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalWebRTCConfigRequest& operator=(OptionalWebRTCConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalWebRTCConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionalWebRTCConfigRequest* internal_default_instance() {
    return reinterpret_cast<const OptionalWebRTCConfigRequest*>(
               &_OptionalWebRTCConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OptionalWebRTCConfigRequest& a, OptionalWebRTCConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionalWebRTCConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalWebRTCConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalWebRTCConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptionalWebRTCConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OptionalWebRTCConfigRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OptionalWebRTCConfigRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.OptionalWebRTCConfigRequest";
  }
  protected:
  explicit OptionalWebRTCConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.OptionalWebRTCConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// -------------------------------------------------------------------

class OptionalWebRTCConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse) */ {
 public:
  inline OptionalWebRTCConfigResponse() : OptionalWebRTCConfigResponse(nullptr) {}
  ~OptionalWebRTCConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR OptionalWebRTCConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptionalWebRTCConfigResponse(const OptionalWebRTCConfigResponse& from);
  OptionalWebRTCConfigResponse(OptionalWebRTCConfigResponse&& from) noexcept
    : OptionalWebRTCConfigResponse() {
    *this = ::std::move(from);
  }

  inline OptionalWebRTCConfigResponse& operator=(const OptionalWebRTCConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalWebRTCConfigResponse& operator=(OptionalWebRTCConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalWebRTCConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionalWebRTCConfigResponse* internal_default_instance() {
    return reinterpret_cast<const OptionalWebRTCConfigResponse*>(
               &_OptionalWebRTCConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(OptionalWebRTCConfigResponse& a, OptionalWebRTCConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionalWebRTCConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalWebRTCConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalWebRTCConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptionalWebRTCConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptionalWebRTCConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptionalWebRTCConfigResponse& from) {
    OptionalWebRTCConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionalWebRTCConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse";
  }
  protected:
  explicit OptionalWebRTCConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .proto.rpc.webrtc.v1.WebRTCConfig config = 1 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::proto::rpc::webrtc::v1::WebRTCConfig& config() const;
  PROTOBUF_NODISCARD ::proto::rpc::webrtc::v1::WebRTCConfig* release_config();
  ::proto::rpc::webrtc::v1::WebRTCConfig* mutable_config();
  void set_allocated_config(::proto::rpc::webrtc::v1::WebRTCConfig* config);
  private:
  const ::proto::rpc::webrtc::v1::WebRTCConfig& _internal_config() const;
  ::proto::rpc::webrtc::v1::WebRTCConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::proto::rpc::webrtc::v1::WebRTCConfig* config);
  ::proto::rpc::webrtc::v1::WebRTCConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::rpc::webrtc::v1::WebRTCConfig* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ICECandidate

// string candidate = 1 [json_name = "candidate"];
inline void ICECandidate::clear_candidate() {
  _impl_.candidate_.ClearToEmpty();
}
inline const std::string& ICECandidate::candidate() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.candidate)
  return _internal_candidate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICECandidate::set_candidate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.candidate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.candidate)
}
inline std::string* ICECandidate::mutable_candidate() {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICECandidate.candidate)
  return _s;
}
inline const std::string& ICECandidate::_internal_candidate() const {
  return _impl_.candidate_.Get();
}
inline void ICECandidate::_internal_set_candidate(const std::string& value) {
  
  _impl_.candidate_.Set(value, GetArenaForAllocation());
}
inline std::string* ICECandidate::_internal_mutable_candidate() {
  
  return _impl_.candidate_.Mutable(GetArenaForAllocation());
}
inline std::string* ICECandidate::release_candidate() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICECandidate.candidate)
  return _impl_.candidate_.Release();
}
inline void ICECandidate::set_allocated_candidate(std::string* candidate) {
  if (candidate != nullptr) {
    
  } else {
    
  }
  _impl_.candidate_.SetAllocated(candidate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.candidate_.IsDefault()) {
    _impl_.candidate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICECandidate.candidate)
}

// optional string sdp_mid = 2 [json_name = "sdpMid"];
inline bool ICECandidate::_internal_has_sdp_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ICECandidate::has_sdp_mid() const {
  return _internal_has_sdp_mid();
}
inline void ICECandidate::clear_sdp_mid() {
  _impl_.sdp_mid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ICECandidate::sdp_mid() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
  return _internal_sdp_mid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICECandidate::set_sdp_mid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sdp_mid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
}
inline std::string* ICECandidate::mutable_sdp_mid() {
  std::string* _s = _internal_mutable_sdp_mid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
  return _s;
}
inline const std::string& ICECandidate::_internal_sdp_mid() const {
  return _impl_.sdp_mid_.Get();
}
inline void ICECandidate::_internal_set_sdp_mid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sdp_mid_.Set(value, GetArenaForAllocation());
}
inline std::string* ICECandidate::_internal_mutable_sdp_mid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sdp_mid_.Mutable(GetArenaForAllocation());
}
inline std::string* ICECandidate::release_sdp_mid() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
  if (!_internal_has_sdp_mid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sdp_mid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_mid_.IsDefault()) {
    _impl_.sdp_mid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ICECandidate::set_allocated_sdp_mid(std::string* sdp_mid) {
  if (sdp_mid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sdp_mid_.SetAllocated(sdp_mid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_mid_.IsDefault()) {
    _impl_.sdp_mid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICECandidate.sdp_mid)
}

// optional uint32 sdpm_line_index = 3 [json_name = "sdpmLineIndex"];
inline bool ICECandidate::_internal_has_sdpm_line_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ICECandidate::has_sdpm_line_index() const {
  return _internal_has_sdpm_line_index();
}
inline void ICECandidate::clear_sdpm_line_index() {
  _impl_.sdpm_line_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ICECandidate::_internal_sdpm_line_index() const {
  return _impl_.sdpm_line_index_;
}
inline uint32_t ICECandidate::sdpm_line_index() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.sdpm_line_index)
  return _internal_sdpm_line_index();
}
inline void ICECandidate::_internal_set_sdpm_line_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sdpm_line_index_ = value;
}
inline void ICECandidate::set_sdpm_line_index(uint32_t value) {
  _internal_set_sdpm_line_index(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.sdpm_line_index)
}

// optional string username_fragment = 4 [json_name = "usernameFragment"];
inline bool ICECandidate::_internal_has_username_fragment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ICECandidate::has_username_fragment() const {
  return _internal_has_username_fragment();
}
inline void ICECandidate::clear_username_fragment() {
  _impl_.username_fragment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ICECandidate::username_fragment() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
  return _internal_username_fragment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICECandidate::set_username_fragment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.username_fragment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
}
inline std::string* ICECandidate::mutable_username_fragment() {
  std::string* _s = _internal_mutable_username_fragment();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
  return _s;
}
inline const std::string& ICECandidate::_internal_username_fragment() const {
  return _impl_.username_fragment_.Get();
}
inline void ICECandidate::_internal_set_username_fragment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.username_fragment_.Set(value, GetArenaForAllocation());
}
inline std::string* ICECandidate::_internal_mutable_username_fragment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.username_fragment_.Mutable(GetArenaForAllocation());
}
inline std::string* ICECandidate::release_username_fragment() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
  if (!_internal_has_username_fragment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.username_fragment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_fragment_.IsDefault()) {
    _impl_.username_fragment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ICECandidate::set_allocated_username_fragment(std::string* username_fragment) {
  if (username_fragment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.username_fragment_.SetAllocated(username_fragment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_fragment_.IsDefault()) {
    _impl_.username_fragment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICECandidate.username_fragment)
}

// -------------------------------------------------------------------

// CallRequest

// string sdp = 1 [json_name = "sdp"];
inline void CallRequest::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& CallRequest::sdp() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallRequest.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRequest::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallRequest.sdp)
}
inline std::string* CallRequest::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallRequest.sdp)
  return _s;
}
inline const std::string& CallRequest::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void CallRequest::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRequest::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRequest::release_sdp() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallRequest.sdp)
  return _impl_.sdp_.Release();
}
inline void CallRequest::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallRequest.sdp)
}

// bool disable_trickle = 2 [json_name = "disableTrickle"];
inline void CallRequest::clear_disable_trickle() {
  _impl_.disable_trickle_ = false;
}
inline bool CallRequest::_internal_disable_trickle() const {
  return _impl_.disable_trickle_;
}
inline bool CallRequest::disable_trickle() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallRequest.disable_trickle)
  return _internal_disable_trickle();
}
inline void CallRequest::_internal_set_disable_trickle(bool value) {
  
  _impl_.disable_trickle_ = value;
}
inline void CallRequest::set_disable_trickle(bool value) {
  _internal_set_disable_trickle(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallRequest.disable_trickle)
}

// -------------------------------------------------------------------

// CallResponseInitStage

// string sdp = 1 [json_name = "sdp"];
inline void CallResponseInitStage::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& CallResponseInitStage::sdp() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallResponseInitStage::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
}
inline std::string* CallResponseInitStage::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
  return _s;
}
inline const std::string& CallResponseInitStage::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void CallResponseInitStage::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* CallResponseInitStage::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* CallResponseInitStage::release_sdp() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
  return _impl_.sdp_.Release();
}
inline void CallResponseInitStage::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallResponseInitStage.sdp)
}

// -------------------------------------------------------------------

// CallResponseUpdateStage

// .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
inline bool CallResponseUpdateStage::_internal_has_candidate() const {
  return this != internal_default_instance() && _impl_.candidate_ != nullptr;
}
inline bool CallResponseUpdateStage::has_candidate() const {
  return _internal_has_candidate();
}
inline void CallResponseUpdateStage::clear_candidate() {
  if (GetArenaForAllocation() == nullptr && _impl_.candidate_ != nullptr) {
    delete _impl_.candidate_;
  }
  _impl_.candidate_ = nullptr;
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallResponseUpdateStage::_internal_candidate() const {
  const ::proto::rpc::webrtc::v1::ICECandidate* p = _impl_.candidate_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::ICECandidate&>(
      ::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallResponseUpdateStage::candidate() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
  return _internal_candidate();
}
inline void CallResponseUpdateStage::unsafe_arena_set_allocated_candidate(
    ::proto::rpc::webrtc::v1::ICECandidate* candidate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.candidate_);
  }
  _impl_.candidate_ = candidate;
  if (candidate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::release_candidate() {
  
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::unsafe_arena_release_candidate() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
  
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::_internal_mutable_candidate() {
  
  if (_impl_.candidate_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(GetArenaForAllocation());
    _impl_.candidate_ = p;
  }
  return _impl_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallResponseUpdateStage::mutable_candidate() {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
  return _msg;
}
inline void CallResponseUpdateStage::set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.candidate_;
  }
  if (candidate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(candidate);
    if (message_arena != submessage_arena) {
      candidate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candidate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.candidate_ = candidate;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallResponseUpdateStage.candidate)
}

// -------------------------------------------------------------------

// CallResponse

// string uuid = 1 [json_name = "uuid"];
inline void CallResponse::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& CallResponse::uuid() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponse.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallResponse::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallResponse.uuid)
}
inline std::string* CallResponse::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponse.uuid)
  return _s;
}
inline const std::string& CallResponse::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void CallResponse::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* CallResponse::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* CallResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponse.uuid)
  return _impl_.uuid_.Release();
}
inline void CallResponse::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallResponse.uuid)
}

// .proto.rpc.webrtc.v1.CallResponseInitStage init = 2 [json_name = "init"];
inline bool CallResponse::_internal_has_init() const {
  return stage_case() == kInit;
}
inline bool CallResponse::has_init() const {
  return _internal_has_init();
}
inline void CallResponse::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void CallResponse::clear_init() {
  if (_internal_has_init()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.init_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::release_init() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponse.init)
  if (_internal_has_init()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::CallResponseInitStage* temp = _impl_.stage_.init_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::CallResponseInitStage& CallResponse::_internal_init() const {
  return _internal_has_init()
      ? *_impl_.stage_.init_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::CallResponseInitStage&>(::proto::rpc::webrtc::v1::_CallResponseInitStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::CallResponseInitStage& CallResponse::init() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponse.init)
  return _internal_init();
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallResponse.init)
  if (_internal_has_init()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::CallResponseInitStage* temp = _impl_.stage_.init_;
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallResponse::unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::CallResponseInitStage* init) {
  clear_stage();
  if (init) {
    set_has_init();
    _impl_.stage_.init_ = init;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallResponse.init)
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_stage();
    set_has_init();
    _impl_.stage_.init_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::CallResponseInitStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.init_;
}
inline ::proto::rpc::webrtc::v1::CallResponseInitStage* CallResponse::mutable_init() {
  ::proto::rpc::webrtc::v1::CallResponseInitStage* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponse.init)
  return _msg;
}

// .proto.rpc.webrtc.v1.CallResponseUpdateStage update = 3 [json_name = "update"];
inline bool CallResponse::_internal_has_update() const {
  return stage_case() == kUpdate;
}
inline bool CallResponse::has_update() const {
  return _internal_has_update();
}
inline void CallResponse::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void CallResponse::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.update_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::release_update() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallResponse.update)
  if (_internal_has_update()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::CallResponseUpdateStage* temp = _impl_.stage_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& CallResponse::_internal_update() const {
  return _internal_has_update()
      ? *_impl_.stage_.update_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::CallResponseUpdateStage&>(::proto::rpc::webrtc::v1::_CallResponseUpdateStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::CallResponseUpdateStage& CallResponse::update() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallResponse.update)
  return _internal_update();
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallResponse.update)
  if (_internal_has_update()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::CallResponseUpdateStage* temp = _impl_.stage_.update_;
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallResponse::unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::CallResponseUpdateStage* update) {
  clear_stage();
  if (update) {
    set_has_update();
    _impl_.stage_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallResponse.update)
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_stage();
    set_has_update();
    _impl_.stage_.update_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::CallResponseUpdateStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.update_;
}
inline ::proto::rpc::webrtc::v1::CallResponseUpdateStage* CallResponse::mutable_update() {
  ::proto::rpc::webrtc::v1::CallResponseUpdateStage* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallResponse.update)
  return _msg;
}

inline bool CallResponse::has_stage() const {
  return stage_case() != STAGE_NOT_SET;
}
inline void CallResponse::clear_has_stage() {
  _impl_._oneof_case_[0] = STAGE_NOT_SET;
}
inline CallResponse::StageCase CallResponse::stage_case() const {
  return CallResponse::StageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallUpdateRequest

// string uuid = 1 [json_name = "uuid"];
inline void CallUpdateRequest::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& CallUpdateRequest::uuid() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallUpdateRequest::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
}
inline std::string* CallUpdateRequest::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
  return _s;
}
inline const std::string& CallUpdateRequest::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void CallUpdateRequest::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* CallUpdateRequest::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* CallUpdateRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
  return _impl_.uuid_.Release();
}
inline void CallUpdateRequest::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.CallUpdateRequest.uuid)
}

// .proto.rpc.webrtc.v1.ICECandidate candidate = 2 [json_name = "candidate"];
inline bool CallUpdateRequest::_internal_has_candidate() const {
  return update_case() == kCandidate;
}
inline bool CallUpdateRequest::has_candidate() const {
  return _internal_has_candidate();
}
inline void CallUpdateRequest::set_has_candidate() {
  _impl_._oneof_case_[0] = kCandidate;
}
inline void CallUpdateRequest::clear_candidate() {
  if (_internal_has_candidate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.update_.candidate_;
    }
    clear_has_update();
  }
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::release_candidate() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  if (_internal_has_candidate()) {
    clear_has_update();
    ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.update_.candidate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.candidate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallUpdateRequest::_internal_candidate() const {
  return _internal_has_candidate()
      ? *_impl_.update_.candidate_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::ICECandidate&>(::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& CallUpdateRequest::candidate() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  return _internal_candidate();
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::unsafe_arena_release_candidate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  if (_internal_has_candidate()) {
    clear_has_update();
    ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.update_.candidate_;
    _impl_.update_.candidate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallUpdateRequest::unsafe_arena_set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate) {
  clear_update();
  if (candidate) {
    set_has_candidate();
    _impl_.update_.candidate_ = candidate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::_internal_mutable_candidate() {
  if (!_internal_has_candidate()) {
    clear_update();
    set_has_candidate();
    _impl_.update_.candidate_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::ICECandidate >(GetArenaForAllocation());
  }
  return _impl_.update_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* CallUpdateRequest::mutable_candidate() {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallUpdateRequest.candidate)
  return _msg;
}

// bool done = 3 [json_name = "done"];
inline bool CallUpdateRequest::_internal_has_done() const {
  return update_case() == kDone;
}
inline bool CallUpdateRequest::has_done() const {
  return _internal_has_done();
}
inline void CallUpdateRequest::set_has_done() {
  _impl_._oneof_case_[0] = kDone;
}
inline void CallUpdateRequest::clear_done() {
  if (_internal_has_done()) {
    _impl_.update_.done_ = false;
    clear_has_update();
  }
}
inline bool CallUpdateRequest::_internal_done() const {
  if (_internal_has_done()) {
    return _impl_.update_.done_;
  }
  return false;
}
inline void CallUpdateRequest::_internal_set_done(bool value) {
  if (!_internal_has_done()) {
    clear_update();
    set_has_done();
  }
  _impl_.update_.done_ = value;
}
inline bool CallUpdateRequest::done() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.done)
  return _internal_done();
}
inline void CallUpdateRequest::set_done(bool value) {
  _internal_set_done(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.CallUpdateRequest.done)
}

// .google.rpc.Status error = 4 [json_name = "error"];
inline bool CallUpdateRequest::_internal_has_error() const {
  return update_case() == kError;
}
inline bool CallUpdateRequest::has_error() const {
  return _internal_has_error();
}
inline void CallUpdateRequest::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline ::google::rpc::Status* CallUpdateRequest::release_error() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  if (_internal_has_error()) {
    clear_has_update();
    ::google::rpc::Status* temp = _impl_.update_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::rpc::Status& CallUpdateRequest::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.update_.error_
      : reinterpret_cast< ::google::rpc::Status&>(::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& CallUpdateRequest::error() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  return _internal_error();
}
inline ::google::rpc::Status* CallUpdateRequest::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  if (_internal_has_error()) {
    clear_has_update();
    ::google::rpc::Status* temp = _impl_.update_.error_;
    _impl_.update_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallUpdateRequest::unsafe_arena_set_allocated_error(::google::rpc::Status* error) {
  clear_update();
  if (error) {
    set_has_error();
    _impl_.update_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.CallUpdateRequest.error)
}
inline ::google::rpc::Status* CallUpdateRequest::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_update();
    set_has_error();
    _impl_.update_.error_ = CreateMaybeMessage< ::google::rpc::Status >(GetArenaForAllocation());
  }
  return _impl_.update_.error_;
}
inline ::google::rpc::Status* CallUpdateRequest::mutable_error() {
  ::google::rpc::Status* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.CallUpdateRequest.error)
  return _msg;
}

inline bool CallUpdateRequest::has_update() const {
  return update_case() != UPDATE_NOT_SET;
}
inline void CallUpdateRequest::clear_has_update() {
  _impl_._oneof_case_[0] = UPDATE_NOT_SET;
}
inline CallUpdateRequest::UpdateCase CallUpdateRequest::update_case() const {
  return CallUpdateRequest::UpdateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallUpdateResponse

// -------------------------------------------------------------------

// ICEServer

// repeated string urls = 1 [json_name = "urls"];
inline int ICEServer::_internal_urls_size() const {
  return _impl_.urls_.size();
}
inline int ICEServer::urls_size() const {
  return _internal_urls_size();
}
inline void ICEServer::clear_urls() {
  _impl_.urls_.Clear();
}
inline std::string* ICEServer::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:proto.rpc.webrtc.v1.ICEServer.urls)
  return _s;
}
inline const std::string& ICEServer::_internal_urls(int index) const {
  return _impl_.urls_.Get(index);
}
inline const std::string& ICEServer::urls(int index) const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICEServer.urls)
  return _internal_urls(index);
}
inline std::string* ICEServer::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICEServer.urls)
  return _impl_.urls_.Mutable(index);
}
inline void ICEServer::set_urls(int index, const std::string& value) {
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, std::string&& value) {
  _impl_.urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value, size_t size) {
  _impl_.urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline std::string* ICEServer::_internal_add_urls() {
  return _impl_.urls_.Add();
}
inline void ICEServer::add_urls(const std::string& value) {
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(std::string&& value) {
  _impl_.urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value, size_t size) {
  _impl_.urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.rpc.webrtc.v1.ICEServer.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ICEServer::urls() const {
  // @@protoc_insertion_point(field_list:proto.rpc.webrtc.v1.ICEServer.urls)
  return _impl_.urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ICEServer::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:proto.rpc.webrtc.v1.ICEServer.urls)
  return &_impl_.urls_;
}

// string username = 2 [json_name = "username"];
inline void ICEServer::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ICEServer::username() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICEServer.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICEServer::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.username)
}
inline std::string* ICEServer::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICEServer.username)
  return _s;
}
inline const std::string& ICEServer::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ICEServer::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ICEServer::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* ICEServer::release_username() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICEServer.username)
  return _impl_.username_.Release();
}
inline void ICEServer::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICEServer.username)
}

// string credential = 3 [json_name = "credential"];
inline void ICEServer::clear_credential() {
  _impl_.credential_.ClearToEmpty();
}
inline const std::string& ICEServer::credential() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.ICEServer.credential)
  return _internal_credential();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICEServer::set_credential(ArgT0&& arg0, ArgT... args) {
 
 _impl_.credential_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.ICEServer.credential)
}
inline std::string* ICEServer::mutable_credential() {
  std::string* _s = _internal_mutable_credential();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.ICEServer.credential)
  return _s;
}
inline const std::string& ICEServer::_internal_credential() const {
  return _impl_.credential_.Get();
}
inline void ICEServer::_internal_set_credential(const std::string& value) {
  
  _impl_.credential_.Set(value, GetArenaForAllocation());
}
inline std::string* ICEServer::_internal_mutable_credential() {
  
  return _impl_.credential_.Mutable(GetArenaForAllocation());
}
inline std::string* ICEServer::release_credential() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.ICEServer.credential)
  return _impl_.credential_.Release();
}
inline void ICEServer::set_allocated_credential(std::string* credential) {
  if (credential != nullptr) {
    
  } else {
    
  }
  _impl_.credential_.SetAllocated(credential, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credential_.IsDefault()) {
    _impl_.credential_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.ICEServer.credential)
}

// -------------------------------------------------------------------

// WebRTCConfig

// repeated .proto.rpc.webrtc.v1.ICEServer additional_ice_servers = 1 [json_name = "additionalIceServers"];
inline int WebRTCConfig::_internal_additional_ice_servers_size() const {
  return _impl_.additional_ice_servers_.size();
}
inline int WebRTCConfig::additional_ice_servers_size() const {
  return _internal_additional_ice_servers_size();
}
inline void WebRTCConfig::clear_additional_ice_servers() {
  _impl_.additional_ice_servers_.Clear();
}
inline ::proto::rpc::webrtc::v1::ICEServer* WebRTCConfig::mutable_additional_ice_servers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _impl_.additional_ice_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer >*
WebRTCConfig::mutable_additional_ice_servers() {
  // @@protoc_insertion_point(field_mutable_list:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return &_impl_.additional_ice_servers_;
}
inline const ::proto::rpc::webrtc::v1::ICEServer& WebRTCConfig::_internal_additional_ice_servers(int index) const {
  return _impl_.additional_ice_servers_.Get(index);
}
inline const ::proto::rpc::webrtc::v1::ICEServer& WebRTCConfig::additional_ice_servers(int index) const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _internal_additional_ice_servers(index);
}
inline ::proto::rpc::webrtc::v1::ICEServer* WebRTCConfig::_internal_add_additional_ice_servers() {
  return _impl_.additional_ice_servers_.Add();
}
inline ::proto::rpc::webrtc::v1::ICEServer* WebRTCConfig::add_additional_ice_servers() {
  ::proto::rpc::webrtc::v1::ICEServer* _add = _internal_add_additional_ice_servers();
  // @@protoc_insertion_point(field_add:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::rpc::webrtc::v1::ICEServer >&
WebRTCConfig::additional_ice_servers() const {
  // @@protoc_insertion_point(field_list:proto.rpc.webrtc.v1.WebRTCConfig.additional_ice_servers)
  return _impl_.additional_ice_servers_;
}

// bool disable_trickle = 2 [json_name = "disableTrickle"];
inline void WebRTCConfig::clear_disable_trickle() {
  _impl_.disable_trickle_ = false;
}
inline bool WebRTCConfig::_internal_disable_trickle() const {
  return _impl_.disable_trickle_;
}
inline bool WebRTCConfig::disable_trickle() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.WebRTCConfig.disable_trickle)
  return _internal_disable_trickle();
}
inline void WebRTCConfig::_internal_set_disable_trickle(bool value) {
  
  _impl_.disable_trickle_ = value;
}
inline void WebRTCConfig::set_disable_trickle(bool value) {
  _internal_set_disable_trickle(value);
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.WebRTCConfig.disable_trickle)
}

// -------------------------------------------------------------------

// AnswerRequestInitStage

// string sdp = 1 [json_name = "sdp"];
inline void AnswerRequestInitStage::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& AnswerRequestInitStage::sdp() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerRequestInitStage::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
}
inline std::string* AnswerRequestInitStage::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
  return _s;
}
inline const std::string& AnswerRequestInitStage::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void AnswerRequestInitStage::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerRequestInitStage::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerRequestInitStage::release_sdp() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
  return _impl_.sdp_.Release();
}
inline void AnswerRequestInitStage::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.sdp)
}

// .proto.rpc.webrtc.v1.WebRTCConfig optional_config = 2 [json_name = "optionalConfig"];
inline bool AnswerRequestInitStage::_internal_has_optional_config() const {
  return this != internal_default_instance() && _impl_.optional_config_ != nullptr;
}
inline bool AnswerRequestInitStage::has_optional_config() const {
  return _internal_has_optional_config();
}
inline void AnswerRequestInitStage::clear_optional_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.optional_config_ != nullptr) {
    delete _impl_.optional_config_;
  }
  _impl_.optional_config_ = nullptr;
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& AnswerRequestInitStage::_internal_optional_config() const {
  const ::proto::rpc::webrtc::v1::WebRTCConfig* p = _impl_.optional_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::WebRTCConfig&>(
      ::proto::rpc::webrtc::v1::_WebRTCConfig_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& AnswerRequestInitStage::optional_config() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
  return _internal_optional_config();
}
inline void AnswerRequestInitStage::unsafe_arena_set_allocated_optional_config(
    ::proto::rpc::webrtc::v1::WebRTCConfig* optional_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optional_config_);
  }
  _impl_.optional_config_ = optional_config;
  if (optional_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::release_optional_config() {
  
  ::proto::rpc::webrtc::v1::WebRTCConfig* temp = _impl_.optional_config_;
  _impl_.optional_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::unsafe_arena_release_optional_config() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
  
  ::proto::rpc::webrtc::v1::WebRTCConfig* temp = _impl_.optional_config_;
  _impl_.optional_config_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::_internal_mutable_optional_config() {
  
  if (_impl_.optional_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::WebRTCConfig>(GetArenaForAllocation());
    _impl_.optional_config_ = p;
  }
  return _impl_.optional_config_;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* AnswerRequestInitStage::mutable_optional_config() {
  ::proto::rpc::webrtc::v1::WebRTCConfig* _msg = _internal_mutable_optional_config();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
  return _msg;
}
inline void AnswerRequestInitStage::set_allocated_optional_config(::proto::rpc::webrtc::v1::WebRTCConfig* optional_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optional_config_;
  }
  if (optional_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optional_config);
    if (message_arena != submessage_arena) {
      optional_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optional_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.optional_config_ = optional_config;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.optional_config)
}

// optional .google.protobuf.Timestamp deadline = 3 [json_name = "deadline"];
inline bool AnswerRequestInitStage::_internal_has_deadline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deadline_ != nullptr);
  return value;
}
inline bool AnswerRequestInitStage::has_deadline() const {
  return _internal_has_deadline();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AnswerRequestInitStage::_internal_deadline() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deadline_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AnswerRequestInitStage::deadline() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
  return _internal_deadline();
}
inline void AnswerRequestInitStage::unsafe_arena_set_allocated_deadline(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deadline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deadline_);
  }
  _impl_.deadline_ = deadline;
  if (deadline) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnswerRequestInitStage::release_deadline() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deadline_;
  _impl_.deadline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnswerRequestInitStage::unsafe_arena_release_deadline() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deadline_;
  _impl_.deadline_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnswerRequestInitStage::_internal_mutable_deadline() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deadline_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deadline_ = p;
  }
  return _impl_.deadline_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AnswerRequestInitStage::mutable_deadline() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deadline();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
  return _msg;
}
inline void AnswerRequestInitStage::set_allocated_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* deadline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deadline_);
  }
  if (deadline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deadline));
    if (message_arena != submessage_arena) {
      deadline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deadline, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deadline_ = deadline;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestInitStage.deadline)
}

// -------------------------------------------------------------------

// AnswerRequestUpdateStage

// .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
inline bool AnswerRequestUpdateStage::_internal_has_candidate() const {
  return this != internal_default_instance() && _impl_.candidate_ != nullptr;
}
inline bool AnswerRequestUpdateStage::has_candidate() const {
  return _internal_has_candidate();
}
inline void AnswerRequestUpdateStage::clear_candidate() {
  if (GetArenaForAllocation() == nullptr && _impl_.candidate_ != nullptr) {
    delete _impl_.candidate_;
  }
  _impl_.candidate_ = nullptr;
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerRequestUpdateStage::_internal_candidate() const {
  const ::proto::rpc::webrtc::v1::ICECandidate* p = _impl_.candidate_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::ICECandidate&>(
      ::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerRequestUpdateStage::candidate() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
  return _internal_candidate();
}
inline void AnswerRequestUpdateStage::unsafe_arena_set_allocated_candidate(
    ::proto::rpc::webrtc::v1::ICECandidate* candidate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.candidate_);
  }
  _impl_.candidate_ = candidate;
  if (candidate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::release_candidate() {
  
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::unsafe_arena_release_candidate() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
  
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::_internal_mutable_candidate() {
  
  if (_impl_.candidate_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(GetArenaForAllocation());
    _impl_.candidate_ = p;
  }
  return _impl_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerRequestUpdateStage::mutable_candidate() {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
  return _msg;
}
inline void AnswerRequestUpdateStage::set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.candidate_;
  }
  if (candidate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(candidate);
    if (message_arena != submessage_arena) {
      candidate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candidate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.candidate_ = candidate;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestUpdateStage.candidate)
}

// -------------------------------------------------------------------

// AnswerRequestDoneStage

// -------------------------------------------------------------------

// AnswerRequestErrorStage

// .google.rpc.Status status = 1 [json_name = "status"];
inline bool AnswerRequestErrorStage::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool AnswerRequestErrorStage::has_status() const {
  return _internal_has_status();
}
inline const ::google::rpc::Status& AnswerRequestErrorStage::_internal_status() const {
  const ::google::rpc::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& AnswerRequestErrorStage::status() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
  return _internal_status();
}
inline void AnswerRequestErrorStage::unsafe_arena_set_allocated_status(
    ::google::rpc::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
}
inline ::google::rpc::Status* AnswerRequestErrorStage::release_status() {
  
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* AnswerRequestErrorStage::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
  
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* AnswerRequestErrorStage::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::google::rpc::Status* AnswerRequestErrorStage::mutable_status() {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
  return _msg;
}
inline void AnswerRequestErrorStage::set_allocated_status(::google::rpc::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequestErrorStage.status)
}

// -------------------------------------------------------------------

// AnswerRequest

// string uuid = 1 [json_name = "uuid"];
inline void AnswerRequest::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& AnswerRequest::uuid() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerRequest::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerRequest.uuid)
}
inline std::string* AnswerRequest::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.uuid)
  return _s;
}
inline const std::string& AnswerRequest::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void AnswerRequest::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerRequest::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.uuid)
  return _impl_.uuid_.Release();
}
inline void AnswerRequest::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.uuid)
}

// .proto.rpc.webrtc.v1.AnswerRequestInitStage init = 2 [json_name = "init"];
inline bool AnswerRequest::_internal_has_init() const {
  return stage_case() == kInit;
}
inline bool AnswerRequest::has_init() const {
  return _internal_has_init();
}
inline void AnswerRequest::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void AnswerRequest::clear_init() {
  if (_internal_has_init()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.init_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::release_init() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.init)
  if (_internal_has_init()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestInitStage* temp = _impl_.stage_.init_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& AnswerRequest::_internal_init() const {
  return _internal_has_init()
      ? *_impl_.stage_.init_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerRequestInitStage&>(::proto::rpc::webrtc::v1::_AnswerRequestInitStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestInitStage& AnswerRequest::init() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.init)
  return _internal_init();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.init)
  if (_internal_has_init()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestInitStage* temp = _impl_.stage_.init_;
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::AnswerRequestInitStage* init) {
  clear_stage();
  if (init) {
    set_has_init();
    _impl_.stage_.init_ = init;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.init)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_stage();
    set_has_init();
    _impl_.stage_.init_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerRequestInitStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.init_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestInitStage* AnswerRequest::mutable_init() {
  ::proto::rpc::webrtc::v1::AnswerRequestInitStage* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.init)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerRequestUpdateStage update = 3 [json_name = "update"];
inline bool AnswerRequest::_internal_has_update() const {
  return stage_case() == kUpdate;
}
inline bool AnswerRequest::has_update() const {
  return _internal_has_update();
}
inline void AnswerRequest::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void AnswerRequest::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.update_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::release_update() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.update)
  if (_internal_has_update()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* temp = _impl_.stage_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& AnswerRequest::_internal_update() const {
  return _internal_has_update()
      ? *_impl_.stage_.update_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage&>(::proto::rpc::webrtc::v1::_AnswerRequestUpdateStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage& AnswerRequest::update() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.update)
  return _internal_update();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.update)
  if (_internal_has_update()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* temp = _impl_.stage_.update_;
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* update) {
  clear_stage();
  if (update) {
    set_has_update();
    _impl_.stage_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.update)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_stage();
    set_has_update();
    _impl_.stage_.update_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.update_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* AnswerRequest::mutable_update() {
  ::proto::rpc::webrtc::v1::AnswerRequestUpdateStage* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.update)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerRequestDoneStage done = 4 [json_name = "done"];
inline bool AnswerRequest::_internal_has_done() const {
  return stage_case() == kDone;
}
inline bool AnswerRequest::has_done() const {
  return _internal_has_done();
}
inline void AnswerRequest::set_has_done() {
  _impl_._oneof_case_[0] = kDone;
}
inline void AnswerRequest::clear_done() {
  if (_internal_has_done()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.done_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::release_done() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.done)
  if (_internal_has_done()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* temp = _impl_.stage_.done_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& AnswerRequest::_internal_done() const {
  return _internal_has_done()
      ? *_impl_.stage_.done_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerRequestDoneStage&>(::proto::rpc::webrtc::v1::_AnswerRequestDoneStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestDoneStage& AnswerRequest::done() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.done)
  return _internal_done();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::unsafe_arena_release_done() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.done)
  if (_internal_has_done()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* temp = _impl_.stage_.done_;
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_done(::proto::rpc::webrtc::v1::AnswerRequestDoneStage* done) {
  clear_stage();
  if (done) {
    set_has_done();
    _impl_.stage_.done_ = done;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.done)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::_internal_mutable_done() {
  if (!_internal_has_done()) {
    clear_stage();
    set_has_done();
    _impl_.stage_.done_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerRequestDoneStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.done_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* AnswerRequest::mutable_done() {
  ::proto::rpc::webrtc::v1::AnswerRequestDoneStage* _msg = _internal_mutable_done();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.done)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerRequestErrorStage error = 5 [json_name = "error"];
inline bool AnswerRequest::_internal_has_error() const {
  return stage_case() == kError;
}
inline bool AnswerRequest::has_error() const {
  return _internal_has_error();
}
inline void AnswerRequest::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void AnswerRequest::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.error_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::release_error() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerRequest.error)
  if (_internal_has_error()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* temp = _impl_.stage_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& AnswerRequest::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.stage_.error_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerRequestErrorStage&>(::proto::rpc::webrtc::v1::_AnswerRequestErrorStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerRequestErrorStage& AnswerRequest::error() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerRequest.error)
  return _internal_error();
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerRequest.error)
  if (_internal_has_error()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* temp = _impl_.stage_.error_;
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerRequest::unsafe_arena_set_allocated_error(::proto::rpc::webrtc::v1::AnswerRequestErrorStage* error) {
  clear_stage();
  if (error) {
    set_has_error();
    _impl_.stage_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerRequest.error)
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_stage();
    set_has_error();
    _impl_.stage_.error_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerRequestErrorStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.error_;
}
inline ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* AnswerRequest::mutable_error() {
  ::proto::rpc::webrtc::v1::AnswerRequestErrorStage* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerRequest.error)
  return _msg;
}

inline bool AnswerRequest::has_stage() const {
  return stage_case() != STAGE_NOT_SET;
}
inline void AnswerRequest::clear_has_stage() {
  _impl_._oneof_case_[0] = STAGE_NOT_SET;
}
inline AnswerRequest::StageCase AnswerRequest::stage_case() const {
  return AnswerRequest::StageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnswerResponseInitStage

// string sdp = 1 [json_name = "sdp"];
inline void AnswerResponseInitStage::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& AnswerResponseInitStage::sdp() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerResponseInitStage::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
}
inline std::string* AnswerResponseInitStage::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
  return _s;
}
inline const std::string& AnswerResponseInitStage::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void AnswerResponseInitStage::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerResponseInitStage::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerResponseInitStage::release_sdp() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
  return _impl_.sdp_.Release();
}
inline void AnswerResponseInitStage::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponseInitStage.sdp)
}

// -------------------------------------------------------------------

// AnswerResponseUpdateStage

// .proto.rpc.webrtc.v1.ICECandidate candidate = 1 [json_name = "candidate"];
inline bool AnswerResponseUpdateStage::_internal_has_candidate() const {
  return this != internal_default_instance() && _impl_.candidate_ != nullptr;
}
inline bool AnswerResponseUpdateStage::has_candidate() const {
  return _internal_has_candidate();
}
inline void AnswerResponseUpdateStage::clear_candidate() {
  if (GetArenaForAllocation() == nullptr && _impl_.candidate_ != nullptr) {
    delete _impl_.candidate_;
  }
  _impl_.candidate_ = nullptr;
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerResponseUpdateStage::_internal_candidate() const {
  const ::proto::rpc::webrtc::v1::ICECandidate* p = _impl_.candidate_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::ICECandidate&>(
      ::proto::rpc::webrtc::v1::_ICECandidate_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::ICECandidate& AnswerResponseUpdateStage::candidate() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
  return _internal_candidate();
}
inline void AnswerResponseUpdateStage::unsafe_arena_set_allocated_candidate(
    ::proto::rpc::webrtc::v1::ICECandidate* candidate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.candidate_);
  }
  _impl_.candidate_ = candidate;
  if (candidate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::release_candidate() {
  
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::unsafe_arena_release_candidate() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
  
  ::proto::rpc::webrtc::v1::ICECandidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::_internal_mutable_candidate() {
  
  if (_impl_.candidate_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::ICECandidate>(GetArenaForAllocation());
    _impl_.candidate_ = p;
  }
  return _impl_.candidate_;
}
inline ::proto::rpc::webrtc::v1::ICECandidate* AnswerResponseUpdateStage::mutable_candidate() {
  ::proto::rpc::webrtc::v1::ICECandidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
  return _msg;
}
inline void AnswerResponseUpdateStage::set_allocated_candidate(::proto::rpc::webrtc::v1::ICECandidate* candidate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.candidate_;
  }
  if (candidate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(candidate);
    if (message_arena != submessage_arena) {
      candidate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candidate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.candidate_ = candidate;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponseUpdateStage.candidate)
}

// -------------------------------------------------------------------

// AnswerResponseDoneStage

// -------------------------------------------------------------------

// AnswerResponseErrorStage

// .google.rpc.Status status = 1 [json_name = "status"];
inline bool AnswerResponseErrorStage::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool AnswerResponseErrorStage::has_status() const {
  return _internal_has_status();
}
inline const ::google::rpc::Status& AnswerResponseErrorStage::_internal_status() const {
  const ::google::rpc::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& AnswerResponseErrorStage::status() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
  return _internal_status();
}
inline void AnswerResponseErrorStage::unsafe_arena_set_allocated_status(
    ::google::rpc::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
}
inline ::google::rpc::Status* AnswerResponseErrorStage::release_status() {
  
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* AnswerResponseErrorStage::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
  
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* AnswerResponseErrorStage::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::google::rpc::Status* AnswerResponseErrorStage::mutable_status() {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
  return _msg;
}
inline void AnswerResponseErrorStage::set_allocated_status(::google::rpc::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponseErrorStage.status)
}

// -------------------------------------------------------------------

// AnswerResponse

// string uuid = 1 [json_name = "uuid"];
inline void AnswerResponse::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& AnswerResponse::uuid() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerResponse::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.rpc.webrtc.v1.AnswerResponse.uuid)
}
inline std::string* AnswerResponse::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.uuid)
  return _s;
}
inline const std::string& AnswerResponse::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void AnswerResponse::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerResponse::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.uuid)
  return _impl_.uuid_.Release();
}
inline void AnswerResponse::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.uuid)
}

// .proto.rpc.webrtc.v1.AnswerResponseInitStage init = 2 [json_name = "init"];
inline bool AnswerResponse::_internal_has_init() const {
  return stage_case() == kInit;
}
inline bool AnswerResponse::has_init() const {
  return _internal_has_init();
}
inline void AnswerResponse::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void AnswerResponse::clear_init() {
  if (_internal_has_init()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.init_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::release_init() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.init)
  if (_internal_has_init()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseInitStage* temp = _impl_.stage_.init_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& AnswerResponse::_internal_init() const {
  return _internal_has_init()
      ? *_impl_.stage_.init_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerResponseInitStage&>(::proto::rpc::webrtc::v1::_AnswerResponseInitStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseInitStage& AnswerResponse::init() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.init)
  return _internal_init();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.init)
  if (_internal_has_init()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseInitStage* temp = _impl_.stage_.init_;
    _impl_.stage_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_init(::proto::rpc::webrtc::v1::AnswerResponseInitStage* init) {
  clear_stage();
  if (init) {
    set_has_init();
    _impl_.stage_.init_ = init;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.init)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_stage();
    set_has_init();
    _impl_.stage_.init_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerResponseInitStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.init_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseInitStage* AnswerResponse::mutable_init() {
  ::proto::rpc::webrtc::v1::AnswerResponseInitStage* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.init)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerResponseUpdateStage update = 3 [json_name = "update"];
inline bool AnswerResponse::_internal_has_update() const {
  return stage_case() == kUpdate;
}
inline bool AnswerResponse::has_update() const {
  return _internal_has_update();
}
inline void AnswerResponse::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void AnswerResponse::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.update_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::release_update() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.update)
  if (_internal_has_update()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* temp = _impl_.stage_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& AnswerResponse::_internal_update() const {
  return _internal_has_update()
      ? *_impl_.stage_.update_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage&>(::proto::rpc::webrtc::v1::_AnswerResponseUpdateStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage& AnswerResponse::update() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.update)
  return _internal_update();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.update)
  if (_internal_has_update()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* temp = _impl_.stage_.update_;
    _impl_.stage_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_update(::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* update) {
  clear_stage();
  if (update) {
    set_has_update();
    _impl_.stage_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.update)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_stage();
    set_has_update();
    _impl_.stage_.update_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.update_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* AnswerResponse::mutable_update() {
  ::proto::rpc::webrtc::v1::AnswerResponseUpdateStage* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.update)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerResponseDoneStage done = 4 [json_name = "done"];
inline bool AnswerResponse::_internal_has_done() const {
  return stage_case() == kDone;
}
inline bool AnswerResponse::has_done() const {
  return _internal_has_done();
}
inline void AnswerResponse::set_has_done() {
  _impl_._oneof_case_[0] = kDone;
}
inline void AnswerResponse::clear_done() {
  if (_internal_has_done()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.done_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::release_done() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.done)
  if (_internal_has_done()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* temp = _impl_.stage_.done_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& AnswerResponse::_internal_done() const {
  return _internal_has_done()
      ? *_impl_.stage_.done_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerResponseDoneStage&>(::proto::rpc::webrtc::v1::_AnswerResponseDoneStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseDoneStage& AnswerResponse::done() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.done)
  return _internal_done();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::unsafe_arena_release_done() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.done)
  if (_internal_has_done()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* temp = _impl_.stage_.done_;
    _impl_.stage_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_done(::proto::rpc::webrtc::v1::AnswerResponseDoneStage* done) {
  clear_stage();
  if (done) {
    set_has_done();
    _impl_.stage_.done_ = done;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.done)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::_internal_mutable_done() {
  if (!_internal_has_done()) {
    clear_stage();
    set_has_done();
    _impl_.stage_.done_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerResponseDoneStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.done_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* AnswerResponse::mutable_done() {
  ::proto::rpc::webrtc::v1::AnswerResponseDoneStage* _msg = _internal_mutable_done();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.done)
  return _msg;
}

// .proto.rpc.webrtc.v1.AnswerResponseErrorStage error = 5 [json_name = "error"];
inline bool AnswerResponse::_internal_has_error() const {
  return stage_case() == kError;
}
inline bool AnswerResponse::has_error() const {
  return _internal_has_error();
}
inline void AnswerResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void AnswerResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stage_.error_;
    }
    clear_has_stage();
  }
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::release_error() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.AnswerResponse.error)
  if (_internal_has_error()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* temp = _impl_.stage_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& AnswerResponse::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.stage_.error_
      : reinterpret_cast< ::proto::rpc::webrtc::v1::AnswerResponseErrorStage&>(::proto::rpc::webrtc::v1::_AnswerResponseErrorStage_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::AnswerResponseErrorStage& AnswerResponse::error() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.AnswerResponse.error)
  return _internal_error();
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.rpc.webrtc.v1.AnswerResponse.error)
  if (_internal_has_error()) {
    clear_has_stage();
    ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* temp = _impl_.stage_.error_;
    _impl_.stage_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnswerResponse::unsafe_arena_set_allocated_error(::proto::rpc::webrtc::v1::AnswerResponseErrorStage* error) {
  clear_stage();
  if (error) {
    set_has_error();
    _impl_.stage_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.AnswerResponse.error)
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_stage();
    set_has_error();
    _impl_.stage_.error_ = CreateMaybeMessage< ::proto::rpc::webrtc::v1::AnswerResponseErrorStage >(GetArenaForAllocation());
  }
  return _impl_.stage_.error_;
}
inline ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* AnswerResponse::mutable_error() {
  ::proto::rpc::webrtc::v1::AnswerResponseErrorStage* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.AnswerResponse.error)
  return _msg;
}

inline bool AnswerResponse::has_stage() const {
  return stage_case() != STAGE_NOT_SET;
}
inline void AnswerResponse::clear_has_stage() {
  _impl_._oneof_case_[0] = STAGE_NOT_SET;
}
inline AnswerResponse::StageCase AnswerResponse::stage_case() const {
  return AnswerResponse::StageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OptionalWebRTCConfigRequest

// -------------------------------------------------------------------

// OptionalWebRTCConfigResponse

// .proto.rpc.webrtc.v1.WebRTCConfig config = 1 [json_name = "config"];
inline bool OptionalWebRTCConfigResponse::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool OptionalWebRTCConfigResponse::has_config() const {
  return _internal_has_config();
}
inline void OptionalWebRTCConfigResponse::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& OptionalWebRTCConfigResponse::_internal_config() const {
  const ::proto::rpc::webrtc::v1::WebRTCConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::rpc::webrtc::v1::WebRTCConfig&>(
      ::proto::rpc::webrtc::v1::_WebRTCConfig_default_instance_);
}
inline const ::proto::rpc::webrtc::v1::WebRTCConfig& OptionalWebRTCConfigResponse::config() const {
  // @@protoc_insertion_point(field_get:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
  return _internal_config();
}
inline void OptionalWebRTCConfigResponse::unsafe_arena_set_allocated_config(
    ::proto::rpc::webrtc::v1::WebRTCConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::release_config() {
  
  ::proto::rpc::webrtc::v1::WebRTCConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
  
  ::proto::rpc::webrtc::v1::WebRTCConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::rpc::webrtc::v1::WebRTCConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::proto::rpc::webrtc::v1::WebRTCConfig* OptionalWebRTCConfigResponse::mutable_config() {
  ::proto::rpc::webrtc::v1::WebRTCConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
  return _msg;
}
inline void OptionalWebRTCConfigResponse::set_allocated_config(::proto::rpc::webrtc::v1::WebRTCConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:proto.rpc.webrtc.v1.OptionalWebRTCConfigResponse.config)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace webrtc
}  // namespace rpc
}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2frpc_2fwebrtc_2fv1_2fsignaling_2eproto
